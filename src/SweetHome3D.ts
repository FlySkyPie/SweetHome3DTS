import '@flyskypie/j4ts-swingundo';
import { SAXException } from '@flyskypie/xml-sax-parser/exceptions/index.js';
import { DefaultHandler } from '@flyskypie/xml-sax-parser/DefaultHandlers.js';

import { EventObject, PropertyChangeSupport, UUID } from './core';

/**
 * Due to circular dependency this can't use this at the moment.
 */
// import { UserPreferences, DefaultUserPreferences } from './UserPreferences';

import { CoreTools } from './CoreTools'

/*
 * Sweet Home 3D, Copyright (c) 2024 Space Mushrooms <info@sweethome3d.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
/**
 * Base class used to write objects to XML.
 * @author Emmanuel Puybaret
 * @class
 */
export abstract class ObjectXMLExporter<T> {
    /**
     * Writes in XML the given <code>object</code> in the element returned by the
     * {@link #getTag(Object) getTag}, then writes its attributes and children
     * calling {@link #writeAttributes(XMLWriter, Object) writeAttributes}
     * and {@link #writeChildren(XMLWriter, Object) writeChildren} methods.
     * @param {XMLWriter} writer
     * @param {Object} object
     */
    public writeElement(writer: XMLWriter, object: T) {
        writer.writeStartElement(this.getTag(object));
        this.writeAttributes(writer, object);
        this.writeChildren(writer, object);
        writer.writeEndElement();
    }

    /**
     * Returns the element tag matching the object in parameter.
     * @return {string} the simple class name of the exported object with its first letter at lower case,
     * without <code>Home</code> prefix if it's the case.
     * @param {Object} object
     */
    getTag(object: T): string {
        let tagName: string = /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))((<any>object.constructor));
        if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(tagName, "Home") && !(tagName === ("Home"))) {
            tagName = tagName.substring(4);
        }
        return /* toLowerCase */tagName.charAt(0).toLowerCase() + tagName.substring(1);
    }

    /**
     * Writes the attributes of the object in parameter.
     * @param {XMLWriter} writer
     * @param {Object} object
     */
    writeAttributes(writer: XMLWriter, object: T) {
    }

    /**
     * Writes the children of the object in parameter.
     * @param {XMLWriter} writer
     * @param {Object} object
     */
    writeChildren(writer: XMLWriter, object: T) {
    }
}
ObjectXMLExporter["__class"] = "com.eteks.sweethome3d.io.ObjectXMLExporter";


/**
 * SAX handler for Sweet Home 3D XML stream. Read home should respect the following DTD:<pre>
 * &lt;!ELEMENT home (property*, furnitureVisibleProperty*, environment?, backgroundImage?, print?, compass?, (camera | observerCamera)*, level*,
 * (pieceOfFurniture | doorOrWindow | furnitureGroup | light)*, wall*, room*, polyline*, dimensionLine*, label*)>
 * &lt;!ATTLIST home
 * version CDATA #IMPLIED
 * name CDATA #IMPLIED
 * camera (observerCamera | topCamera) "topCamera"
 * selectedLevel CDATA #IMPLIED
 * wallHeight CDATA #IMPLIED
 * basePlanLocked (false | true) "false"
 * furnitureSortedProperty CDATA #IMPLIED
 * furnitureDescendingSorted (false | true) "false">
 * 
 * &lt;!ELEMENT property EMPTY>
 * &lt;!ATTLIST property
 * name CDATA #REQUIRED
 * value CDATA #REQUIRED
 * type (STRING|CONTENT) "STRING">
 * 
 * &lt;!ELEMENT furnitureVisibleProperty EMPTY>
 * &lt;!ATTLIST furnitureVisibleProperty name CDATA #REQUIRED>
 * 
 * &lt;!ELEMENT environment (property*, (camera | observerCamera)*, texture?, texture?) >
 * &lt;!ATTLIST environment
 * groundColor CDATA #IMPLIED
 * backgroundImageVisibleOnGround3D (false | true) "false"
 * skyColor CDATA #IMPLIED
 * lightColor CDATA #IMPLIED
 * wallsAlpha CDATA "0"
 * allLevelsVisible (false | true) "false"
 * observerCameraElevationAdjusted (false | true) "true"
 * ceillingLightColor CDATA #IMPLIED
 * drawingMode (FILL | OUTLINE | FILL_AND_OUTLINE) "FILL"
 * subpartSizeUnderLight CDATA "0"
 * photoWidth CDATA "400"
 * photoHeight CDATA "300"
 * photoAspectRatio (FREE_RATIO | VIEW_3D_RATIO | RATIO_4_3 | RATIO_3_2 | RATIO_16_9 | RATIO_2_1 | RATIO_24_10 | SQUARE_RATIO) "VIEW_3D_RATIO"
 * photoQuality CDATA "0"
 * videoWidth CDATA "320"
 * videoAspectRatio (RATIO_4_3 | RATIO_16_9 | RATIO_24_10) "RATIO_4_3"
 * videoQuality CDATA "0"
 * videoSpeed CDATA #IMPLIED
 * videoFrameRate CDATA "25">
 * 
 * &lt;!ELEMENT backgroundImage EMPTY>
 * &lt;!ATTLIST backgroundImage
 * image CDATA #REQUIRED
 * scaleDistance CDATA #REQUIRED
 * scaleDistanceXStart CDATA #REQUIRED
 * scaleDistanceYStart CDATA #REQUIRED
 * scaleDistanceXEnd CDATA #REQUIRED
 * scaleDistanceYEnd CDATA #REQUIRED
 * xOrigin CDATA "0"
 * yOrigin CDATA "0"
 * visible (false | true) "true">
 * 
 * &lt;!ELEMENT print (printedLevel*)>
 * &lt;!ATTLIST print
 * headerFormat CDATA #IMPLIED
 * footerFormat CDATA #IMPLIED
 * planScale CDATA #IMPLIED
 * furniturePrinted (false | true) "true"
 * planPrinted (false | true) "true"
 * view3DPrinted (false | true) "true"
 * paperWidth CDATA #REQUIRED
 * paperHeight CDATA #REQUIRED
 * paperTopMargin CDATA #REQUIRED
 * paperLeftMargin CDATA #REQUIRED
 * paperBottomMargin CDATA #REQUIRED
 * paperRightMargin CDATA #REQUIRED
 * paperOrientation (PORTRAIT | LANDSCAPE | REVERSE_LANDSCAPE) #REQUIRED>
 * 
 * &lt;!ELEMENT printedLevel EMPTY>
 * &lt;!ATTLIST printedLevel level ID #REQUIRED>
 * 
 * &lt;!ELEMENT compass (property*)>
 * &lt;!ATTLIST compass
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED
 * diameter CDATA #REQUIRED
 * northDirection CDATA "0"
 * longitude CDATA #IMPLIED
 * latitude CDATA #IMPLIED
 * timeZone CDATA #IMPLIED
 * visible (false | true) "true">
 * 
 * &lt;!ENTITY % cameraCommonAttributes
 * 'id ID #IMPLIED
 * name CDATA #IMPLIED
 * lens (PINHOLE | NORMAL | FISHEYE | SPHERICAL) "PINHOLE"
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED
 * z CDATA #REQUIRED
 * yaw CDATA #REQUIRED
 * pitch CDATA #REQUIRED
 * time CDATA #IMPLIED
 * fieldOfView CDATA #REQUIRED
 * renderer CADATA #IMPLIED'>
 * 
 * &lt;!ELEMENT camera (property*)>
 * &lt;!ATTLIST camera
 * %cameraCommonAttributes;
 * attribute (topCamera | storedCamera | cameraPath) #REQUIRED>
 * 
 * &lt;!ELEMENT observerCamera (property*)>
 * &lt;!ATTLIST observerCamera
 * %cameraCommonAttributes;
 * attribute (observerCamera | storedCamera | cameraPath) #REQUIRED
 * fixedSize (false | true) "false">
 * 
 * &lt;!ELEMENT level (property*, backgroundImage?)>
 * &lt;!ATTLIST level
 * id ID #REQUIRED
 * name CDATA #REQUIRED
 * elevation CDATA #REQUIRED
 * floorThickness CDATA #REQUIRED
 * height CDATA #REQUIRED
 * elevationIndex CDATA "-1"
 * visible (false | true) "true"
 * viewable (false | true) "true">
 * 
 * &lt;!ENTITY % furnitureCommonAttributes
 * 'id ID #IMPLIED
 * name CDATA #REQUIRED
 * angle CDATA "0"
 * visible (false | true) "true"
 * movable (false | true) "true"
 * description CDATA #IMPLIED
 * information CDATA #IMPLIED
 * license CDATA #IMPLIED
 * creator CDATA #IMPLIED
 * modelMirrored (false | true) "false"
 * nameVisible (false | true) "false"
 * nameAngle CDATA "0"
 * nameXOffset CDATA "0"
 * nameYOffset CDATA "0"
 * price CDATA #IMPLIED'>
 * 
 * &lt;!ELEMENT furnitureGroup ((pieceOfFurniture | doorOrWindow | furnitureGroup | light)*, property*, textStyle?)>
 * &lt;!ATTLIST furnitureGroup
 * %furnitureCommonAttributes;
 * level IDREF #IMPLIED
 * x CDATA #IMPLIED
 * y CDATA #IMPLIED
 * elevation CDATA #IMPLIED
 * width CDATA #IMPLIED
 * depth CDATA #IMPLIED
 * height CDATA #IMPLIED
 * dropOnTopElevation CDATA #IMPLIED>
 * 
 * &lt;!ENTITY % pieceOfFurnitureCommonAttributes
 * 'level IDREF #IMPLIED
 * catalogId CDATA #IMPLIED
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED
 * elevation CDATA "0"
 * width CDATA #REQUIRED
 * depth CDATA #REQUIRED
 * height CDATA #REQUIRED
 * dropOnTopElevation CDATA "1"
 * model CDATA #IMPLIED
 * icon CDATA #IMPLIED
 * planIcon CDATA #IMPLIED
 * modelRotation CDATA "1 0 0 0 1 0 0 0 1"
 * modelCenteredAtOrigin CDATA #IMPLIED
 * backFaceShown (false | true) "false"
 * modelFlags CDATA #IMPLIED
 * modelSize CDATA #IMPLIED
 * doorOrWindow (false | true) "false"
 * resizable (false | true) "true"
 * deformable (false | true) "true"
 * texturable (false | true) "true"
 * staircaseCutOutShape CDATA #IMPLIED
 * color CDATA #IMPLIED
 * shininess CDATA #IMPLIED
 * valueAddedTaxPercentage CDATA #IMPLIED
 * currency CDATA #IMPLIED'>
 * 
 * &lt;!ENTITY % pieceOfFurnitureHorizontalRotationAttributes
 * 'horizontallyRotatable (false | true) "true"
 * pitch CDATA "0"
 * roll CDATA "0"
 * widthInPlan CDATA #IMPLIED
 * depthInPlan CDATA #IMPLIED
 * heightInPlan CDATA #IMPLIED'>
 * 
 * &lt;!ELEMENT pieceOfFurniture (property*, textStyle?, texture?, material*, transformation*)>
 * &lt;!ATTLIST pieceOfFurniture
 * %furnitureCommonAttributes;
 * %pieceOfFurnitureCommonAttributes;
 * %pieceOfFurnitureHorizontalRotationAttributes;>
 * 
 * &lt;!ELEMENT doorOrWindow (sash*, property*, textStyle?, texture?, material*, transformation*)>
 * &lt;!ATTLIST doorOrWindow
 * %furnitureCommonAttributes;
 * %pieceOfFurnitureCommonAttributes;
 * wallThickness CDATA "1"
 * wallDistance CDATA "0"
 * wallWidth CDATA "1"
 * wallLeft CDATA "0"
 * wallHeight CDATA "1"
 * wallTop CDATA "0"
 * wallCutOutOnBothSides (false | true) "false"
 * widthDepthDeformable (false | true) "true"
 * cutOutShape CDATA #IMPLIED
 * boundToWall (false | true) "true">
 * 
 * &lt;!ELEMENT sash EMPTY>
 * &lt;!ATTLIST sash
 * xAxis CDATA #REQUIRED
 * yAxis CDATA #REQUIRED
 * width CDATA #REQUIRED
 * startAngle CDATA #REQUIRED
 * endAngle CDATA #REQUIRED>
 * 
 * &lt;!ELEMENT light (lightSource*, lightSourceMaterial*, property*, textStyle?, texture?, material*, transformation*)>
 * &lt;!ATTLIST light
 * %furnitureCommonAttributes;
 * %pieceOfFurnitureCommonAttributes;
 * %pieceOfFurnitureHorizontalRotationAttributes;
 * power CDATA "0.5">
 * 
 * &lt;!ELEMENT lightSource EMPTY>
 * &lt;!ATTLIST lightSource
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED
 * z CDATA #REQUIRED
 * color CDATA #REQUIRED
 * diameter CDATA #IMPLIED>
 * 
 * &lt;!ELEMENT lightSourceMaterial EMPTY>
 * &lt;!ATTLIST lightSourceMaterial
 * name #REQUIRED>
 * 
 * &lt;!ELEMENT shelfUnit (shelf*, property*, textStyle?, texture?, material*, transformation*)>
 * &lt;!ATTLIST shelfUnit
 * %furnitureCommonAttributes;
 * %pieceOfFurnitureCommonAttributes;
 * %pieceOfFurnitureHorizontalRotationAttributes;>
 * 
 * &lt;!ELEMENT shelf EMPTY>
 * &lt;!ATTLIST shelf
 * elevation CDATA #IMPLIED
 * xLower CDATA #IMPLIED
 * yLower CDATA #IMPLIED
 * zLower CDATA #IMPLIED
 * xUpper CDATA #IMPLIED
 * yUpper CDATA #IMPLIED
 * zUpper CDATA #IMPLIED>
 * 
 * &lt;!ELEMENT textStyle EMPTY>
 * &lt;!ATTLIST textStyle
 * attribute (nameStyle | areaStyle | lengthStyle) #IMPLIED
 * fontName CDATA #IMPLIED
 * fontSize CDATA #REQUIRED
 * bold (false | true) "false"
 * italic (false | true) "false"
 * alignment (LEFT | CENTER | RIGHT) "CENTER">
 * 
 * &lt;!ELEMENT texture EMPTY>
 * &lt;!ATTLIST texture
 * attribute (groundTexture | skyTexture | leftSideTexture | rightSideTexture | floorTexture | ceilingTexture) #IMPLIED
 * catalogId CDATA #IMPLIED
 * name CDATA #REQUIRED
 * width CDATA #REQUIRED
 * height CDATA #REQUIRED
 * xOffset CDATA "0"
 * yOffset CDATA "0"
 * angle CDATA "0"
 * scale CDATA "1"
 * creator CDATA #IMPLIED
 * fittingArea (false | true) "false"
 * leftToRightOriented (true | false) "true"
 * image CDATA #REQUIRED>
 * 
 * &lt;!ELEMENT material (texture?)>
 * &lt;!ATTLIST material
 * name CDATA #REQUIRED
 * key CDATA #IMPLIED
 * color CDATA #IMPLIED
 * shininess CDATA #IMPLIED>
 * 
 * &lt;!ELEMENT transformation EMPTY>
 * &lt;!ATTLIST transformation
 * name CDATA #REQUIRED
 * matrix CDATA #REQUIRED>
 * 
 * &lt;!ELEMENT wall (property*, texture?, texture?, baseboard?, baseboard?)>
 * &lt;!ATTLIST wall
 * id ID #REQUIRED
 * level IDREF #IMPLIED
 * wallAtStart IDREF #IMPLIED
 * wallAtEnd IDREF #IMPLIED
 * xStart CDATA #REQUIRED
 * yStart CDATA #REQUIRED
 * xEnd CDATA #REQUIRED
 * yEnd CDATA #REQUIRED
 * height CDATA #IMPLIED
 * heightAtEnd CDATA #IMPLIED
 * thickness CDATA #REQUIRED
 * arcExtent CDATA #IMPLIED
 * pattern CDATA #IMPLIED
 * topColor CDATA #IMPLIED
 * leftSideColor CDATA #IMPLIED
 * leftSideShininess CDATA "0"
 * rightSideColor CDATA #IMPLIED
 * rightSideShininess CDATA "0">
 * 
 * &lt;!ELEMENT baseboard (texture?)>
 * &lt;!ATTLIST baseboard
 * attribute (leftSideBaseboard | rightSideBaseboard) #REQUIRED
 * thickness CDATA #REQUIRED
 * height CDATA #REQUIRED
 * color CDATA #IMPLIED>
 * 
 * &lt;!ELEMENT room (property*, textStyle?, textStyle?, texture?, texture?, point+)>
 * &lt;!ATTLIST room
 * id ID #IMPLIED
 * level IDREF #IMPLIED
 * name CDATA #IMPLIED
 * nameAngle CDATA "0"
 * nameXOffset CDATA "0"
 * nameYOffset CDATA "-40"
 * areaVisible (false | true) "false"
 * areaAngle CDATA "0"
 * areaXOffset CDATA "0"
 * areaYOffset CDATA "0"
 * floorVisible (false | true) "true"
 * floorColor CDATA #IMPLIED
 * floorShininess CDATA "0"
 * ceilingVisible (false | true) "true"
 * ceilingColor CDATA #IMPLIED
 * ceilingShininess CDATA "0"
 * ceilingFlat (false | true) "false">
 * 
 * &lt;!ELEMENT point EMPTY>
 * &lt;!ATTLIST point
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED>
 * 
 * &lt;!ELEMENT polyline (property*, point+)>
 * &lt;!ATTLIST polyline
 * id ID #IMPLIED
 * level IDREF #IMPLIED
 * thickness CDATA "1"
 * capStyle (BUTT | SQUARE | ROUND) "BUTT"
 * joinStyle (BEVEL | MITER | ROUND | CURVED) "MITER"
 * dashStyle (SOLID | DOT | DASH | DASH_DOT | DASH_DOT_DOT | CUSTOMIZED) "SOLID"
 * dashPattern CDATA #IMPLIED
 * dashOffset CDATA "0"
 * startArrowStyle (NONE | DELTA | OPEN | DISC) "NONE"
 * endArrowStyle (NONE | DELTA | OPEN | DISC) "NONE"
 * elevation CDATA #IMPLIED
 * color CDATA #IMPLIED
 * closedPath (false | true) "false">
 * 
 * &lt;!ELEMENT dimensionLine (property*, textStyle?)>
 * &lt;!ATTLIST dimensionLine
 * id ID #IMPLIED
 * level IDREF #IMPLIED
 * xStart CDATA #REQUIRED
 * yStart CDATA #REQUIRED
 * elevationStart CDATA "0"
 * xEnd CDATA #REQUIRED
 * yEnd CDATA #REQUIRED
 * elevationEnd CDATA "0"
 * offset CDATA #REQUIRED
 * endMarkSize CDATA "10";
 * angle CDATA "0"
 * color CDATA #IMPLIED
 * visibleIn3D (false | true) "false">
 * 
 * &lt;!ELEMENT label (property*, textStyle?, text)>
 * &lt;!ATTLIST label
 * id ID #IMPLIED
 * level IDREF #IMPLIED
 * x CDATA #REQUIRED
 * y CDATA #REQUIRED
 * angle CDATA "0"
 * elevation CDATA "0"
 * pitch CDATA #IMPLIED
 * color CDATA #IMPLIED
 * outlineColor CDATA #IMPLIED>
 * 
 * &lt;!ELEMENT text (#PCDATA)>
 * </pre>
 * with <code>home</code> as root element.
 * Attributes named <code>attribute</code> indicate the names of the object fields
 * where some elements should be stored.
 * @author Emmanuel Puybaret
 * @param {UserPreferences} preferences
 * @class
 * @extends DefaultHandler
 */
export class HomeXMLHandler extends DefaultHandler {
    /*private*/ preferences: any;

    /*private*/ home: Home;

    /*private*/ buffer: { str: string, toString: Function }

    /*private*/ elements: Array<string>;

    /*private*/ attributes: Array<any>;

    /*private*/ groupsFurniture: Array<Array<HomePieceOfFurniture>>;

    /*private*/ properties: Array<any>;

    /*private*/ textStyles: Array<any>;

    /*private*/ levels: any;

    /*private*/ joinedWalls: any;

    /*private*/ homeElementName: string;

    /*private*/ labelText: string;

    /*private*/ leftSideBaseboard: Baseboard;

    /*private*/ rightSideBaseboard: Baseboard;

    /*private*/ homeBackgroundImage: BackgroundImage;

    /*private*/ backgroundImage: BackgroundImage;

    /*private*/ textures: any;

    /*private*/ materials: Array<HomeMaterial>;

    /*private*/ transformations: Array<Transformation>;

    /*private*/ materialTexture: HomeTexture;

    /*private*/ sashes: Array<Sash>;

    /*private*/ lightSources: Array<LightSource>;

    /*private*/ lightSourceMaterialNames: Array<string>;

    /*private*/ shelfBoxes: Array<BoxBounds>;

    /*private*/ shelfElevations: Array<number>;

    /*private*/ points: Array<number[]>;

    /*private*/ furnitureVisiblePropertyNames: Array<string>;

    /*private*/ printedLevelIds: Array<string>;

    static UNIQUE_ATTRIBUTE: string = "@&unique&@";

    public constructor(preferences?: any) {
        if (((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null)) {
            let __args = arguments;
            super();
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.homeElementName === undefined) { this.homeElementName = null; }
            if (this.labelText === undefined) { this.labelText = null; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.homeBackgroundImage === undefined) { this.homeBackgroundImage = null; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.materialTexture === undefined) { this.materialTexture = null; }
            this.buffer = { str: "", toString: function () { return this.str; } };
            this.elements = <any>([]);
            this.attributes = <any>([]);
            this.groupsFurniture = <any>([]);
            this.properties = <any>([]);
            this.textStyles = <any>([]);
            this.levels = <any>({});
            this.joinedWalls = <any>({});
            this.textures = <any>({});
            this.materials = <any>([]);
            this.transformations = <any>([]);
            this.sashes = <any>([]);
            this.lightSources = <any>([]);
            this.lightSourceMaterialNames = <any>([]);
            this.shelfBoxes = <any>([]);
            this.shelfElevations = <any>([]);
            this.points = <any>([]);
            this.furnitureVisiblePropertyNames = <any>([]);
            this.printedLevelIds = <any>([]);
            this.preferences = preferences != null ? preferences : new DefaultUserPreferences(false, null);
        } else if (preferences === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let preferences: any = null;
                super();
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.home === undefined) { this.home = null; }
                if (this.homeElementName === undefined) { this.homeElementName = null; }
                if (this.labelText === undefined) { this.labelText = null; }
                if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                if (this.homeBackgroundImage === undefined) { this.homeBackgroundImage = null; }
                if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                if (this.materialTexture === undefined) { this.materialTexture = null; }
                this.buffer = { str: "", toString: function () { return this.str; } };
                this.elements = <any>([]);
                this.attributes = <any>([]);
                this.groupsFurniture = <any>([]);
                this.properties = <any>([]);
                this.textStyles = <any>([]);
                this.levels = <any>({});
                this.joinedWalls = <any>({});
                this.textures = <any>({});
                this.materials = <any>([]);
                this.transformations = <any>([]);
                this.sashes = <any>([]);
                this.lightSources = <any>([]);
                this.lightSourceMaterialNames = <any>([]);
                this.shelfBoxes = <any>([]);
                this.shelfElevations = <any>([]);
                this.points = <any>([]);
                this.furnitureVisiblePropertyNames = <any>([]);
                this.printedLevelIds = <any>([]);
                this.preferences = preferences != null ? preferences : new DefaultUserPreferences(false, null);
            }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.homeElementName === undefined) { this.homeElementName = null; }
            if (this.labelText === undefined) { this.labelText = null; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.homeBackgroundImage === undefined) { this.homeBackgroundImage = null; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.materialTexture === undefined) { this.materialTexture = null; }
            this.buffer = { str: "", toString: function () { return this.str; } };
            this.elements = <any>([]);
            this.attributes = <any>([]);
            this.groupsFurniture = <any>([]);
            this.properties = <any>([]);
            this.textStyles = <any>([]);
            this.levels = <any>({});
            this.joinedWalls = <any>({});
            this.textures = <any>({});
            this.materials = <any>([]);
            this.transformations = <any>([]);
            this.sashes = <any>([]);
            this.lightSources = <any>([]);
            this.lightSourceMaterialNames = <any>([]);
            this.shelfBoxes = <any>([]);
            this.shelfElevations = <any>([]);
            this.points = <any>([]);
            this.furnitureVisiblePropertyNames = <any>([]);
            this.printedLevelIds = <any>([]);
        } else throw new Error('invalid overload');
    }

    /**
     * 
     */
    public startDocument() {
        this.home = null;
        /* clear */(this.elements.length = 0);
        /* clear */(this.attributes.length = 0);
        /* clear */(this.groupsFurniture.length = 0);
        /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.levels);
        /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.joinedWalls);
    }

    /**
     * 
     * @param {string} uri
     * @param {string} localName
     * @param {string} name
     * @param {Attributes} attributes
     */
    public startElement(uri: string, localName: string, name: string, attributes: Attributes) {
        /* setLength */((sb, length) => sb.str = sb.str.substring(0, length))(this.buffer, 0);
        /* push */(this.elements.push(name) > 0);
        const attributesMap: any = <any>({});
        for (let i: number = 0; i < attributes.getLength(); i++) {
            {
            /* put */(attributesMap[attributes.getQName(i)] = attributes.getValue(i).replace("&quot;", "\"").replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&"));
            };
        }
        /* push */(this.attributes.push(attributesMap) > 0);
        if (!("property" === name) && !("furnitureVisibleProperty" === name) && !("textStyle" === name)) {
            /* push */(this.properties.push({}) > 0);
            /* push */(this.textStyles.push({}) > 0);
        }
        if ("home" === name) {
            this.setHome(this.createHome(name, attributesMap));
            /* clear */(this.furnitureVisiblePropertyNames.length = 0);
            this.homeBackgroundImage = null;
        } else if ("environment" === name) {
            /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.textures);
        } else if ("level" === name) {
            this.backgroundImage = null;
        } else if (("pieceOfFurniture" === name) || ("doorOrWindow" === name) || ("light" === name) || ("shelfUnit" === name) || ("furnitureGroup" === name)) {
            /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.textures);
            /* clear */(this.materials.length = 0);
            /* clear */(this.transformations.length = 0);
            /* clear */(this.sashes.length = 0);
            /* clear */(this.lightSources.length = 0);
            /* clear */(this.lightSourceMaterialNames.length = 0);
            /* clear */(this.shelfBoxes.length = 0);
            /* clear */(this.shelfElevations.length = 0);
            if ("furnitureGroup" === name) {
                /* push */(this.groupsFurniture.push([]) > 0);
            }
        } else if ("room" === name) {
            /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.textures);
            /* clear */(this.points.length = 0);
        } else if ("polyline" === name) {
            /* clear */(this.points.length = 0);
        } else if ("label" === name) {
            this.labelText = null;
        } else if ("wall" === name) {
            /* clear */(obj => { for (let member in obj) delete obj[member]; })(this.textures);
            this.leftSideBaseboard = null;
            this.rightSideBaseboard = null;
        } else if ("baseboard" === name) {
            /* remove */(map => { let deleted = this.textures[HomeXMLHandler.UNIQUE_ATTRIBUTE]; delete this.textures[HomeXMLHandler.UNIQUE_ATTRIBUTE]; return deleted; })(this.textures);
        } else if ("material" === name) {
            this.materialTexture = null;
        }
    }

    /**
     * 
     * @param {char[]} ch
     * @param {number} start
     * @param {number} length
     */
    public characters(ch: string[], start: number, length: number) {
        /* append */(sb => { sb.str += (<any>ch).substr(start, length); return sb; })(this.buffer);
    }

    /**
     * 
     * @param {string} uri
     * @param {string} localName
     * @param {string} name
     */
    public endElement(uri: string, localName: string, name: string) {
        /* pop */this.elements.pop();
        const parent: string = /* isEmpty */(this.elements.length == 0) ? null : /* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.elements);
        const attributesMap: any = /* pop */this.attributes.pop();
        if (this.homeElementName != null && (this.homeElementName === name)) {
            this.setHomeAttributes(this.home, name, attributesMap);
        } else if ("furnitureVisibleProperty" === name) {
            if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name") == null) {
                throw new SAXException("Missing name attribute");
            }
            /* add */(this.furnitureVisiblePropertyNames.push(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name")) > 0);
        } else if ("environment" === name) {
            this.setEnvironmentAttributes(this.home.getEnvironment(), name, attributesMap);
        } else if ("compass" === name) {
            this.setCompassAttributes(this.home.getCompass(), name, attributesMap);
        } else if ("print" === name) {
            this.home.setPrint(this.createPrint(attributesMap));
        } else if (("printedLevel" === name) && ("print" === parent)) {
            if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level") == null) {
                throw new SAXException("Missing level attribute");
            }
            /* add */(this.printedLevelIds.push(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level")) > 0);
        } else if ("level" === name) {
            const level: Level = this.createLevel(name, attributesMap);
            this.setLevelAttributes(level, name, attributesMap);
            /* put */(this.levels[/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "id")] = level);
            this.home.addLevel(level);
        } else if (("camera" === name) || ("observerCamera" === name)) {
            const camera: Camera = this.createCamera(name, attributesMap);
            this.setCameraAttributes(camera, name, attributesMap);
            const attribute: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "attribute");
            if ("cameraPath" === attribute) {
                const cameraPath: Array<Camera> = <any>(this.home.getEnvironment().getVideoCameraPath().slice(0));
                /* add */(cameraPath.push(camera) > 0);
                this.home.getEnvironment().setVideoCameraPath(cameraPath);
            } else if ("topCamera" === attribute) {
                const topCamera: Camera = this.home.getTopCamera();
                topCamera.setCamera(camera);
                topCamera.setTime(camera.getTime());
                topCamera.setLens(camera.getLens());
            } else if ("observerCamera" === attribute) {
                const observerCamera: ObserverCamera = this.home.getObserverCamera();
                observerCamera.setCamera(camera);
                observerCamera.setTime(camera.getTime());
                observerCamera.setLens(camera.getLens());
                observerCamera.setFixedSize((<ObserverCamera>camera).isFixedSize());
            } else if ("storedCamera" === attribute) {
                const storedCameras: Array<Camera> = <any>(this.home.getStoredCameras().slice(0));
                /* add */(storedCameras.push(camera) > 0);
                this.home.setStoredCameras(storedCameras);
            }
        } else if (("pieceOfFurniture" === name) || ("doorOrWindow" === name) || ("light" === name) || ("shelfUnit" === name) || ("furnitureGroup" === name)) {
            const piece: HomePieceOfFurniture = "furnitureGroup" === name ? this.createFurnitureGroup(name, attributesMap, /* pop */this.groupsFurniture.pop()) : this.createPieceOfFurniture(name, attributesMap);
            this.setPieceOfFurnitureAttributes(piece, name, attributesMap);
            if (this.homeElementName != null && (this.homeElementName === parent)) {
                this.home.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
                const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
                if (levelId != null) {
                    piece.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
                }
            } else if ("furnitureGroup" === parent) {
                /* add */(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.groupsFurniture).push(piece) > 0);
            }
        } else if ("wall" === name) {
            const wall: Wall = this.createWall(name, attributesMap);
            /* put */(this.joinedWalls[/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "id")] = new HomeXMLHandler.JoinedWall(wall, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "wallAtStart"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "wallAtEnd")));
            this.setWallAttributes(wall, name, attributesMap);
            this.home.addWall(wall);
            const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
            if (levelId != null) {
                wall.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
            }
        } else if ("baseboard" === name) {
            const baseboard: Baseboard = this.createBaseboard(name, attributesMap);
            if ("leftSideBaseboard" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "attribute")) {
                this.leftSideBaseboard = baseboard;
            } else {
                this.rightSideBaseboard = baseboard;
            }
        } else if ("room" === name) {
            const room: Room = this.createRoom(name, attributesMap, /* toArray */this.points.slice(0));
            this.setRoomAttributes(room, name, attributesMap);
            this.home.addRoom$com_eteks_sweethome3d_model_Room(room);
            const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
            if (levelId != null) {
                room.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
            }
        } else if ("polyline" === name) {
            const polyline: Polyline = this.createPolyline(name, attributesMap, /* toArray */this.points.slice(0));
            this.setPolylineAttributes(polyline, name, attributesMap);
            this.home.addPolyline$com_eteks_sweethome3d_model_Polyline(polyline);
            const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
            if (levelId != null) {
                polyline.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
            }
        } else if ("dimensionLine" === name) {
            const dimensionLine: DimensionLine = this.createDimensionLine(name, attributesMap);
            this.setDimensionLineAttributes(dimensionLine, name, attributesMap);
            this.home.addDimensionLine(dimensionLine);
            const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
            if (levelId != null) {
                dimensionLine.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
            }
        } else if ("label" === name) {
            const label: Label = this.createLabel(name, attributesMap, this.labelText);
            this.setLabelAttributes(label, name, attributesMap);
            this.home.addLabel(label);
            const levelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "level");
            if (levelId != null) {
                label.setLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, levelId));
            }
        } else if ("text" === name) {
            this.labelText = this.getCharacters();
        } else if ("textStyle" === name) {
            const attribute: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "attribute");
            /* put */(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles)[attribute != null ? attribute : HomeXMLHandler.UNIQUE_ATTRIBUTE] = this.createTextStyle(name, attributesMap));
        } else if ("texture" === name) {
            if ("material" === parent) {
                this.materialTexture = this.createTexture(name, attributesMap);
            } else {
                const attribute: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "attribute");
                /* put */(this.textures[attribute != null ? attribute : HomeXMLHandler.UNIQUE_ATTRIBUTE] = this.createTexture(name, attributesMap));
            }
        } else if ("material" === name) {
            /* add */(this.materials.push(this.createMaterial(name, attributesMap)) > 0);
        } else if ("transformation" === name) {
            const matrixAttribute: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "matrix");
            if (matrixAttribute == null) {
                throw new SAXException("Missing attribute matrix");
            } else {
                const values: string[] = matrixAttribute.split(/ /);
                if (values.length < 12) {
                    throw new SAXException("Missing values for attribute matrix");
                }
                try {
                    const matrix: number[][] = [[/* parseFloat */parseFloat(values[0]), /* parseFloat */parseFloat(values[1]), /* parseFloat */parseFloat(values[2]), /* parseFloat */parseFloat(values[3])], [/* parseFloat */parseFloat(values[4]), /* parseFloat */parseFloat(values[5]), /* parseFloat */parseFloat(values[6]), /* parseFloat */parseFloat(values[7])], [/* parseFloat */parseFloat(values[8]), /* parseFloat */parseFloat(values[9]), /* parseFloat */parseFloat(values[10]), /* parseFloat */parseFloat(values[11])]];
                    const transformation: Transformation = new Transformation(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name"), matrix);
                    /* add */(this.transformations.push(<Transformation>this.resolveObject(transformation, name, attributesMap)) > 0);
                } catch (ex) {
                    throw new SAXException("Invalid value for attribute matrix", ex);
                }
            }
        } else if ("point" === name) {
            /* add */(this.points.push([this.parseFloat(attributesMap, "x"), this.parseFloat(attributesMap, "y")]) > 0);
        } else if ("sash" === name) {
            const sash: Sash = new Sash(this.parseFloat(attributesMap, "xAxis"), this.parseFloat(attributesMap, "yAxis"), this.parseFloat(attributesMap, "width"), this.parseFloat(attributesMap, "startAngle"), this.parseFloat(attributesMap, "endAngle"));
            /* add */(this.sashes.push(<Sash>this.resolveObject(sash, name, attributesMap)) > 0);
        } else if ("lightSource" === name) {
            const lightSource: LightSource = new LightSource(this.parseFloat(attributesMap, "x"), this.parseFloat(attributesMap, "y"), this.parseFloat(attributesMap, "z"), this.parseOptionalColor(attributesMap, "color"), this.parseOptionalFloat(attributesMap, "diameter"));
            /* add */(this.lightSources.push(<LightSource>this.resolveObject(lightSource, name, attributesMap)) > 0);
        } else if ("lightSourceMaterial" === name) {
            /* add */(this.lightSourceMaterialNames.push(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name")) > 0);
        } else if ("shelf" === name) {
            if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "xLower") != null) {
                /* add */(this.shelfBoxes.push(new BoxBounds(this.parseFloat(attributesMap, "xLower"), this.parseFloat(attributesMap, "yLower"), this.parseFloat(attributesMap, "zLower"), this.parseFloat(attributesMap, "xUpper"), this.parseFloat(attributesMap, "yUpper"), this.parseFloat(attributesMap, "zUpper"))) > 0);
            } else {
                /* add */(this.shelfElevations.push(this.parseFloat(attributesMap, "elevation")) > 0);
            }
        } else if ("backgroundImage" === name) {
            let backgroundImage: BackgroundImage = new BackgroundImage(this.parseContent(name, attributesMap, "image"), this.parseFloat(attributesMap, "scaleDistance"), this.parseFloat(attributesMap, "scaleDistanceXStart"), this.parseFloat(attributesMap, "scaleDistanceYStart"), this.parseFloat(attributesMap, "scaleDistanceXEnd"), this.parseFloat(attributesMap, "scaleDistanceYEnd"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "xOrigin") != null ? this.parseFloat(attributesMap, "xOrigin") : 0, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "yOrigin") != null ? this.parseFloat(attributesMap, "yOrigin") : 0, !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "visible")));
            backgroundImage = <BackgroundImage>this.resolveObject(backgroundImage, name, attributesMap);
            if (this.homeElementName != null && (this.homeElementName === parent)) {
                this.homeBackgroundImage = backgroundImage;
            } else {
                this.backgroundImage = backgroundImage;
            }
        } else if ("property" === name) {
            if (this.homeElementName != null) {
                if (/* Enum.name */ObjectProperty.Type[ObjectProperty.Type.CONTENT] === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "type")) {
                    /* put */(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.properties)[/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name")] = this.parseContent(name, attributesMap, "value"));
                } else {
                    /* put */(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.properties)[/* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "name")] = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributesMap, "value"));
                }
            }
        }
        if (!("property" === name) && !("furnitureVisibleProperty" === name) && !("textStyle" === name)) {
            /* pop */this.properties.pop();
            /* pop */this.textStyles.pop();
        }
    }

    /**
     * Returns the trimmed string of last element value.
     * @return {string}
     * @private
     */
    getCharacters(): string {
        return this.buffer.str.replace(/&quot;/g, '\"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
    }

    /**
     * 
     */
    public endDocument() {
        const printedLevels: Array<Level> = <any>([]);
        for (let index = 0; index < this.printedLevelIds.length; index++) {
            let levelId = this.printedLevelIds[index];
            {
                {
                    let array = this.home.getLevels();
                    for (let index1 = 0; index1 < array.length; index1++) {
                        let level = array[index1];
                        {
                            if (levelId === level.getId()) {
                                /* add */(printedLevels.push(level) > 0);
                                break;
                            }
                        }
                    }
                }
            }
        }
        const print: HomePrint = this.home.getPrint();
        if (print != null && !/* isEmpty */(printedLevels.length == 0) && (<any>print.constructor) === HomePrint) {
            this.home.setPrint(new HomePrint(print.getPaperOrientation(), print.getPaperWidth(), print.getPaperHeight(), print.getPaperTopMargin(), print.getPaperLeftMargin(), print.getPaperBottomMargin(), print.getPaperRightMargin(), print.isFurniturePrinted(), print.isPlanPrinted(), printedLevels, print.isView3DPrinted(), print.getPlanScale(), print.getHeaderFormat(), print.getFooterFormat()));
        }
        {
            let array = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.joinedWalls);
            for (let index = 0; index < array.length; index++) {
                let joinedWall = array[index];
                {
                    const wall: Wall = joinedWall.getWall();
                    if (joinedWall.getWallAtStartId() != null && !(joinedWall.getWallAtStartId() === wall.getId())) {
                        const joinedWallAtStart: HomeXMLHandler.JoinedWall = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.joinedWalls, joinedWall.getWallAtStartId());
                        if (joinedWallAtStart != null) {
                            wall.setWallAtStart(joinedWallAtStart.getWall());
                        }
                    }
                    if (joinedWall.getWallAtEndId() != null && !(joinedWall.getWallAtEndId() === wall.getId())) {
                        const joinedWallAtEnd: HomeXMLHandler.JoinedWall = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.joinedWalls, joinedWall.getWallAtEndId());
                        if (joinedWallAtEnd != null) {
                            wall.setWallAtEnd(joinedWallAtEnd.getWall());
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the object that will be stored in a home. This method is called for each home object created by this handler
     * after its instantiation and returns <code>elementObject</code>. It might be overridden to substitute an object
     * parsed from an XML element and its attributes for an other one of a different subclass if needed.
     * @param {Object} elementObject
     * @param {string} elementName
     * @param {Object} attributes
     * @return {Object}
     */
    resolveObject(elementObject: any, elementName: string, attributes: any): any {
        return elementObject;
    }

    /**
     * Returns a new {@link Home} instance initialized from the given <code>attributes</code>.
     * @return {Home} a home instance with its version set.
     * @param {string} elementName
     * @param {Object} attributes
     * @private
     */
    createHome(elementName: string, attributes: any): Home {
        let home: Home;
        if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "wallHeight") != null) {
            home = new Home(this.parseFloat(attributes, "wallHeight"));
        } else {
            home = new Home();
        }
        const version: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "version");
        if (version != null) {
            try {
                home.setVersion(/* parseInt */parseInt(version));
            } catch (ex) {
                throw new SAXException("Invalid value for integer attribute version", ex);
            }
        }
        return <Home>this.resolveObject(home, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>home</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Home} home
     * @param {string} elementName
     * @param {Object} attributes
     */
    setHomeAttributes(home: Home, elementName: string, attributes: any) {
        {
            let array = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function () { return this.k }, getValue: function () { return this.v } }); return s; })(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.properties));
            for (let index = 0; index < array.length; index++) {
                let property = array[index];
                {
                    if (typeof property.getValue() === 'string') {
                        home.setProperty(property.getKey(), <string>property.getValue());
                    }
                }
            }
        }
        if (/* size */(<number>this.furnitureVisiblePropertyNames.length) > 0) {
            this.home.setFurnitureVisiblePropertyNames(this.furnitureVisiblePropertyNames);
        }
        this.home.setBackgroundImage(this.homeBackgroundImage);
        home.setName(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name"));
        const selectedLevelId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "selectedLevel");
        if (selectedLevelId != null) {
            this.home.setSelectedLevel(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.levels, selectedLevelId));
        }
        if ("observerCamera" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "camera")) {
            this.home.setCamera(this.home.getObserverCamera());
        }
        home.setBasePlanLocked("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "basePlanLocked"));
        const furnitureSortedPropertyName: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "furnitureSortedProperty");
        if (furnitureSortedPropertyName != null) {
            try {
                home.setFurnitureSortedPropertyName(furnitureSortedPropertyName);
            } catch (ex) {
            }
        }
        home.setFurnitureDescendingSorted("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "furnitureDescendingSorted"));
        if (attributes['structure']) { home['structure'] = this.parseContent(this.homeElementName, attributes, 'structure'); }
    }

    /**
     * Sets the attributes of the given <code>environment</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {HomeEnvironment} environment
     * @param {string} elementName
     * @param {Object} attributes
     * @private
     */
    setEnvironmentAttributes(environment: HomeEnvironment, elementName: string, attributes: any) {
        this.setProperties(environment, elementName, attributes);
        const groundColor: number = this.parseOptionalColor(attributes, "groundColor");
        if (groundColor != null) {
            environment.setGroundColor(groundColor);
        }
        environment.setGroundTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "groundTexture"));
        environment.setBackgroundImageVisibleOnGround3D("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "backgroundImageVisibleOnGround3D"));
        const skyColor: number = this.parseOptionalColor(attributes, "skyColor");
        if (skyColor != null) {
            environment.setSkyColor(skyColor);
        }
        environment.setSkyTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "skyTexture"));
        const lightColor: number = this.parseOptionalColor(attributes, "lightColor");
        if (lightColor != null) {
            environment.setLightColor(lightColor);
        }
        const wallsAlpha: number = this.parseOptionalFloat(attributes, "wallsAlpha");
        if (wallsAlpha != null) {
            environment.setWallsAlpha(wallsAlpha);
        }
        environment.setAllLevelsVisible("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "allLevelsVisible"));
        environment.setObserverCameraElevationAdjusted(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "observerCameraElevationAdjusted")));
        const ceillingLightColor: number = this.parseOptionalColor(attributes, "ceillingLightColor");
        if (ceillingLightColor != null) {
            environment.setCeillingLightColor(ceillingLightColor);
        }
        const drawingMode: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "drawingMode");
        if (drawingMode != null) {
            try {
                environment.setDrawingMode(/* Enum.valueOf */<any>HomeEnvironment.DrawingMode[drawingMode]);
            } catch (ex) {
            }
        }
        const subpartSizeUnderLight: number = this.parseOptionalFloat(attributes, "subpartSizeUnderLight");
        if (subpartSizeUnderLight != null) {
            environment.setSubpartSizeUnderLight(subpartSizeUnderLight);
        }
        const photoWidth: number = this.parseOptionalInteger(attributes, "photoWidth");
        if (photoWidth != null) {
            environment.setPhotoWidth(photoWidth);
        }
        const photoHeight: number = this.parseOptionalInteger(attributes, "photoHeight");
        if (photoHeight != null) {
            environment.setPhotoHeight(photoHeight);
        }
        const photoAspectRatio: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "photoAspectRatio");
        if (photoAspectRatio != null) {
            try {
                environment.setPhotoAspectRatio(/* Enum.valueOf */<any>AspectRatio[photoAspectRatio]);
            } catch (ex) {
            }
        }
        const photoQuality: number = this.parseOptionalInteger(attributes, "photoQuality");
        if (photoQuality != null) {
            environment.setPhotoQuality(photoQuality);
        }
        const videoWidth: number = this.parseOptionalInteger(attributes, "videoWidth");
        if (videoWidth != null) {
            environment.setVideoWidth(videoWidth);
        }
        const videoAspectRatio: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "videoAspectRatio");
        if (videoAspectRatio != null) {
            try {
                environment.setVideoAspectRatio(/* Enum.valueOf */<any>AspectRatio[videoAspectRatio]);
            } catch (ex) {
            }
        }
        const videoQuality: number = this.parseOptionalInteger(attributes, "videoQuality");
        if (videoQuality != null) {
            environment.setVideoQuality(videoQuality);
        }
        const videoSpeed: number = this.parseOptionalFloat(attributes, "videoSpeed");
        if (videoSpeed != null) {
            environment.setVideoSpeed(videoSpeed);
        }
        const videoFrameRate: number = this.parseOptionalInteger(attributes, "videoFrameRate");
        if (videoFrameRate != null) {
            environment.setVideoFrameRate(videoFrameRate);
        }
    }

    /**
     * Returns a new {@link HomePrint} instance initialized from the given <code>attributes</code>.
     * @param {Object} attributes
     * @return {HomePrint}
     */
    createPrint(attributes: any): HomePrint {
        let paperOrientation: HomePrint.PaperOrientation = HomePrint.PaperOrientation.PORTRAIT;
        try {
            if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "paperOrientation") == null) {
                throw new SAXException("Missing paperOrientation attribute");
            }
            paperOrientation = /* Enum.valueOf */ <any>HomePrint.PaperOrientation[/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "paperOrientation")];
        } catch (ex) {
        }
        const homePrint: HomePrint = new HomePrint(paperOrientation, this.parseFloat(attributes, "paperWidth"), this.parseFloat(attributes, "paperHeight"), this.parseFloat(attributes, "paperTopMargin"), this.parseFloat(attributes, "paperLeftMargin"), this.parseFloat(attributes, "paperBottomMargin"), this.parseFloat(attributes, "paperRightMargin"), !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "furniturePrinted")), !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "planPrinted")), !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "view3DPrinted")), this.parseOptionalFloat(attributes, "planScale"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "headerFormat"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "footerFormat"));
        return <HomePrint>this.resolveObject(homePrint, "print", attributes);
    }

    /**
     * Sets the attributes of the given <code>compass</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Compass} compass
     * @param {string} elementName
     * @param {Object} attributes
     */
    setCompassAttributes(compass: Compass, elementName: string, attributes: any) {
        this.setProperties(compass, elementName, attributes);
        compass.setX(this.parseOptionalFloat(attributes, "x"));
        compass.setY(this.parseOptionalFloat(attributes, "y"));
        compass.setDiameter(this.parseOptionalFloat(attributes, "diameter"));
        const northDirection: number = this.parseOptionalFloat(attributes, "northDirection");
        if (northDirection != null) {
            compass.setNorthDirection(northDirection);
        }
        const longitude: number = this.parseOptionalFloat(attributes, "longitude");
        if (longitude != null) {
            compass.setLongitude(longitude);
        }
        const latitude: number = this.parseOptionalFloat(attributes, "latitude");
        if (latitude != null) {
            compass.setLatitude(latitude);
        }
        const timeZone: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "timeZone");
        if (timeZone != null) {
            compass.setTimeZone(timeZone);
        }
        compass.setVisible(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "visible")));
    }

    /**
     * Returns a new {@link Camera} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {Camera}
     * @private
     */
    createCamera(elementName: string, attributes: any): Camera {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const x: number = this.parseFloat(attributes, "x");
        const y: number = this.parseFloat(attributes, "y");
        const z: number = this.parseFloat(attributes, "z");
        const yaw: number = this.parseFloat(attributes, "yaw");
        const pitch: number = this.parseFloat(attributes, "pitch");
        const fieldOfView: number = this.parseFloat(attributes, "fieldOfView");
        let camera: Camera;
        if ("observerCamera" === elementName) {
            camera = id != null ? new ObserverCamera(id, x, y, z, yaw, pitch, fieldOfView) : new ObserverCamera(x, y, z, yaw, pitch, fieldOfView);
        } else {
            camera = id != null ? new Camera(id, x, y, z, yaw, pitch, fieldOfView) : new Camera(x, y, z, yaw, pitch, fieldOfView);
        }
        return <Camera>this.resolveObject(camera, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>camera</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Camera} camera
     * @param {string} elementName
     * @param {Object} attributes
     */
    setCameraAttributes(camera: Camera, elementName: string, attributes: any) {
        this.setProperties(camera, elementName, attributes);
        if (camera != null && camera instanceof <any>ObserverCamera) {
            (<ObserverCamera>camera).setFixedSize("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "fixedSize"));
        }
        const lens: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "lens");
        if (lens != null) {
            try {
                camera.setLens(/* Enum.valueOf */<any>Camera.Lens[lens]);
            } catch (ex) {
            }
        }
        const time: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "time");
        if (time != null) {
            try {
                camera.setTime(/* parseLong */parseInt(time));
            } catch (ex) {
                throw new SAXException("Invalid value for long attribute time", ex);
            }
        }
        camera.setName(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name"));
        camera.setRenderer(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "renderer"));
    }

    /**
     * Returns a new {@link Level} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {Level}
     * @private
     */
    createLevel(elementName: string, attributes: any): Level {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const name: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name");
        const elevation: number = this.parseFloat(attributes, "elevation");
        const floorThickness: number = this.parseFloat(attributes, "floorThickness");
        const height: number = this.parseFloat(attributes, "height");
        const level: Level = id != null ? new Level(id, name, elevation, floorThickness, height) : new Level(name, elevation, floorThickness, height);
        return <Level>this.resolveObject(level, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>level</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Level} level
     * @param {string} elementName
     * @param {Object} attributes
     */
    setLevelAttributes(level: Level, elementName: string, attributes: any) {
        this.setProperties(level, elementName, attributes);
        level.setBackgroundImage(this.backgroundImage);
        const elevationIndex: number = this.parseOptionalInteger(attributes, "elevationIndex");
        if (elevationIndex != null) {
            level.setElevationIndex(elevationIndex);
        }
        level.setVisible(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "visible")));
        level.setViewable(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "viewable")));
    }

    /**
     * Returns a new {@link HomePieceOfFurniture} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {HomePieceOfFurniture}
     * @private
     */
    createPieceOfFurniture(elementName: string, attributes: any): HomePieceOfFurniture {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const catalogId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "catalogId");
        const tags: string[] = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "tags") != null ? /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "tags").split(/ /) : null;
        const elevation: number = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "elevation") != null ? this.parseFloat(attributes, "elevation") : 0;
        const dropOnTopElevation: number = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "dropOnTopElevation") != null ? this.parseFloat(attributes, "dropOnTopElevation") : 1;
        let modelRotation: number[][] = null;
        if (/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelRotation") != null) {
            const values: string[] = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelRotation").split(/ /);
            if (values.length < 9) {
                throw new SAXException("Missing values for attribute modelRotation");
            }
            try {
                modelRotation = [[/* parseFloat */parseFloat(values[0]), /* parseFloat */parseFloat(values[1]), /* parseFloat */parseFloat(values[2])], [/* parseFloat */parseFloat(values[3]), /* parseFloat */parseFloat(values[4]), /* parseFloat */parseFloat(values[5])], [/* parseFloat */parseFloat(values[6]), /* parseFloat */parseFloat(values[7]), /* parseFloat */parseFloat(values[8])]];
            } catch (ex) {
                throw new SAXException("Invalid value for attribute modelRotation", ex);
            }
        }
        const name: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name");
        const description: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "description");
        const information: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "information");
        const license: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "license");
        const creationDate: number = this.parseOptionalLong(attributes, "creationDate");
        const grade: number = this.parseOptionalFloat(attributes, "grade");
        const icon: Content = this.parseContent(elementName, attributes, "icon");
        const planIcon: Content = this.parseContent(elementName, attributes, "planIcon");
        const model: Content = this.parseContent(elementName, attributes, "model");
        const width: number = this.parseFloat(attributes, "width");
        const depth: number = this.parseFloat(attributes, "depth");
        const height: number = this.parseFloat(attributes, "height");
        const movable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "movable"));
        let modelFlags: number = this.parseOptionalInteger(attributes, "modelFlags");
        if (modelFlags == null) {
            modelFlags = "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "backFaceShown") ? PieceOfFurniture.SHOW_BACK_FACE : 0;
        }
        const modelSize: number = this.parseOptionalLong(attributes, "modelSize");
        const creator: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "creator");
        const resizable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "resizable"));
        const deformable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "deformable"));
        const texturable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "texturable"));
        const price: Big = this.parseOptionalDecimal(attributes, "price");
        const valueAddedTaxPercentage: Big = this.parseOptionalDecimal(attributes, "valueAddedTaxPercentage");
        const currency: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "currency");
        let piece: HomePieceOfFurniture;
        if (("doorOrWindow" === elementName) || ("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "doorOrWindow"))) {
            const wallThickness: number = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "wallThickness") != null ? this.parseFloat(attributes, "wallThickness") : 1;
            const wallDistance: number = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "wallDistance") != null ? this.parseFloat(attributes, "wallDistance") : 0;
            let cutOutShape: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "cutOutShape");
            if (cutOutShape == null && !("doorOrWindow" === elementName)) {
                cutOutShape = PieceOfFurniture.DEFAULT_CUT_OUT_SHAPE;
            }
            const wallCutOutOnBothSides: boolean = "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "wallCutOutOnBothSides");
            const widthDepthDeformable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "widthDepthDeformable"));
            const catalogDoorOrWindow: CatalogDoorOrWindow = new CatalogDoorOrWindow(catalogId, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, cutOutShape, wallThickness, wallDistance, wallCutOutOnBothSides, widthDepthDeformable, /* toArray */this.sashes.slice(0), modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, price, valueAddedTaxPercentage, currency, null, null);
            piece = id != null ? new HomeDoorOrWindow(id, catalogDoorOrWindow) : new HomeDoorOrWindow(catalogDoorOrWindow);
        } else {
            const staircaseCutOutShape: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "staircaseCutOutShape");
            const horizontallyRotatable: boolean = !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "horizontallyRotatable"));
            if ("light" === elementName) {
                const catalogLight: CatalogLight = new CatalogLight(catalogId, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, /* toArray */this.lightSources.slice(0), /* toArray */this.lightSourceMaterialNames.slice(0), staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, null, null);
                piece = id != null ? new HomeLight(id, catalogLight) : new HomeLight(catalogLight);
            } else if ("shelfUnit" === elementName) {
                const shelfElevations: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>this.shelfElevations.length));
                for (let i: number = 0; i < shelfElevations.length; i++) {
                    {
                        shelfElevations[i] = /* floatValue *//* get */this.shelfElevations[i];
                    };
                }
                const catalogShelfUnit: CatalogShelfUnit = new CatalogShelfUnit(catalogId, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, shelfElevations, /* toArray */this.shelfBoxes.slice(0), movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, null, null);
                piece = id != null ? new HomeShelfUnit(id, catalogShelfUnit) : new HomeShelfUnit(catalogShelfUnit);
            } else {
                const catalogPiece: CatalogPieceOfFurniture = new CatalogPieceOfFurniture(catalogId, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, null, null);
                piece = id != null ? new HomePieceOfFurniture(id, catalogPiece) : new HomePieceOfFurniture(catalogPiece);
            }
        }
        return <HomePieceOfFurniture>this.resolveObject(piece, elementName, attributes);
    }

    /**
     * Returns a new {@link HomeFurnitureGroup} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomeFurnitureGroup}
     * @private
     */
    createFurnitureGroup(elementName: string, attributes: any, furniture: Array<HomePieceOfFurniture>): HomeFurnitureGroup {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const angle: number = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "angle") != null ? this.parseFloat(attributes, "angle") : 0;
        const modelMirrored: boolean = "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelMirrored");
        const name: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name");
        const furnitureGroup: HomeFurnitureGroup = id != null ? new HomeFurnitureGroup(id, furniture, angle, modelMirrored, name) : new HomeFurnitureGroup(furniture, angle, modelMirrored, name);
        return <HomeFurnitureGroup>this.resolveObject(furnitureGroup, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>piece</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {HomePieceOfFurniture} piece
     * @param {string} elementName
     * @param {Object} attributes
     */
    setPieceOfFurnitureAttributes(piece: HomePieceOfFurniture, elementName: string, attributes: any) {
        this.setProperties(piece, elementName, attributes);
        piece.setNameStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles), "nameStyle"));
        piece.setNameVisible("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "nameVisible"));
        const nameAngle: number = this.parseOptionalFloat(attributes, "nameAngle");
        if (nameAngle != null) {
            piece.setNameAngle(nameAngle);
        }
        const nameXOffset: number = this.parseOptionalFloat(attributes, "nameXOffset");
        if (nameXOffset != null) {
            piece.setNameXOffset(nameXOffset);
        }
        const nameYOffset: number = this.parseOptionalFloat(attributes, "nameYOffset");
        if (nameYOffset != null) {
            piece.setNameYOffset(nameYOffset);
        }
        piece.setVisible(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "visible")));
        if (!(piece != null && piece instanceof <any>HomeFurnitureGroup)) {
            const x: number = this.parseOptionalFloat(attributes, "x");
            if (x != null) {
                piece.setX(x);
            }
            const y: number = this.parseOptionalFloat(attributes, "y");
            if (y != null) {
                piece.setY(y);
            }
            const angle: number = this.parseOptionalFloat(attributes, "angle");
            if (angle != null) {
                piece.setAngle(angle);
            }
            if (piece.isHorizontallyRotatable()) {
                const pitch: number = this.parseOptionalFloat(attributes, "pitch");
                if (pitch != null) {
                    piece.setPitch(pitch);
                }
                const roll: number = this.parseOptionalFloat(attributes, "roll");
                if (roll != null) {
                    piece.setRoll(roll);
                }
            }
            const widthInPlan: number = this.parseOptionalFloat(attributes, "widthInPlan");
            if (widthInPlan != null) {
                piece.setWidthInPlan(widthInPlan);
            }
            const depthInPlan: number = this.parseOptionalFloat(attributes, "depthInPlan");
            if (depthInPlan != null) {
                piece.setDepthInPlan(depthInPlan);
            }
            const heightInPlan: number = this.parseOptionalFloat(attributes, "heightInPlan");
            if (heightInPlan != null) {
                piece.setHeightInPlan(heightInPlan);
            }
            if (this.home.getVersion() < 5500 || ("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelCenteredAtOrigin"))) {
                piece.setModelCenteredAtOrigin(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelRotation") == null);
            }
            if (piece.isResizable()) {
                piece.setModelMirrored("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "modelMirrored"));
            }
            if (piece.isTexturable()) {
                if (/* size */(<number>this.materials.length) > 0) {
                    piece.setModelMaterials(/* toArray */this.materials.slice(0));
                }
                const color: number = this.parseOptionalColor(attributes, "color");
                if (color != null) {
                    piece.setColor(color);
                }
                const texture: HomeTexture = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, HomeXMLHandler.UNIQUE_ATTRIBUTE);
                if (texture != null) {
                    piece.setTexture(texture);
                }
                const shininess: number = this.parseOptionalFloat(attributes, "shininess");
                if (shininess != null) {
                    piece.setShininess(shininess);
                }
            }
            if (piece.isDeformable()) {
                if (/* size */(<number>this.transformations.length) > 0) {
                    piece.setModelTransformations(/* toArray */this.transformations.slice(0));
                }
            }
            if ((piece != null && piece instanceof <any>HomeLight) && /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "power") != null) {
                (<HomeLight>piece).setPower(this.parseFloat(attributes, "power"));
            } else if ((piece != null && piece instanceof <any>HomeDoorOrWindow) && ("doorOrWindow" === elementName)) {
                const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                doorOrWindow.setBoundToWall(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "boundToWall")));
                const wallWidth: number = this.parseOptionalFloat(attributes, "wallWidth");
                if (wallWidth != null) {
                    doorOrWindow.setWallWidth(wallWidth);
                }
                const wallLeft: number = this.parseOptionalFloat(attributes, "wallLeft");
                if (wallLeft != null) {
                    doorOrWindow.setWallLeft(wallLeft);
                }
                const wallHeight: number = this.parseOptionalFloat(attributes, "wallHeight");
                if (wallHeight != null) {
                    doorOrWindow.setWallHeight(wallHeight);
                }
                const wallTop: number = this.parseOptionalFloat(attributes, "wallTop");
                if (wallTop != null) {
                    doorOrWindow.setWallTop(wallTop);
                }
            }
        } else {
            piece.setCatalogId(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "catalogId"));
            piece.setDescription(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "description"));
            piece.setInformation(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "information"));
            piece.setLicense(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "license"));
            piece.setCreator(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "creator"));
        }
    }

    /**
     * Returns a new {@link Wall} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {Wall}
     * @private
     */
    createWall(elementName: string, attributes: any): Wall {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const xStart: number = this.parseFloat(attributes, "xStart");
        const yStart: number = this.parseFloat(attributes, "yStart");
        const xEnd: number = this.parseFloat(attributes, "xEnd");
        const yEnd: number = this.parseFloat(attributes, "yEnd");
        const thickness: number = this.parseFloat(attributes, "thickness");
        const wall: Wall = id != null ? new Wall(id, xStart, yStart, xEnd, yEnd, thickness, 0) : new Wall(xStart, yStart, xEnd, yEnd, thickness, 0);
        return <Wall>this.resolveObject(wall, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>wall</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Wall} wall
     * @param {string} elementName
     * @param {Object} attributes
     */
    setWallAttributes(wall: Wall, elementName: string, attributes: any) {
        this.setProperties(wall, elementName, attributes);
        wall.setLeftSideBaseboard(this.leftSideBaseboard);
        wall.setRightSideBaseboard(this.rightSideBaseboard);
        wall.setHeight(this.parseOptionalFloat(attributes, "height"));
        wall.setHeightAtEnd(this.parseOptionalFloat(attributes, "heightAtEnd"));
        wall.setArcExtent(this.parseOptionalFloat(attributes, "arcExtent"));
        wall.setTopColor(this.parseOptionalColor(attributes, "topColor"));
        wall.setLeftSideColor(this.parseOptionalColor(attributes, "leftSideColor"));
        wall.setLeftSideTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "leftSideTexture"));
        const leftSideShininess: number = this.parseOptionalFloat(attributes, "leftSideShininess");
        if (leftSideShininess != null) {
            wall.setLeftSideShininess(leftSideShininess);
        }
        wall.setRightSideColor(this.parseOptionalColor(attributes, "rightSideColor"));
        wall.setRightSideTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "rightSideTexture"));
        const rightSideShininess: number = this.parseOptionalFloat(attributes, "rightSideShininess");
        if (rightSideShininess != null) {
            wall.setRightSideShininess(rightSideShininess);
        }
        const pattern: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "pattern");
        if (pattern != null) {
            try {
                wall.setPattern(this.preferences.getPatternsCatalog().getPattern$java_lang_String(pattern));
            } catch (ex) {
            }
        }
    }

    /**
     * Returns a new {@link Room} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @param {float[][]} points
     * @return {Room}
     * @private
     */
    createRoom(elementName: string, attributes: any, points: number[][]): Room {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const room: Room = id != null ? new Room(id, points) : new Room(points);
        return <Room>this.resolveObject(room, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>room</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Room} room
     * @param {string} elementName
     * @param {Object} attributes
     */
    setRoomAttributes(room: Room, elementName: string, attributes: any) {
        this.setProperties(room, elementName, attributes);
        room.setNameStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles), "nameStyle"));
        room.setAreaStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles), "areaStyle"));
        room.setName(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name"));
        const nameAngle: number = this.parseOptionalFloat(attributes, "nameAngle");
        if (nameAngle != null) {
            room.setNameAngle(nameAngle);
        }
        const nameXOffset: number = this.parseOptionalFloat(attributes, "nameXOffset");
        if (nameXOffset != null) {
            room.setNameXOffset(nameXOffset);
        }
        const nameYOffset: number = this.parseOptionalFloat(attributes, "nameYOffset");
        if (nameYOffset != null) {
            room.setNameYOffset(nameYOffset);
        }
        room.setAreaVisible("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "areaVisible"));
        const areaAngle: number = this.parseOptionalFloat(attributes, "areaAngle");
        if (areaAngle != null) {
            room.setAreaAngle(areaAngle);
        }
        const areaXOffset: number = this.parseOptionalFloat(attributes, "areaXOffset");
        if (areaXOffset != null) {
            room.setAreaXOffset(areaXOffset);
        }
        const areaYOffset: number = this.parseOptionalFloat(attributes, "areaYOffset");
        if (areaYOffset != null) {
            room.setAreaYOffset(areaYOffset);
        }
        room.setFloorVisible(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "floorVisible")));
        room.setFloorColor(this.parseOptionalColor(attributes, "floorColor"));
        room.setFloorTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "floorTexture"));
        const floorShininess: number = this.parseOptionalFloat(attributes, "floorShininess");
        if (floorShininess != null) {
            room.setFloorShininess(floorShininess);
        }
        room.setCeilingVisible(!("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "ceilingVisible")));
        room.setCeilingColor(this.parseOptionalColor(attributes, "ceilingColor"));
        room.setCeilingTexture(/* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, "ceilingTexture"));
        const ceilingShininess: number = this.parseOptionalFloat(attributes, "ceilingShininess");
        if (ceilingShininess != null) {
            room.setCeilingShininess(ceilingShininess);
        }
        room.setCeilingFlat("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "ceilingFlat"));
    }

    /**
     * Returns a new {@link Polyline} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @param {float[][]} points
     * @return {Polyline}
     * @private
     */
    createPolyline(elementName: string, attributes: any, points: number[][]): Polyline {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const polyline: Polyline = id != null ? new Polyline(id, points) : new Polyline(points);
        return <Polyline>this.resolveObject(polyline, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>polyline</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Polyline} polyline
     * @param {string} elementName
     * @param {Object} attributes
     */
    setPolylineAttributes(polyline: Polyline, elementName: string, attributes: any) {
        this.setProperties(polyline, elementName, attributes);
        const thickness: number = this.parseOptionalFloat(attributes, "thickness");
        if (thickness != null) {
            polyline.setThickness(thickness);
        }
        const capStyle: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "capStyle");
        if (capStyle != null) {
            try {
                polyline.setCapStyle(/* Enum.valueOf */<any>Polyline.CapStyle[capStyle]);
            } catch (ex) {
            }
        }
        const joinStyle: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "joinStyle");
        if (joinStyle != null) {
            try {
                polyline.setJoinStyle(/* Enum.valueOf */<any>Polyline.JoinStyle[joinStyle]);
            } catch (ex) {
            }
        }
        const dashStyle: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "dashStyle");
        if (dashStyle != null) {
            try {
                polyline.setDashStyle(/* Enum.valueOf */<any>Polyline.DashStyle[dashStyle]);
            } catch (ex) {
            }
        }
        const dashPattern: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "dashPattern");
        if (dashPattern != null) {
            try {
                const values: string[] = dashPattern.split(/ /);
                const pattern: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(values.length);
                for (let i: number = 0; i < values.length; i++) {
                    {
                        pattern[i] = /* parseFloat */parseFloat(values[i]);
                    };
                }
                polyline.setDashPattern(pattern);
            } catch (ex) {
                throw new SAXException("Invalid value for dash pattern", ex);
            }
        }
        const dashOffset: number = this.parseOptionalFloat(attributes, "dashOffset");
        if (dashOffset != null) {
            polyline.setDashOffset(dashOffset);
        }
        const startArrowStyle: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "startArrowStyle");
        if (startArrowStyle != null) {
            try {
                polyline.setStartArrowStyle(/* Enum.valueOf */<any>Polyline.ArrowStyle[startArrowStyle]);
            } catch (ex) {
            }
        }
        const endArrowStyle: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "endArrowStyle");
        if (endArrowStyle != null) {
            try {
                polyline.setEndArrowStyle(/* Enum.valueOf */<any>Polyline.ArrowStyle[endArrowStyle]);
            } catch (ex) {
            }
        }
        const elevation: number = this.parseOptionalFloat(attributes, "elevation");
        if (elevation != null) {
            polyline.setVisibleIn3D(true);
            polyline.setElevation(elevation);
        }
        const color: number = this.parseOptionalColor(attributes, "color");
        if (color != null) {
            polyline.setColor(color);
        }
        polyline.setClosedPath("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "closedPath"));
    }

    /**
     * Returns a new {@link DimensionLine} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {DimensionLine}
     * @private
     */
    createDimensionLine(elementName: string, attributes: any): DimensionLine {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const xStart: number = this.parseFloat(attributes, "xStart");
        const yStart: number = this.parseFloat(attributes, "yStart");
        let optionalValue: number = this.parseOptionalFloat(attributes, "elevationStart");
        const elevationStart: number = optionalValue != null ? /* floatValue */optionalValue : 0;
        const xEnd: number = this.parseFloat(attributes, "xEnd");
        const yEnd: number = this.parseFloat(attributes, "yEnd");
        optionalValue = this.parseOptionalFloat(attributes, "elevationEnd");
        const elevationEnd: number = optionalValue != null ? /* floatValue */optionalValue : 0;
        const offset: number = this.parseFloat(attributes, "offset");
        const dimensionLine: DimensionLine = id != null ? new DimensionLine(id, xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, offset) : new DimensionLine(xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, offset);
        optionalValue = this.parseOptionalFloat(attributes, "endMarkSize");
        if (optionalValue != null) {
            dimensionLine.setEndMarkSize(/* floatValue */optionalValue);
        }
        optionalValue = this.parseOptionalFloat(attributes, "pitch");
        if (optionalValue != null) {
            dimensionLine.setPitch(/* floatValue */optionalValue);
        }
        const color: number = this.parseOptionalColor(attributes, "color");
        if (color != null) {
            dimensionLine.setColor(color);
        }
        dimensionLine.setVisibleIn3D("true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "visibleIn3D"));
        return <DimensionLine>this.resolveObject(dimensionLine, elementName, attributes);
    }

    /**
     * Sets the attributes of the given dimension line.
     * If needed, this method should be called from {@link #endElement}.
     * @param {DimensionLine} dimensionLine
     * @param {string} elementName
     * @param {Object} attributes
     */
    setDimensionLineAttributes(dimensionLine: DimensionLine, elementName: string, attributes: any) {
        this.setProperties(dimensionLine, elementName, attributes);
        dimensionLine.setLengthStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles), "lengthStyle"));
    }

    /**
     * Returns a new {@link Label} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @param {string} text
     * @return {Label}
     * @private
     */
    createLabel(elementName: string, attributes: any, text: string): Label {
        const id: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "id");
        const x: number = this.parseFloat(attributes, "x");
        const y: number = this.parseFloat(attributes, "y");
        const label: Label = id != null ? new Label(id, text, x, y) : new Label(text, x, y);
        return <Label>this.resolveObject(label, elementName, attributes);
    }

    /**
     * Sets the attributes of the given <code>label</code>.
     * If needed, this method should be called from {@link #endElement}.
     * @param {Label} label
     * @param {string} elementName
     * @param {Object} attributes
     */
    setLabelAttributes(label: Label, elementName: string, attributes: any) {
        this.setProperties(label, elementName, attributes);
        label.setStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.textStyles), HomeXMLHandler.UNIQUE_ATTRIBUTE));
        const angle: number = this.parseOptionalFloat(attributes, "angle");
        if (angle != null) {
            label.setAngle(angle);
        }
        const elevation: number = this.parseOptionalFloat(attributes, "elevation");
        if (elevation != null) {
            label.setElevation(elevation);
        }
        const pitch: number = this.parseOptionalFloat(attributes, "pitch");
        if (pitch != null) {
            label.setPitch(pitch);
        }
        label.setColor(this.parseOptionalColor(attributes, "color"));
        label.setOutlineColor(this.parseOptionalColor(attributes, "outlineColor"));
    }

    /**
     * Returns a new {@link Baseboard} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {Baseboard}
     * @private
     */
    createBaseboard(elementName: string, attributes: any): Baseboard {
        const baseboard: Baseboard = Baseboard.getInstance(this.parseFloat(attributes, "thickness"), this.parseFloat(attributes, "height"), this.parseOptionalColor(attributes, "color"), /* get */((m, k) => m[k] === undefined ? null : m[k])(this.textures, HomeXMLHandler.UNIQUE_ATTRIBUTE));
        return <Baseboard>this.resolveObject(baseboard, elementName, attributes);
    }

    /**
     * Returns a new {@link TextStyle} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {TextStyle}
     * @private
     */
    createTextStyle(elementName: string, attributes: any): TextStyle {
        let alignment: TextStyle.Alignment = TextStyle.Alignment.CENTER;
        const alignmentString: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "alignment");
        if (alignmentString != null) {
            try {
                alignment = /* Enum.valueOf */ <any>TextStyle.Alignment[alignmentString];
            } catch (ex) {
            }
        }
        const textStyle: TextStyle = new TextStyle(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "fontName"), this.parseFloat(attributes, "fontSize"), "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "bold"), "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "italic"), alignment);
        return <TextStyle>this.resolveObject(textStyle, elementName, attributes);
    }

    /**
     * Returns a new {@link HomeTexture} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {HomeTexture}
     * @private
     */
    createTexture(elementName: string, attributes: any): HomeTexture {
        const catalogId: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "catalogId");
        const texture: HomeTexture = new HomeTexture(new CatalogTexture(catalogId, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name"), this.parseContent(elementName, attributes, "image"), this.parseFloat(attributes, "width"), this.parseFloat(attributes, "height"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "creator")), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "xOffset") != null ? this.parseFloat(attributes, "xOffset") : 0, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "yOffset") != null ? this.parseFloat(attributes, "yOffset") : 0, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "angle") != null ? this.parseFloat(attributes, "angle") : 0, /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "scale") != null ? this.parseFloat(attributes, "scale") : 1, "true" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "fittingArea"), !("false" === /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "leftToRightOriented")));
        return <HomeTexture>this.resolveObject(texture, elementName, attributes);
    }

    /**
     * Returns a new {@link HomeMaterial} instance initialized from the given <code>attributes</code>.
     * @param {string} elementName
     * @param {Object} attributes
     * @return {HomeMaterial}
     * @private
     */
    createMaterial(elementName: string, attributes: any): HomeMaterial {
        const material: HomeMaterial = new HomeMaterial(/* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "name"), /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, "key"), this.parseOptionalColor(attributes, "color"), this.materialTexture, this.parseOptionalFloat(attributes, "shininess"));
        return <HomeMaterial>this.resolveObject(material, elementName, attributes);
    }

    /**
     * Sets the properties of the given <code>object</code>.
     * @param {HomeObject} object
     * @param {string} elementName
     * @param {Object} attributes
     * @private
     */
    setProperties(object: HomeObject, elementName: string, attributes: any) {
        {
            let array = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function () { return this.k }, getValue: function () { return this.v } }); return s; })(/* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.properties));
            for (let index = 0; index < array.length; index++) {
                let property = array[index];
                {
                    object.setProperty$java_lang_String$java_lang_Object(property.getKey(), property.getValue());
                }
            }
        }
    }

    /**
     * Returns the color integer from a hexadecimal string.
     * @param {Object} attributes
     * @param {string} name
     * @return {number}
     * @private
     */
    parseOptionalColor(attributes: any, name: string): number {
        const color: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (color != null) {
            try {
                return (<number>/* parseLong */parseInt(color, 16) | 0);
            } catch (ex) {
                throw new SAXException("Invalid value for color attribute " + name, ex);
            }
        } else {
            return null;
        }
    }

    parseOptionalInteger(attributes: any, name: string): number {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (value != null) {
            try {
                return /* parseInt */parseInt(value);
            } catch (ex) {
                throw new SAXException("Invalid value for integer attribute " + name, ex);
            }
        } else {
            return null;
        }
    }

    parseOptionalLong(attributes: any, name: string): number {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (value != null) {
            try {
                return /* parseLong */parseInt(value);
            } catch (ex) {
                throw new SAXException("Invalid value for long attribute " + name, ex);
            }
        } else {
            return null;
        }
    }

    parseOptionalDecimal(attributes: any, name: string): Big {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (value != null) {
            try {
                return new Big(value);
            } catch (ex) {
                throw new SAXException("Invalid value for decimal attribute " + name, ex);
            }
        } else {
            return null;
        }
    }

    parseOptionalFloat(attributes: any, name: string): number {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (value != null) {
            try {
                return /* parseFloat */parseFloat(value);
            } catch (ex) {
                throw new SAXException("Invalid value for float attribute " + name, ex);
            }
        } else {
            return null;
        }
    }

    parseFloat(attributes: any, name: string): number {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(attributes, name);
        if (value != null) {
            try {
                return /* parseFloat */parseFloat(value);
            } catch (ex) {
                throw new SAXException("Invalid value for float attribute " + name, ex);
            }
        } else {
            throw new SAXException("Missing float attribute " + name);
        }
    }

    /**
     * Returns the content object matching the attribute named <code>attributeName</code> in the given element.
     * @param {string} elementName
     * @param {Object} attributes
     * @param {string} attributeName
     * @return {Object}
     */
    parseContent(elementName: string, attributes: any, attributeName: string): Content {
        var contentFile = attributes[attributeName]; if (contentFile === undefined) { return null; } else if (contentFile.indexOf('://') >= 0) { return URLContent.fromURL(contentFile); } else { return new HomeURLContent('jar:' + this['homeUrl'] + '!/' + contentFile); }
    }

    /**
     * Sets the home that will be updated by this handler.
     * If a subclass of this handler uses a root element different from <code>home</code>,
     * it should call this method from {@link #startElement} to store the
     * {@link Home} subclass instance read from the XML stream.
     * @param {Home} home
     */
    setHome(home: Home) {
        this.home = home;
        this.homeElementName = /* peek */(a => a.length == 0 ? null : a[a.length - 1])(this.elements);
    }

    /**
     * Returns the home read by this handler.
     * @return {Home}
     */
    public getHome(): Home {
        return this.home;
    }
}
HomeXMLHandler["__class"] = "com.eteks.sweethome3d.io.HomeXMLHandler";
HomeXMLHandler["__interfaces"] = ["org.xml.sax.ErrorHandler", "org.xml.sax.DTDHandler", "org.xml.sax.ContentHandler", "org.xml.sax.EntityResolver"];



export namespace HomeXMLHandler {

    /**
     * Class storing the ID of the walls connected to a given wall.
     * @param {Wall} wall
     * @param {string} wallAtStartId
     * @param {string} wallAtEndId
     * @class
     */
    export class JoinedWall {
        wall: Wall;

        wallAtStartId: string;

        wallAtEndId: string;

        public constructor(wall: Wall, wallAtStartId: string, wallAtEndId: string) {
            if (this.wall === undefined) { this.wall = null; }
            if (this.wallAtStartId === undefined) { this.wallAtStartId = null; }
            if (this.wallAtEndId === undefined) { this.wallAtEndId = null; }
            this.wall = wall;
            this.wallAtStartId = wallAtStartId;
            this.wallAtEndId = wallAtEndId;
        }

        public getWall(): Wall {
            return this.wall;
        }

        public getWallAtStartId(): string {
            return this.wallAtStartId;
        }

        public getWallAtEndId(): string {
            return this.wallAtEndId;
        }
    }
    JoinedWall["__class"] = "com.eteks.sweethome3d.io.HomeXMLHandler.JoinedWall";

}


/**
 * Creates a writer in the given output stream encoded in UTF-8.
 * @param {StringWriter} out
 * @class
 * @extends java.io.FilterWriter
 * @author Emmanuel Puybaret
 */
export class XMLWriter {
/*private*/ out: StringWriter;
    /*private*/ elements: Array<string>;

    /*private*/ emptyElement: boolean;

    /*private*/ elementWithText: boolean;

    public constructor(out: StringWriter) {
        this.elements = <any>([]);
        if (this.emptyElement === undefined) { this.emptyElement = false; }
        if (this.elementWithText === undefined) { this.elementWithText = false; }
        this.out = out; this.out.write("<?xml version='1.0'?>\n");
    }

    /**
     * Writes a start tag for the given element.
     * @param {string} element
     */
    public writeStartElement(element: string) {
        if (/* size */(<number>this.elements.length) > 0) {
            if (this.emptyElement) {
                this.out.write(">");
            }
            this.writeIndentation();
        }
        this.out.write("<" + element);
        /* push */(this.elements.push(element) > 0);
        this.emptyElement = true;
        this.elementWithText = false;
    }

    /**
     * Writes an end tag for the given element.
     */
    public writeEndElement() {
        const element: string = /* pop */this.elements.pop();
        if (this.emptyElement) {
            this.out.write("/>");
        } else {
            if (!this.elementWithText) {
                this.writeIndentation();
            }
            this.out.write("</" + element + ">");
        }
        this.emptyElement = false;
        this.elementWithText = false;
    }

    /**
     * Adds spaces according to the current depth of XML tree.
     * @private
     */
    /*private*/ writeIndentation() {
        this.out.write("\n");
        for (let i: number = 0; i < /* size */(<number>this.elements.length); i++) {
            {
                this.out.write("  ");
            };
        }
    }

    public writeAttribute$java_lang_String$java_lang_String(name: string, value: string) {
        this.out.write(" " + name + "=\'" + XMLWriter.replaceByEntities(value) + "\'");
    }

    public writeAttribute$java_lang_String$java_lang_String$java_lang_String(name: string, value: string, defaultValue: string) {
        if ((value != null || value !== defaultValue) && !(value === defaultValue)) {
            this.writeAttribute$java_lang_String$java_lang_String(name, value);
        }
    }

    /**
     * Writes the name and the value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>defaultValue</code>.
     * @param {string} name
     * @param {string} value
     * @param {string} defaultValue
     */
    public writeAttribute(name?: any, value?: any, defaultValue?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof value === 'string') || value === null) && ((typeof defaultValue === 'string') || defaultValue === null)) {
            return <any>this.writeAttribute$java_lang_String$java_lang_String$java_lang_String(name, value, defaultValue);
        } else if (((typeof name === 'string') || name === null) && ((typeof value === 'string') || value === null) && defaultValue === undefined) {
            return <any>this.writeAttribute$java_lang_String$java_lang_String(name, value);
        } else throw new Error('invalid overload');
    }

    public writeIntegerAttribute$java_lang_String$int(name: string, value: number) {
        this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
    }

    public writeIntegerAttribute$java_lang_String$int$int(name: string, value: number, defaultValue: number) {
        if (value !== defaultValue) {
            this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
        }
    }

    /**
     * Writes the name and the integer value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>defaultValue</code>.
     * @param {string} name
     * @param {number} value
     * @param {number} defaultValue
     */
    public writeIntegerAttribute(name?: any, value?: any, defaultValue?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && ((typeof defaultValue === 'number') || defaultValue === null)) {
            return <any>this.writeIntegerAttribute$java_lang_String$int$int(name, value, defaultValue);
        } else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && defaultValue === undefined) {
            return <any>this.writeIntegerAttribute$java_lang_String$int(name, value);
        } else throw new Error('invalid overload');
    }

    public writeLongAttribute$java_lang_String$long(name: string, value: number) {
        this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
    }

    public writeLongAttribute$java_lang_String$java_lang_Long(name: string, value: number) {
        if (value != null) {
            this.writeAttribute$java_lang_String$java_lang_String(name, value.toString());
        }
    }

    /**
     * Writes the name and the long value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>null</code>.
     * @param {string} name
     * @param {number} value
     */
    public writeLongAttribute(name?: any, value?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null)) {
            return <any>this.writeLongAttribute$java_lang_String$java_lang_Long(name, value);
        } else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null)) {
            return <any>this.writeLongAttribute$java_lang_String$long(name, value);
        } else throw new Error('invalid overload');
    }

    public writeFloatAttribute$java_lang_String$float(name: string, value: number) {
        this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
    }

    public writeFloatAttribute$java_lang_String$float$float(name: string, value: number, defaultValue: number) {
        if (value !== defaultValue) {
            this.writeFloatAttribute$java_lang_String$float(name, value);
        }
    }

    /**
     * Writes the name and the float value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>defaultValue</code>.
     * @param {string} name
     * @param {number} value
     * @param {number} defaultValue
     */
    public writeFloatAttribute(name?: any, value?: any, defaultValue?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && ((typeof defaultValue === 'number') || defaultValue === null)) {
            return <any>this.writeFloatAttribute$java_lang_String$float$float(name, value, defaultValue);
        } else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && defaultValue === undefined) {
            return <any>this.writeFloatAttribute$java_lang_String$java_lang_Float(name, value);
        } else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && defaultValue === undefined) {
            return <any>this.writeFloatAttribute$java_lang_String$float(name, value);
        } else throw new Error('invalid overload');
    }

    public writeFloatAttribute$java_lang_String$java_lang_Float(name: string, value: number) {
        if (value != null) {
            this.writeAttribute$java_lang_String$java_lang_String(name, value.toString());
        }
    }

    /**
     * Writes the name and the value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>null</code>.
     * @param {string} name
     * @param {Big} value
     */
    public writeBigDecimalAttribute(name: string, value: Big) {
        if (value != null) {
            this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
        }
    }

    /**
     * Writes the name and the boolean value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>defaultValue</code>.
     * @param {string} name
     * @param {boolean} value
     * @param {boolean} defaultValue
     */
    public writeBooleanAttribute(name: string, value: boolean, defaultValue: boolean) {
        if (value !== defaultValue) {
            this.writeAttribute$java_lang_String$java_lang_String(name, /* valueOf */String(value).toString());
        }
    }

    /**
     * Writes the name and the color value of an attribute in the tag of the last started element,
     * except if <code>value</code> equals <code>null</code>. The color is written in hexadecimal.
     * @param {string} name
     * @param {number} color
     */
    public writeColorAttribute(name: string, color: number) {
        if (color != null) {
            this.writeAttribute$java_lang_String$java_lang_String(name, CoreTools.format("%08X", color));
        }
    }

    /**
     * Writes the given <code>text</code> as the content of the current element.
     * @param {string} text
     */
    public writeText(text: string) {
        if (this.emptyElement) {
            this.out.write(">");
            this.emptyElement = false;
            this.elementWithText = true;
        }
        this.out.write(XMLWriter.replaceByEntities(text));
    }

    /**
     * Returns the string in parameter with &amp;, &lt;, &apos;, &quot; and feed line characters replaced by their matching entities.
     * @param {string} s
     * @return {string}
     * @private
     */
    /*private*/ static replaceByEntities(s: string): string {
        return /* replace *//* replace *//* replace *//* replace *//* replace */s.split("&").join("&amp;").split("<").join("&lt;").split("\'").join("&apos;").split("\"").join("&quot;").split("\n").join("&#10;");
    }

    public write$int(c: number) {
        this.writeText(/* valueOf */String(String.fromCharCode(c)).toString());
    }

    public write$char_A$int$int(buffer: string[], offset: number, length: number) {
        this.writeText(buffer.join('').substr(offset, length));
    }

    /**
     * Writes the given characters array as the content of the current element.
     * @param {char[]} buffer
     * @param {number} offset
     * @param {number} length
     */
    public write(buffer?: any, offset?: any, length?: any) {
        if (((buffer != null && buffer instanceof <any>Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'string'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
            return <any>this.write$char_A$int$int(buffer, offset, length);
        } else if (((typeof buffer === 'string') || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
            return <any>this.write$java_lang_String$int$int(buffer, offset, length);
        } else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && length === undefined) {
            return <any>this.write$int(buffer);
        } else throw new Error('invalid overload');
    }

    public write$java_lang_String$int$int(str: string, offset: number, length: number) {
        this.writeText(str.substring(offset, offset + length));
    }
}
XMLWriter["__class"] = "com.eteks.sweethome3d.io.XMLWriter";


/**
 * An image used as texture.
 * @author Emmanuel Puybaret
 * @class
 */
interface TextureImage {
    /**
     * Returns the name of this texture image.
     * @return {string}
     */
    getName(): string;

    /**
     * Returns the creator of this texture.
     * @return {string}
     */
    getCreator(): string;

    /**
     * Returns the content of the image used for this texture.
     * @return {Object}
     */
    getImage(): Content;

    /**
     * Returns the width of the image in centimeters.
     * @return {number}
     */
    getWidth(): number;

    /**
     * Returns the height of the image in centimeters.
     * @return {number}
     */
    getHeight(): number;
}

/**
 * A listener notified when items are added or removed from a collection.
 * <code>T</code> is the type of item stored in the collection.
 * @author Emmanuel Puybaret
 * @class
 */
interface CollectionListener<T> {
    /**
     * Called when an item is added or deleted from a collection.
     * @param {CollectionEvent} ev
     */
    (ev: CollectionEvent<T>);
}

/**
 * Listener implemented to receive notifications of selection changes in {@link Home}.
 * @author Emmanuel Puybaret
 * @class
 */
interface SelectionListener {
    /**
     * Invoked when selection changed.
     * @param {SelectionEvent} selectionEvent
     */
    selectionChanged(selectionEvent: SelectionEvent);
}

/**
 * A piece of furniture used as a door or a window.
 * @author Emmanuel Puybaret
 * @class
 */
interface DoorOrWindow extends PieceOfFurniture {
    /**
     * Returns the default thickness of the wall in which this door or window should be placed.
     * @return {number} a value in percentage of the depth of this door or window.
     */
    getWallThickness(): number;

    /**
     * Returns the default distance that should lie outside of this door or window.
     * @return {number} a distance in percentage of the depth of this door or the window.
     */
    getWallDistance(): number;

    /**
     * Returns a copy of the sashes attached to this door or window.
     * If no sash is defined an empty array is returned.
     * @return {com.eteks.sweethome3d.model.Sash[]}
     */
    getSashes(): Sash[];

    /**
     * Returns the shape used to cut out walls that intersect this new door or window.
     * @return {string} <code>null</code> or a shape defined with the syntax of the d attribute of a
     * <a href="http://www.w3.org/TR/SVG/paths.html">SVG path element</a>
     * that fits in a square spreading from (0, 0) to (1, 1) which will be
     * scaled afterwards to the real size of this door or window.
     */
    getCutOutShape(): string;

    /**
     * Returns <code>true</code> if this door or window should cut out the both sides
     * of the walls it intersects, even if its front or back side are within the wall thickness.
     * @return {boolean}
     */
    isWallCutOutOnBothSides(): boolean;

    /**
     * Returns <code>false</code> if the width and depth of the new door or window may
     * not be changed independently from each other. When <code>false</code>, this door or window
     * will also make a hole in the wall when it's placed whatever its depth if its
     * {@link #isBoundToWall() bouldToWall} flag is <code>true</code>.
     * @return {boolean}
     */
    isWidthDepthDeformable(): boolean;
}

/**
 * Creates a <code>IllegalHomonymException</code> with its message.
 * @param {string} s
 * @class
 * @extends Error
 * @author Emmanuel Puybaret
 * @ignore
 */
export class IllegalHomonymException {
    public constructor(s?: any) {
        if (((typeof s === 'string') || s === null)) {
            let __args = arguments;
        } else if (s === undefined) {
            let __args = arguments;
        } else throw new Error('invalid overload');
    }
}
IllegalHomonymException["__class"] = "com.eteks.sweethome3d.model.IllegalHomonymException";


/**
 * Creates a catalog piece of furniture of the default catalog.
 * <br>Caution: The constructor of <code>CatalogPieceOfFurniture</code> was modified in version 5.5 with incompatible changes with previous versions and might require some changes in your program.
 * @param {string} id    the id of the new piece or <code>null</code>
 * @param {string} name  the name of the new piece
 * @param {string} description the description of the new piece
 * @param {string} information additional information associated to the new piece
 * @param {string} license license of the new piece
 * @param {java.lang.String[]} tags tags associated to the new piece
 * @param {number} creationDate creation date of the new piece in milliseconds since the epoch
 * @param {number} grade grade of the piece of furniture or <code>null</code>
 * @param {Object} icon content of the icon of the new piece
 * @param {Object} planIcon content of the icon of the new piece displayed in plan
 * @param {Object} model content of the 3D model of the new piece
 * @param {number} width  the width in centimeters of the new piece
 * @param {number} depth  the depth in centimeters of the new piece
 * @param {number} height  the height in centimeters of the new piece
 * @param {number} elevation  the elevation in centimeters of the new piece
 * @param {number} dropOnTopElevation  a percentage of the height at which should be placed
 * an object dropped on the new piece
 * @param {boolean} movable if <code>true</code>, the new piece is movable
 * @param {string} staircaseCutOutShape the shape used to cut out upper levels when they intersect
 * with the piece like a staircase
 * @param {float[][]} modelRotation the rotation 3 by 3 matrix applied to the piece model
 * @param {number} modelFlags flags which should be applied to piece model
 * @param {number} modelSize size of the 3D model of the new piece
 * @param {string} creator the creator of the model
 * @param {boolean} resizable if <code>true</code>, the size of the new piece may be edited
 * @param {boolean} deformable if <code>true</code>, the width, depth and height of the new piece may
 * change independently from each other
 * @param {boolean} texturable if <code>false</code> this piece should always keep the same color or texture
 * @param {boolean} horizontallyRotatable if <code>false</code> this piece
 * should not rotate around an horizontal axis
 * @param {Big} price the price of the new piece or <code>null</code>
 * @param {Big} valueAddedTaxPercentage the Value Added Tax percentage applied to the
 * price of the new piece or <code>null</code>
 * @param {string} currency the price currency, noted with ISO 4217 code, or <code>null</code>
 * @param {Object} properties additional properties associating a key to a value or <code>null</code>
 * @param {Object} contents   additional contents associating a key to a value or <code>null</code>
 * @class
 * @author Emmanuel Puybaret
 */
export class CatalogPieceOfFurniture implements PieceOfFurniture, CatalogItem {
    static __static_initialized: boolean = false;
    static __static_initialize() { if (!CatalogPieceOfFurniture.__static_initialized) { CatalogPieceOfFurniture.__static_initialized = true; CatalogPieceOfFurniture.__static_initializer_0(); } }

    static EMPTY_CRITERIA: number[][]; public static EMPTY_CRITERIA_$LI$(): number[][] { CatalogPieceOfFurniture.__static_initialize(); if (CatalogPieceOfFurniture.EMPTY_CRITERIA == null) { CatalogPieceOfFurniture.EMPTY_CRITERIA = []; } return CatalogPieceOfFurniture.EMPTY_CRITERIA; }

    /*private*/ id: string;

    /*private*/ name: string;

    /*private*/ description: string;

    /*private*/ information: string;

    /*private*/ license: string;

    /*private*/ tags: string[];

    /*private*/ creationDate: number;

    /*private*/ grade: number;

    /*private*/ icon: Content;

    /*private*/ planIcon: Content;

    /*private*/ model: Content;

    /*private*/ width: number;

    /*private*/ depth: number;

    /*private*/ height: number;

    /*private*/ proportional: boolean;

    /*private*/ elevation: number;

    /*private*/ dropOnTopElevation: number;

    /*private*/ movable: boolean;

    /*private*/ doorOrWindow: boolean;

    /*private*/ staircaseCutOutShape: string;

    /*private*/ modelRotation: number[][];

    /*private*/ modelFlags: number;

    /*private*/ modelSize: number;

    /*private*/ creator: string;

    /*private*/ color: number;

    /*private*/ iconYaw: number;

    /*private*/ iconPitch: number;

    /*private*/ iconScale: number;

    /*private*/ modifiable: boolean;

    /*private*/ resizable: boolean;

    /*private*/ deformable: boolean;

    /*private*/ texturable: boolean;

    /*private*/ horizontallyRotatable: boolean;

    /*private*/ price: Big;

    /*private*/ valueAddedTaxPercentage: Big;

    /*private*/ currency: string;

    /*private*/ properties: any;

    /*private*/ category: FurnitureCategory;

    /*private*/ filterCollationKey: number[];

    static COMPARATOR: any; public static COMPARATOR_$LI$(): any { CatalogPieceOfFurniture.__static_initialize(); return CatalogPieceOfFurniture.COMPARATOR; }

    static recentFilters: any; public static recentFilters_$LI$(): any { CatalogPieceOfFurniture.__static_initialize(); return CatalogPieceOfFurniture.recentFilters; }

    static __static_initializer_0() {
        CatalogPieceOfFurniture.COMPARATOR = /* getInstance */{ compare: (o1, o2) => o1.toString().localeCompare(o2.toString()), equals: (o1, o2) => o1.toString().localeCompare(o2.toString()) === 0 };
        /* setStrength */CatalogPieceOfFurniture.COMPARATOR_$LI$();
        CatalogPieceOfFurniture.recentFilters = {};
    }

    public constructor(id?: any, name?: any, description?: any, information?: any, license?: any, tags?: any, creationDate?: any, grade?: any, icon?: any, planIcon?: any, model?: any, width?: any, depth?: any, height?: any, elevation?: any, dropOnTopElevation?: any, movable?: any, doorOrWindow?: any, staircaseCutOutShape?: any, color?: any, modelRotation?: any, modelFlags?: any, modelSize?: any, creator?: any, resizable?: any, deformable?: any, texturable?: any, horizontallyRotatable?: any, price?: any, valueAddedTaxPercentage?: any, currency?: any, properties?: any, contents?: any, iconYaw?: any, iconPitch?: any, iconScale?: any, proportional?: any, modifiable?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((typeof license === 'string') || license === null) && ((tags != null && tags instanceof <any>Array && (tags.length == 0 || tags[0] == null || (typeof tags[0] === 'string'))) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((model != null && (model.constructor != null && model.constructor["__interfaces"] != null && model.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'number') || dropOnTopElevation === null) && ((typeof movable === 'boolean') || movable === null) && ((typeof doorOrWindow === 'boolean') || doorOrWindow === null) && ((typeof staircaseCutOutShape === 'string') || staircaseCutOutShape === null) && ((typeof color === 'number') || color === null) && ((modelRotation != null && modelRotation instanceof <any>Array && (modelRotation.length == 0 || modelRotation[0] == null || modelRotation[0] instanceof Array)) || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'number') || modelSize === null) && ((typeof creator === 'string') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((typeof texturable === 'boolean') || texturable === null) && ((typeof horizontallyRotatable === 'boolean') || horizontallyRotatable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((valueAddedTaxPercentage != null && valueAddedTaxPercentage instanceof <any>Big) || valueAddedTaxPercentage === null) && ((typeof currency === 'string') || currency === null) && ((properties != null && (properties instanceof Object)) || properties === null) && ((contents != null && (contents instanceof Object)) || contents === null) && ((typeof iconYaw === 'number') || iconYaw === null) && ((typeof iconPitch === 'number') || iconPitch === null) && ((typeof iconScale === 'number') || iconScale === null) && ((typeof proportional === 'boolean') || proportional === null) && ((typeof modifiable === 'boolean') || modifiable === null)) {
            let __args = arguments;
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            this.id = id;
            this.name = name;
            this.description = description;
            this.information = information;
            this.license = license;
            this.tags = tags;
            this.creationDate = creationDate;
            this.grade = grade;
            this.icon = icon;
            this.planIcon = planIcon;
            this.model = model;
            this.width = width;
            this.depth = depth;
            this.height = height;
            this.elevation = elevation;
            this.dropOnTopElevation = dropOnTopElevation;
            this.movable = movable;
            this.doorOrWindow = doorOrWindow;
            this.color = color;
            this.staircaseCutOutShape = staircaseCutOutShape;
            this.creator = creator;
            this.horizontallyRotatable = horizontallyRotatable;
            this.price = price;
            this.valueAddedTaxPercentage = valueAddedTaxPercentage;
            this.currency = currency;
            if (properties == null || /* size */Object.keys(properties).length === 0) {
                if (contents == null || /* size */Object.keys(contents).length === 0) {
                    this.properties = /* emptyMap */{};
                } else if (/* size */Object.keys(contents).length === 1) {
                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                } else {
                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                }
            } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
            } else {
                this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                if (contents != null) {
                    /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                }
            }
            if (modelRotation == null) {
                this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
            } else {
                this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
            }
            this.modelFlags = modelFlags;
            this.modelSize = modelSize;
            this.resizable = resizable;
            this.deformable = deformable;
            this.texturable = texturable;
            this.iconYaw = iconYaw;
            this.iconPitch = iconPitch;
            this.iconScale = iconScale;
            this.proportional = proportional;
            this.modifiable = modifiable;
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((typeof license === 'string') || license === null) && ((tags != null && tags instanceof <any>Array && (tags.length == 0 || tags[0] == null || (typeof tags[0] === 'string'))) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((model != null && (model.constructor != null && model.constructor["__interfaces"] != null && model.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'number') || dropOnTopElevation === null) && ((typeof movable === 'boolean') || movable === null) && ((typeof doorOrWindow === 'string') || doorOrWindow === null) && ((staircaseCutOutShape != null && staircaseCutOutShape instanceof <any>Array && (staircaseCutOutShape.length == 0 || staircaseCutOutShape[0] == null || staircaseCutOutShape[0] instanceof Array)) || staircaseCutOutShape === null) && ((typeof color === 'number') || color === null) && ((typeof modelRotation === 'number') || modelRotation === null) && ((typeof modelFlags === 'string') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((horizontallyRotatable != null && horizontallyRotatable instanceof <any>Big) || horizontallyRotatable === null) && ((typeof price === 'string') || price === null) && ((valueAddedTaxPercentage != null && (valueAddedTaxPercentage instanceof Object)) || valueAddedTaxPercentage === null) && ((currency != null && (currency instanceof Object)) || currency === null) && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let staircaseCutOutShape: any = __args[17];
            let modelRotation: any = __args[18];
            let modelFlags: any = __args[19];
            let modelSize: any = __args[20];
            let creator: any = __args[21];
            let resizable: any = __args[22];
            let deformable: any = __args[23];
            let texturable: any = __args[24];
            let horizontallyRotatable: any = __args[25];
            let price: any = __args[26];
            let valueAddedTaxPercentage: any = __args[27];
            let currency: any = __args[28];
            let properties: any = __args[29];
            let contents: any = __args[30];
            {
                let __args = arguments;
                let doorOrWindow: any = false;
                let color: any = null;
                let iconYaw: any = <number>Math.PI / 8;
                let iconPitch: any = 0;
                let iconScale: any = 1;
                let proportional: any = true;
                let modifiable: any = false;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                this.id = id;
                this.name = name;
                this.description = description;
                this.information = information;
                this.license = license;
                this.tags = tags;
                this.creationDate = creationDate;
                this.grade = grade;
                this.icon = icon;
                this.planIcon = planIcon;
                this.model = model;
                this.width = width;
                this.depth = depth;
                this.height = height;
                this.elevation = elevation;
                this.dropOnTopElevation = dropOnTopElevation;
                this.movable = movable;
                this.doorOrWindow = doorOrWindow;
                this.color = color;
                this.staircaseCutOutShape = staircaseCutOutShape;
                this.creator = creator;
                this.horizontallyRotatable = horizontallyRotatable;
                this.price = price;
                this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                this.currency = currency;
                if (properties == null || /* size */Object.keys(properties).length === 0) {
                    if (contents == null || /* size */Object.keys(contents).length === 0) {
                        this.properties = /* emptyMap */{};
                    } else if (/* size */Object.keys(contents).length === 1) {
                        this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                    } else {
                        this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                    }
                } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                } else {
                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                    if (contents != null) {
                        /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                    }
                }
                if (modelRotation == null) {
                    this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                } else {
                    this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                }
                this.modelFlags = modelFlags;
                this.modelSize = modelSize;
                this.resizable = resizable;
                this.deformable = deformable;
                this.texturable = texturable;
                this.iconYaw = iconYaw;
                this.iconPitch = iconPitch;
                this.iconScale = iconScale;
                this.proportional = proportional;
                this.modifiable = modifiable;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Array && (doorOrWindow.length == 0 || doorOrWindow[0] == null || doorOrWindow[0] instanceof Array)) || doorOrWindow === null) && ((typeof staircaseCutOutShape === 'boolean') || staircaseCutOutShape === null) && ((typeof color === 'number') || color === null) && ((typeof modelRotation === 'string') || modelRotation === null) && ((typeof modelFlags === 'boolean') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((deformable != null && deformable instanceof <any>Big) || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((typeof horizontallyRotatable === 'string') || horizontallyRotatable === null) && ((price != null && (price instanceof Object)) || price === null) && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let staircaseCutOutShape: any = __args[16];
            let modelRotation: any = __args[17];
            let backFaceShown: any = __args[18];
            let modelSize: any = __args[19];
            let creator: any = __args[20];
            let resizable: any = __args[21];
            let deformable: any = __args[22];
            let texturable: any = __args[23];
            let horizontallyRotatable: any = __args[24];
            let price: any = __args[25];
            let valueAddedTaxPercentage: any = __args[26];
            let currency: any = __args[27];
            let properties: any = __args[28];
            {
                let __args = arguments;
                let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                {
                    let __args = arguments;
                    let license: any = null;
                    let contents: any = null;
                    {
                        let __args = arguments;
                        let doorOrWindow: any = false;
                        let color: any = null;
                        let iconYaw: any = <number>Math.PI / 8;
                        let iconPitch: any = 0;
                        let iconScale: any = 1;
                        let proportional: any = true;
                        let modifiable: any = false;
                        if (this.id === undefined) { this.id = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.description === undefined) { this.description = null; }
                        if (this.information === undefined) { this.information = null; }
                        if (this.license === undefined) { this.license = null; }
                        if (this.tags === undefined) { this.tags = null; }
                        if (this.creationDate === undefined) { this.creationDate = null; }
                        if (this.grade === undefined) { this.grade = null; }
                        if (this.icon === undefined) { this.icon = null; }
                        if (this.planIcon === undefined) { this.planIcon = null; }
                        if (this.model === undefined) { this.model = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.depth === undefined) { this.depth = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.proportional === undefined) { this.proportional = false; }
                        if (this.elevation === undefined) { this.elevation = 0; }
                        if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                        if (this.movable === undefined) { this.movable = false; }
                        if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                        if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                        if (this.modelRotation === undefined) { this.modelRotation = null; }
                        if (this.modelFlags === undefined) { this.modelFlags = 0; }
                        if (this.modelSize === undefined) { this.modelSize = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.color === undefined) { this.color = null; }
                        if (this.iconYaw === undefined) { this.iconYaw = 0; }
                        if (this.iconPitch === undefined) { this.iconPitch = 0; }
                        if (this.iconScale === undefined) { this.iconScale = 0; }
                        if (this.modifiable === undefined) { this.modifiable = false; }
                        if (this.resizable === undefined) { this.resizable = false; }
                        if (this.deformable === undefined) { this.deformable = false; }
                        if (this.texturable === undefined) { this.texturable = false; }
                        if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                        if (this.price === undefined) { this.price = null; }
                        if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                        if (this.currency === undefined) { this.currency = null; }
                        if (this.properties === undefined) { this.properties = null; }
                        if (this.category === undefined) { this.category = null; }
                        if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                        this.id = id;
                        this.name = name;
                        this.description = description;
                        this.information = information;
                        this.license = license;
                        this.tags = tags;
                        this.creationDate = creationDate;
                        this.grade = grade;
                        this.icon = icon;
                        this.planIcon = planIcon;
                        this.model = model;
                        this.width = width;
                        this.depth = depth;
                        this.height = height;
                        this.elevation = elevation;
                        this.dropOnTopElevation = dropOnTopElevation;
                        this.movable = movable;
                        this.doorOrWindow = doorOrWindow;
                        this.color = color;
                        this.staircaseCutOutShape = staircaseCutOutShape;
                        this.creator = creator;
                        this.horizontallyRotatable = horizontallyRotatable;
                        this.price = price;
                        this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                        this.currency = currency;
                        if (properties == null || /* size */Object.keys(properties).length === 0) {
                            if (contents == null || /* size */Object.keys(contents).length === 0) {
                                this.properties = /* emptyMap */{};
                            } else if (/* size */Object.keys(contents).length === 1) {
                                this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                            } else {
                                this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                            }
                        } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                            this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                        } else {
                            this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                            if (contents != null) {
                                /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                            }
                        }
                        if (modelRotation == null) {
                            this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                        } else {
                            this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                        }
                        this.modelFlags = modelFlags;
                        this.modelSize = modelSize;
                        this.resizable = resizable;
                        this.deformable = deformable;
                        this.texturable = texturable;
                        this.iconYaw = iconYaw;
                        this.iconPitch = iconPitch;
                        this.iconScale = iconScale;
                        this.proportional = proportional;
                        this.modifiable = modifiable;
                    }
                    if (this.id === undefined) { this.id = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.description === undefined) { this.description = null; }
                    if (this.information === undefined) { this.information = null; }
                    if (this.license === undefined) { this.license = null; }
                    if (this.tags === undefined) { this.tags = null; }
                    if (this.creationDate === undefined) { this.creationDate = null; }
                    if (this.grade === undefined) { this.grade = null; }
                    if (this.icon === undefined) { this.icon = null; }
                    if (this.planIcon === undefined) { this.planIcon = null; }
                    if (this.model === undefined) { this.model = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.depth === undefined) { this.depth = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.proportional === undefined) { this.proportional = false; }
                    if (this.elevation === undefined) { this.elevation = 0; }
                    if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                    if (this.movable === undefined) { this.movable = false; }
                    if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                    if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                    if (this.modelRotation === undefined) { this.modelRotation = null; }
                    if (this.modelFlags === undefined) { this.modelFlags = 0; }
                    if (this.modelSize === undefined) { this.modelSize = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.iconYaw === undefined) { this.iconYaw = 0; }
                    if (this.iconPitch === undefined) { this.iconPitch = 0; }
                    if (this.iconScale === undefined) { this.iconScale = 0; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.resizable === undefined) { this.resizable = false; }
                    if (this.deformable === undefined) { this.deformable = false; }
                    if (this.texturable === undefined) { this.texturable = false; }
                    if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                    if (this.price === undefined) { this.price = null; }
                    if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                    if (this.currency === undefined) { this.currency = null; }
                    if (this.properties === undefined) { this.properties = null; }
                    if (this.category === undefined) { this.category = null; }
                    if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                }
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Array && (doorOrWindow.length == 0 || doorOrWindow[0] == null || doorOrWindow[0] instanceof Array)) || doorOrWindow === null) && ((typeof staircaseCutOutShape === 'number') || staircaseCutOutShape === null) && ((typeof color === 'number') || color === null) && ((typeof modelRotation === 'string') || modelRotation === null) && ((typeof modelFlags === 'boolean') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((deformable != null && deformable instanceof <any>Big) || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((typeof horizontallyRotatable === 'string') || horizontallyRotatable === null) && ((price != null && (price instanceof Object)) || price === null) && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let staircaseCutOutShape: any = __args[16];
            let modelRotation: any = __args[17];
            let modelFlags: any = __args[18];
            let modelSize: any = __args[19];
            let creator: any = __args[20];
            let resizable: any = __args[21];
            let deformable: any = __args[22];
            let texturable: any = __args[23];
            let horizontallyRotatable: any = __args[24];
            let price: any = __args[25];
            let valueAddedTaxPercentage: any = __args[26];
            let currency: any = __args[27];
            let properties: any = __args[28];
            {
                let __args = arguments;
                let license: any = null;
                let contents: any = null;
                {
                    let __args = arguments;
                    let doorOrWindow: any = false;
                    let color: any = null;
                    let iconYaw: any = <number>Math.PI / 8;
                    let iconPitch: any = 0;
                    let iconScale: any = 1;
                    let proportional: any = true;
                    let modifiable: any = false;
                    if (this.id === undefined) { this.id = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.description === undefined) { this.description = null; }
                    if (this.information === undefined) { this.information = null; }
                    if (this.license === undefined) { this.license = null; }
                    if (this.tags === undefined) { this.tags = null; }
                    if (this.creationDate === undefined) { this.creationDate = null; }
                    if (this.grade === undefined) { this.grade = null; }
                    if (this.icon === undefined) { this.icon = null; }
                    if (this.planIcon === undefined) { this.planIcon = null; }
                    if (this.model === undefined) { this.model = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.depth === undefined) { this.depth = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.proportional === undefined) { this.proportional = false; }
                    if (this.elevation === undefined) { this.elevation = 0; }
                    if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                    if (this.movable === undefined) { this.movable = false; }
                    if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                    if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                    if (this.modelRotation === undefined) { this.modelRotation = null; }
                    if (this.modelFlags === undefined) { this.modelFlags = 0; }
                    if (this.modelSize === undefined) { this.modelSize = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.iconYaw === undefined) { this.iconYaw = 0; }
                    if (this.iconPitch === undefined) { this.iconPitch = 0; }
                    if (this.iconScale === undefined) { this.iconScale = 0; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.resizable === undefined) { this.resizable = false; }
                    if (this.deformable === undefined) { this.deformable = false; }
                    if (this.texturable === undefined) { this.texturable = false; }
                    if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                    if (this.price === undefined) { this.price = null; }
                    if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                    if (this.currency === undefined) { this.currency = null; }
                    if (this.properties === undefined) { this.properties = null; }
                    if (this.category === undefined) { this.category = null; }
                    if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                    this.id = id;
                    this.name = name;
                    this.description = description;
                    this.information = information;
                    this.license = license;
                    this.tags = tags;
                    this.creationDate = creationDate;
                    this.grade = grade;
                    this.icon = icon;
                    this.planIcon = planIcon;
                    this.model = model;
                    this.width = width;
                    this.depth = depth;
                    this.height = height;
                    this.elevation = elevation;
                    this.dropOnTopElevation = dropOnTopElevation;
                    this.movable = movable;
                    this.doorOrWindow = doorOrWindow;
                    this.color = color;
                    this.staircaseCutOutShape = staircaseCutOutShape;
                    this.creator = creator;
                    this.horizontallyRotatable = horizontallyRotatable;
                    this.price = price;
                    this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                    this.currency = currency;
                    if (properties == null || /* size */Object.keys(properties).length === 0) {
                        if (contents == null || /* size */Object.keys(contents).length === 0) {
                            this.properties = /* emptyMap */{};
                        } else if (/* size */Object.keys(contents).length === 1) {
                            this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                        } else {
                            this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                        }
                    } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                        this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                    } else {
                        this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                        if (contents != null) {
                            /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                        }
                    }
                    if (modelRotation == null) {
                        this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                    } else {
                        this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                    }
                    this.modelFlags = modelFlags;
                    this.modelSize = modelSize;
                    this.resizable = resizable;
                    this.deformable = deformable;
                    this.texturable = texturable;
                    this.iconYaw = iconYaw;
                    this.iconPitch = iconPitch;
                    this.iconScale = iconScale;
                    this.proportional = proportional;
                    this.modifiable = modifiable;
                }
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Array && (doorOrWindow.length == 0 || doorOrWindow[0] == null || doorOrWindow[0] instanceof Array)) || doorOrWindow === null) && ((typeof staircaseCutOutShape === 'boolean') || staircaseCutOutShape === null) && ((typeof color === 'number') || color === null) && ((typeof modelRotation === 'string') || modelRotation === null) && ((typeof modelFlags === 'boolean') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((deformable != null && deformable instanceof <any>Big) || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((typeof horizontallyRotatable === 'string') || horizontallyRotatable === null) && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let staircaseCutOutShape: any = __args[16];
            let modelRotation: any = __args[17];
            let backFaceShown: any = __args[18];
            let modelSize: any = __args[19];
            let creator: any = __args[20];
            let resizable: any = __args[21];
            let deformable: any = __args[22];
            let texturable: any = __args[23];
            let horizontallyRotatable: any = __args[24];
            let price: any = __args[25];
            let valueAddedTaxPercentage: any = __args[26];
            let currency: any = __args[27];
            {
                let __args = arguments;
                let properties: any = null;
                {
                    let __args = arguments;
                    let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                    {
                        let __args = arguments;
                        let license: any = null;
                        let contents: any = null;
                        {
                            let __args = arguments;
                            let doorOrWindow: any = false;
                            let color: any = null;
                            let iconYaw: any = <number>Math.PI / 8;
                            let iconPitch: any = 0;
                            let iconScale: any = 1;
                            let proportional: any = true;
                            let modifiable: any = false;
                            if (this.id === undefined) { this.id = null; }
                            if (this.name === undefined) { this.name = null; }
                            if (this.description === undefined) { this.description = null; }
                            if (this.information === undefined) { this.information = null; }
                            if (this.license === undefined) { this.license = null; }
                            if (this.tags === undefined) { this.tags = null; }
                            if (this.creationDate === undefined) { this.creationDate = null; }
                            if (this.grade === undefined) { this.grade = null; }
                            if (this.icon === undefined) { this.icon = null; }
                            if (this.planIcon === undefined) { this.planIcon = null; }
                            if (this.model === undefined) { this.model = null; }
                            if (this.width === undefined) { this.width = 0; }
                            if (this.depth === undefined) { this.depth = 0; }
                            if (this.height === undefined) { this.height = 0; }
                            if (this.proportional === undefined) { this.proportional = false; }
                            if (this.elevation === undefined) { this.elevation = 0; }
                            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                            if (this.movable === undefined) { this.movable = false; }
                            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                            if (this.modelRotation === undefined) { this.modelRotation = null; }
                            if (this.modelFlags === undefined) { this.modelFlags = 0; }
                            if (this.modelSize === undefined) { this.modelSize = null; }
                            if (this.creator === undefined) { this.creator = null; }
                            if (this.color === undefined) { this.color = null; }
                            if (this.iconYaw === undefined) { this.iconYaw = 0; }
                            if (this.iconPitch === undefined) { this.iconPitch = 0; }
                            if (this.iconScale === undefined) { this.iconScale = 0; }
                            if (this.modifiable === undefined) { this.modifiable = false; }
                            if (this.resizable === undefined) { this.resizable = false; }
                            if (this.deformable === undefined) { this.deformable = false; }
                            if (this.texturable === undefined) { this.texturable = false; }
                            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                            if (this.price === undefined) { this.price = null; }
                            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                            if (this.currency === undefined) { this.currency = null; }
                            if (this.properties === undefined) { this.properties = null; }
                            if (this.category === undefined) { this.category = null; }
                            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                            this.id = id;
                            this.name = name;
                            this.description = description;
                            this.information = information;
                            this.license = license;
                            this.tags = tags;
                            this.creationDate = creationDate;
                            this.grade = grade;
                            this.icon = icon;
                            this.planIcon = planIcon;
                            this.model = model;
                            this.width = width;
                            this.depth = depth;
                            this.height = height;
                            this.elevation = elevation;
                            this.dropOnTopElevation = dropOnTopElevation;
                            this.movable = movable;
                            this.doorOrWindow = doorOrWindow;
                            this.color = color;
                            this.staircaseCutOutShape = staircaseCutOutShape;
                            this.creator = creator;
                            this.horizontallyRotatable = horizontallyRotatable;
                            this.price = price;
                            this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                            this.currency = currency;
                            if (properties == null || /* size */Object.keys(properties).length === 0) {
                                if (contents == null || /* size */Object.keys(contents).length === 0) {
                                    this.properties = /* emptyMap */{};
                                } else if (/* size */Object.keys(contents).length === 1) {
                                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                                } else {
                                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                                }
                            } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                                this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                            } else {
                                this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                                if (contents != null) {
                                    /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                                }
                            }
                            if (modelRotation == null) {
                                this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                            } else {
                                this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                            }
                            this.modelFlags = modelFlags;
                            this.modelSize = modelSize;
                            this.resizable = resizable;
                            this.deformable = deformable;
                            this.texturable = texturable;
                            this.iconYaw = iconYaw;
                            this.iconPitch = iconPitch;
                            this.iconScale = iconScale;
                            this.proportional = proportional;
                            this.modifiable = modifiable;
                        }
                        if (this.id === undefined) { this.id = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.description === undefined) { this.description = null; }
                        if (this.information === undefined) { this.information = null; }
                        if (this.license === undefined) { this.license = null; }
                        if (this.tags === undefined) { this.tags = null; }
                        if (this.creationDate === undefined) { this.creationDate = null; }
                        if (this.grade === undefined) { this.grade = null; }
                        if (this.icon === undefined) { this.icon = null; }
                        if (this.planIcon === undefined) { this.planIcon = null; }
                        if (this.model === undefined) { this.model = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.depth === undefined) { this.depth = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.proportional === undefined) { this.proportional = false; }
                        if (this.elevation === undefined) { this.elevation = 0; }
                        if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                        if (this.movable === undefined) { this.movable = false; }
                        if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                        if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                        if (this.modelRotation === undefined) { this.modelRotation = null; }
                        if (this.modelFlags === undefined) { this.modelFlags = 0; }
                        if (this.modelSize === undefined) { this.modelSize = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.color === undefined) { this.color = null; }
                        if (this.iconYaw === undefined) { this.iconYaw = 0; }
                        if (this.iconPitch === undefined) { this.iconPitch = 0; }
                        if (this.iconScale === undefined) { this.iconScale = 0; }
                        if (this.modifiable === undefined) { this.modifiable = false; }
                        if (this.resizable === undefined) { this.resizable = false; }
                        if (this.deformable === undefined) { this.deformable = false; }
                        if (this.texturable === undefined) { this.texturable = false; }
                        if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                        if (this.price === undefined) { this.price = null; }
                        if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                        if (this.currency === undefined) { this.currency = null; }
                        if (this.properties === undefined) { this.properties = null; }
                        if (this.category === undefined) { this.category = null; }
                        if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                    }
                    if (this.id === undefined) { this.id = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.description === undefined) { this.description = null; }
                    if (this.information === undefined) { this.information = null; }
                    if (this.license === undefined) { this.license = null; }
                    if (this.tags === undefined) { this.tags = null; }
                    if (this.creationDate === undefined) { this.creationDate = null; }
                    if (this.grade === undefined) { this.grade = null; }
                    if (this.icon === undefined) { this.icon = null; }
                    if (this.planIcon === undefined) { this.planIcon = null; }
                    if (this.model === undefined) { this.model = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.depth === undefined) { this.depth = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.proportional === undefined) { this.proportional = false; }
                    if (this.elevation === undefined) { this.elevation = 0; }
                    if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                    if (this.movable === undefined) { this.movable = false; }
                    if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                    if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                    if (this.modelRotation === undefined) { this.modelRotation = null; }
                    if (this.modelFlags === undefined) { this.modelFlags = 0; }
                    if (this.modelSize === undefined) { this.modelSize = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.iconYaw === undefined) { this.iconYaw = 0; }
                    if (this.iconPitch === undefined) { this.iconPitch = 0; }
                    if (this.iconScale === undefined) { this.iconScale = 0; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.resizable === undefined) { this.resizable = false; }
                    if (this.deformable === undefined) { this.deformable = false; }
                    if (this.texturable === undefined) { this.texturable = false; }
                    if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                    if (this.price === undefined) { this.price = null; }
                    if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                    if (this.currency === undefined) { this.currency = null; }
                    if (this.properties === undefined) { this.properties = null; }
                    if (this.category === undefined) { this.category = null; }
                    if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                }
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Array && (doorOrWindow.length == 0 || doorOrWindow[0] == null || doorOrWindow[0] instanceof Array)) || doorOrWindow === null) && ((typeof staircaseCutOutShape === 'boolean') || staircaseCutOutShape === null) && ((typeof color === 'string') || color === null) && ((typeof modelRotation === 'boolean') || modelRotation === null) && ((typeof modelFlags === 'boolean') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((creator != null && creator instanceof <any>Big) || creator === null) && ((resizable != null && resizable instanceof <any>Big) || resizable === null) && ((typeof deformable === 'string') || deformable === null) && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let staircaseCutOutShape: any = __args[16];
            let modelRotation: any = __args[17];
            let backFaceShown: any = __args[18];
            let creator: any = __args[19];
            let resizable: any = __args[20];
            let deformable: any = __args[21];
            let texturable: any = __args[22];
            let price: any = __args[23];
            let valueAddedTaxPercentage: any = __args[24];
            let currency: any = __args[25];
            {
                let __args = arguments;
                let modelSize: any = null;
                let horizontallyRotatable: any = true;
                {
                    let __args = arguments;
                    let properties: any = null;
                    {
                        let __args = arguments;
                        let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                        {
                            let __args = arguments;
                            let license: any = null;
                            let contents: any = null;
                            {
                                let __args = arguments;
                                let doorOrWindow: any = false;
                                let color: any = null;
                                let iconYaw: any = <number>Math.PI / 8;
                                let iconPitch: any = 0;
                                let iconScale: any = 1;
                                let proportional: any = true;
                                let modifiable: any = false;
                                if (this.id === undefined) { this.id = null; }
                                if (this.name === undefined) { this.name = null; }
                                if (this.description === undefined) { this.description = null; }
                                if (this.information === undefined) { this.information = null; }
                                if (this.license === undefined) { this.license = null; }
                                if (this.tags === undefined) { this.tags = null; }
                                if (this.creationDate === undefined) { this.creationDate = null; }
                                if (this.grade === undefined) { this.grade = null; }
                                if (this.icon === undefined) { this.icon = null; }
                                if (this.planIcon === undefined) { this.planIcon = null; }
                                if (this.model === undefined) { this.model = null; }
                                if (this.width === undefined) { this.width = 0; }
                                if (this.depth === undefined) { this.depth = 0; }
                                if (this.height === undefined) { this.height = 0; }
                                if (this.proportional === undefined) { this.proportional = false; }
                                if (this.elevation === undefined) { this.elevation = 0; }
                                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                                if (this.movable === undefined) { this.movable = false; }
                                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                                if (this.modelRotation === undefined) { this.modelRotation = null; }
                                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                                if (this.modelSize === undefined) { this.modelSize = null; }
                                if (this.creator === undefined) { this.creator = null; }
                                if (this.color === undefined) { this.color = null; }
                                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                                if (this.iconScale === undefined) { this.iconScale = 0; }
                                if (this.modifiable === undefined) { this.modifiable = false; }
                                if (this.resizable === undefined) { this.resizable = false; }
                                if (this.deformable === undefined) { this.deformable = false; }
                                if (this.texturable === undefined) { this.texturable = false; }
                                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                                if (this.price === undefined) { this.price = null; }
                                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                                if (this.currency === undefined) { this.currency = null; }
                                if (this.properties === undefined) { this.properties = null; }
                                if (this.category === undefined) { this.category = null; }
                                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                                this.id = id;
                                this.name = name;
                                this.description = description;
                                this.information = information;
                                this.license = license;
                                this.tags = tags;
                                this.creationDate = creationDate;
                                this.grade = grade;
                                this.icon = icon;
                                this.planIcon = planIcon;
                                this.model = model;
                                this.width = width;
                                this.depth = depth;
                                this.height = height;
                                this.elevation = elevation;
                                this.dropOnTopElevation = dropOnTopElevation;
                                this.movable = movable;
                                this.doorOrWindow = doorOrWindow;
                                this.color = color;
                                this.staircaseCutOutShape = staircaseCutOutShape;
                                this.creator = creator;
                                this.horizontallyRotatable = horizontallyRotatable;
                                this.price = price;
                                this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                                this.currency = currency;
                                if (properties == null || /* size */Object.keys(properties).length === 0) {
                                    if (contents == null || /* size */Object.keys(contents).length === 0) {
                                        this.properties = /* emptyMap */{};
                                    } else if (/* size */Object.keys(contents).length === 1) {
                                        this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                                    } else {
                                        this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                                    }
                                } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                                } else {
                                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                                    if (contents != null) {
                                        /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                                    }
                                }
                                if (modelRotation == null) {
                                    this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                                } else {
                                    this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                                }
                                this.modelFlags = modelFlags;
                                this.modelSize = modelSize;
                                this.resizable = resizable;
                                this.deformable = deformable;
                                this.texturable = texturable;
                                this.iconYaw = iconYaw;
                                this.iconPitch = iconPitch;
                                this.iconScale = iconScale;
                                this.proportional = proportional;
                                this.modifiable = modifiable;
                            }
                            if (this.id === undefined) { this.id = null; }
                            if (this.name === undefined) { this.name = null; }
                            if (this.description === undefined) { this.description = null; }
                            if (this.information === undefined) { this.information = null; }
                            if (this.license === undefined) { this.license = null; }
                            if (this.tags === undefined) { this.tags = null; }
                            if (this.creationDate === undefined) { this.creationDate = null; }
                            if (this.grade === undefined) { this.grade = null; }
                            if (this.icon === undefined) { this.icon = null; }
                            if (this.planIcon === undefined) { this.planIcon = null; }
                            if (this.model === undefined) { this.model = null; }
                            if (this.width === undefined) { this.width = 0; }
                            if (this.depth === undefined) { this.depth = 0; }
                            if (this.height === undefined) { this.height = 0; }
                            if (this.proportional === undefined) { this.proportional = false; }
                            if (this.elevation === undefined) { this.elevation = 0; }
                            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                            if (this.movable === undefined) { this.movable = false; }
                            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                            if (this.modelRotation === undefined) { this.modelRotation = null; }
                            if (this.modelFlags === undefined) { this.modelFlags = 0; }
                            if (this.modelSize === undefined) { this.modelSize = null; }
                            if (this.creator === undefined) { this.creator = null; }
                            if (this.color === undefined) { this.color = null; }
                            if (this.iconYaw === undefined) { this.iconYaw = 0; }
                            if (this.iconPitch === undefined) { this.iconPitch = 0; }
                            if (this.iconScale === undefined) { this.iconScale = 0; }
                            if (this.modifiable === undefined) { this.modifiable = false; }
                            if (this.resizable === undefined) { this.resizable = false; }
                            if (this.deformable === undefined) { this.deformable = false; }
                            if (this.texturable === undefined) { this.texturable = false; }
                            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                            if (this.price === undefined) { this.price = null; }
                            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                            if (this.currency === undefined) { this.currency = null; }
                            if (this.properties === undefined) { this.properties = null; }
                            if (this.category === undefined) { this.category = null; }
                            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                        }
                        if (this.id === undefined) { this.id = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.description === undefined) { this.description = null; }
                        if (this.information === undefined) { this.information = null; }
                        if (this.license === undefined) { this.license = null; }
                        if (this.tags === undefined) { this.tags = null; }
                        if (this.creationDate === undefined) { this.creationDate = null; }
                        if (this.grade === undefined) { this.grade = null; }
                        if (this.icon === undefined) { this.icon = null; }
                        if (this.planIcon === undefined) { this.planIcon = null; }
                        if (this.model === undefined) { this.model = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.depth === undefined) { this.depth = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.proportional === undefined) { this.proportional = false; }
                        if (this.elevation === undefined) { this.elevation = 0; }
                        if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                        if (this.movable === undefined) { this.movable = false; }
                        if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                        if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                        if (this.modelRotation === undefined) { this.modelRotation = null; }
                        if (this.modelFlags === undefined) { this.modelFlags = 0; }
                        if (this.modelSize === undefined) { this.modelSize = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.color === undefined) { this.color = null; }
                        if (this.iconYaw === undefined) { this.iconYaw = 0; }
                        if (this.iconPitch === undefined) { this.iconPitch = 0; }
                        if (this.iconScale === undefined) { this.iconScale = 0; }
                        if (this.modifiable === undefined) { this.modifiable = false; }
                        if (this.resizable === undefined) { this.resizable = false; }
                        if (this.deformable === undefined) { this.deformable = false; }
                        if (this.texturable === undefined) { this.texturable = false; }
                        if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                        if (this.price === undefined) { this.price = null; }
                        if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                        if (this.currency === undefined) { this.currency = null; }
                        if (this.properties === undefined) { this.properties = null; }
                        if (this.category === undefined) { this.category = null; }
                        if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                    }
                    if (this.id === undefined) { this.id = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.description === undefined) { this.description = null; }
                    if (this.information === undefined) { this.information = null; }
                    if (this.license === undefined) { this.license = null; }
                    if (this.tags === undefined) { this.tags = null; }
                    if (this.creationDate === undefined) { this.creationDate = null; }
                    if (this.grade === undefined) { this.grade = null; }
                    if (this.icon === undefined) { this.icon = null; }
                    if (this.planIcon === undefined) { this.planIcon = null; }
                    if (this.model === undefined) { this.model = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.depth === undefined) { this.depth = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.proportional === undefined) { this.proportional = false; }
                    if (this.elevation === undefined) { this.elevation = 0; }
                    if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                    if (this.movable === undefined) { this.movable = false; }
                    if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                    if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                    if (this.modelRotation === undefined) { this.modelRotation = null; }
                    if (this.modelFlags === undefined) { this.modelFlags = 0; }
                    if (this.modelSize === undefined) { this.modelSize = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.iconYaw === undefined) { this.iconYaw = 0; }
                    if (this.iconPitch === undefined) { this.iconPitch = 0; }
                    if (this.iconScale === undefined) { this.iconScale = 0; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.resizable === undefined) { this.resizable = false; }
                    if (this.deformable === undefined) { this.deformable = false; }
                    if (this.texturable === undefined) { this.texturable = false; }
                    if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                    if (this.price === undefined) { this.price = null; }
                    if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                    if (this.currency === undefined) { this.currency = null; }
                    if (this.properties === undefined) { this.properties = null; }
                    if (this.category === undefined) { this.category = null; }
                    if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                }
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || name === null) && ((description != null && (description.constructor != null && description.constructor["__interfaces"] != null && description.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || description === null) && ((typeof information === 'number') || information === null) && ((typeof license === 'number') || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'boolean') || grade === null) && ((typeof icon === 'string') || icon === null) && ((typeof planIcon === 'number') || planIcon === null) && ((model != null && model instanceof <any>Array && (model.length == 0 || model[0] == null || model[0] instanceof Array)) || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'string') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'number') || dropOnTopElevation === null) && ((typeof movable === 'number') || movable === null) && ((typeof doorOrWindow === 'boolean') || doorOrWindow === null) && staircaseCutOutShape === undefined && color === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let icon: any = __args[1];
            let model: any = __args[2];
            let width: any = __args[3];
            let depth: any = __args[4];
            let height: any = __args[5];
            let elevation: any = __args[6];
            let movable: any = __args[7];
            let staircaseCutOutShape: any = __args[8];
            let color: any = __args[9];
            let modelRotation: any = __args[10];
            let modelFlags: any = __args[11];
            let modelSize: any = __args[12];
            let creator: any = __args[13];
            let iconYaw: any = __args[14];
            let iconPitch: any = __args[15];
            let iconScale: any = __args[16];
            let proportional: any = __args[17];
            {
                let __args = arguments;
                let id: any = null;
                let description: any = null;
                let information: any = null;
                let license: any = null;
                let tags: any = [];
                let creationDate: any = /* currentTimeMillis */Date.now();
                let grade: any = null;
                let planIcon: any = null;
                let dropOnTopElevation: any = 1.0;
                let doorOrWindow: any = false;
                let resizable: any = true;
                let deformable: any = true;
                let texturable: any = true;
                let horizontallyRotatable: any = true;
                let price: any = null;
                let valueAddedTaxPercentage: any = null;
                let currency: any = null;
                let properties: any = null;
                let contents: any = null;
                let modifiable: any = true;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                this.id = id;
                this.name = name;
                this.description = description;
                this.information = information;
                this.license = license;
                this.tags = tags;
                this.creationDate = creationDate;
                this.grade = grade;
                this.icon = icon;
                this.planIcon = planIcon;
                this.model = model;
                this.width = width;
                this.depth = depth;
                this.height = height;
                this.elevation = elevation;
                this.dropOnTopElevation = dropOnTopElevation;
                this.movable = movable;
                this.doorOrWindow = doorOrWindow;
                this.color = color;
                this.staircaseCutOutShape = staircaseCutOutShape;
                this.creator = creator;
                this.horizontallyRotatable = horizontallyRotatable;
                this.price = price;
                this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                this.currency = currency;
                if (properties == null || /* size */Object.keys(properties).length === 0) {
                    if (contents == null || /* size */Object.keys(contents).length === 0) {
                        this.properties = /* emptyMap */{};
                    } else if (/* size */Object.keys(contents).length === 1) {
                        this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                    } else {
                        this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                    }
                } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                } else {
                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                    if (contents != null) {
                        /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                    }
                }
                if (modelRotation == null) {
                    this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                } else {
                    this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                }
                this.modelFlags = modelFlags;
                this.modelSize = modelSize;
                this.resizable = resizable;
                this.deformable = deformable;
                this.texturable = texturable;
                this.iconYaw = iconYaw;
                this.iconPitch = iconPitch;
                this.iconScale = iconScale;
                this.proportional = proportional;
                this.modifiable = modifiable;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((information != null && (information.constructor != null && information.constructor["__interfaces"] != null && information.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || information === null) && ((license != null && (license.constructor != null && license.constructor["__interfaces"] != null && license.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || license === null) && ((tags != null && (tags.constructor != null && tags.constructor["__interfaces"] != null && tags.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((typeof icon === 'number') || icon === null) && ((typeof planIcon === 'number') || planIcon === null) && ((typeof model === 'boolean') || model === null) && ((width != null && width instanceof <any>Array && (width.length == 0 || width[0] == null || width[0] instanceof Array)) || width === null) && ((typeof depth === 'string') || depth === null) && ((typeof height === 'boolean') || height === null) && ((typeof elevation === 'boolean') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((movable != null && movable instanceof <any>Big) || movable === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Big) || doorOrWindow === null) && staircaseCutOutShape === undefined && color === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let icon: any = __args[3];
            let planIcon: any = __args[4];
            let model: any = __args[5];
            let width: any = __args[6];
            let depth: any = __args[7];
            let height: any = __args[8];
            let elevation: any = __args[9];
            let movable: any = __args[10];
            let modelRotation: any = __args[11];
            let creator: any = __args[12];
            let resizable: any = __args[13];
            let deformable: any = __args[14];
            let texturable: any = __args[15];
            let price: any = __args[16];
            let valueAddedTaxPercentage: any = __args[17];
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || name === null) && ((description != null && (description.constructor != null && description.constructor["__interfaces"] != null && description.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || description === null) && ((typeof information === 'number') || information === null) && ((typeof license === 'number') || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'boolean') || grade === null) && ((typeof icon === 'string') || icon === null) && ((typeof planIcon === 'number') || planIcon === null) && ((model != null && model instanceof <any>Array && (model.length == 0 || model[0] == null || model[0] instanceof Array)) || model === null) && ((typeof width === 'boolean') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'string') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && movable === undefined && doorOrWindow === undefined && staircaseCutOutShape === undefined && color === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let icon: any = __args[1];
            let model: any = __args[2];
            let width: any = __args[3];
            let depth: any = __args[4];
            let height: any = __args[5];
            let elevation: any = __args[6];
            let movable: any = __args[7];
            let staircaseCutOutShape: any = __args[8];
            let color: any = __args[9];
            let modelRotation: any = __args[10];
            let backFaceShown: any = __args[11];
            let modelSize: any = __args[12];
            let creator: any = __args[13];
            let iconYaw: any = __args[14];
            let proportional: any = __args[15];
            {
                let __args = arguments;
                let id: any = null;
                let description: any = null;
                let information: any = null;
                let license: any = null;
                let tags: any = [];
                let creationDate: any = /* currentTimeMillis */Date.now();
                let grade: any = null;
                let planIcon: any = null;
                let dropOnTopElevation: any = 1.0;
                let doorOrWindow: any = false;
                let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                let resizable: any = true;
                let deformable: any = true;
                let texturable: any = true;
                let horizontallyRotatable: any = true;
                let price: any = null;
                let valueAddedTaxPercentage: any = null;
                let currency: any = null;
                let properties: any = null;
                let contents: any = null;
                let iconPitch: any = <number>(-Math.PI / 16);
                let iconScale: any = 1;
                let modifiable: any = true;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                this.id = id;
                this.name = name;
                this.description = description;
                this.information = information;
                this.license = license;
                this.tags = tags;
                this.creationDate = creationDate;
                this.grade = grade;
                this.icon = icon;
                this.planIcon = planIcon;
                this.model = model;
                this.width = width;
                this.depth = depth;
                this.height = height;
                this.elevation = elevation;
                this.dropOnTopElevation = dropOnTopElevation;
                this.movable = movable;
                this.doorOrWindow = doorOrWindow;
                this.color = color;
                this.staircaseCutOutShape = staircaseCutOutShape;
                this.creator = creator;
                this.horizontallyRotatable = horizontallyRotatable;
                this.price = price;
                this.valueAddedTaxPercentage = valueAddedTaxPercentage;
                this.currency = currency;
                if (properties == null || /* size */Object.keys(properties).length === 0) {
                    if (contents == null || /* size */Object.keys(contents).length === 0) {
                        this.properties = /* emptyMap */{};
                    } else if (/* size */Object.keys(contents).length === 1) {
                        this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(contents)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(contents)).next());
                    } else {
                        this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(contents));
                    }
                } else if (/* size */Object.keys(properties).length === 1 && (contents == null || /* size */Object.keys(contents).length === 0)) {
                    this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(properties)).next());
                } else {
                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(properties));
                    if (contents != null) {
                        /* putAll */(function (m, n) { for (var i in n) m[i] = n[i]; })(this.properties, contents);
                    }
                }
                if (modelRotation == null) {
                    this.modelRotation = PieceOfFurniture.IDENTITY_ROTATION_$LI$();
                } else {
                    this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
                }
                this.modelFlags = modelFlags;
                this.modelSize = modelSize;
                this.resizable = resizable;
                this.deformable = deformable;
                this.texturable = texturable;
                this.iconYaw = iconYaw;
                this.iconPitch = iconPitch;
                this.iconScale = iconScale;
                this.proportional = proportional;
                this.modifiable = modifiable;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((information != null && (information.constructor != null && information.constructor["__interfaces"] != null && information.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || information === null) && ((license != null && (license.constructor != null && license.constructor["__interfaces"] != null && license.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || license === null) && ((tags != null && (tags.constructor != null && tags.constructor["__interfaces"] != null && tags.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((typeof icon === 'number') || icon === null) && ((typeof planIcon === 'number') || planIcon === null) && ((typeof model === 'boolean') || model === null) && ((width != null && width instanceof <any>Array && (width.length == 0 || width[0] == null || width[0] instanceof Array)) || width === null) && ((typeof depth === 'string') || depth === null) && ((typeof height === 'boolean') || height === null) && ((elevation != null && elevation instanceof <any>Big) || elevation === null) && ((dropOnTopElevation != null && dropOnTopElevation instanceof <any>Big) || dropOnTopElevation === null) && movable === undefined && doorOrWindow === undefined && staircaseCutOutShape === undefined && color === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let icon: any = __args[3];
            let planIcon: any = __args[4];
            let model: any = __args[5];
            let width: any = __args[6];
            let depth: any = __args[7];
            let height: any = __args[8];
            let elevation: any = __args[9];
            let movable: any = __args[10];
            let modelRotation: any = __args[11];
            let creator: any = __args[12];
            let resizable: any = __args[13];
            let price: any = __args[14];
            let valueAddedTaxPercentage: any = __args[15];
            {
                let __args = arguments;
                let deformable: any = true;
                let texturable: any = true;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.tags === undefined) { this.tags = null; }
                if (this.creationDate === undefined) { this.creationDate = null; }
                if (this.grade === undefined) { this.grade = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((information != null && (information.constructor != null && information.constructor["__interfaces"] != null && information.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || information === null) && ((license != null && (license.constructor != null && license.constructor["__interfaces"] != null && license.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((typeof icon === 'number') || icon === null) && ((typeof planIcon === 'boolean') || planIcon === null) && ((typeof model === 'boolean') || model === null) && ((width != null && width instanceof <any>Array && (width.length == 0 || width[0] == null || width[0] instanceof Array)) || width === null) && ((typeof depth === 'string') || depth === null) && ((typeof height === 'boolean') || height === null) && ((elevation != null && elevation instanceof <any>Big) || elevation === null) && ((dropOnTopElevation != null && dropOnTopElevation instanceof <any>Big) || dropOnTopElevation === null) && movable === undefined && doorOrWindow === undefined && staircaseCutOutShape === undefined && color === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && horizontallyRotatable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined && iconYaw === undefined && iconPitch === undefined && iconScale === undefined && proportional === undefined && modifiable === undefined) {
            let __args = arguments;
            let icon: any = __args[3];
            let model: any = __args[4];
            let width: any = __args[5];
            let depth: any = __args[6];
            let height: any = __args[7];
            let elevation: any = __args[8];
            let movable: any = __args[9];
            let doorOrWindow: any = __args[10];
            let modelRotation: any = __args[11];
            let creator: any = __args[12];
            let resizable: any = __args[13];
            let price: any = __args[14];
            let valueAddedTaxPercentage: any = __args[15];
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.tags === undefined) { this.tags = null; }
            if (this.creationDate === undefined) { this.creationDate = null; }
            if (this.grade === undefined) { this.grade = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the ID of this piece of furniture or <code>null</code>.
     * @return {string}
     */
    public getId(): string {
        return this.id;
    }

    /**
     * Returns the name of this piece of furniture.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the description of this piece of furniture.
     * The returned value may be <code>null</code>.
     * @return {string}
     */
    public getDescription(): string {
        return this.description;
    }

    /**
     * Returns the additional information associated to this piece, or <code>null</code>.
     * @return {string}
     */
    public getInformation(): string {
        return this.information;
    }

    /**
     * Returns the license associated to this piece, or <code>null</code>.
     * @return {string}
     */
    public getLicense(): string {
        return this.license;
    }

    /**
     * Returns the tags associated to this piece.
     * @return {java.lang.String[]}
     */
    public getTags(): string[] {
        return this.tags;
    }

    /**
     * Returns the creation date of this piece in milliseconds since the epoch,
     * or <code>null</code> if no date is given to this piece.
     * @return {number}
     */
    public getCreationDate(): number {
        return this.creationDate;
    }

    /**
     * Returns the grade of this piece, or <code>null</code> if no grade is given to this piece.
     * @return {number}
     */
    public getGrade(): number {
        return this.grade;
    }

    /**
     * Returns the depth of this piece of furniture.
     * @return {number}
     */
    public getDepth(): number {
        return this.depth;
    }

    /**
     * Returns the height of this piece of furniture.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Returns the width of this piece of furniture.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Returns the elevation of this piece of furniture.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Returns the elevation at which should be placed an object dropped on this piece.
     * @return {number} a percentage of the height of this piece. A negative value means that the piece
     * should be ignored when an object is dropped on it.
     */
    public getDropOnTopElevation(): number {
        return this.dropOnTopElevation;
    }

    /**
     * Returns <code>true</code> if this piece of furniture is movable.
     * @return {boolean}
     */
    public isMovable(): boolean {
        return this.movable;
    }

    /**
     * Returns <code>true</code> if this piece of furniture is a door or a window.
     * As this method existed before {@linkplain CatalogDoorOrWindow CatalogDoorOrWindow} class,
     * you shouldn't rely on the value returned by this method to guess if a piece
     * is an instance of <code>DoorOrWindow</code> class.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return this.doorOrWindow;
    }

    /**
     * Returns the icon of this piece of furniture.
     * @return {Object}
     */
    public getIcon(): Content {
        return this.icon;
    }

    /**
     * Returns the icon of this piece of furniture displayed in plan or <code>null</code>.
     * @return {Object}
     */
    public getPlanIcon(): Content {
        return this.planIcon;
    }

    /**
     * Returns the 3D model of this piece of furniture.
     * @return {Object}
     */
    public getModel(): Content {
        return this.model;
    }

    /**
     * Returns the flags which should be applied to the 3D model of this piece of furniture.
     * @return {number}
     */
    public getModelFlags(): number {
        return this.modelFlags;
    }

    /**
     * Returns the size of the 3D model of this piece of furniture.
     * @return {number}
     */
    public getModelSize(): number {
        return this.modelSize;
    }

    /**
     * Returns the rotation 3 by 3 matrix of this piece of furniture that ensures
     * its model is correctly oriented.
     * @return {float[][]}
     */
    public getModelRotation(): number[][] {
        return CatalogPieceOfFurniture.deepClone(this.modelRotation);
    }

    /**
     * Returns a deep copy of the given array.
     * @param {float[][]} array
     * @return {float[][]}
     * @private
     */
    static deepClone(array: number[][]): number[][] {
        const clone: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(array.length);
        for (let i: number = 0; i < array.length; i++) {
            {
                clone[i] = /* clone */array[i].slice(0);
            };
        }
        return clone;
    }

    /**
     * Returns the shape used to cut out upper levels when they intersect with the piece
     * like a staircase.
     * @return {string}
     */
    public getStaircaseCutOutShape(): string {
        return this.staircaseCutOutShape;
    }

    /**
     * Returns the creator of this piece.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Returns <code>true</code> if the back face of the piece of furniture
     * model should be displayed.
     * @return {boolean}
     */
    public isBackFaceShown(): boolean {
        return (this.modelFlags & PieceOfFurniture.SHOW_BACK_FACE) === PieceOfFurniture.SHOW_BACK_FACE;
    }

    /**
     * Returns the color of this piece of furniture.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Returns the yaw angle used to create the piece icon.
     * @return {number}
     */
    public getIconYaw(): number {
        return this.iconYaw;
    }

    /**
     * Returns the pitch angle used to create the piece icon.
     * @return {number}
     */
    public getIconPitch(): number {
        return this.iconPitch;
    }

    /**
     * Returns the scale used to create the piece icon.
     * @return {number}
     */
    public getIconScale(): number {
        return this.iconScale;
    }

    /**
     * Returns <code>true</code> if size proportions should be kept.
     * @return {boolean}
     */
    public isProportional(): boolean {
        return this.proportional;
    }

    /**
     * Returns <code>true</code> if this piece is modifiable (not read from resources).
     * @return {boolean}
     */
    public isModifiable(): boolean {
        return this.modifiable;
    }

    /**
     * Returns <code>true</code> if this piece is resizable.
     * @return {boolean}
     */
    public isResizable(): boolean {
        return this.resizable;
    }

    /**
     * Returns <code>true</code> if this piece is deformable.
     * @return {boolean}
     */
    public isDeformable(): boolean {
        return this.deformable;
    }

    /**
     * Returns <code>true</code> if this piece is deformable.
     * @return {boolean}
     */
    public isWidthDepthDeformable(): boolean {
        return this.isDeformable();
    }

    /**
     * Returns <code>false</code> if this piece should always keep the same color or texture.
     * @return {boolean}
     */
    public isTexturable(): boolean {
        return this.texturable;
    }

    /**
     * Returns <code>false</code> if this piece should not rotate around an horizontal axis.
     * @return {boolean}
     */
    public isHorizontallyRotatable(): boolean {
        return this.horizontallyRotatable;
    }

    /**
     * Returns the price of this piece of furniture or <code>null</code>.
     * @return {Big}
     */
    public getPrice(): Big {
        return this.price;
    }

    /**
     * Returns the Value Added Tax percentage applied to the price of this piece of furniture.
     * @return {Big}
     */
    public getValueAddedTaxPercentage(): Big {
        return this.valueAddedTaxPercentage;
    }

    /**
     * Returns the price currency, noted with ISO 4217 code, or <code>null</code>
     * if it has no price or default currency should be used.
     * @return {string}
     */
    public getCurrency(): string {
        return this.currency;
    }

    /**
     * Returns the value of an additional property <code>name</code> of this piece.
     * @return {string} the value of the property or <code>null</code> if it doesn't exist or if it's not a string.
     * @param {string} name
     */
    public getProperty(name: string): string {
        const propertyValue: any = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
        if (typeof propertyValue === 'string') {
            return <string>propertyValue;
        } else {
            return null;
        }
    }

    /**
     * Returns the names of the additional properties of this piece.
     * @return {string[]} a collection of all the names of the properties
     */
    public getPropertyNames(): Array<string> {
        return /* keySet */Object.keys(this.properties);
    }

    /**
     * Returns the value of an additional content <code>name</code> associated to this piece.
     * @return {Object} the value of the content or <code>null</code> if it doesn't exist or if it's not a content.
     * @param {string} name
     */
    public getContentProperty(name: string): Content {
        const propertyValue: any = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
        if (propertyValue != null && (propertyValue.constructor != null && propertyValue.constructor["__interfaces"] != null && propertyValue.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) {
            return <Content><any>propertyValue;
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if the type of given additional property is a content.
     * @param {string} name
     * @return {boolean}
     */
    public isContentProperty(name: string): boolean {
        return (/* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name) != null && (/* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor != null && /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor["__interfaces"] != null && /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0));
    }

    /**
     * Returns the category of this piece of furniture.
     * @return {FurnitureCategory}
     */
    public getCategory(): FurnitureCategory {
        return this.category;
    }

    /**
     * Sets the category of this piece of furniture.
     * @param {FurnitureCategory} category
     * @private
     */
    setCategory(category: FurnitureCategory) {
        this.category = category;
    }

    /**
     * Returns <code>true</code> if this piece and the one in parameter are the same objects.
     * Note that, from version 3.6, two pieces of furniture can have the same name.
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        return /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(this, obj));
    }

    /**
     * Returns default hash code.
     * @return {number}
     */
    public hashCode(): number {
        return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this));
    }

    /**
     * Compares the names of this piece and the one in parameter.
     * @param {CatalogPieceOfFurniture} piece
     * @return {number}
     */
    public compareTo(piece: CatalogPieceOfFurniture): number {
        const nameComparison: number = CatalogPieceOfFurniture.COMPARATOR_$LI$().compare(this.name, piece.name);
        if (nameComparison !== 0) {
            return nameComparison;
        } else {
            return this.modifiable === piece.modifiable ? 0 : (this.modifiable ? 1 : -1);
        }
    }

    /**
     * Returns <code>true</code> if this piece matches the given <code>filter</code> text.
     * Each substring of the <code>filter</code> is considered as a search criterion that can match
     * the name, the category name, the creator, the license, the description or the tags of this piece.
     * @param {string} filter
     * @return {boolean}
     */
    public matchesFilter(filter: string): boolean {
        const filterCriteriaCollationKeys: number[][] = this.getFilterCollationKeys(filter);
        let checkedCriteria: number = 0;
        if (filterCriteriaCollationKeys.length > 0) {
            const furnitureCollationKey: number[] = this.getPieceOfFurnitureCollationKey();
            for (let i: number = 0; i < filterCriteriaCollationKeys.length; i++) {
                {
                    if (this.isSubCollationKey(furnitureCollationKey, filterCriteriaCollationKeys[i], 0)) {
                        checkedCriteria++;
                    } else {
                        break;
                    }
                };
            }
        }
        return checkedCriteria === filterCriteriaCollationKeys.length;
    }

    /**
     * Returns the collation key bytes of each criterion in the given <code>filter</code>.
     * @param {string} filter
     * @return {byte[][]}
     * @private
     */
    /*private*/ getFilterCollationKeys(filter: string): number[][] {
        if (filter.length === 0) {
            return CatalogPieceOfFurniture.EMPTY_CRITERIA_$LI$();
        }
        let filterCollationKeys: number[][] = /* get */((m, k) => m[k] === undefined ? null : m[k])(CatalogPieceOfFurniture.recentFilters_$LI$(), filter);
        if (filterCollationKeys == null) {
            const filterCriteria: string[] = filter.split(/\s|\p{Punct}|\\|/);
            const filterCriteriaCollationKeys: Array<number[]> = <any>([]);
            for (let index = 0; index < filterCriteria.length; index++) {
                let criterion = filterCriteria[index];
                {
                    if (criterion.length > 0) {
                        /* add */(filterCriteriaCollationKeys.push(CatalogPieceOfFurniture.COMPARATOR_$LI$().getCollationKey(criterion).toByteArray()) > 0);
                    }
                }
            }
            if (/* size */(<number>filterCriteriaCollationKeys.length) === 0) {
                filterCollationKeys = CatalogPieceOfFurniture.EMPTY_CRITERIA_$LI$();
            } else {
                filterCollationKeys = /* toArray */filterCriteriaCollationKeys.slice(0);
            }
            /* put */(CatalogPieceOfFurniture.recentFilters_$LI$()[filter] = filterCollationKeys);
        }
        return filterCollationKeys;
    }

    /**
     * Returns the collation key bytes used to compare the given <code>piece</code> with filter.
     * @return {byte[]}
     * @private
     */
    /*private*/ getPieceOfFurnitureCollationKey(): number[] {
        if (this.filterCollationKey == null) {
            const search: { str: string, toString: Function } = { str: "", toString: function () { return this.str; } };
            {
                let array = this.getFilterCriteria();
                for (let index = 0; index < array.length; index++) {
                    let criterion = array[index];
                    {
                        if (/* length */search.str.length !== 0) {
                            /* append */(sb => { sb.str += <any>'|'; return sb; })(search);
                        }
                        /* append */(sb => { sb.str += <any>criterion; return sb; })(search);
                    }
                }
            }
            this.filterCollationKey = CatalogPieceOfFurniture.COMPARATOR_$LI$().getCollationKey(/* toString */search.str).toByteArray();
        }
        return this.filterCollationKey;
    }

    /**
     * Returns the strings used as criteria for filtering (name, category, creator, license, description and tags).
     * @see CatalogPieceOfFurniture#matchesFilter(String)
     * @return {java.lang.String[]}
     */
    getFilterCriteria(): string[] {
        const criteria: Array<string> = <any>([]);
        /* add */(criteria.push(this.getName()) > 0);
        if (this.getCategory() != null) {
            /* add */(criteria.push(this.getCategory().getName()) > 0);
        }
        if (this.getCreator() != null) {
            /* add */(criteria.push(this.getCreator()) > 0);
        }
        if (this.getDescription() != null) {
            /* add */(criteria.push(this.getDescription()) > 0);
        }
        if (this.getLicense() != null) {
            /* add */(criteria.push(this.getLicense()) > 0);
        }
        {
            let array = this.getTags();
            for (let index = 0; index < array.length; index++) {
                let tag = array[index];
                {
                    /* add */(criteria.push(tag) > 0);
                }
            }
        }
        return /* toArray */criteria.slice(0);
    }

    /**
     * Returns <code>true</code> if the given filter collation key is a sub part of the first array collator key.
     * @param {byte[]} collationKey
     * @param {byte[]} filterCollationKey
     * @param {number} start
     * @return {boolean}
     * @private
     */
    /*private*/ isSubCollationKey(collationKey: number[], filterCollationKey: number[], start: number): boolean {
        for (let i: number = start, n: number = collationKey.length - 4, m: number = filterCollationKey.length - 4; i < n && i < n - m + 1; i++) {
            {
                if (collationKey[i] === filterCollationKey[0]) {
                    for (let j: number = 1; j < m; j++) {
                        {
                            if (collationKey[i + j] !== filterCollationKey[j]) {
                                return this.isSubCollationKey(collationKey, filterCollationKey, i + 1);
                            }
                        };
                    }
                    return true;
                }
            };
        }
        return false;
    }

    /**
     * Returns a clone of this piece.
     * @return {CatalogPieceOfFurniture}
     */
    public clone(): CatalogPieceOfFurniture {
        try {
            const clone: CatalogPieceOfFurniture = <CatalogPieceOfFurniture>/* clone *//* clone */((o: any) => { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; })(this);
            clone.category = null;
            return clone;
        } catch (ex) {
            throw new IllegalStateException("Super class isn\'t cloneable");
        }
    }
}
CatalogPieceOfFurniture["__class"] = "com.eteks.sweethome3d.model.CatalogPieceOfFurniture";
CatalogPieceOfFurniture["__interfaces"] = ["com.eteks.sweethome3d.model.CatalogItem", "com.eteks.sweethome3d.model.PieceOfFurniture"];



/**
 * Create a category.
 * @param {string} name the name of the category.
 * @class
 * @author Emmanuel Puybaret
 */
export class FurnitureCategory {
    /*private*/ name: string;

    /*private*/ furniture: Array<CatalogPieceOfFurniture>;

    static COMPARATOR: any; public static COMPARATOR_$LI$(): any { if (FurnitureCategory.COMPARATOR == null) { FurnitureCategory.COMPARATOR = /* getInstance */{ compare: (o1, o2) => o1.toString().localeCompare(o2.toString()), equals: (o1, o2) => o1.toString().localeCompare(o2.toString()) === 0 }; } return FurnitureCategory.COMPARATOR; }

    public constructor(name: string) {
        if (this.name === undefined) { this.name = null; }
        if (this.furniture === undefined) { this.furniture = null; }
        this.name = name;
        this.furniture = <any>([]);
    }

    /**
     * Returns the name of this category.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the furniture list of this category sorted by name.
     * @return {CatalogPieceOfFurniture[]} a list of furniture.
     */
    public getFurniture(): Array<CatalogPieceOfFurniture> {
        return /* unmodifiableList */this.furniture.slice(0);
    }

    /**
     * Returns the count of furniture in this category.
     * @return {number}
     */
    public getFurnitureCount(): number {
        return /* size */(<number>this.furniture.length);
    }

    /**
     * Returns the piece of furniture at a given <code>index</code>.
     * @param {number} index
     * @return {CatalogPieceOfFurniture}
     */
    public getPieceOfFurniture(index: number): CatalogPieceOfFurniture {
        return /* get */this.furniture[index];
    }

    /**
     * Returns the index of the given <code>piece</code> of furniture.
     * @param {CatalogPieceOfFurniture} piece
     * @return {number}
     */
    public getIndexOfPieceOfFurniture(piece: CatalogPieceOfFurniture): number {
        return this.furniture.indexOf(piece);
    }

    /**
     * Adds a piece of furniture to this category.
     * @param {CatalogPieceOfFurniture} piece the piece to add.
     * @private
     */
    add(piece: CatalogPieceOfFurniture) {
        piece.setCategory(this);
        let index: number = /* binarySearch */((l, key) => { let comp = (a, b) => { if (a.compareTo) return (<number>a.compareTo(b)); else return a.localeCompare(b); }; let low = 0; let high = l.length - 1; while (low <= high) { let mid = (low + high) >>> 1; let midVal = l[mid]; let cmp = comp(midVal, key); if (cmp < 0) low = mid + 1; else if (cmp > 0) high = mid - 1; else return mid; } return -(low + 1); })(this.furniture, piece);
        if (index < 0) {
            index = -index - 1;
        }
        /* add */this.furniture.splice(index, 0, piece);
    }

    /**
     * Deletes a piece of furniture from this category.
     * @param {CatalogPieceOfFurniture} piece the piece to remove.
     * @throws IllegalArgumentException if the piece doesn't exist in this category.
     * @private
     */
    delete(piece: CatalogPieceOfFurniture) {
        const pieceIndex: number = this.furniture.indexOf(piece);
        if (pieceIndex === -1) {
            throw new IllegalArgumentException(this.name + " doesn\'t contain piece " + piece.getName());
        }
        this.furniture = <any>(this.furniture.slice(0));
        /* remove */this.furniture.splice(pieceIndex, 1)[0];
    }

    /**
     * Returns <code>true</code> if this category and the one in parameter have the same name.
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        return (obj != null && obj instanceof <any>FurnitureCategory) && FurnitureCategory.COMPARATOR_$LI$().equals(this.name, (<FurnitureCategory>obj).name);
    }

    /**
     * 
     * @return {number}
     */
    public hashCode(): number {
        return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name));
    }

    /**
     * Compares the names of this category and the one in parameter.
     * @param {FurnitureCategory} category
     * @return {number}
     */
    public compareTo(category: FurnitureCategory): number {
        return FurnitureCategory.COMPARATOR_$LI$().compare(this.name, category.name);
    }
}
FurnitureCategory["__class"] = "com.eteks.sweethome3d.model.FurnitureCategory";


/**
 * An item of a catalog.
 * @author Emmanuel Puybaret
 * @class
 */
interface CatalogItem {
    /**
     * Returns the name of this catalog item.
     * @return {string}
     */
    getName(): string;

    /**
     * Returns the icon of this catalog item.
     * @return {Object}
     */
    getIcon(): Content;

    /**
     * Returns the creator of this catalog item or <code>null</code>.
     * @return {string}
     */
    getCreator(): string;
}

/**
 * Creates a home texture from an existing one with customized parameters.
 * @param {Object} texture the texture from which data are copied
 * @param {number} xOffset the offset applied to the texture along X axis in percentage of its width
 * @param {number} yOffset the offset applied to the texture along Y axis in percentage of its height
 * @param {number} angle   the rotation angle applied to the texture
 * @param {number} scale   the scale applied to the texture
 * @param {boolean} fittingArea if <code>true</code> the texture will fit at its best the area to which it's applied
 * @param {boolean} leftToRightOriented orientation used on the texture when applied on objects seen from front
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeTexture implements TextureImage {
    /*private*/ catalogId: string;

    /*private*/ name: string;

    /*private*/ creator: string;

    /*private*/ image: Content;

    /*private*/ width: number;

    /*private*/ height: number;

    /*private*/ xOffset: number;

    /*private*/ yOffset: number;

    /*private*/ angle: number;

    /*private*/ scale: number;

    /*private*/ fittingArea: boolean;

    /*private*/ leftToRightOriented: boolean;

    public constructor(texture?: any, xOffset?: any, yOffset?: any, angle?: any, scale?: any, fittingArea?: any, leftToRightOriented?: any) {
        if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && ((typeof xOffset === 'number') || xOffset === null) && ((typeof yOffset === 'number') || yOffset === null) && ((typeof angle === 'number') || angle === null) && ((typeof scale === 'number') || scale === null) && ((typeof fittingArea === 'boolean') || fittingArea === null) && ((typeof leftToRightOriented === 'boolean') || leftToRightOriented === null)) {
            let __args = arguments;
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
            this.name = texture.getName();
            this.creator = texture.getCreator();
            this.image = texture.getImage();
            this.width = texture.getWidth();
            this.height = texture.getHeight();
            this.xOffset = xOffset;
            this.yOffset = yOffset;
            this.angle = angle;
            this.scale = scale;
            this.fittingArea = fittingArea;
            this.leftToRightOriented = leftToRightOriented;
            if (texture != null && texture instanceof <any>HomeTexture) {
                this.catalogId = (<HomeTexture><any>texture).getCatalogId();
            } else if (texture != null && texture instanceof <any>CatalogTexture) {
                this.catalogId = (<CatalogTexture><any>texture).getId();
            } else {
                this.catalogId = null;
            }
        } else if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && ((typeof xOffset === 'number') || xOffset === null) && ((typeof yOffset === 'number') || yOffset === null) && ((typeof angle === 'number') || angle === null) && ((typeof scale === 'number') || scale === null) && ((typeof fittingArea === 'boolean') || fittingArea === null) && leftToRightOriented === undefined) {
            let __args = arguments;
            let leftToRightOriented: any = __args[5];
            {
                let __args = arguments;
                let fittingArea: any = false;
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.xOffset === undefined) { this.xOffset = 0; }
                if (this.yOffset === undefined) { this.yOffset = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.scale === undefined) { this.scale = 0; }
                if (this.fittingArea === undefined) { this.fittingArea = false; }
                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                this.name = texture.getName();
                this.creator = texture.getCreator();
                this.image = texture.getImage();
                this.width = texture.getWidth();
                this.height = texture.getHeight();
                this.xOffset = xOffset;
                this.yOffset = yOffset;
                this.angle = angle;
                this.scale = scale;
                this.fittingArea = fittingArea;
                this.leftToRightOriented = leftToRightOriented;
                if (texture != null && texture instanceof <any>HomeTexture) {
                    this.catalogId = (<HomeTexture><any>texture).getCatalogId();
                } else if (texture != null && texture instanceof <any>CatalogTexture) {
                    this.catalogId = (<CatalogTexture><any>texture).getId();
                } else {
                    this.catalogId = null;
                }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
        } else if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && ((typeof xOffset === 'number') || xOffset === null) && ((typeof yOffset === 'number') || yOffset === null) && ((typeof angle === 'boolean') || angle === null) && scale === undefined && fittingArea === undefined && leftToRightOriented === undefined) {
            let __args = arguments;
            let angle: any = __args[1];
            let scale: any = __args[2];
            let leftToRightOriented: any = __args[3];
            {
                let __args = arguments;
                let xOffset: any = 0;
                let yOffset: any = 0;
                {
                    let __args = arguments;
                    let fittingArea: any = false;
                    if (this.catalogId === undefined) { this.catalogId = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.image === undefined) { this.image = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.xOffset === undefined) { this.xOffset = 0; }
                    if (this.yOffset === undefined) { this.yOffset = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    if (this.scale === undefined) { this.scale = 0; }
                    if (this.fittingArea === undefined) { this.fittingArea = false; }
                    if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                    this.name = texture.getName();
                    this.creator = texture.getCreator();
                    this.image = texture.getImage();
                    this.width = texture.getWidth();
                    this.height = texture.getHeight();
                    this.xOffset = xOffset;
                    this.yOffset = yOffset;
                    this.angle = angle;
                    this.scale = scale;
                    this.fittingArea = fittingArea;
                    this.leftToRightOriented = leftToRightOriented;
                    if (texture != null && texture instanceof <any>HomeTexture) {
                        this.catalogId = (<HomeTexture><any>texture).getCatalogId();
                    } else if (texture != null && texture instanceof <any>CatalogTexture) {
                        this.catalogId = (<CatalogTexture><any>texture).getId();
                    } else {
                        this.catalogId = null;
                    }
                }
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.xOffset === undefined) { this.xOffset = 0; }
                if (this.yOffset === undefined) { this.yOffset = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.scale === undefined) { this.scale = 0; }
                if (this.fittingArea === undefined) { this.fittingArea = false; }
                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
        } else if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && ((typeof xOffset === 'number') || xOffset === null) && ((typeof yOffset === 'boolean') || yOffset === null) && angle === undefined && scale === undefined && fittingArea === undefined && leftToRightOriented === undefined) {
            let __args = arguments;
            let angle: any = __args[1];
            let leftToRightOriented: any = __args[2];
            {
                let __args = arguments;
                let scale: any = 1;
                {
                    let __args = arguments;
                    let xOffset: any = 0;
                    let yOffset: any = 0;
                    {
                        let __args = arguments;
                        let fittingArea: any = false;
                        if (this.catalogId === undefined) { this.catalogId = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.image === undefined) { this.image = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.xOffset === undefined) { this.xOffset = 0; }
                        if (this.yOffset === undefined) { this.yOffset = 0; }
                        if (this.angle === undefined) { this.angle = 0; }
                        if (this.scale === undefined) { this.scale = 0; }
                        if (this.fittingArea === undefined) { this.fittingArea = false; }
                        if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                        this.name = texture.getName();
                        this.creator = texture.getCreator();
                        this.image = texture.getImage();
                        this.width = texture.getWidth();
                        this.height = texture.getHeight();
                        this.xOffset = xOffset;
                        this.yOffset = yOffset;
                        this.angle = angle;
                        this.scale = scale;
                        this.fittingArea = fittingArea;
                        this.leftToRightOriented = leftToRightOriented;
                        if (texture != null && texture instanceof <any>HomeTexture) {
                            this.catalogId = (<HomeTexture><any>texture).getCatalogId();
                        } else if (texture != null && texture instanceof <any>CatalogTexture) {
                            this.catalogId = (<CatalogTexture><any>texture).getId();
                        } else {
                            this.catalogId = null;
                        }
                    }
                    if (this.catalogId === undefined) { this.catalogId = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.image === undefined) { this.image = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.xOffset === undefined) { this.xOffset = 0; }
                    if (this.yOffset === undefined) { this.yOffset = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    if (this.scale === undefined) { this.scale = 0; }
                    if (this.fittingArea === undefined) { this.fittingArea = false; }
                    if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                }
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.xOffset === undefined) { this.xOffset = 0; }
                if (this.yOffset === undefined) { this.yOffset = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.scale === undefined) { this.scale = 0; }
                if (this.fittingArea === undefined) { this.fittingArea = false; }
                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
        } else if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && ((typeof xOffset === 'number') || xOffset === null) && yOffset === undefined && angle === undefined && scale === undefined && fittingArea === undefined && leftToRightOriented === undefined) {
            let __args = arguments;
            let angle: any = __args[1];
            {
                let __args = arguments;
                let leftToRightOriented: any = true;
                {
                    let __args = arguments;
                    let scale: any = 1;
                    {
                        let __args = arguments;
                        let xOffset: any = 0;
                        let yOffset: any = 0;
                        {
                            let __args = arguments;
                            let fittingArea: any = false;
                            if (this.catalogId === undefined) { this.catalogId = null; }
                            if (this.name === undefined) { this.name = null; }
                            if (this.creator === undefined) { this.creator = null; }
                            if (this.image === undefined) { this.image = null; }
                            if (this.width === undefined) { this.width = 0; }
                            if (this.height === undefined) { this.height = 0; }
                            if (this.xOffset === undefined) { this.xOffset = 0; }
                            if (this.yOffset === undefined) { this.yOffset = 0; }
                            if (this.angle === undefined) { this.angle = 0; }
                            if (this.scale === undefined) { this.scale = 0; }
                            if (this.fittingArea === undefined) { this.fittingArea = false; }
                            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                            this.name = texture.getName();
                            this.creator = texture.getCreator();
                            this.image = texture.getImage();
                            this.width = texture.getWidth();
                            this.height = texture.getHeight();
                            this.xOffset = xOffset;
                            this.yOffset = yOffset;
                            this.angle = angle;
                            this.scale = scale;
                            this.fittingArea = fittingArea;
                            this.leftToRightOriented = leftToRightOriented;
                            if (texture != null && texture instanceof <any>HomeTexture) {
                                this.catalogId = (<HomeTexture><any>texture).getCatalogId();
                            } else if (texture != null && texture instanceof <any>CatalogTexture) {
                                this.catalogId = (<CatalogTexture><any>texture).getId();
                            } else {
                                this.catalogId = null;
                            }
                        }
                        if (this.catalogId === undefined) { this.catalogId = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.image === undefined) { this.image = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.xOffset === undefined) { this.xOffset = 0; }
                        if (this.yOffset === undefined) { this.yOffset = 0; }
                        if (this.angle === undefined) { this.angle = 0; }
                        if (this.scale === undefined) { this.scale = 0; }
                        if (this.fittingArea === undefined) { this.fittingArea = false; }
                        if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                    }
                    if (this.catalogId === undefined) { this.catalogId = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.image === undefined) { this.image = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.xOffset === undefined) { this.xOffset = 0; }
                    if (this.yOffset === undefined) { this.yOffset = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    if (this.scale === undefined) { this.scale = 0; }
                    if (this.fittingArea === undefined) { this.fittingArea = false; }
                    if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                }
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.xOffset === undefined) { this.xOffset = 0; }
                if (this.yOffset === undefined) { this.yOffset = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.scale === undefined) { this.scale = 0; }
                if (this.fittingArea === undefined) { this.fittingArea = false; }
                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
        } else if (((texture != null && (texture.constructor != null && texture.constructor["__interfaces"] != null && texture.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || texture === null) && xOffset === undefined && yOffset === undefined && angle === undefined && scale === undefined && fittingArea === undefined && leftToRightOriented === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let angle: any = 0;
                {
                    let __args = arguments;
                    let leftToRightOriented: any = true;
                    {
                        let __args = arguments;
                        let scale: any = 1;
                        {
                            let __args = arguments;
                            let xOffset: any = 0;
                            let yOffset: any = 0;
                            {
                                let __args = arguments;
                                let fittingArea: any = false;
                                if (this.catalogId === undefined) { this.catalogId = null; }
                                if (this.name === undefined) { this.name = null; }
                                if (this.creator === undefined) { this.creator = null; }
                                if (this.image === undefined) { this.image = null; }
                                if (this.width === undefined) { this.width = 0; }
                                if (this.height === undefined) { this.height = 0; }
                                if (this.xOffset === undefined) { this.xOffset = 0; }
                                if (this.yOffset === undefined) { this.yOffset = 0; }
                                if (this.angle === undefined) { this.angle = 0; }
                                if (this.scale === undefined) { this.scale = 0; }
                                if (this.fittingArea === undefined) { this.fittingArea = false; }
                                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                                this.name = texture.getName();
                                this.creator = texture.getCreator();
                                this.image = texture.getImage();
                                this.width = texture.getWidth();
                                this.height = texture.getHeight();
                                this.xOffset = xOffset;
                                this.yOffset = yOffset;
                                this.angle = angle;
                                this.scale = scale;
                                this.fittingArea = fittingArea;
                                this.leftToRightOriented = leftToRightOriented;
                                if (texture != null && texture instanceof <any>HomeTexture) {
                                    this.catalogId = (<HomeTexture><any>texture).getCatalogId();
                                } else if (texture != null && texture instanceof <any>CatalogTexture) {
                                    this.catalogId = (<CatalogTexture><any>texture).getId();
                                } else {
                                    this.catalogId = null;
                                }
                            }
                            if (this.catalogId === undefined) { this.catalogId = null; }
                            if (this.name === undefined) { this.name = null; }
                            if (this.creator === undefined) { this.creator = null; }
                            if (this.image === undefined) { this.image = null; }
                            if (this.width === undefined) { this.width = 0; }
                            if (this.height === undefined) { this.height = 0; }
                            if (this.xOffset === undefined) { this.xOffset = 0; }
                            if (this.yOffset === undefined) { this.yOffset = 0; }
                            if (this.angle === undefined) { this.angle = 0; }
                            if (this.scale === undefined) { this.scale = 0; }
                            if (this.fittingArea === undefined) { this.fittingArea = false; }
                            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                        }
                        if (this.catalogId === undefined) { this.catalogId = null; }
                        if (this.name === undefined) { this.name = null; }
                        if (this.creator === undefined) { this.creator = null; }
                        if (this.image === undefined) { this.image = null; }
                        if (this.width === undefined) { this.width = 0; }
                        if (this.height === undefined) { this.height = 0; }
                        if (this.xOffset === undefined) { this.xOffset = 0; }
                        if (this.yOffset === undefined) { this.yOffset = 0; }
                        if (this.angle === undefined) { this.angle = 0; }
                        if (this.scale === undefined) { this.scale = 0; }
                        if (this.fittingArea === undefined) { this.fittingArea = false; }
                        if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                    }
                    if (this.catalogId === undefined) { this.catalogId = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.image === undefined) { this.image = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.xOffset === undefined) { this.xOffset = 0; }
                    if (this.yOffset === undefined) { this.yOffset = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    if (this.scale === undefined) { this.scale = 0; }
                    if (this.fittingArea === undefined) { this.fittingArea = false; }
                    if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
                }
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.xOffset === undefined) { this.xOffset = 0; }
                if (this.yOffset === undefined) { this.yOffset = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.scale === undefined) { this.scale = 0; }
                if (this.fittingArea === undefined) { this.fittingArea = false; }
                if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.xOffset === undefined) { this.xOffset = 0; }
            if (this.yOffset === undefined) { this.yOffset = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.scale === undefined) { this.scale = 0; }
            if (this.fittingArea === undefined) { this.fittingArea = false; }
            if (this.leftToRightOriented === undefined) { this.leftToRightOriented = false; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the catalog ID of this texture or <code>null</code> if it doesn't exist.
     * @return {string}
     */
    public getCatalogId(): string {
        return this.catalogId;
    }

    /**
     * Returns the name of this texture.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the creator of this texture.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Returns the content of the image used for this texture.
     * @return {Object}
     */
    public getImage(): Content {
        return this.image;
    }

    /**
     * Returns the width of the image in centimeters.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Returns the height of the image in centimeters.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Returns the offset applied to the texture along X axis in percentage of its width.
     * @return {number}
     */
    public getXOffset(): number {
        return this.xOffset;
    }

    /**
     * Returns the offset applied to the texture along Y axis in percentage of its height.
     * @return {number}
     */
    public getYOffset(): number {
        return this.yOffset;
    }

    /**
     * Returns the angle of rotation in radians applied to this texture.
     * @return {number}
     */
    public getAngle(): number {
        return this.angle;
    }

    /**
     * Returns the scale applied to this texture.
     * @return {number}
     */
    public getScale(): number {
        return this.scale;
    }

    /**
     * Returns <code>true</code> the texture should fit the area to which it's applied.
     * @return {boolean}
     */
    public isFittingArea(): boolean {
        return this.fittingArea;
    }

    /**
     * Sets whether the texture should fit the area to which it's applied.
     * @param {boolean} fittingArea
     */
    public setFittingArea(fittingArea: boolean) {
        this.fittingArea = fittingArea;
    }

    /**
     * Returns <code>true</code> if the objects using this texture should take into account
     * the orientation of the texture.
     * @return {boolean}
     */
    public isLeftToRightOriented(): boolean {
        return this.leftToRightOriented;
    }

    /**
     * Returns <code>true</code> if the object in parameter is equal to this texture.
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        if (obj === this) {
            return true;
        } else if (obj != null && obj instanceof <any>HomeTexture) {
            const texture: HomeTexture = <HomeTexture>obj;
            return (texture.name === this.name || texture.name != null && (texture.name === this.name)) && (texture.image === this.image || texture.image != null && /* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(texture.image, this.image))) && texture.width === this.width && texture.height === this.height && texture.xOffset === this.xOffset && texture.yOffset === this.yOffset && texture.fittingArea === this.fittingArea && texture.leftToRightOriented === this.leftToRightOriented && texture.angle === this.angle && texture.scale === this.scale;
        } else {
            return false;
        }
    }

    /**
     * Returns a hash code for this texture.
     * @return {number}
     */
    public hashCode(): number {
        return (this.name != null ? /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name)) : 0) + (this.image != null ? /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.image)) : 0) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.width) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.height) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.xOffset) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.yOffset) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.angle) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.scale);
    }
}
HomeTexture["__class"] = "com.eteks.sweethome3d.model.HomeTexture";
HomeTexture["__interfaces"] = ["com.eteks.sweethome3d.model.TextureImage"];



/**
 * Creates a background image.
 * @param {Object} image
 * @param {number} scaleDistance
 * @param {number} scaleDistanceXStart
 * @param {number} scaleDistanceYStart
 * @param {number} scaleDistanceXEnd
 * @param {number} scaleDistanceYEnd
 * @param {number} xOrigin
 * @param {number} yOrigin
 * @param {boolean} visible
 * @class
 * @author Emmanuel Puybaret
 */
export class BackgroundImage {
    /*private*/ image: Content;

    /*private*/ scaleDistance: number;

    /*private*/ scaleDistanceXStart: number;

    /*private*/ scaleDistanceYStart: number;

    /*private*/ scaleDistanceXEnd: number;

    /*private*/ scaleDistanceYEnd: number;

    /*private*/ xOrigin: number;

    /*private*/ yOrigin: number;

    /*private*/ invisible: boolean;

    public constructor(image?: any, scaleDistance?: any, scaleDistanceXStart?: any, scaleDistanceYStart?: any, scaleDistanceXEnd?: any, scaleDistanceYEnd?: any, xOrigin?: any, yOrigin?: any, visible?: any) {
        if (((image != null && (image.constructor != null && image.constructor["__interfaces"] != null && image.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || image === null) && ((typeof scaleDistance === 'number') || scaleDistance === null) && ((typeof scaleDistanceXStart === 'number') || scaleDistanceXStart === null) && ((typeof scaleDistanceYStart === 'number') || scaleDistanceYStart === null) && ((typeof scaleDistanceXEnd === 'number') || scaleDistanceXEnd === null) && ((typeof scaleDistanceYEnd === 'number') || scaleDistanceYEnd === null) && ((typeof xOrigin === 'number') || xOrigin === null) && ((typeof yOrigin === 'number') || yOrigin === null) && ((typeof visible === 'boolean') || visible === null)) {
            let __args = arguments;
            if (this.image === undefined) { this.image = null; }
            if (this.scaleDistance === undefined) { this.scaleDistance = 0; }
            if (this.scaleDistanceXStart === undefined) { this.scaleDistanceXStart = 0; }
            if (this.scaleDistanceYStart === undefined) { this.scaleDistanceYStart = 0; }
            if (this.scaleDistanceXEnd === undefined) { this.scaleDistanceXEnd = 0; }
            if (this.scaleDistanceYEnd === undefined) { this.scaleDistanceYEnd = 0; }
            if (this.xOrigin === undefined) { this.xOrigin = 0; }
            if (this.yOrigin === undefined) { this.yOrigin = 0; }
            if (this.invisible === undefined) { this.invisible = false; }
            this.image = image;
            this.scaleDistance = scaleDistance;
            this.scaleDistanceXStart = scaleDistanceXStart;
            this.scaleDistanceYStart = scaleDistanceYStart;
            this.scaleDistanceXEnd = scaleDistanceXEnd;
            this.scaleDistanceYEnd = scaleDistanceYEnd;
            this.xOrigin = xOrigin;
            this.yOrigin = yOrigin;
            this.invisible = !visible;
        } else if (((image != null && (image.constructor != null && image.constructor["__interfaces"] != null && image.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || image === null) && ((typeof scaleDistance === 'number') || scaleDistance === null) && ((typeof scaleDistanceXStart === 'number') || scaleDistanceXStart === null) && ((typeof scaleDistanceYStart === 'number') || scaleDistanceYStart === null) && ((typeof scaleDistanceXEnd === 'number') || scaleDistanceXEnd === null) && ((typeof scaleDistanceYEnd === 'number') || scaleDistanceYEnd === null) && ((typeof xOrigin === 'number') || xOrigin === null) && ((typeof yOrigin === 'number') || yOrigin === null) && visible === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let visible: any = true;
                if (this.image === undefined) { this.image = null; }
                if (this.scaleDistance === undefined) { this.scaleDistance = 0; }
                if (this.scaleDistanceXStart === undefined) { this.scaleDistanceXStart = 0; }
                if (this.scaleDistanceYStart === undefined) { this.scaleDistanceYStart = 0; }
                if (this.scaleDistanceXEnd === undefined) { this.scaleDistanceXEnd = 0; }
                if (this.scaleDistanceYEnd === undefined) { this.scaleDistanceYEnd = 0; }
                if (this.xOrigin === undefined) { this.xOrigin = 0; }
                if (this.yOrigin === undefined) { this.yOrigin = 0; }
                if (this.invisible === undefined) { this.invisible = false; }
                this.image = image;
                this.scaleDistance = scaleDistance;
                this.scaleDistanceXStart = scaleDistanceXStart;
                this.scaleDistanceYStart = scaleDistanceYStart;
                this.scaleDistanceXEnd = scaleDistanceXEnd;
                this.scaleDistanceYEnd = scaleDistanceYEnd;
                this.xOrigin = xOrigin;
                this.yOrigin = yOrigin;
                this.invisible = !visible;
            }
            if (this.image === undefined) { this.image = null; }
            if (this.scaleDistance === undefined) { this.scaleDistance = 0; }
            if (this.scaleDistanceXStart === undefined) { this.scaleDistanceXStart = 0; }
            if (this.scaleDistanceYStart === undefined) { this.scaleDistanceYStart = 0; }
            if (this.scaleDistanceXEnd === undefined) { this.scaleDistanceXEnd = 0; }
            if (this.scaleDistanceYEnd === undefined) { this.scaleDistanceYEnd = 0; }
            if (this.xOrigin === undefined) { this.xOrigin = 0; }
            if (this.yOrigin === undefined) { this.yOrigin = 0; }
            if (this.invisible === undefined) { this.invisible = false; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the image content of this background image.
     * @return {Object}
     */
    public getImage(): Content {
        return this.image;
    }

    /**
     * Returns the distance used to compute the scale of this image.
     * @return {number}
     */
    public getScaleDistance(): number {
        return this.scaleDistance;
    }

    /**
     * Returns the abscissa of the start point used to compute
     * the scale of this image.
     * @return {number}
     */
    public getScaleDistanceXStart(): number {
        return this.scaleDistanceXStart;
    }

    /**
     * Returns the ordinate of the start point used to compute
     * the scale of this image.
     * @return {number}
     */
    public getScaleDistanceYStart(): number {
        return this.scaleDistanceYStart;
    }

    /**
     * Returns the abscissa of the end point used to compute
     * the scale of this image.
     * @return {number}
     */
    public getScaleDistanceXEnd(): number {
        return this.scaleDistanceXEnd;
    }

    /**
     * Returns the ordinate of the end point used to compute
     * the scale of this image.
     * @return {number}
     */
    public getScaleDistanceYEnd(): number {
        return this.scaleDistanceYEnd;
    }

    /**
     * Returns the scale of this image.
     * @return {number}
     */
    public getScale(): number {
        return BackgroundImage.getScale(this.scaleDistance, this.scaleDistanceXStart, this.scaleDistanceYStart, this.scaleDistanceXEnd, this.scaleDistanceYEnd);
    }

    /**
     * Returns the scale equal to <code>scaleDistance</code> divided
     * by the distance between the points
     * (<code>scaleDistanceXStart</code>, <code>scaleDistanceYStart</code>)
     * and (<code>scaleDistanceXEnd</code>, <code>scaleDistanceYEnd</code>).
     * @param {number} scaleDistance
     * @param {number} scaleDistanceXStart
     * @param {number} scaleDistanceYStart
     * @param {number} scaleDistanceXEnd
     * @param {number} scaleDistanceYEnd
     * @return {number}
     */
    public static getScale(scaleDistance: number, scaleDistanceXStart: number, scaleDistanceYStart: number, scaleDistanceXEnd: number, scaleDistanceYEnd: number): number {
        return <number>(scaleDistance / java.awt.geom.Point2D.distance(scaleDistanceXStart, scaleDistanceYStart, scaleDistanceXEnd, scaleDistanceYEnd));
    }

    /**
     * Returns the origin abscissa of this image.
     * @return {number}
     */
    public getXOrigin(): number {
        return this.xOrigin;
    }

    /**
     * Returns the origin ordinate of this image.
     * @return {number}
     */
    public getYOrigin(): number {
        return this.yOrigin;
    }

    /**
     * Returns <code>true</code> if this image is visible in plan.
     * @return {boolean}
     */
    public isVisible(): boolean {
        return !this.invisible;
    }
}
BackgroundImage["__class"] = "com.eteks.sweethome3d.model.BackgroundImage";


/**
 * A library able to provide additional capabilities to Sweet Home 3D.
 * @author Emmanuel Puybaret
 * @class
 */
interface Library {
    /**
     * Returns the location where this library is stored.
     * @return {string}
     */
    getLocation(): string;

    /**
     * Returns the id of this library.
     * @return {string}
     */
    getId(): string;

    /**
     * Returns the type of this library.
     * @return {string}
     */
    getType(): string;

    /**
     * Returns the name of this library.
     * @return {string}
     */
    getName(): string;

    /**
     * Returns the description of this library.
     * @return {string}
     */
    getDescription(): string;

    /**
     * Returns the version of this library.
     * @return {string}
     */
    getVersion(): string;

    /**
     * Returns the license of this library.
     * @return {string}
     */
    getLicense(): string;

    /**
     * Returns the provider of this library.
     * @return {string}
     */
    getProvider(): string;
}

/**
 * Creates an event with an associated list of selected items.
 * @param {Object} source
 * @param {? extends java.lang.Object[]} oldSelectedItems
 * @param {? extends java.lang.Object[]} selectedItems
 * @class
 * @extends EventObject
 * @author Emmanuel Puybaret
 */
export class SelectionEvent extends EventObject {
    /*private*/ oldSelectedItems: Array<any>;

    /*private*/ selectedItems: Array<any>;

    public constructor(source?: any, oldSelectedItems?: any, selectedItems?: any) {
        if (((source != null) || source === null) && ((oldSelectedItems != null && (oldSelectedItems instanceof Array)) || oldSelectedItems === null) && ((selectedItems != null && (selectedItems instanceof Array)) || selectedItems === null)) {
            let __args = arguments;
            super(source);
            if (this.oldSelectedItems === undefined) { this.oldSelectedItems = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            this.oldSelectedItems = oldSelectedItems;
            this.selectedItems = selectedItems;
        } else if (((source != null) || source === null) && ((oldSelectedItems != null && (oldSelectedItems instanceof Array)) || oldSelectedItems === null) && selectedItems === undefined) {
            let __args = arguments;
            let selectedItems: any = __args[1];
            {
                let __args = arguments;
                let oldSelectedItems: any = null;
                super(source);
                if (this.oldSelectedItems === undefined) { this.oldSelectedItems = null; }
                if (this.selectedItems === undefined) { this.selectedItems = null; }
                this.oldSelectedItems = oldSelectedItems;
                this.selectedItems = selectedItems;
            }
            if (this.oldSelectedItems === undefined) { this.oldSelectedItems = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the previously selected items or <code>null</code> if not known.
     * @return {? extends java.lang.Object[]}
     */
    public getOldSelectedItems(): Array<any> {
        return this.oldSelectedItems;
    }

    /**
     * Returns the selected items.
     * @return {? extends java.lang.Object[]}
     */
    public getSelectedItems(): Array<any> {
        return this.selectedItems;
    }
}
SelectionEvent["__class"] = "com.eteks.sweethome3d.model.SelectionEvent";
SelectionEvent['__transients'] = ['source'];

/**
 * Creates a collection change support.
 * @param {Object} source  the collection to which data will be added.
 * @class
 * @author Emmanuel Puybaret
 */
export class CollectionChangeSupport<T> {
    /*private*/ source: any;

    /*private*/ collectionListeners: Array<CollectionListener<T>>;

    public constructor(source: any) {
        if (this.source === undefined) { this.source = null; }
        if (this.collectionListeners === undefined) { this.collectionListeners = null; }
        this.source = source;
        this.collectionListeners = <any>([]);
    }

    /**
     * Adds the <code>listener</code> in parameter to the list of listeners that may be notified.
     * @param {Object} listener  the listener to add
     */
    public addCollectionListener(listener: CollectionListener<T>) {
        /* add */(this.collectionListeners.push(listener) > 0);
    }

    /**
     * Removes the <code>listener</code> in parameter to the list of listeners that may be notified.
     * @param {Object} listener  the listener to remove. If it doesn't exist, it's simply ignored.
     */
    public removeCollectionListener(listener: CollectionListener<T>) {
        /* remove */(a => { let index = a.indexOf(listener); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.collectionListeners);
    }

    public fireCollectionChanged$java_lang_Object$com_eteks_sweethome3d_model_CollectionEvent_Type(item: T, eventType: CollectionEvent.Type) {
        this.fireCollectionChanged(item, -1, eventType);
    }

    public fireCollectionChanged$java_lang_Object$int$com_eteks_sweethome3d_model_CollectionEvent_Type(item: T, index: number, eventType: CollectionEvent.Type) {
        if (!/* isEmpty */(this.collectionListeners.length == 0)) {
            const event: CollectionEvent<T> = <any>(new CollectionEvent<T>(this.source, item, index, eventType));
            const listeners: CollectionListener<T>[] = /* toArray */this.collectionListeners.slice(0);
            for (let index1 = 0; index1 < listeners.length; index1++) {
                let listener = listeners[index1];
                {
                    listener(event);
                }
            }
        }
    }

    /**
     * Fires a collection event about <code>item</code> at a given <code>index</code>.
     * @param {Object} item     the added ore deleted item
     * @param {number} index    the optional index at which the item was added or deleted
     * @param {CollectionEvent.Type} eventType <code>CollectionEvent.Type.ADD</code> or <code>CollectionEvent.Type.DELETE</code>
     */
    public fireCollectionChanged(item?: any, index?: any, eventType?: any) {
        if (((item != null) || item === null) && ((typeof index === 'number') || index === null) && ((typeof eventType === 'number') || eventType === null)) {
            return <any>this.fireCollectionChanged$java_lang_Object$int$com_eteks_sweethome3d_model_CollectionEvent_Type(item, index, eventType);
        } else if (((item != null) || item === null) && ((typeof index === 'number') || index === null) && eventType === undefined) {
            return <any>this.fireCollectionChanged$java_lang_Object$com_eteks_sweethome3d_model_CollectionEvent_Type(item, index);
        } else throw new Error('invalid overload');
    }
}
CollectionChangeSupport["__class"] = "com.eteks.sweethome3d.model.CollectionChangeSupport";


/**
 * Creates a <code>RecorderException</code> with its message
 * and the internal cause that initiated this exception.
 * @param {string} message
 * @param {Error} cause
 * @class
 * @extends Error
 * @author Emmanuel Puybaret
 * @ignore
 */
export class RecorderException extends Error {
    public constructor(message?: any, cause?: any) {
        if (((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
            let __args = arguments;
            super(message); this.message = message;
        } else if (((typeof message === 'string') || message === null) && cause === undefined) {
            let __args = arguments;
            super(message); this.message = message;
        } else if (message === undefined && cause === undefined) {
            let __args = arguments;
            super();
        } else throw new Error('invalid overload');
    }
}
RecorderException["__class"] = "com.eteks.sweethome3d.model.RecorderException";


/**
 * Creates a home descriptor.
 * @param {string} name name of the home
 * @param {Object} content content that allows to read home data
 * @param {Object} icon icon of the home
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeDescriptor {
    /*private*/ name: string;

    /*private*/ content: Content;

    /*private*/ icon: Content;

    public constructor(name: string, content: Content, icon: Content) {
        if (this.name === undefined) { this.name = null; }
        if (this.content === undefined) { this.content = null; }
        if (this.icon === undefined) { this.icon = null; }
        this.name = name;
        this.content = content;
        this.icon = icon;
    }

    /**
     * Returns the name of this home.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the content to read this home.
     * @return {Object}
     */
    public getContent(): Content {
        return this.content;
    }

    /**
     * Returns the icon of this home.
     * @return {Object}
     */
    public getIcon(): Content {
        return this.icon;
    }
}
HomeDescriptor["__class"] = "com.eteks.sweethome3d.model.HomeDescriptor";


/**
 * An object that is selectable in home.
 * @author Emmanuel Puybaret
 * @class
 */
interface Selectable {
    /**
     * Returns the points of the shape surrounding this object.
     * @return {float[][]} an array of the (x,y) coordinates of the rectangle.
     */
    getPoints(): number[][];

    /**
     * Returns <code>true</code> if this object intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean;

    /**
     * Returns <code>true</code> if this object contains the point at
     * (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    containsPoint(x: number, y: number, margin: number): boolean;

    /**
     * Moves this object of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    move(dx: number, dy: number);

    /**
     * Returns a clone of this object.
     * @return {Object}
     */
    clone(): Selectable;
}

/**
 * Creates a baseboard.
 * @param {number} thickness
 * @param {number} height
 * @param {number} color
 * @param {HomeTexture} texture
 * @class
 * @author Emmanuel Puybaret
 */
export class Baseboard {
    /*private*/ thickness: number;

    /*private*/ height: number;

    /*private*/ color: number;

    /*private*/ texture: HomeTexture;

    static baseboardsCache: Array<Baseboard>; public static baseboardsCache_$LI$(): Array<Baseboard> { if (Baseboard.baseboardsCache == null) { Baseboard.baseboardsCache = []; } return Baseboard.baseboardsCache; }

    public constructor(thickness?: any, height?: any, color?: any, texture?: any, cached?: any) {
        if (((typeof thickness === 'number') || thickness === null) && ((typeof height === 'number') || height === null) && ((typeof color === 'number') || color === null) && ((texture != null && texture instanceof <any>HomeTexture) || texture === null) && ((typeof cached === 'boolean') || cached === null)) {
            let __args = arguments;
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            this.height = height;
            this.thickness = thickness;
            this.color = color;
            this.texture = texture;
            if (cached) {
                /* add */(Baseboard.baseboardsCache_$LI$().push(this) > 0);
            }
        } else if (((typeof thickness === 'number') || thickness === null) && ((typeof height === 'number') || height === null) && ((typeof color === 'number') || color === null) && ((texture != null && texture instanceof <any>HomeTexture) || texture === null) && cached === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let thickness: any = __args[1];
                let height: any = __args[0];
                let cached: any = true;
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.color === undefined) { this.color = null; }
                if (this.texture === undefined) { this.texture = null; }
                this.height = height;
                this.thickness = thickness;
                this.color = color;
                this.texture = texture;
                if (cached) {
                    /* add */(Baseboard.baseboardsCache_$LI$().push(this) > 0);
                }
            }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns an instance of this class matching the given parameters.
     * @param {number} thickness
     * @param {number} height
     * @param {number} color
     * @param {HomeTexture} texture
     * @return {Baseboard}
     */
    public static getInstance(thickness: number, height: number, color: number, texture: HomeTexture): Baseboard {
        const baseboard: Baseboard = new Baseboard(thickness, height, color, texture, false);
        for (let i: number = /* size */(<number>Baseboard.baseboardsCache_$LI$().length) - 1; i >= 0; i--) {
            {
                const cachedBaseboard: Baseboard = /* get *//* get */Baseboard.baseboardsCache_$LI$()[i];
                if (cachedBaseboard == null) {
                /* remove */Baseboard.baseboardsCache_$LI$().splice(i, 1)[0];
                } else if (cachedBaseboard.equals(baseboard)) {
                    return baseboard;
                }
            };
        }
        /* add */(Baseboard.baseboardsCache_$LI$().push(baseboard) > 0);
        return baseboard;
    }

    /**
     * Returns the thickness of this baseboard.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Returns the height of this baseboard.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Returns the color of this baseboard.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Returns the texture of this baseboard.
     * @return {HomeTexture}
     */
    public getTexture(): HomeTexture {
        return this.texture;
    }

    /**
     * Returns <code>true</code> if this baseboard is equal to <code>object</code>.
     * @param {Object} object
     * @return {boolean}
     */
    public equals(object: any): boolean {
        if (object != null && object instanceof <any>Baseboard) {
            const baseboard: Baseboard = <Baseboard>object;
            return baseboard.thickness === this.thickness && baseboard.height === this.height && (baseboard.color === this.color || baseboard.color != null && (baseboard.color === this.color)) && (baseboard.texture === this.texture || baseboard.texture != null && baseboard.texture.equals(this.texture));
        }
        return false;
    }

    /**
     * Returns a hash code for this baseboard.
     * @return {number}
     */
    public hashCode(): number {
        let hashCode: number = /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.thickness) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.height);
        if (this.color != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.color));
        }
        if (this.texture != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.texture));
        }
        return hashCode;
    }
}
Baseboard["__class"] = "com.eteks.sweethome3d.model.Baseboard";


/**
 * Furniture catalog.
 * @author Emmanuel Puybaret
 * @class
 */
export class FurnitureCatalog {
    /*private*/ categories: Array<FurnitureCategory>;

    /*private*/ furnitureChangeSupport: CollectionChangeSupport<CatalogPieceOfFurniture>;

    /**
     * Returns the categories list sorted by name.
     * @return {FurnitureCategory[]} a list of categories.
     */
    public getCategories(): Array<FurnitureCategory> {
        return /* unmodifiableList */this.categories.slice(0);
    }

    /**
     * Returns the count of categories in this catalog.
     * @return {number}
     */
    public getCategoriesCount(): number {
        return /* size */(<number>this.categories.length);
    }

    /**
     * Returns the category at a given <code>index</code>.
     * @param {number} index
     * @return {FurnitureCategory}
     */
    public getCategory(index: number): FurnitureCategory {
        return /* get */this.categories[index];
    }

    /**
     * Adds the furniture <code>listener</code> in parameter to this catalog.
     * @param {Object} listener
     */
    public addFurnitureListener(listener: CollectionListener<CatalogPieceOfFurniture>) {
        this.furnitureChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the furniture <code>listener</code> in parameter from this catalog.
     * @param {Object} listener
     */
    public removeFurnitureListener(listener: CollectionListener<CatalogPieceOfFurniture>) {
        this.furnitureChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Adds <code>piece</code> of a given <code>category</code> to this catalog.
     * Once the <code>piece</code> is added, furniture listeners added to this catalog will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification.
     * @param {FurnitureCategory} category the category of the piece.
     * @param {CatalogPieceOfFurniture} piece    a piece of furniture.
     */
    public add(category: FurnitureCategory, piece: CatalogPieceOfFurniture) {
        const index: number = /* binarySearch */((l, key) => { let comp = (a, b) => { if (a.compareTo) return (<number>a.compareTo(b)); else return a.localeCompare(b); }; let low = 0; let high = l.length - 1; while (low <= high) { let mid = (low + high) >>> 1; let midVal = l[mid]; let cmp = comp(midVal, key); if (cmp < 0) low = mid + 1; else if (cmp > 0) high = mid - 1; else return mid; } return -(low + 1); })(this.categories, category);
        if (index < 0) {
            category = new FurnitureCategory(category.getName());
            /* add */this.categories.splice(-index - 1, 0, category);
        } else {
            category = /* get */this.categories[index];
        }
        category.add(piece);
        this.furnitureChangeSupport.fireCollectionChanged(piece, category.getIndexOfPieceOfFurniture(piece), CollectionEvent.Type.ADD);
    }

    /**
     * Deletes the <code>piece</code> from this catalog.
     * If then piece category is empty, it will be removed from the categories of this catalog.
     * Once the <code>piece</code> is deleted, furniture listeners added to this catalog will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification.
     * @param {CatalogPieceOfFurniture} piece a piece of furniture in that category.
     */
    public delete(piece: CatalogPieceOfFurniture) {
        const category: FurnitureCategory = piece.getCategory();
        if (category != null) {
            const pieceIndex: number = category.getIndexOfPieceOfFurniture(piece);
            if (pieceIndex >= 0) {
                category.delete(piece);
                if (category.getFurnitureCount() === 0) {
                    this.categories = <any>(this.categories.slice(0));
                    /* remove */(a => { let index = a.indexOf(category); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.categories);
                }
                this.furnitureChangeSupport.fireCollectionChanged(piece, pieceIndex, CollectionEvent.Type.DELETE);
                return;
            }
        }
        throw new IllegalArgumentException("catalog doesn\'t contain piece " + piece.getName());
    }

    /**
     * Returns the piece of furniture with the given <code>id</code> if it exists.
     * @param {string} id
     * @return {CatalogPieceOfFurniture}
     */
    public getPieceOfFurnitureWithId(id: string): CatalogPieceOfFurniture {
        for (let index = 0; index < this.categories.length; index++) {
            let category = this.categories[index];
            {
                {
                    let array = category.getFurniture();
                    for (let index1 = 0; index1 < array.length; index1++) {
                        let piece = array[index1];
                        {
                            if (id === piece.getId()) {
                                return piece;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    constructor() {
        this.categories = <any>([]);
        this.furnitureChangeSupport = <any>(new CollectionChangeSupport<CatalogPieceOfFurniture>(this));
    }
}
FurnitureCatalog["__class"] = "com.eteks.sweethome3d.model.FurnitureCatalog";


/**
 * An object that belongs to a level.
 * @author Emmanuel Puybaret
 * @class
 */
interface Elevatable {
    /**
     * Returns the level of this object.
     * @return {Level}
     */
    getLevel(): Level;

    /**
     * Returns <code>true</code> if this object can be viewed at the given level.
     * @param {Level} level
     * @return {boolean}
     */
    isAtLevel(level: Level): boolean;
}

/**
 * Information about additional property.
 * @author Emmanuel Puybaret
 * @param {string} name
 * @param {string} displayedName
 * @param {ObjectProperty.Type} type
 * @param {boolean} displayable
 * @param {boolean} modifiable
 * @param {boolean} exportable
 * @class
 */
export class ObjectProperty {
    /*private*/ name: string;

    /*private*/ displayedName: string;

    /*private*/ type: ObjectProperty.Type;

    /*private*/ typeName: string;

    /*private*/ displayable: boolean;

    /*private*/ modifiable: boolean;

    /*private*/ exportable: boolean;

    public constructor(name?: any, displayedName?: any, type?: any, displayable?: any, modifiable?: any, exportable?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof displayedName === 'string') || displayedName === null) && ((typeof type === 'number') || type === null) && ((typeof displayable === 'boolean') || displayable === null) && ((typeof modifiable === 'boolean') || modifiable === null) && ((typeof exportable === 'boolean') || exportable === null)) {
            let __args = arguments;
            if (this.name === undefined) { this.name = null; }
            if (this.displayedName === undefined) { this.displayedName = null; }
            if (this.type === undefined) { this.type = null; }
            if (this.typeName === undefined) { this.typeName = null; }
            if (this.displayable === undefined) { this.displayable = false; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.exportable === undefined) { this.exportable = false; }
            this.name = name;
            this.displayedName = displayedName;
            this.type = type;
            this.typeName = type != null ? /* Enum.name */ObjectProperty.Type[type] : null;
            this.displayable = displayable;
            this.modifiable = modifiable;
            this.exportable = exportable;
        } else if (((typeof name === 'string') || name === null) && ((typeof displayedName === 'number') || displayedName === null) && ((typeof type === 'boolean') || type === null) && ((typeof displayable === 'boolean') || displayable === null) && ((typeof modifiable === 'boolean') || modifiable === null) && exportable === undefined) {
            let __args = arguments;
            let type: any = __args[1];
            let displayable: any = __args[2];
            let modifiable: any = __args[3];
            let exportable: any = __args[4];
            {
                let __args = arguments;
                let displayedName: any = null;
                let displayable: any = true;
                let modifiable: any = true;
                let exportable: any = true;
                if (this.name === undefined) { this.name = null; }
                if (this.displayedName === undefined) { this.displayedName = null; }
                if (this.type === undefined) { this.type = null; }
                if (this.typeName === undefined) { this.typeName = null; }
                if (this.displayable === undefined) { this.displayable = false; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.exportable === undefined) { this.exportable = false; }
                this.name = name;
                this.displayedName = displayedName;
                this.type = type;
                this.typeName = type != null ? /* Enum.name */ObjectProperty.Type[type] : null;
                this.displayable = displayable;
                this.modifiable = modifiable;
                this.exportable = exportable;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.displayedName === undefined) { this.displayedName = null; }
            if (this.type === undefined) { this.type = null; }
            if (this.typeName === undefined) { this.typeName = null; }
            if (this.displayable === undefined) { this.displayable = false; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.exportable === undefined) { this.exportable = false; }
        } else if (((typeof name === 'string') || name === null) && ((typeof displayedName === 'number') || displayedName === null) && type === undefined && displayable === undefined && modifiable === undefined && exportable === undefined) {
            let __args = arguments;
            let type: any = __args[1];
            {
                let __args = arguments;
                let displayedName: any = null;
                let displayable: any = true;
                let modifiable: any = true;
                let exportable: any = true;
                if (this.name === undefined) { this.name = null; }
                if (this.displayedName === undefined) { this.displayedName = null; }
                if (this.type === undefined) { this.type = null; }
                if (this.typeName === undefined) { this.typeName = null; }
                if (this.displayable === undefined) { this.displayable = false; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.exportable === undefined) { this.exportable = false; }
                this.name = name;
                this.displayedName = displayedName;
                this.type = type;
                this.typeName = type != null ? /* Enum.name */ObjectProperty.Type[type] : null;
                this.displayable = displayable;
                this.modifiable = modifiable;
                this.exportable = exportable;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.displayedName === undefined) { this.displayedName = null; }
            if (this.type === undefined) { this.type = null; }
            if (this.typeName === undefined) { this.typeName = null; }
            if (this.displayable === undefined) { this.displayable = false; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.exportable === undefined) { this.exportable = false; }
        } else if (((typeof name === 'string') || name === null) && displayedName === undefined && type === undefined && displayable === undefined && modifiable === undefined && exportable === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let type: any = null;
                {
                    let __args = arguments;
                    let displayedName: any = null;
                    let displayable: any = true;
                    let modifiable: any = true;
                    let exportable: any = true;
                    if (this.name === undefined) { this.name = null; }
                    if (this.displayedName === undefined) { this.displayedName = null; }
                    if (this.type === undefined) { this.type = null; }
                    if (this.typeName === undefined) { this.typeName = null; }
                    if (this.displayable === undefined) { this.displayable = false; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.exportable === undefined) { this.exportable = false; }
                    this.name = name;
                    this.displayedName = displayedName;
                    this.type = type;
                    this.typeName = type != null ? /* Enum.name */ObjectProperty.Type[type] : null;
                    this.displayable = displayable;
                    this.modifiable = modifiable;
                    this.exportable = exportable;
                }
                if (this.name === undefined) { this.name = null; }
                if (this.displayedName === undefined) { this.displayedName = null; }
                if (this.type === undefined) { this.type = null; }
                if (this.typeName === undefined) { this.typeName = null; }
                if (this.displayable === undefined) { this.displayable = false; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.exportable === undefined) { this.exportable = false; }
            }
            if (this.name === undefined) { this.name = null; }
            if (this.displayedName === undefined) { this.displayedName = null; }
            if (this.type === undefined) { this.type = null; }
            if (this.typeName === undefined) { this.typeName = null; }
            if (this.displayable === undefined) { this.displayable = false; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.exportable === undefined) { this.exportable = false; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns an <code>ObjectProperty</code> instance built from the given <code>description</code>.
     * @param {string} description a string containing property name possibly followed by a
     * colon, the property type and displayable modifiable exportable displayedName attributes
     * name:(ANY|STRING|DATE|BOOLEAN|INTEGER|NUMBER|PRICE|LENGTH|PERCENTAGE|CONTENT) displayable=(true|false) modifiable=(true|false) exportable=(true|false) displayedName=text
     * @return {ObjectProperty}
     */
    public static fromDescription(description: string): ObjectProperty {
        if (description.length === 0) {
            throw new IllegalArgumentException("Description empty");
        }
        const colonIndex: number = description.indexOf(':');
        const propertyName: string = description.substring(0, colonIndex > 0 ? colonIndex : description.length).trim();
        let type: ObjectProperty.Type = null;
        let displayable: boolean = true;
        let modifiable: boolean = true;
        let exportable: boolean = true;
        let displayedName: string = null;
        if (colonIndex > 0) {
            const attributes: string[] = description.substring(colonIndex + 1).trim().split(/ /);
            if (attributes.length > 0) {
                type = /* Enum.valueOf */ <any>ObjectProperty.Type[attributes[0]];
                for (let i: number = 1; i < attributes.length; i++) {
                    {
                        if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(attributes[i], "displayable=")) {
                            displayable = /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))("true", attributes[i].substring("displayable=".length + 1));
                        } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(attributes[i], "modifiable=")) {
                            modifiable = /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))("true", attributes[i].substring("modifiable=".length + 1));
                        } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(attributes[i], "exportable=")) {
                            exportable = /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))("true", attributes[i].substring("exportable=".length + 1));
                        } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(attributes[i], "displayedName=")) {
                            displayedName = description.substring(description.indexOf("displayedName=") + "displayedName=".length);
                        }
                    };
                }
            }
        }
        return new ObjectProperty(propertyName, displayedName, type, displayable, modifiable, exportable);
    }

    /**
     * Returns the name of this property.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the type of this property.
     * @return {ObjectProperty.Type}
     */
    public getType(): ObjectProperty.Type {
        return this.type;
    }

    /**
     * Returns whether the value of this property is displayable.
     * @return {boolean}
     */
    public isDisplayable(): boolean {
        return this.displayable;
    }

    /**
     * Returns whether the value of this property is modifiable.
     * @return {boolean}
     */
    public isModifiable(): boolean {
        return this.modifiable;
    }

    /**
     * Returns whether the value of this property is exportable.
     * @return {boolean}
     */
    public isExportable(): boolean {
        return this.exportable;
    }

    /**
     * Returns a text used for label and header.
     * @return {string}
     */
    public getDisplayedName(): string {
        if (this.displayedName != null) {
            return this.displayedName;
        } else {
            const displayedName: string = /* replace */this.name.split('_').join(' ').toLowerCase();
            return /* toUpperCase */displayedName.charAt(0).toUpperCase() + (displayedName.length > 1 ? displayedName.substring(1) : "");
        }
    }

    /**
     * 
     * @return {number}
     */
    public hashCode(): number {
        return this.name == null ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name));
    }

    /**
     * 
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        if (this === obj) {
            return true;
        } else if (obj != null && obj instanceof <any>ObjectProperty) {
            return this.name === (<ObjectProperty>obj).name;
        }
        return false;
    }
}
ObjectProperty["__class"] = "com.eteks.sweethome3d.model.ObjectProperty";


export namespace ObjectProperty {

    /**
     * Property type.
     * @enum
     * @property {ObjectProperty.Type} ANY
     * @property {ObjectProperty.Type} STRING
     * @property {ObjectProperty.Type} BOOLEAN
     * @property {ObjectProperty.Type} INTEGER
     * @property {ObjectProperty.Type} NUMBER
     * @property {ObjectProperty.Type} PRICE
     * @property {ObjectProperty.Type} LENGTH
     * @property {ObjectProperty.Type} PERCENTAGE
     * @property {ObjectProperty.Type} DATE
     * @property {ObjectProperty.Type} CONTENT
     * @class
     */
    export enum Type {
        ANY, STRING, BOOLEAN, INTEGER, NUMBER, PRICE, LENGTH, PERCENTAGE, DATE, CONTENT
    }
}
ObjectProperty['__transients'] = ['type'];

/**
 * A piece of furniture.
 * @author Emmanuel Puybaret
 * @class
 */
interface PieceOfFurniture {
    /**
     * Returns the name of this piece of furniture.
     * @return {string}
     */
    getName(): string;

    /**
     * Returns the description of this piece of furniture.
     * @return {string}
     */
    getDescription(): string;

    /**
     * Returns the additional information associated to this piece, or <code>null</code>.
     * @return {string}
     */
    getInformation(): string;

    /**
     * Returns the license of this piece of furniture.
     * @return {string}
     */
    getLicense(): string;

    /**
     * Returns the depth of this piece of furniture.
     * @return {number}
     */
    getDepth(): number;

    /**
     * Returns the height of this piece of furniture.
     * @return {number}
     */
    getHeight(): number;

    /**
     * Returns the width of this piece of furniture.
     * @return {number}
     */
    getWidth(): number;

    /**
     * Returns the elevation of this piece of furniture.
     * @return {number}
     */
    getElevation(): number;

    /**
     * Returns the elevation at which should be placed an object dropped on this piece.
     * @return {number} a percentage of the height of this piece. A negative value means that the piece
     * should be ignored when an object is dropped on it.
     */
    getDropOnTopElevation(): number;

    /**
     * Returns <code>true</code> if this piece of furniture is movable.
     * @return {boolean}
     */
    isMovable(): boolean;

    /**
     * Returns <code>true</code> if this piece of furniture is a door or a window.
     * As this method existed before {@linkplain DoorOrWindow DoorOrWindow} interface,
     * you shouldn't rely on the value returned by this method to guess if a piece
     * is an instance of <code>DoorOrWindow</code> class.
     * @return {boolean}
     */
    isDoorOrWindow(): boolean;

    /**
     * Returns the icon of this piece of furniture.
     * @return {Object}
     */
    getIcon(): Content;

    /**
     * Returns the icon of this piece of furniture displayed in plan or <code>null</code>.
     * @return {Object}
     */
    getPlanIcon(): Content;

    /**
     * Returns the 3D model of this piece of furniture.
     * @return {Object}
     */
    getModel(): Content;

    /**
     * Returns flags that should apply on the model of this piece of furniture.
     * @return {number}
     */
    getModelFlags(): number;

    /**
     * Returns the size of the 3D model of this piece of furniture or <code>null</code> if not known.
     * @return {number}
     */
    getModelSize(): number;

    /**
     * Returns the rotation 3 by 3 matrix of this piece of furniture that ensures
     * its model is correctly oriented.
     * @return {float[][]}
     */
    getModelRotation(): number[][];

    /**
     * Returns the shape used to cut out upper levels when they intersect with the piece
     * like a staircase.
     * @return {string}
     */
    getStaircaseCutOutShape(): string;

    /**
     * Returns the creator of this piece or <code>null</code>.
     * @return {string}
     */
    getCreator(): string;

    /**
     * Returns <code>true</code> if the back face of the piece of furniture
     * model should be displayed.
     * @return {boolean}
     */
    isBackFaceShown(): boolean;

    /**
     * Returns the color of this piece of furniture.
     * @return {number}
     */
    getColor(): number;

    /**
     * Returns <code>true</code> if this piece is resizable.
     * @return {boolean}
     */
    isResizable(): boolean;

    /**
     * Returns <code>true</code> if this piece is deformable. The width, depth and height
     * of a deformable piece may change independently from each other.
     * @return {boolean}
     */
    isDeformable(): boolean;

    /**
     * Returns <code>true</code> if the width and depth of this piece may
     * be changed independently from each other.
     * @return {boolean}
     */
    isWidthDepthDeformable(): boolean;

    /**
     * Returns <code>false</code> if this piece should always keep the same color or texture.
     * @return {boolean}
     */
    isTexturable(): boolean;

    /**
     * Returns <code>false</code> if this piece should not rotate around an horizontal axis.
     * @return {boolean}
     */
    isHorizontallyRotatable(): boolean;

    /**
     * Returns the price of this piece of furniture or <code>null</code>.
     * @return {Big}
     */
    getPrice(): Big;

    /**
     * Returns the Value Added Tax percentage applied to the price of this piece of furniture.
     * @return {Big}
     */
    getValueAddedTaxPercentage(): Big;

    /**
     * Returns the price currency, noted with ISO 4217 code, or <code>null</code>
     * if it has no price or default currency should be used.
     * @return {string}
     */
    getCurrency(): string;

    /**
     * Returns the value of an additional property <code>name</code> of this piece.
     * @return {string} the value of the property or <code>null</code> if it doesn't exist or if it's not a string.
     * @param {string} name
     */
    getProperty(name: string): string;

    /**
     * Returns the names of the additional properties of this piece.
     * @return {string[]} a collection of all the names of the properties
     */
    getPropertyNames(): Array<string>;

    /**
     * Returns the value of an additional content <code>name</code> associated to this piece.
     * @return {Object} the value of the content or <code>null</code> if it doesn't exist or if it's not a content.
     * @param {string} name
     */
    getContentProperty(name: string): Content;

    /**
     * Returns <code>true</code> if the type of given additional property is a content.
     * @param {string} name
     * @return {boolean}
     */
    isContentProperty(name: string): boolean;
}

export namespace PieceOfFurniture {

    /**
     * The default cut out shape that covers a 1 unit wide square.
     */
    export const DEFAULT_CUT_OUT_SHAPE: string = "M0,0 v1 h1 v-1 z";

    /**
     * Identity model rotation matrix.
     */
    export let IDENTITY_ROTATION: number[][]; export function IDENTITY_ROTATION_$LI$(): number[][] { if (PieceOfFurniture.IDENTITY_ROTATION == null) { PieceOfFurniture.IDENTITY_ROTATION = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; } return PieceOfFurniture.IDENTITY_ROTATION; };

    /**
     * The flag used to specify that the back faces of a 3D model should be shown.
     */
    export const SHOW_BACK_FACE: number = 1;

    /**
     * The flag used to specify that the shapes of a 3D model which uses a material prefixed by "edge_color" should be hidden.
     */
    export const HIDE_EDGE_COLOR_MATERIAL: number = 2;
}


/**
 * Create a print attributes for home from the given parameters.
 * @param {HomePrint.PaperOrientation} paperOrientation
 * @param {number} paperWidth
 * @param {number} paperHeight
 * @param {number} paperTopMargin
 * @param {number} paperLeftMargin
 * @param {number} paperBottomMargin
 * @param {number} paperRightMargin
 * @param {boolean} furniturePrinted
 * @param {boolean} planPrinted
 * @param {Level[]} printedLevels
 * @param {boolean} view3DPrinted
 * @param {number} planScale
 * @param {string} headerFormat
 * @param {string} footerFormat
 * @class
 * @author Emmanuel Puybaret
 */
export class HomePrint {
    /*private*/ paperOrientation: HomePrint.PaperOrientation;

    /*private*/ paperWidth: number;

    /*private*/ paperHeight: number;

    /*private*/ paperTopMargin: number;

    /*private*/ paperLeftMargin: number;

    /*private*/ paperBottomMargin: number;

    /*private*/ paperRightMargin: number;

    /*private*/ furniturePrinted: boolean;

    /*private*/ planPrinted: boolean;

    /*private*/ printedLevels: Array<Level>;

    /*private*/ view3DPrinted: boolean;

    /*private*/ planScale: number;

    /*private*/ headerFormat: string;

    /*private*/ footerFormat: string;

    public constructor(paperOrientation?: any, paperWidth?: any, paperHeight?: any, paperTopMargin?: any, paperLeftMargin?: any, paperBottomMargin?: any, paperRightMargin?: any, furniturePrinted?: any, planPrinted?: any, printedLevels?: any, view3DPrinted?: any, planScale?: any, headerFormat?: any, footerFormat?: any) {
        if (((typeof paperOrientation === 'number') || paperOrientation === null) && ((typeof paperWidth === 'number') || paperWidth === null) && ((typeof paperHeight === 'number') || paperHeight === null) && ((typeof paperTopMargin === 'number') || paperTopMargin === null) && ((typeof paperLeftMargin === 'number') || paperLeftMargin === null) && ((typeof paperBottomMargin === 'number') || paperBottomMargin === null) && ((typeof paperRightMargin === 'number') || paperRightMargin === null) && ((typeof furniturePrinted === 'boolean') || furniturePrinted === null) && ((typeof planPrinted === 'boolean') || planPrinted === null) && ((printedLevels != null && (printedLevels instanceof Array)) || printedLevels === null) && ((typeof view3DPrinted === 'boolean') || view3DPrinted === null) && ((typeof planScale === 'number') || planScale === null) && ((typeof headerFormat === 'string') || headerFormat === null) && ((typeof footerFormat === 'string') || footerFormat === null)) {
            let __args = arguments;
            if (this.paperOrientation === undefined) { this.paperOrientation = null; }
            if (this.paperWidth === undefined) { this.paperWidth = 0; }
            if (this.paperHeight === undefined) { this.paperHeight = 0; }
            if (this.paperTopMargin === undefined) { this.paperTopMargin = 0; }
            if (this.paperLeftMargin === undefined) { this.paperLeftMargin = 0; }
            if (this.paperBottomMargin === undefined) { this.paperBottomMargin = 0; }
            if (this.paperRightMargin === undefined) { this.paperRightMargin = 0; }
            if (this.furniturePrinted === undefined) { this.furniturePrinted = false; }
            if (this.planPrinted === undefined) { this.planPrinted = false; }
            if (this.printedLevels === undefined) { this.printedLevels = null; }
            if (this.view3DPrinted === undefined) { this.view3DPrinted = false; }
            if (this.planScale === undefined) { this.planScale = null; }
            if (this.headerFormat === undefined) { this.headerFormat = null; }
            if (this.footerFormat === undefined) { this.footerFormat = null; }
            this.paperOrientation = paperOrientation;
            this.paperWidth = paperWidth;
            this.paperHeight = paperHeight;
            this.paperTopMargin = paperTopMargin;
            this.paperLeftMargin = paperLeftMargin;
            this.paperBottomMargin = paperBottomMargin;
            this.paperRightMargin = paperRightMargin;
            this.furniturePrinted = furniturePrinted;
            this.planPrinted = planPrinted;
            this.printedLevels = printedLevels != null ? /* unmodifiableList */printedLevels.slice(0) : null;
            this.view3DPrinted = view3DPrinted;
            this.planScale = planScale;
            this.headerFormat = headerFormat;
            this.footerFormat = footerFormat;
        } else if (((typeof paperOrientation === 'number') || paperOrientation === null) && ((typeof paperWidth === 'number') || paperWidth === null) && ((typeof paperHeight === 'number') || paperHeight === null) && ((typeof paperTopMargin === 'number') || paperTopMargin === null) && ((typeof paperLeftMargin === 'number') || paperLeftMargin === null) && ((typeof paperBottomMargin === 'number') || paperBottomMargin === null) && ((typeof paperRightMargin === 'number') || paperRightMargin === null) && ((typeof furniturePrinted === 'boolean') || furniturePrinted === null) && ((typeof planPrinted === 'boolean') || planPrinted === null) && ((typeof printedLevels === 'boolean') || printedLevels === null) && ((typeof view3DPrinted === 'number') || view3DPrinted === null) && ((typeof planScale === 'string') || planScale === null) && ((typeof headerFormat === 'string') || headerFormat === null) && footerFormat === undefined) {
            let __args = arguments;
            let view3DPrinted: any = __args[9];
            let planScale: any = __args[10];
            let headerFormat: any = __args[11];
            let footerFormat: any = __args[12];
            {
                let __args = arguments;
                let printedLevels: any = null;
                if (this.paperOrientation === undefined) { this.paperOrientation = null; }
                if (this.paperWidth === undefined) { this.paperWidth = 0; }
                if (this.paperHeight === undefined) { this.paperHeight = 0; }
                if (this.paperTopMargin === undefined) { this.paperTopMargin = 0; }
                if (this.paperLeftMargin === undefined) { this.paperLeftMargin = 0; }
                if (this.paperBottomMargin === undefined) { this.paperBottomMargin = 0; }
                if (this.paperRightMargin === undefined) { this.paperRightMargin = 0; }
                if (this.furniturePrinted === undefined) { this.furniturePrinted = false; }
                if (this.planPrinted === undefined) { this.planPrinted = false; }
                if (this.printedLevels === undefined) { this.printedLevels = null; }
                if (this.view3DPrinted === undefined) { this.view3DPrinted = false; }
                if (this.planScale === undefined) { this.planScale = null; }
                if (this.headerFormat === undefined) { this.headerFormat = null; }
                if (this.footerFormat === undefined) { this.footerFormat = null; }
                this.paperOrientation = paperOrientation;
                this.paperWidth = paperWidth;
                this.paperHeight = paperHeight;
                this.paperTopMargin = paperTopMargin;
                this.paperLeftMargin = paperLeftMargin;
                this.paperBottomMargin = paperBottomMargin;
                this.paperRightMargin = paperRightMargin;
                this.furniturePrinted = furniturePrinted;
                this.planPrinted = planPrinted;
                this.printedLevels = printedLevels != null ? /* unmodifiableList */printedLevels.slice(0) : null;
                this.view3DPrinted = view3DPrinted;
                this.planScale = planScale;
                this.headerFormat = headerFormat;
                this.footerFormat = footerFormat;
            }
            if (this.paperOrientation === undefined) { this.paperOrientation = null; }
            if (this.paperWidth === undefined) { this.paperWidth = 0; }
            if (this.paperHeight === undefined) { this.paperHeight = 0; }
            if (this.paperTopMargin === undefined) { this.paperTopMargin = 0; }
            if (this.paperLeftMargin === undefined) { this.paperLeftMargin = 0; }
            if (this.paperBottomMargin === undefined) { this.paperBottomMargin = 0; }
            if (this.paperRightMargin === undefined) { this.paperRightMargin = 0; }
            if (this.furniturePrinted === undefined) { this.furniturePrinted = false; }
            if (this.planPrinted === undefined) { this.planPrinted = false; }
            if (this.printedLevels === undefined) { this.printedLevels = null; }
            if (this.view3DPrinted === undefined) { this.view3DPrinted = false; }
            if (this.planScale === undefined) { this.planScale = null; }
            if (this.headerFormat === undefined) { this.headerFormat = null; }
            if (this.footerFormat === undefined) { this.footerFormat = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the paper orientation.
     * @return {HomePrint.PaperOrientation}
     */
    public getPaperOrientation(): HomePrint.PaperOrientation {
        return this.paperOrientation;
    }

    /**
     * Returns the margin at paper bottom in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperBottomMargin(): number {
        return this.paperBottomMargin;
    }

    /**
     * Returns the paper height in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperHeight(): number {
        return this.paperHeight;
    }

    /**
     * Returns the margin at paper left in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperLeftMargin(): number {
        return this.paperLeftMargin;
    }

    /**
     * Returns the margin at paper right in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperRightMargin(): number {
        return this.paperRightMargin;
    }

    /**
     * Returns the margin at paper top in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperTopMargin(): number {
        return this.paperTopMargin;
    }

    /**
     * Returns the paper width in 1/72nds of an inch.
     * @return {number}
     */
    public getPaperWidth(): number {
        return this.paperWidth;
    }

    /**
     * Returns whether home furniture should be printed or not.
     * @return {boolean}
     */
    public isFurniturePrinted(): boolean {
        return this.furniturePrinted;
    }

    /**
     * Returns whether home plan should be printed or not.
     * @return {boolean}
     */
    public isPlanPrinted(): boolean {
        return this.planPrinted;
    }

    /**
     * Returns the printed levels or <code>null</code> if all levels should be printed.
     * @return {Level[]}
     */
    public getPrintedLevels(): Array<Level> {
        return this.printedLevels;
    }

    /**
     * Returns whether home 3D view should be printed or not.
     * @return {boolean}
     */
    public isView3DPrinted(): boolean {
        return this.view3DPrinted;
    }

    /**
     * Returns the scale used to print home plan or
     * <code>null</code> if no special scale is desired.
     * @return {number}
     */
    public getPlanScale(): number {
        return this.planScale;
    }

    /**
     * Returns the string format used to print page headers.
     * @return {string}
     */
    public getHeaderFormat(): string {
        return this.headerFormat;
    }

    /**
     * Returns the string format used to print page footers.
     * @return {string}
     */
    public getFooterFormat(): string {
        return this.footerFormat;
    }
}
HomePrint["__class"] = "com.eteks.sweethome3d.model.HomePrint";


export namespace HomePrint {

    /**
     * Paper orientation.
     * @enum
     * @property {HomePrint.PaperOrientation} PORTRAIT
     * @property {HomePrint.PaperOrientation} LANDSCAPE
     * @property {HomePrint.PaperOrientation} REVERSE_LANDSCAPE
     * @class
     */
    export enum PaperOrientation {
        PORTRAIT, LANDSCAPE, REVERSE_LANDSCAPE
    }
}


/**
 * Creates a text style from its font's name, its size, style and alignment.
 * @param {string} fontName
 * @param {number} fontSize
 * @param {boolean} bold
 * @param {boolean} italic
 * @param {TextStyle.Alignment} alignment
 * @class
 * @author Emmanuel Puybaret
 */
export class TextStyle {
    /*private*/ fontName: string;

    /*private*/ fontSize: number;

    /*private*/ bold: boolean;

    /*private*/ italic: boolean;

    /*private*/ alignment: TextStyle.Alignment;

    static textStylesCache: Array<TextStyle>; public static textStylesCache_$LI$(): Array<TextStyle> { if (TextStyle.textStylesCache == null) { TextStyle.textStylesCache = []; } return TextStyle.textStylesCache; }

    public constructor(fontName?: any, fontSize?: any, bold?: any, italic?: any, alignment?: any, cached?: any) {
        if (((typeof fontName === 'string') || fontName === null) && ((typeof fontSize === 'number') || fontSize === null) && ((typeof bold === 'boolean') || bold === null) && ((typeof italic === 'boolean') || italic === null) && ((typeof alignment === 'number') || alignment === null) && ((typeof cached === 'boolean') || cached === null)) {
            let __args = arguments;
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontSize === undefined) { this.fontSize = 0; }
            if (this.bold === undefined) { this.bold = false; }
            if (this.italic === undefined) { this.italic = false; }
            if (this.alignment === undefined) { this.alignment = null; }
            this.fontName = fontName;
            this.fontSize = fontSize;
            this.bold = bold;
            this.italic = italic;
            this.alignment = alignment;
            if (cached) {
                /* add */(TextStyle.textStylesCache_$LI$().push(this) > 0);
            }
        } else if (((typeof fontName === 'string') || fontName === null) && ((typeof fontSize === 'number') || fontSize === null) && ((typeof bold === 'boolean') || bold === null) && ((typeof italic === 'boolean') || italic === null) && ((typeof alignment === 'number') || alignment === null) && cached === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let cached: any = true;
                if (this.fontName === undefined) { this.fontName = null; }
                if (this.fontSize === undefined) { this.fontSize = 0; }
                if (this.bold === undefined) { this.bold = false; }
                if (this.italic === undefined) { this.italic = false; }
                if (this.alignment === undefined) { this.alignment = null; }
                this.fontName = fontName;
                this.fontSize = fontSize;
                this.bold = bold;
                this.italic = italic;
                this.alignment = alignment;
                if (cached) {
                    /* add */(TextStyle.textStylesCache_$LI$().push(this) > 0);
                }
            }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontSize === undefined) { this.fontSize = 0; }
            if (this.bold === undefined) { this.bold = false; }
            if (this.italic === undefined) { this.italic = false; }
            if (this.alignment === undefined) { this.alignment = null; }
        } else if (((typeof fontName === 'string') || fontName === null) && ((typeof fontSize === 'number') || fontSize === null) && ((typeof bold === 'boolean') || bold === null) && ((typeof italic === 'boolean') || italic === null) && alignment === undefined && cached === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let alignment: any = TextStyle.Alignment.CENTER;
                {
                    let __args = arguments;
                    let cached: any = true;
                    if (this.fontName === undefined) { this.fontName = null; }
                    if (this.fontSize === undefined) { this.fontSize = 0; }
                    if (this.bold === undefined) { this.bold = false; }
                    if (this.italic === undefined) { this.italic = false; }
                    if (this.alignment === undefined) { this.alignment = null; }
                    this.fontName = fontName;
                    this.fontSize = fontSize;
                    this.bold = bold;
                    this.italic = italic;
                    this.alignment = alignment;
                    if (cached) {
                        /* add */(TextStyle.textStylesCache_$LI$().push(this) > 0);
                    }
                }
                if (this.fontName === undefined) { this.fontName = null; }
                if (this.fontSize === undefined) { this.fontSize = 0; }
                if (this.bold === undefined) { this.bold = false; }
                if (this.italic === undefined) { this.italic = false; }
                if (this.alignment === undefined) { this.alignment = null; }
            }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontSize === undefined) { this.fontSize = 0; }
            if (this.bold === undefined) { this.bold = false; }
            if (this.italic === undefined) { this.italic = false; }
            if (this.alignment === undefined) { this.alignment = null; }
        } else if (((typeof fontName === 'number') || fontName === null) && ((typeof fontSize === 'boolean') || fontSize === null) && ((typeof bold === 'boolean') || bold === null) && italic === undefined && alignment === undefined && cached === undefined) {
            let __args = arguments;
            let fontSize: any = __args[0];
            let bold: any = __args[1];
            let italic: any = __args[2];
            {
                let __args = arguments;
                let fontName: any = null;
                {
                    let __args = arguments;
                    let alignment: any = TextStyle.Alignment.CENTER;
                    {
                        let __args = arguments;
                        let cached: any = true;
                        if (this.fontName === undefined) { this.fontName = null; }
                        if (this.fontSize === undefined) { this.fontSize = 0; }
                        if (this.bold === undefined) { this.bold = false; }
                        if (this.italic === undefined) { this.italic = false; }
                        if (this.alignment === undefined) { this.alignment = null; }
                        this.fontName = fontName;
                        this.fontSize = fontSize;
                        this.bold = bold;
                        this.italic = italic;
                        this.alignment = alignment;
                        if (cached) {
                            /* add */(TextStyle.textStylesCache_$LI$().push(this) > 0);
                        }
                    }
                    if (this.fontName === undefined) { this.fontName = null; }
                    if (this.fontSize === undefined) { this.fontSize = 0; }
                    if (this.bold === undefined) { this.bold = false; }
                    if (this.italic === undefined) { this.italic = false; }
                    if (this.alignment === undefined) { this.alignment = null; }
                }
                if (this.fontName === undefined) { this.fontName = null; }
                if (this.fontSize === undefined) { this.fontSize = 0; }
                if (this.bold === undefined) { this.bold = false; }
                if (this.italic === undefined) { this.italic = false; }
                if (this.alignment === undefined) { this.alignment = null; }
            }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontSize === undefined) { this.fontSize = 0; }
            if (this.bold === undefined) { this.bold = false; }
            if (this.italic === undefined) { this.italic = false; }
            if (this.alignment === undefined) { this.alignment = null; }
        } else if (((typeof fontName === 'number') || fontName === null) && fontSize === undefined && bold === undefined && italic === undefined && alignment === undefined && cached === undefined) {
            let __args = arguments;
            let fontSize: any = __args[0];
            {
                let __args = arguments;
                let bold: any = false;
                let italic: any = false;
                {
                    let __args = arguments;
                    let fontName: any = null;
                    {
                        let __args = arguments;
                        let alignment: any = TextStyle.Alignment.CENTER;
                        {
                            let __args = arguments;
                            let cached: any = true;
                            if (this.fontName === undefined) { this.fontName = null; }
                            if (this.fontSize === undefined) { this.fontSize = 0; }
                            if (this.bold === undefined) { this.bold = false; }
                            if (this.italic === undefined) { this.italic = false; }
                            if (this.alignment === undefined) { this.alignment = null; }
                            this.fontName = fontName;
                            this.fontSize = fontSize;
                            this.bold = bold;
                            this.italic = italic;
                            this.alignment = alignment;
                            if (cached) {
                                /* add */(TextStyle.textStylesCache_$LI$().push(this) > 0);
                            }
                        }
                        if (this.fontName === undefined) { this.fontName = null; }
                        if (this.fontSize === undefined) { this.fontSize = 0; }
                        if (this.bold === undefined) { this.bold = false; }
                        if (this.italic === undefined) { this.italic = false; }
                        if (this.alignment === undefined) { this.alignment = null; }
                    }
                    if (this.fontName === undefined) { this.fontName = null; }
                    if (this.fontSize === undefined) { this.fontSize = 0; }
                    if (this.bold === undefined) { this.bold = false; }
                    if (this.italic === undefined) { this.italic = false; }
                    if (this.alignment === undefined) { this.alignment = null; }
                }
                if (this.fontName === undefined) { this.fontName = null; }
                if (this.fontSize === undefined) { this.fontSize = 0; }
                if (this.bold === undefined) { this.bold = false; }
                if (this.italic === undefined) { this.italic = false; }
                if (this.alignment === undefined) { this.alignment = null; }
            }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontSize === undefined) { this.fontSize = 0; }
            if (this.bold === undefined) { this.bold = false; }
            if (this.italic === undefined) { this.italic = false; }
            if (this.alignment === undefined) { this.alignment = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the text style instance matching the given parameters.
     * @param {string} fontName
     * @param {number} fontSize
     * @param {boolean} bold
     * @param {boolean} italic
     * @param {TextStyle.Alignment} alignment
     * @return {TextStyle}
     * @private
     */
    getInstance(fontName: string, fontSize: number, bold: boolean, italic: boolean, alignment: TextStyle.Alignment): TextStyle {
        const textStyle: TextStyle = new TextStyle(fontName, fontSize, bold, italic, alignment, false);
        for (let i: number = /* size */(<number>TextStyle.textStylesCache_$LI$().length) - 1; i >= 0; i--) {
            {
                const cachedTextStyle: TextStyle = /* get *//* get */TextStyle.textStylesCache_$LI$()[i];
                if (cachedTextStyle == null) {
                /* remove */TextStyle.textStylesCache_$LI$().splice(i, 1)[0];
                } else if (cachedTextStyle.equals(textStyle)) {
                    return textStyle;
                }
            };
        }
        /* add */(TextStyle.textStylesCache_$LI$().push(textStyle) > 0);
        return textStyle;
    }

    /**
     * Returns the font name of this text style.
     * @return {string}
     */
    public getFontName(): string {
        return this.fontName;
    }

    /**
     * Returns the font size of this text style.
     * @return {number}
     */
    public getFontSize(): number {
        return this.fontSize;
    }

    /**
     * Returns whether this text style is bold or not.
     * @return {boolean}
     */
    public isBold(): boolean {
        return this.bold;
    }

    /**
     * Returns whether this text style is italic or not.
     * @return {boolean}
     */
    public isItalic(): boolean {
        return this.italic;
    }

    /**
     * Returns the alignment applied on text using this style.
     * @return {TextStyle.Alignment}
     */
    public getAlignment(): TextStyle.Alignment {
        return this.alignment;
    }

    public deriveStyle$java_lang_String(fontName: string): TextStyle {
        if (this.getFontName() === fontName || (fontName != null && (fontName === this.getFontName()))) {
            return this;
        } else {
            return this.getInstance(fontName, this.getFontSize(), this.isBold(), this.isItalic(), this.getAlignment());
        }
    }

    /**
     * Returns a derived style of this text style with a given font name.
     * @param {string} fontName
     * @return {TextStyle}
     */
    public deriveStyle(fontName?: any): TextStyle {
        if (((typeof fontName === 'string') || fontName === null)) {
            return <any>this.deriveStyle$java_lang_String(fontName);
        } else if (((typeof fontName === 'number') || fontName === null)) {
            return <any>this.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(fontName);
        } else if (((typeof fontName === 'number') || fontName === null)) {
            return <any>this.deriveStyle$float(fontName);
        } else throw new Error('invalid overload');
    }

    public deriveStyle$float(fontSize: number): TextStyle {
        if (this.getFontSize() === fontSize) {
            return this;
        } else {
            return this.getInstance(this.getFontName(), fontSize, this.isBold(), this.isItalic(), this.getAlignment());
        }
    }

    public deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(alignment: TextStyle.Alignment): TextStyle {
        if (this.getAlignment() === alignment) {
            return this;
        } else {
            return this.getInstance(this.getFontName(), this.getFontSize(), this.isBold(), this.isItalic(), alignment);
        }
    }

    /**
     * Returns a derived style of this text style with a given bold style.
     * @param {boolean} bold
     * @return {TextStyle}
     */
    public deriveBoldStyle(bold: boolean): TextStyle {
        if (this.isBold() === bold) {
            return this;
        } else {
            return this.getInstance(this.getFontName(), this.getFontSize(), bold, this.isItalic(), this.getAlignment());
        }
    }

    /**
     * Returns a derived style of this text style with a given italic style.
     * @param {boolean} italic
     * @return {TextStyle}
     */
    public deriveItalicStyle(italic: boolean): TextStyle {
        if (this.isItalic() === italic) {
            return this;
        } else {
            return this.getInstance(this.getFontName(), this.getFontSize(), this.isBold(), italic, this.getAlignment());
        }
    }

    /**
     * Returns <code>true</code> if this text style is equal to <code>object</code>.
     * @param {Object} object
     * @return {boolean}
     */
    public equals(object: any): boolean {
        if (object != null && object instanceof <any>TextStyle) {
            const textStyle: TextStyle = <TextStyle>object;
            return (textStyle.fontName === this.fontName || (textStyle.fontName != null && (textStyle.fontName === this.fontName))) && textStyle.fontSize === this.fontSize && textStyle.bold === this.bold && textStyle.italic === this.italic && textStyle.alignment === this.alignment;
        }
        return false;
    }

    /**
     * Returns a hash code for this text style.
     * @return {number}
     */
    public hashCode(): number {
        let hashCode: number = /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.fontSize);
        if (this.fontName != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.fontName));
        }
        if (this.bold) {
            hashCode++;
        }
        if (this.italic) {
            hashCode++;
        }
        hashCode += 0;
        return hashCode;
    }
}
TextStyle["__class"] = "com.eteks.sweethome3d.model.TextStyle";


export namespace TextStyle {

    export enum Alignment {
        LEFT, CENTER, RIGHT
    }
}


/**
 * Creates a material instance from parameters.
 * @param {string} name
 * @param {float[][]} matrix
 * @class
 * @author Emmanuel Puybaret
 */
export class Transformation {
    /*private*/ name: string;

    /*private*/ matrix: number[][];

    public constructor(name: string, matrix: number[][]) {
        if (this.name === undefined) { this.name = null; }
        if (this.matrix === undefined) { this.matrix = null; }
        this.name = name;
        this.matrix = matrix;
    }

    /**
     * Returns the name of this transformation.
     * @return {string} the name of the transformation.
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the matrix of this transformation.
     * @return {float[][]} a 4x3 float array.
     */
    public getMatrix(): number[][] {
        return [[this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3]], [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3]], [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3]]];
    }

    /**
     * Returns <code>true</code> if this transformation is equal to <code>object</code>.
     * @param {Object} object
     * @return {boolean}
     */
    public equals(object: any): boolean {
        if (object != null && object instanceof <any>Transformation) {
            const transformation: Transformation = <Transformation>object;
            if (transformation.name === this.name) {
                for (let i: number = 0; i < this.matrix.length; i++) {
                    {
                        for (let j: number = 0; j < this.matrix[i].length; j++) {
                            {
                                if (transformation.matrix[i][j] !== this.matrix[i][j]) {
                                    return false;
                                }
                            };
                        }
                    };
                }
                return true;
            }
        }
        return false;
    }

    /**
     * Returns a hash code for this transformation.
     * @return {number}
     */
    public hashCode(): number {
        return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name)) + /* deepHashCode */(function (array) { function deepHashCode(array) { if (array == null) return 0; var hashCode = 1; for (var i = 0; i < array.length; i++) { var elementHashCode = 1; if (Array.isArray(array[i])) elementHashCode = deepHashCode(array[i]); else if (typeof array[i] == 'number') elementHashCode = (array[i] * 1000) | 0; hashCode = 31 * hashCode + elementHashCode; } return hashCode; } return deepHashCode; })(this.matrix);
    }
}
Transformation["__class"] = "com.eteks.sweethome3d.model.Transformation";


/**
 * Content for files, images...
 * @author Emmanuel Puybaret
 * @class
 */
interface Content { }

/**
 * Creates a catalog texture.
 * @param {string} id the ID of this texture
 * @param {string} name the name of this texture
 * @param {Object} image the content of the image used for this texture
 * @param {number} width the width of the texture in centimeters
 * @param {number} height the height of the texture in centimeters
 * @param {boolean} modifiable <code>true</code> if this texture can be modified
 * @param {string} creator
 * @class
 * @author Emmanuel Puybaret
 */
export class CatalogTexture implements TextureImage, CatalogItem {
    static __static_initialized: boolean = false;
    static __static_initialize() { if (!CatalogTexture.__static_initialized) { CatalogTexture.__static_initialized = true; CatalogTexture.__static_initializer_0(); } }

    static EMPTY_CRITERIA: number[][]; public static EMPTY_CRITERIA_$LI$(): number[][] { CatalogTexture.__static_initialize(); if (CatalogTexture.EMPTY_CRITERIA == null) { CatalogTexture.EMPTY_CRITERIA = []; } return CatalogTexture.EMPTY_CRITERIA; }

    /*private*/ id: string;

    /*private*/ name: string;

    /*private*/ image: Content;

    /*private*/ width: number;

    /*private*/ height: number;

    /*private*/ creator: string;

    /*private*/ modifiable: boolean;

    /*private*/ category: TexturesCategory;

    /*private*/ filterCollationKey: number[];

    static COMPARATOR: any; public static COMPARATOR_$LI$(): any { CatalogTexture.__static_initialize(); return CatalogTexture.COMPARATOR; }

    static recentFilters: any; public static recentFilters_$LI$(): any { CatalogTexture.__static_initialize(); return CatalogTexture.recentFilters; }

    static __static_initializer_0() {
        CatalogTexture.COMPARATOR = /* getInstance */{ compare: (o1, o2) => o1.toString().localeCompare(o2.toString()), equals: (o1, o2) => o1.toString().localeCompare(o2.toString()) === 0 };
        /* setStrength */CatalogTexture.COMPARATOR_$LI$();
        CatalogTexture.recentFilters = {};
    }

    public constructor(id?: any, name?: any, image?: any, width?: any, height?: any, creator?: any, modifiable?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((image != null && (image.constructor != null && image.constructor["__interfaces"] != null && image.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || image === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null) && ((typeof creator === 'string') || creator === null) && ((typeof modifiable === 'boolean') || modifiable === null)) {
            let __args = arguments;
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            this.id = id;
            this.name = name;
            this.image = image;
            this.width = width;
            this.height = height;
            this.creator = creator;
            this.modifiable = modifiable;
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((image != null && (image.constructor != null && image.constructor["__interfaces"] != null && image.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || image === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null) && ((typeof creator === 'string') || creator === null) && modifiable === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let modifiable: any = false;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                this.id = id;
                this.name = name;
                this.image = image;
                this.width = width;
                this.height = height;
                this.creator = creator;
                this.modifiable = modifiable;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || name === null) && ((typeof image === 'number') || image === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'boolean') || height === null) && creator === undefined && modifiable === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let image: any = __args[1];
            let width: any = __args[2];
            let height: any = __args[3];
            let modifiable: any = __args[4];
            {
                let __args = arguments;
                let id: any = null;
                let creator: any = null;
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                this.id = id;
                this.name = name;
                this.image = image;
                this.width = width;
                this.height = height;
                this.creator = creator;
                this.modifiable = modifiable;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else if (((typeof id === 'string') || id === null) && ((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || name === null) && ((typeof image === 'number') || image === null) && ((typeof width === 'number') || width === null) && height === undefined && creator === undefined && modifiable === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let image: any = __args[1];
            let width: any = __args[2];
            let height: any = __args[3];
            {
                let __args = arguments;
                let id: any = null;
                let creator: any = null;
                {
                    let __args = arguments;
                    let modifiable: any = false;
                    if (this.id === undefined) { this.id = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.image === undefined) { this.image = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.modifiable === undefined) { this.modifiable = false; }
                    if (this.category === undefined) { this.category = null; }
                    if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
                    this.id = id;
                    this.name = name;
                    this.image = image;
                    this.width = width;
                    this.height = height;
                    this.creator = creator;
                    this.modifiable = modifiable;
                }
                if (this.id === undefined) { this.id = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.modifiable === undefined) { this.modifiable = false; }
                if (this.category === undefined) { this.category = null; }
                if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
            }
            if (this.id === undefined) { this.id = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.modifiable === undefined) { this.modifiable = false; }
            if (this.category === undefined) { this.category = null; }
            if (this.filterCollationKey === undefined) { this.filterCollationKey = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the ID of this texture or <code>null</code>.
     * @return {string}
     */
    public getId(): string {
        return this.id;
    }

    /**
     * Returns the name of this texture.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the content of the image used for this texture.
     * @return {Object}
     */
    public getImage(): Content {
        return this.image;
    }

    /**
     * Returns the icon of this texture.
     * @return {Object} the image of this texture.
     */
    public getIcon(): Content {
        return this.getImage();
    }

    /**
     * Returns the width of the image in centimeters.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Returns the height of the image in centimeters.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Returns the creator of this texture or <code>null</code>.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Returns <code>true</code> if this texture is modifiable (not read from resources).
     * @return {boolean}
     */
    public isModifiable(): boolean {
        return this.modifiable;
    }

    /**
     * Returns the category of this texture.
     * @return {TexturesCategory}
     */
    public getCategory(): TexturesCategory {
        return this.category;
    }

    /**
     * Sets the category of this texture.
     * @param {TexturesCategory} category
     * @private
     */
    setCategory(category: TexturesCategory) {
        this.category = category;
    }

    /**
     * Returns true if this texture and the one in parameter are the same objects.
     * Note that, from version 3.6, two textures can have the same name.
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        return /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(this, obj));
    }

    /**
     * Returns default hash code.
     * @return {number}
     */
    public hashCode(): number {
        return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this));
    }

    /**
     * Compares the names of this texture and the one in parameter.
     * @param {CatalogTexture} texture
     * @return {number}
     */
    public compareTo(texture: CatalogTexture): number {
        const nameComparison: number = CatalogTexture.COMPARATOR_$LI$().compare(this.name, texture.name);
        if (nameComparison !== 0) {
            return nameComparison;
        } else {
            return this.modifiable === texture.modifiable ? 0 : (this.modifiable ? 1 : -1);
        }
    }

    /**
     * Returns <code>true</code> if this texture matches the given <code>filter</code> text.
     * Each substring of the <code>filter</code> is considered as a search criterion that can match
     * the name, the category name or the creator of this texture.
     * @param {string} filter
     * @return {boolean}
     */
    public matchesFilter(filter: string): boolean {
        const filterCriteriaCollationKeys: number[][] = this.getFilterCollationKeys(filter);
        let checkedCriteria: number = 0;
        if (filterCriteriaCollationKeys.length > 0) {
            const furnitureCollationKey: number[] = this.getTextureCollationKey();
            for (let i: number = 0; i < filterCriteriaCollationKeys.length; i++) {
                {
                    if (this.isSubCollationKey(furnitureCollationKey, filterCriteriaCollationKeys[i], 0)) {
                        checkedCriteria++;
                    } else {
                        break;
                    }
                };
            }
        }
        return checkedCriteria === filterCriteriaCollationKeys.length;
    }

    /**
     * Returns the collation key bytes of each criterion in the given <code>filter</code>.
     * @param {string} filter
     * @return {byte[][]}
     * @private
     */
    /*private*/ getFilterCollationKeys(filter: string): number[][] {
        if (filter.length === 0) {
            return CatalogTexture.EMPTY_CRITERIA_$LI$();
        }
        let filterCollationKeys: number[][] = /* get */((m, k) => m[k] === undefined ? null : m[k])(CatalogTexture.recentFilters_$LI$(), filter);
        if (filterCollationKeys == null) {
            const filterCriteria: string[] = filter.split(/\s|\p{Punct}|\\|/);
            const filterCriteriaCollationKeys: Array<number[]> = <any>([]);
            for (let index = 0; index < filterCriteria.length; index++) {
                let criterion = filterCriteria[index];
                {
                    if (criterion.length > 0) {
                        /* add */(filterCriteriaCollationKeys.push(CatalogTexture.COMPARATOR_$LI$().getCollationKey(criterion).toByteArray()) > 0);
                    }
                }
            }
            if (/* size */(<number>filterCriteriaCollationKeys.length) === 0) {
                filterCollationKeys = CatalogTexture.EMPTY_CRITERIA_$LI$();
            } else {
                filterCollationKeys = /* toArray */filterCriteriaCollationKeys.slice(0);
            }
            /* put */(CatalogTexture.recentFilters_$LI$()[filter] = filterCollationKeys);
        }
        return filterCollationKeys;
    }

    /**
     * Returns the collation key bytes used to compare the given <code>texture</code> with filter.
     * @return {byte[]}
     * @private
     */
    /*private*/ getTextureCollationKey(): number[] {
        if (this.filterCollationKey == null) {
            const search: { str: string, toString: Function } = { str: "", toString: function () { return this.str; } };
            /* append */(sb => { sb.str += <any>this.getName(); return sb; })(search);
            /* append */(sb => { sb.str += <any>'|'; return sb; })(search);
            if (this.getCategory() != null) {
                /* append */(sb => { sb.str += <any>this.getCategory().getName(); return sb; })(search);
                /* append */(sb => { sb.str += <any>'|'; return sb; })(search);
            }
            if (this.getCreator() != null) {
                /* append */(sb => { sb.str += <any>this.getCreator(); return sb; })(search);
                /* append */(sb => { sb.str += <any>'|'; return sb; })(search);
            }
            this.filterCollationKey = CatalogTexture.COMPARATOR_$LI$().getCollationKey(/* toString */search.str).toByteArray();
        }
        return this.filterCollationKey;
    }

    /**
     * Returns <code>true</code> if the given filter collation key is a sub part of the first array collator key.
     * @param {byte[]} collationKey
     * @param {byte[]} filterCollationKey
     * @param {number} start
     * @return {boolean}
     * @private
     */
    /*private*/ isSubCollationKey(collationKey: number[], filterCollationKey: number[], start: number): boolean {
        for (let i: number = start, n: number = collationKey.length - 4, m: number = filterCollationKey.length - 4; i < n && i < n - m + 1; i++) {
            {
                if (collationKey[i] === filterCollationKey[0]) {
                    for (let j: number = 1; j < m; j++) {
                        {
                            if (collationKey[i + j] !== filterCollationKey[j]) {
                                return this.isSubCollationKey(collationKey, filterCollationKey, i + 1);
                            }
                        };
                    }
                    return true;
                }
            };
        }
        return false;
    }
}
CatalogTexture["__class"] = "com.eteks.sweethome3d.model.CatalogTexture";
CatalogTexture["__interfaces"] = ["com.eteks.sweethome3d.model.CatalogItem", "com.eteks.sweethome3d.model.TextureImage"];



/**
 * A piece of furniture that contains one or more light sources.
 * @author Emmanuel Puybaret
 * @class
 */
interface Light extends PieceOfFurniture {
    /**
     * Returns the sources managed by this light. Each light source point
     * is a percentage of the width, the depth and the height of this light.
     * @return {com.eteks.sweethome3d.model.LightSource[]} a copy of light sources array.
     */
    getLightSources(): LightSource[];

    /**
     * Returns the material names of the light sources in the 3D model managed by this light.
     * @return {java.lang.String[]} a copy of light source material names array.
     */
    getLightSourceMaterialNames(): string[];
}

/**
 * Create a category.
 * @param {string} name the name of the category.
 * @class
 * @author Emmanuel Puybaret
 */
export class TexturesCategory {
    /*private*/ name: string;

    /*private*/ textures: Array<CatalogTexture>;

    static COMPARATOR: any; public static COMPARATOR_$LI$(): any { if (TexturesCategory.COMPARATOR == null) { TexturesCategory.COMPARATOR = /* getInstance */{ compare: (o1, o2) => o1.toString().localeCompare(o2.toString()), equals: (o1, o2) => o1.toString().localeCompare(o2.toString()) === 0 }; } return TexturesCategory.COMPARATOR; }

    public constructor(name: string) {
        if (this.name === undefined) { this.name = null; }
        if (this.textures === undefined) { this.textures = null; }
        this.name = name;
        this.textures = <any>([]);
    }

    /**
     * Returns the name of this category.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the textures list of this category sorted by name.
     * @return {CatalogTexture[]} a list of furniture.
     */
    public getTextures(): Array<CatalogTexture> {
        return /* unmodifiableList */this.textures.slice(0);
    }

    /**
     * Returns the count of textures in this category.
     * @return {number}
     */
    public getTexturesCount(): number {
        return /* size */(<number>this.textures.length);
    }

    /**
     * Returns the texture at a given <code>index</code>.
     * @param {number} index
     * @return {CatalogTexture}
     */
    public getTexture(index: number): CatalogTexture {
        return /* get */this.textures[index];
    }

    /**
     * Returns the index of the given <code>texture</code>.
     * @param {CatalogTexture} texture
     * @return {number}
     */
    public getIndexOfTexture(texture: CatalogTexture): number {
        return this.textures.indexOf(texture);
    }

    /**
     * Adds a texture to this category.
     * @param {CatalogTexture} texture the texture to add.
     * @private
     */
    add(texture: CatalogTexture) {
        texture.setCategory(this);
        let index: number = /* binarySearch */((l, key) => { let comp = (a, b) => { if (a.compareTo) return (<number>a.compareTo(b)); else return a.localeCompare(b); }; let low = 0; let high = l.length - 1; while (low <= high) { let mid = (low + high) >>> 1; let midVal = l[mid]; let cmp = comp(midVal, key); if (cmp < 0) low = mid + 1; else if (cmp > 0) high = mid - 1; else return mid; } return -(low + 1); })(this.textures, texture);
        if (index < 0) {
            index = -index - 1;
        }
        /* add */this.textures.splice(index, 0, texture);
    }

    /**
     * Deletes a texture from this category.
     * @param {CatalogTexture} texture the texture to remove.
     * @throws IllegalArgumentException if the texture doesn't exist in this category.
     * @private
     */
    delete(texture: CatalogTexture) {
        const textureIndex: number = this.textures.indexOf(texture);
        if (textureIndex === -1) {
            throw new IllegalArgumentException(this.name + " doesn\'t contain texture " + texture.getName());
        }
        this.textures = <any>(this.textures.slice(0));
        /* remove */this.textures.splice(textureIndex, 1)[0];
    }

    /**
     * Returns true if this category and the one in parameter have the same name.
     * @param {Object} obj
     * @return {boolean}
     */
    public equals(obj: any): boolean {
        return (obj != null && obj instanceof <any>TexturesCategory) && TexturesCategory.COMPARATOR_$LI$().equals(this.name, (<TexturesCategory>obj).name);
    }

    /**
     * 
     * @return {number}
     */
    public hashCode(): number {
        return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name));
    }

    /**
     * Compares the names of this category and the one in parameter.
     * @param {TexturesCategory} category
     * @return {number}
     */
    public compareTo(category: TexturesCategory): number {
        return TexturesCategory.COMPARATOR_$LI$().compare(this.name, category.name);
    }
}
TexturesCategory["__class"] = "com.eteks.sweethome3d.model.TexturesCategory";


/**
 * Creates an event for an item with its index.
 * @param {Object} source the object to which an item was added or deleted
 * @param {Object} item   the added or deleted item
 * @param {number} index  the index at which the item was added or deleted, or -1 if unknown
 * @param {CollectionEvent.Type} type   <code>CollectionEvent.Type.ADD</code> or <code>CollectionEvent.Type.DELETE</code>
 * @class
 * @extends EventObject
 * @author Emmanuel Puybaret
 */
export class CollectionEvent<T> extends EventObject {
    /*private*/ item: T;

    /*private*/ index: number;

    /*private*/ type: CollectionEvent.Type;

    public constructor(source?: any, item?: any, index?: any, type?: any) {
        if (((source != null) || source === null) && ((item != null) || item === null) && ((typeof index === 'number') || index === null) && ((typeof type === 'number') || type === null)) {
            let __args = arguments;
            super(source);
            if (this.item === undefined) { this.item = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.type === undefined) { this.type = null; }
            this.item = item;
            this.index = index;
            this.type = type;
        } else if (((source != null) || source === null) && ((item != null) || item === null) && ((typeof index === 'number') || index === null) && type === undefined) {
            let __args = arguments;
            let type: any = __args[2];
            {
                let __args = arguments;
                let index: any = -1;
                super(source);
                if (this.item === undefined) { this.item = null; }
                if (this.index === undefined) { this.index = 0; }
                if (this.type === undefined) { this.type = null; }
                this.item = item;
                this.index = index;
                this.type = type;
            }
            if (this.item === undefined) { this.item = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.type === undefined) { this.type = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the added or deleted item.
     * @return {Object}
     */
    public getItem(): T {
        return this.item;
    }

    /**
     * Returns the index of the item in collection or -1 if this index is unknown.
     * @return {number}
     */
    public getIndex(): number {
        return this.index;
    }

    /**
     * Returns the type of event.
     * @return {CollectionEvent.Type}
     */
    public getType(): CollectionEvent.Type {
        return this.type;
    }
}
CollectionEvent["__class"] = "com.eteks.sweethome3d.model.CollectionEvent";


export namespace CollectionEvent {

    /**
     * The type of change in the collection.
     * @enum
     * @property {CollectionEvent.Type} ADD
     * @property {CollectionEvent.Type} DELETE
     * @class
     */
    export enum Type {
        ADD, DELETE
    }
}
CollectionEvent['__transients'] = ['source'];

/**
 * A piece of furniture whith shelves.
 * @author Emmanuel Puybaret
 * @class
 */
interface ShelfUnit extends PieceOfFurniture {
    /**
     * Returns the elevation(s) at which other objects can be placed on this shelf unit.
     * @return {float[]}
     */
    getShelfElevations(): number[];

    /**
     * Returns the coordinates of the shelf box(es) in which other objects can be placed in this shelf unit.
     * @return {com.eteks.sweethome3d.model.BoxBounds[]}
     */
    getShelfBoxes(): BoxBounds[];
}

/**
 * Creates a material instance from parameters.
 * @param {string} name
 * @param {string} key
 * @param {number} color
 * @param {HomeTexture} texture
 * @param {number} shininess
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeMaterial {
    /*private*/ name: string;

    /*private*/ key: string;

    /*private*/ color: number;

    /*private*/ texture: HomeTexture;

    /*private*/ shininess: number;

    public constructor(name?: any, key?: any, color?: any, texture?: any, shininess?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof key === 'string') || key === null) && ((typeof color === 'number') || color === null) && ((texture != null && texture instanceof <any>HomeTexture) || texture === null) && ((typeof shininess === 'number') || shininess === null)) {
            let __args = arguments;
            if (this.name === undefined) { this.name = null; }
            if (this.key === undefined) { this.key = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            this.name = name;
            this.key = key;
            this.color = color;
            this.texture = texture;
            this.shininess = shininess;
        } else if (((typeof name === 'string') || name === null) && ((typeof key === 'number') || key === null) && ((color != null && color instanceof <any>HomeTexture) || color === null) && ((typeof texture === 'number') || texture === null) && shininess === undefined) {
            let __args = arguments;
            let color: any = __args[1];
            let texture: any = __args[2];
            let shininess: any = __args[3];
            {
                let __args = arguments;
                let key: any = null;
                if (this.name === undefined) { this.name = null; }
                if (this.key === undefined) { this.key = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.texture === undefined) { this.texture = null; }
                if (this.shininess === undefined) { this.shininess = null; }
                this.name = name;
                this.key = key;
                this.color = color;
                this.texture = texture;
                this.shininess = shininess;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.key === undefined) { this.key = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the name of this material.
     * @return {string} the name of the material or <code>null</code> if material has no name.
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Returns the key of this material. If not <code>null</code>, this key should be used
     * as the unique identifier to find this material among the ones available on a model,
     * rather than the name of this material.
     * @return {string} the key of the material or <code>null</code> if material has no key.
     */
    public getKey(): string {
        return this.key;
    }

    /**
     * Returns the color of this material.
     * @return {number} the color of the material as RGB code or <code>null</code> if material color is unchanged.
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Returns the texture of this material.
     * @return {HomeTexture} the texture of the material or <code>null</code> if material texture is unchanged.
     */
    public getTexture(): HomeTexture {
        return this.texture;
    }

    /**
     * Returns the shininess of this material.
     * @return {number} a value between 0 (matt) and 1 (very shiny) or <code>null</code> if material shininess is unchanged.
     */
    public getShininess(): number {
        return this.shininess;
    }

    /**
     * Returns <code>true</code> if this material is equal to <code>object</code>.
     * @param {Object} object
     * @return {boolean}
     */
    public equals(object: any): boolean {
        if (object != null && object instanceof <any>HomeMaterial) {
            const material: HomeMaterial = <HomeMaterial>object;
            return (material.name === this.name || (material.name != null && (material.name === this.name))) && (material.key === this.key || (material.key != null && (material.key === this.name))) && (material.color === this.color || (material.color != null && (material.color === this.color))) && (material.texture === this.texture || (material.texture != null && material.texture.equals(this.texture))) && (material.shininess === this.shininess || (material.shininess != null && (material.shininess === this.shininess)));
        }
        return false;
    }

    /**
     * Returns a hash code for this material.
     * @return {number}
     */
    public hashCode(): number {
        let hashCode: number = 0;
        if (this.name != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.name));
        }
        if (this.key != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.key));
        }
        if (this.color != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.color));
        }
        if (this.texture != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.texture));
        }
        if (this.shininess != null) {
            hashCode += /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0); } })(this.shininess));
        }
        return hashCode;
    }
}
HomeMaterial["__class"] = "com.eteks.sweethome3d.model.HomeMaterial";


/**
 * Creates a new object with a unique ID prefixed by <code>object-</code>.
 * @class
 * @author Emmanuel Puybaret
 */
export abstract class HomeObject {
    static ID_DEFAULT_PREFIX: string = "object";

    /*private*/ id: string;

    /*private*/ properties: any;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /**
     * Returns a new ID prefixed by the given string.
     * @param {string} prefix
     * @return {string}
     */
    static createId(prefix: string): string {
        return prefix + "-" + UUID.randomUUID();
    }

    public constructor(id?: any) {
        if (((typeof id === 'string') || id === null)) {
            let __args = arguments;
            if (this.id === undefined) { this.id = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (id == null) {
                throw new IllegalArgumentException("ID must exist");
            }
            this.id = id;
        } else if (id === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let id: any = HomeObject.createId(HomeObject.ID_DEFAULT_PREFIX);
                if (this.id === undefined) { this.id = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (id == null) {
                    throw new IllegalArgumentException("ID must exist");
                }
                this.id = id;
            }
            if (this.id === undefined) { this.id = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        } else throw new Error('invalid overload');
    }

    public addPropertyChangeListener(propertyName: any, listener?: any) { if (this.propertyChangeSupport == null) { this.propertyChangeSupport = new PropertyChangeSupport(this); } if (listener === undefined) { this.propertyChangeSupport.addPropertyChangeListener(propertyName); } else { this.propertyChangeSupport.addPropertyChangeListener(propertyName, listener); } }

    public removePropertyChangeListener(propertyName: any, listener?: any) { if (this.propertyChangeSupport != null) { if (listener === undefined) { this.propertyChangeSupport.removePropertyChangeListener(<any>propertyName); } else { this.propertyChangeSupport.removePropertyChangeListener(propertyName, listener); } if (this.propertyChangeSupport.getPropertyChangeListeners().length === 0) { this.propertyChangeSupport = null; } } }

    /**
     * Fires a property change of {@link PropertyChangeEvent} class to listeners.
     * @param {string} propertyName
     * @param {Object} oldValue
     * @param {Object} newValue
     */
    firePropertyChange(propertyName: string, oldValue: any, newValue: any) {
        if (this.propertyChangeSupport != null) {
            this.propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);
        }
    }

    /**
     * Returns the ID of this object.
     * @return {string} a unique ID
     */
    public getId(): string {
        return this.id;
    }

    /**
     * Returns the value of the property <code>name</code> associated with this object.
     * @return {string} the value of the property or <code>null</code> if it doesn't exist.
     * @param {string} name
     */
    public getProperty(name: string): string {
        if (this.properties != null) {
            const propertyValue: any = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
            if (typeof propertyValue === 'string') {
                return <string>propertyValue;
            }
        }
        return null;
    }

    /**
     * Returns the value of the content <code>name</code> associated to this object.
     * @return {Object} the value of the content or <code>null</code> if it doesn't exist or if it's not a content.
     * @param {string} name
     */
    public getContentProperty(name: string): Content {
        if (this.properties != null) {
            const propertyValue: any = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
            if (propertyValue != null && (propertyValue.constructor != null && propertyValue.constructor["__interfaces"] != null && propertyValue.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) {
                return <Content><any>propertyValue;
            }
        }
        return null;
    }

    /**
     * Returns <code>true</code> if the type of given property is a content.
     * @param {string} name
     * @return {boolean}
     */
    public isContentProperty(name: string): boolean {
        return this.properties != null && (/* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name) != null && (/* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor != null && /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor["__interfaces"] != null && /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name).constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0));
    }

    public setProperty$java_lang_String$java_lang_String(name: string, value: string) {
        this.setProperty$java_lang_String$java_lang_Object(name, <any>value);
    }

    /**
     * Sets the value of a property associated with this object. Once the property is updated,
     * listeners added to this object will receive a change event of {@link PropertyChangeEvent} class.<br>
     * To avoid any issue with existing or future properties of Sweet Home 3D classes,
     * do not use property names written with only upper case letters.
     * @param {string} name   the name of the property to set
     * @param {string} value  the new value of the property or <code>null</code> to remove an existing property
     */
    public setProperty(name?: any, value?: any) {
        if (((typeof name === 'string') || name === null) && ((typeof value === 'string') || value === null)) {
            return <any>this.setProperty$java_lang_String$java_lang_String(name, value);
        } else if (((typeof name === 'string') || name === null) && ((value != null) || value === null)) {
            return <any>this.setProperty$java_lang_String$java_lang_Object(name, value);
        } else throw new Error('invalid overload');
    }

    public setProperty$java_lang_String$java_lang_Object(name: string, value: any) {
        if (value != null && !((typeof value === 'string') || (value != null && (value.constructor != null && value.constructor["__interfaces"] != null && value.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)))) {
            throw new IllegalArgumentException("Property value can be only a string or a content, not an instance of " + (<any>value.constructor));
        }
        const oldValue: any = this.properties != null ? /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name) : null;
        if (value == null) {
            if (this.properties != null && oldValue != null) {
                try {
                    /* remove */(map => { let deleted = this.properties[name]; delete this.properties[name]; return deleted; })(this.properties);
                    if (/* size */Object.keys(this.properties).length === 0) {
                        this.properties = null;
                    }
                } catch (ex) {
                    this.properties = null;
                }
                this.firePropertyChange(name, oldValue, null);
            }
        } else {
            if (this.properties == null || (/* size */Object.keys(this.properties).length === 1 && oldValue != null)) {
                this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any>value; return o; })(name);
            } else {
                if (/* size */Object.keys(this.properties).length === 1) {
                    this.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(this.properties));
                }
                /* put */(this.properties[name] = value);
            }
            this.firePropertyChange(name, oldValue, value);
        }
    }

    /**
     * Returns the property names.
     * @return {string[]} a collection of all the names of the properties set with {@link #setProperty(String, String) setProperty}
     */
    public getPropertyNames(): Array<string> {
        if (this.properties != null) {
            return /* keySet */Object.keys(this.properties);
        } else {
            return /* emptySet */[];
        }
    }

    /**
     * Returns a copy of this object with a new id.
     * @return {HomeObject}
     */
    public duplicate(): HomeObject {
        const copy: HomeObject = /* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        let index: number = 0;
        let c: string;
        while ((index < this.id.length && (c => c.charCodeAt == null ? <any>c : c.charCodeAt(0))((c = /* toLowerCase */this.id.charAt(index).toLowerCase())) >= 'a'.charCodeAt(0) && (c => c.charCodeAt == null ? <any>c : c.charCodeAt(0))(c) <= 'z'.charCodeAt(0))) {
            {
                index++;
            }
        };
        const prefix: string = index >= 0 ? this.id.substring(0, index) : HomeObject.ID_DEFAULT_PREFIX;
        copy.id = HomeObject.createId(prefix);
        return copy;
    }

    /**
     * Returns a clone of this object.
     * The returned object has the same id as this object.
     * @return {HomeObject}
     */
    public clone(): HomeObject {
        try {
            const clone: HomeObject = <HomeObject>/* clone *//* clone */((o: any) => { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; })(this);
            if (this.properties != null) {
                clone.properties = /* size */Object.keys(clone.properties).length === 1 ? /* singletonMap */(k => { let o = {}; o[k] = <any>/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* values */(obj => Object.keys(obj).map(key => obj[key]))(this.properties)).next(); return o; })(/* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(/* keySet */Object.keys(this.properties)).next()) : <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(this.properties));
            }
            clone.propertyChangeSupport = null;
            return clone;
        } catch (ex) {
            throw new IllegalStateException("Super class isn\'t cloneable");
        }
    }
}
HomeObject["__class"] = "com.eteks.sweethome3d.model.HomeObject";
HomeObject['__transients'] = ['propertyChangeSupport'];

/**
 * Textures catalog.
 * @author Emmanuel Puybaret
 * @class
 */
export class TexturesCatalog {
    /*private*/ categories: Array<TexturesCategory>;

    /*private*/ texturesChangeSupport: CollectionChangeSupport<CatalogTexture>;

    /**
     * Returns the categories list sorted by name.
     * @return {TexturesCategory[]} a list of categories.
     */
    public getCategories(): Array<TexturesCategory> {
        return /* unmodifiableList */this.categories.slice(0);
    }

    /**
     * Returns the count of categories in this catalog.
     * @return {number}
     */
    public getCategoriesCount(): number {
        return /* size */(<number>this.categories.length);
    }

    /**
     * Returns the category at a given <code>index</code>.
     * @param {number} index
     * @return {TexturesCategory}
     */
    public getCategory(index: number): TexturesCategory {
        return /* get */this.categories[index];
    }

    /**
     * Adds the texture <code>listener</code> in parameter to this catalog.
     * @param {Object} listener
     */
    public addTexturesListener(listener: CollectionListener<CatalogTexture>) {
        this.texturesChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the texture <code>listener</code> in parameter from this catalog.
     * @param {Object} listener
     */
    public removeTexturesListener(listener: CollectionListener<CatalogTexture>) {
        this.texturesChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Adds <code>texture</code> of a given <code>category</code> to this catalog.
     * Once the <code>texture</code> is added, texture listeners added to this catalog will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged} notification.
     * @param {TexturesCategory} category the category of the texture.
     * @param {CatalogTexture} texture  a texture.
     */
    public add(category: TexturesCategory, texture: CatalogTexture) {
        const index: number = /* binarySearch */((l, key) => { let comp = (a, b) => { if (a.compareTo) return (<number>a.compareTo(b)); else return a.localeCompare(b); }; let low = 0; let high = l.length - 1; while (low <= high) { let mid = (low + high) >>> 1; let midVal = l[mid]; let cmp = comp(midVal, key); if (cmp < 0) low = mid + 1; else if (cmp > 0) high = mid - 1; else return mid; } return -(low + 1); })(this.categories, category);
        if (index < 0) {
            category = new TexturesCategory(category.getName());
            /* add */this.categories.splice(-index - 1, 0, category);
        } else {
            category = /* get */this.categories[index];
        }
        category.add(texture);
        this.texturesChangeSupport.fireCollectionChanged(texture, category.getIndexOfTexture(texture), CollectionEvent.Type.ADD);
    }

    /**
     * Deletes the <code>texture</code> from this catalog.
     * If then texture category is empty, it will be removed from the categories of this catalog.
     * Once the <code>texture</code> is deleted, texture listeners added to this catalog will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged} notification.
     * @param {CatalogTexture} texture a texture.
     */
    public delete(texture: CatalogTexture) {
        const category: TexturesCategory = texture.getCategory();
        if (category != null) {
            const textureIndex: number = category.getIndexOfTexture(texture);
            if (textureIndex >= 0) {
                category.delete(texture);
                if (category.getTexturesCount() === 0) {
                    this.categories = <any>(this.categories.slice(0));
                    /* remove */(a => { let index = a.indexOf(category); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.categories);
                }
                this.texturesChangeSupport.fireCollectionChanged(texture, textureIndex, CollectionEvent.Type.DELETE);
                return;
            }
        }
        throw new IllegalArgumentException("catalog doesn\'t contain texture " + texture.getName());
    }

    constructor() {
        this.categories = <any>([]);
        this.texturesChangeSupport = <any>(new CollectionChangeSupport<CatalogTexture>(this));
    }
}
TexturesCatalog["__class"] = "com.eteks.sweethome3d.model.TexturesCatalog";


/**
 * Creates a window sash.
 * @param {number} xAxis
 * @param {number} yAxis
 * @param {number} width
 * @param {number} startAngle
 * @param {number} endAngle
 * @class
 * @author Emmanuel Puybaret
 */
export class Sash {
    /*private*/ xAxis: number;

    /*private*/ yAxis: number;

    /*private*/ width: number;

    /*private*/ startAngle: number;

    /*private*/ endAngle: number;

    public constructor(xAxis: number, yAxis: number, width: number, startAngle: number, endAngle: number) {
        if (this.xAxis === undefined) { this.xAxis = 0; }
        if (this.yAxis === undefined) { this.yAxis = 0; }
        if (this.width === undefined) { this.width = 0; }
        if (this.startAngle === undefined) { this.startAngle = 0; }
        if (this.endAngle === undefined) { this.endAngle = 0; }
        this.xAxis = xAxis;
        this.yAxis = yAxis;
        this.width = width;
        this.startAngle = startAngle;
        this.endAngle = endAngle;
    }

    /**
     * Returns the abscissa of the axis around which this sash turns, relatively to
     * the top left corner of the window or the door.
     * @return {number} a value in percentage of the width of the door or the window.
     */
    public getXAxis(): number {
        return this.xAxis;
    }

    /**
     * Returns the ordinate of the axis around which this sash turns, relatively to
     * the top left corner of the window or the door.
     * @return {number} a value in percentage of the depth of the door or the window.
     */
    public getYAxis(): number {
        return this.yAxis;
    }

    /**
     * Returns the width of this sash.
     * @return {number} a value in percentage of the width of the door or the window.
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Returns the opening start angle of this sash.
     * @return {number} an angle in radians.
     */
    public getStartAngle(): number {
        return this.startAngle;
    }

    /**
     * Returns the opening end angle of this sash.
     * @return {number} an angle in radians.
     */
    public getEndAngle(): number {
        return this.endAngle;
    }
}
Sash["__class"] = "com.eteks.sweethome3d.model.Sash";


/**
 * Creates a new light source.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {number} color
 * @param {number} diameter
 * @class
 * @author Emmanuel Puybaret
 */
export class LightSource {
    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ z: number;

    /*private*/ color: number;

    /*private*/ diameter: number;

    public constructor(x?: any, y?: any, z?: any, color?: any, diameter?: any) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof color === 'number') || color === null) && ((typeof diameter === 'number') || diameter === null)) {
            let __args = arguments;
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.color === undefined) { this.color = 0; }
            if (this.diameter === undefined) { this.diameter = null; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.color = color;
            this.diameter = diameter;
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof color === 'number') || color === null) && diameter === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let diameter: any = null;
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.z === undefined) { this.z = 0; }
                if (this.color === undefined) { this.color = 0; }
                if (this.diameter === undefined) { this.diameter = null; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.color = color;
                this.diameter = diameter;
            }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.color === undefined) { this.color = 0; }
            if (this.diameter === undefined) { this.diameter = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the abscissa of this source.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Returns the ordinate of this source.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Returns the elevation of this source.
     * @return {number}
     */
    public getZ(): number {
        return this.z;
    }

    /**
     * Returns the RGB color code of this source.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Returns the diameter of this source or <code>null</code> if it's not defined.
     * @return {number}
     */
    public getDiameter(): number {
        return this.diameter;
    }
}
LightSource["__class"] = "com.eteks.sweethome3d.model.LightSource";


/**
 * The aspect ratio of pictures.
 * @enum
 * @property {AspectRatio} FREE_RATIO
 * @property {AspectRatio} VIEW_3D_RATIO
 * @property {AspectRatio} RATIO_4_3
 * @property {AspectRatio} RATIO_3_2
 * @property {AspectRatio} RATIO_16_9
 * @property {AspectRatio} RATIO_2_1
 * @property {AspectRatio} RATIO_24_10
 * @property {AspectRatio} SQUARE_RATIO
 * @class
 */
enum AspectRatio {
    FREE_RATIO, VIEW_3D_RATIO, RATIO_4_3, RATIO_3_2, RATIO_16_9, RATIO_2_1, RATIO_24_10, SQUARE_RATIO
}

/** @ignore */
export class AspectRatio_$WRAPPER {
    /*private*/ value;

    constructor(protected _$ordinal: number, protected _$name: string, value) {
        if (this.value === undefined) { this.value = null; }
        this.value = value;
    }

    /**
     * Returns the value of this aspect ratio (width / height) or <code>null</code> if it's not known.
     * @return {number}
     */
    public getValue(): number {
        return this.value;
    }
    public name(): string { return this._$name; }
    public ordinal(): number { return this._$ordinal; }
    public compareTo(other: any): number { return this._$ordinal - (isNaN(other) ? other._$ordinal : other); }
}
AspectRatio["__class"] = "com.eteks.sweethome3d.model.AspectRatio";
AspectRatio["_$wrappers"] = { 0: new AspectRatio_$WRAPPER(0, "FREE_RATIO", null), 1: new AspectRatio_$WRAPPER(1, "VIEW_3D_RATIO", null), 2: new AspectRatio_$WRAPPER(2, "RATIO_4_3", 4.0 / 3), 3: new AspectRatio_$WRAPPER(3, "RATIO_3_2", 1.5), 4: new AspectRatio_$WRAPPER(4, "RATIO_16_9", 16.0 / 9), 5: new AspectRatio_$WRAPPER(5, "RATIO_2_1", 2.0 / 1.0), 6: new AspectRatio_$WRAPPER(6, "RATIO_24_10", 2.4), 7: new AspectRatio_$WRAPPER(7, "SQUARE_RATIO", 1.0) };


/**
 * Creates the bounds of a box from the coordinates of its lower and upper corners.
 * @param {number} xLower
 * @param {number} yLower
 * @param {number} zLower
 * @param {number} xUpper
 * @param {number} yUpper
 * @param {number} zUpper
 * @class
 * @author Emmanuel Puybaret
 */
export class BoxBounds {
    /*private*/ xLower: number;

    /*private*/ yLower: number;

    /*private*/ zLower: number;

    /*private*/ xUpper: number;

    /*private*/ yUpper: number;

    /*private*/ zUpper: number;

    public constructor(xLower: number, yLower: number, zLower: number, xUpper: number, yUpper: number, zUpper: number) {
        if (this.xLower === undefined) { this.xLower = 0; }
        if (this.yLower === undefined) { this.yLower = 0; }
        if (this.zLower === undefined) { this.zLower = 0; }
        if (this.xUpper === undefined) { this.xUpper = 0; }
        if (this.yUpper === undefined) { this.yUpper = 0; }
        if (this.zUpper === undefined) { this.zUpper = 0; }
        this.xLower = xLower;
        this.yLower = yLower;
        this.zLower = zLower;
        this.xUpper = xUpper;
        this.yUpper = yUpper;
        this.zUpper = zUpper;
    }

    /**
     * Returns the abscissa of the lower corner of these bounds.
     * @return {number}
     */
    public getXLower(): number {
        return this.xLower;
    }

    /**
     * Returns the ordinate of the lower corner of these bounds.
     * @return {number}
     */
    public getYLower(): number {
        return this.yLower;
    }

    /**
     * Returns the elevation of the lower corner of these bounds.
     * @return {number}
     */
    public getZLower(): number {
        return this.zLower;
    }

    /**
     * Returns the abscissa of the upper corner of these bounds.
     * @return {number}
     */
    public getXUpper(): number {
        return this.xUpper;
    }

    /**
     * Returns the ordinate of the upper corner of these bounds.
     * @return {number}
     */
    public getYUpper(): number {
        return this.yUpper;
    }

    /**
     * Returns the elevation of the upper corner of these bounds.
     * @return {number}
     */
    public getZUpper(): number {
        return this.zUpper;
    }

    /**
     * Returns <code>true</code> if these bounds are equal to <code>object</code>.
     * @param {Object} object
     * @return {boolean}
     */
    public equals(object: any): boolean {
        if (object != null && object instanceof <any>BoxBounds) {
            const bounds: BoxBounds = <BoxBounds>object;
            return bounds.xLower === this.xLower && bounds.yLower === this.yLower && bounds.zLower === this.zLower && bounds.xUpper === this.xUpper && bounds.yUpper === this.yUpper && bounds.zUpper === this.zUpper;
        }
        return false;
    }

    /**
     * Returns a hash code for these bounds.
     * @return {number}
     */
    public hashCode(): number {
        let hashCode: number = /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.xLower) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.yLower) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.zLower);
        hashCode += 31 * (/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.xUpper) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.yUpper) + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.zUpper));
        return hashCode;
    }
}
BoxBounds["__class"] = "com.eteks.sweethome3d.model.BoxBounds";


/**
 * Creates a patterns catalog.
 * @param {*[]} patterns
 * @class
 * @author Emmanuel Puybaret
 */
export class PatternsCatalog {
    /*private*/ patterns: Array<TextureImage>;

    public constructor(patterns: Array<TextureImage>) {
        if (this.patterns === undefined) { this.patterns = null; }
        this.patterns = <any>(patterns.slice(0));
    }

    /**
     * Returns the patterns list.
     * @return {*[]} a list of furniture.
     */
    public getPatterns(): Array<TextureImage> {
        return /* unmodifiableList */this.patterns.slice(0);
    }

    /**
     * Returns the count of patterns in this category.
     * @return {number}
     */
    public getPatternsCount(): number {
        return /* size */(<number>this.patterns.length);
    }

    public getPattern$int(index: number): TextureImage {
        return /* get */this.patterns[index];
    }

    public getPattern$java_lang_String(name: string): TextureImage {
        for (let index = 0; index < this.patterns.length; index++) {
            let pattern = this.patterns[index];
            {
                if (name === pattern.getName()) {
                    return pattern;
                }
            }
        }
        throw new IllegalArgumentException("No pattern with name " + name);
    }

    /**
     * Returns the pattern with a given <code>name</code>.
     * @throws IllegalArgumentException if no pattern with the given <code>name</code> exists
     * @param {string} name
     * @return {Object}
     */
    public getPattern(name?: any): TextureImage {
        if (((typeof name === 'string') || name === null)) {
            return <any>this.getPattern$java_lang_String(name);
        } else if (((typeof name === 'number') || name === null)) {
            return <any>this.getPattern$int(name);
        } else throw new Error('invalid overload');
    }
}
PatternsCatalog["__class"] = "com.eteks.sweethome3d.model.PatternsCatalog";


/**
 * Homes recorder.
 * @author Emmanuel Puybaret
 * @class
 */
interface HomeRecorder { }

export namespace HomeRecorder {

    /**
     * Recorder type used as a hint to select a home recorder.
     * @enum
     * @property {HomeRecorder.Type} DEFAULT
     * The default recorder type.
     * @property {HomeRecorder.Type} COMPRESSED
     * A recorder type able to compress home data.
     * @class
     */
    export enum Type {

        /**
         * The default recorder type.
         */
        DEFAULT,
        /**
         * A recorder type able to compress home data.
         */
        COMPRESSED
    }
}


/**
 * Application managing a list of homes displayed at screen.
 * @author Emmanuel Puybaret
 * @class
 */
export abstract class HomeApplication {
    /*private*/ homes: Array<Home>;

    /*private*/ homesChangeSupport: CollectionChangeSupport<Home>;

    /**
     * Adds the home <code>listener</code> in parameter to this application.
     * @param {Object} listener
     */
    public addHomesListener(listener: CollectionListener<Home>) {
        this.homesChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the home <code>listener</code> in parameter from this application.
     * @param {Object} listener
     */
    public removeHomesListener(listener: CollectionListener<Home>) {
        this.homesChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a new home.
     * @return {Home} a new home with wall heights equal to the one in user preferences.
     */
    public createHome(): Home {
        return new Home(this.getUserPreferences().getNewWallHeight());
    }

    /**
     * Returns a collection of the homes of this application.
     * @return {Home[]}
     */
    public getHomes(): Array<Home> {
        return /* unmodifiableList */this.homes.slice(0);
    }

    /**
     * Adds a given <code>home</code> to the homes list of this application.
     * Once the <code>home</code> is added, home listeners added
     * to this application will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Home} home
     */
    public addHome(home: Home) {
        this.homes = <any>(this.homes.slice(0));
        /* add */(this.homes.push(home) > 0);
        this.homesChangeSupport.fireCollectionChanged(home, /* size */(<number>this.homes.length) - 1, CollectionEvent.Type.ADD);
    }

    /**
     * Removes a given <code>home</code> from the homes list  of this application.
     * Once the <code>home</code> is removed, home listeners added
     * to this application will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {Home} home
     */
    public deleteHome(home: Home) {
        const index: number = this.homes.indexOf(home);
        if (index !== -1) {
            this.homes = <any>(this.homes.slice(0));
            /* remove */this.homes.splice(index, 1)[0];
            this.homesChangeSupport.fireCollectionChanged(home, index, CollectionEvent.Type.DELETE);
        }
    }

    public getHomeRecorder$(): HomeRecorder { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }

    public getHomeRecorder$com_eteks_sweethome3d_model_HomeRecorder_Type(type: HomeRecorder.Type): HomeRecorder {
        return this.getHomeRecorder$();
    }

    /**
     * Returns a recorder of a given <code>type</code> able to write and read homes.
     * Subclasses may override this method to return a recorder matching <code>type</code>.
     * @param {HomeRecorder.Type} type  a hint for the application to choose the returned recorder.
     * @return {Object} the default recorder able to write and read homes.
     */
    public getHomeRecorder(type?: any): HomeRecorder {
        if (((typeof type === 'number') || type === null)) {
            return <any>this.getHomeRecorder$com_eteks_sweethome3d_model_HomeRecorder_Type(type);
        } else if (type === undefined) {
            return <any>this.getHomeRecorder$();
        } else throw new Error('invalid overload');
    }

    /**
     * Returns user preferences.
     * @return {UserPreferences}
     */
    public abstract getUserPreferences(): any;

    /**
     * Returns the name of this application. Default implementation returns <i>Sweet Home 3D</i>.
     * @return {string}
     */
    public getName(): string {
        return "Sweet Home 3D";
    }

    /**
     * Returns information about the version of this application.
     * Default implementation returns an empty string.
     * @return {string}
     */
    public getVersion(): string {
        return "";
    }

    /**
     * Returns the id of this application.
     * Default implementation returns null.
     * @return {string}
     */
    public getId(): string {
        return null;
    }

    constructor() {
        this.homes = <any>([]);
        this.homesChangeSupport = <any>(new CollectionChangeSupport<Home>(this));
    }
}
HomeApplication["__class"] = "com.eteks.sweethome3d.model.HomeApplication";


/**
 * A factory that specifies how to create the 3D objects from Sweet Home 3D model objects.
 * @author Emmanuel Puybaret
 * @class
 */
interface Object3DFactory {
    /**
     * Returns the 3D object matching a given <code>item</code>.
     * @param {Home} home           the home of an item
     * @param {Object} item           a selectable item of a home
     * @param {UserPreferences} preferences    preferences of the application
     * @param {Object} context        context used to distinguish the creation of a 3D object from an other one.
     * @param {boolean} waitForLoading if <code>true</code> all resources used by the returned object should be available
     * @return {Object}
     */
    createObject3D(home?: any, item?: any, preferences?: any, context?: any, waitForLoading?: any): any;
}

/**
 * A view that displays Sweet Home 3D help.
 * @author Emmanuel Puybaret
 * @class
 */
interface HelpView extends View {
    /**
     * Displays this pane in a frame.
     */
    displayView();
}

/**
 * A view able to transfer data.
 * @author Emmanuel Puybaret
 * @class
 */
interface TransferableView extends View {
    /**
     * Returns data at given types for transfer purpose.
     * Caution : this method can be called from a separate thread.
     * @param {TransferableView.DataType} dataType
     * @return {Object}
     */
    createTransferData(dataType: TransferableView.DataType): any;
}

export namespace TransferableView {

    /**
     * Data types.
     * @class
     */
    export class DataType {
        public static PLAN_IMAGE: TransferableView.DataType; public static PLAN_IMAGE_$LI$(): TransferableView.DataType { if (DataType.PLAN_IMAGE == null) { DataType.PLAN_IMAGE = new TransferableView.DataType("PLAN_IMAGE"); } return DataType.PLAN_IMAGE; }

        public static FURNITURE_LIST: TransferableView.DataType; public static FURNITURE_LIST_$LI$(): TransferableView.DataType { if (DataType.FURNITURE_LIST == null) { DataType.FURNITURE_LIST = new TransferableView.DataType("FURNITURE_LIST"); } return DataType.FURNITURE_LIST; }

        __name: string;

        constructor(name: string) {
            if (this.__name === undefined) { this.__name = null; }
            this.__name = name;
        }

        public name(): string {
            return this.__name;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.__name;
        }
    }
    DataType["__class"] = "com.eteks.sweethome3d.viewcontroller.TransferableView.DataType";


    /**
     * An observer to follow the data created for transfer.
     * @class
     */
    export interface TransferObserver {
        dataReady(data: any[]);
    }
}


/**
 * A view that edits the texture of its controller.
 * @author Emmanuel Puybaret
 * @class
 */
interface TextureChoiceView extends View {
    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected texture from catalog or not.
     * @return {boolean} <code>true</code> if user confirmed to delete.
     */
    confirmDeleteSelectedCatalogTexture(): boolean;
}

/**
 * A view that displays the different steps that helps the user to import a piece of furniture.
 * @author Emmanuel Puybaret
 * @class
 */
interface ImportedFurnitureWizardStepsView extends View {
    /**
     * Returns the icon content of the chosen piece.
     * @return {Object}
     */
    getIcon(): Content;
}

/**
 * Creates the controller of user preferences view.
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {HomeController} homeController
 * @class
 * @author Emmanuel Puybaret
 */
export class UserPreferencesController implements Controller {
    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ homeController: HomeController;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ userPreferencesView: DialogView;

    /*private*/ language: string;

    /*private*/ unit: any;

    /*private*/ currency: string;

    /*private*/ valueAddedTaxEnabled: boolean;

    /*private*/ furnitureCatalogViewedInTree: boolean;

    /*private*/ navigationPanelVisible: boolean;

    /*private*/ editingIn3DViewEnabled: boolean;

    /*private*/ aerialViewCenteredOnSelectionEnabled: boolean;

    /*private*/ observerCameraSelectedAtChange: boolean;

    /*private*/ magnetismEnabled: boolean;

    /*private*/ rulersVisible: boolean;

    /*private*/ gridVisible: boolean;

    /*private*/ defaultFontName: string;

    /*private*/ furnitureViewedFromTop: boolean;

    /*private*/ furnitureModelIconSize: number;

    /*private*/ roomFloorColoredOrTextured: boolean;

    /*private*/ wallPattern: TextureImage;

    /*private*/ newWallPattern: TextureImage;

    /*private*/ newWallThickness: number;

    /*private*/ newWallHeight: number;

    /*private*/ newFloorThickness: number;

    /*private*/ checkUpdatesEnabled: boolean;

    /*private*/ autoSaveDelayForRecovery: number;

    /*private*/ autoSaveForRecoveryEnabled: boolean;

    public constructor(preferences?: any, viewFactory?: any, contentManager?: any, homeController?: any) {
        if (((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && ((homeController != null && homeController instanceof <any>HomeController) || homeController === null)) {
            let __args = arguments;
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.homeController === undefined) { this.homeController = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.userPreferencesView === undefined) { this.userPreferencesView = null; }
            if (this.language === undefined) { this.language = null; }
            if (this.unit === undefined) { this.unit = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.valueAddedTaxEnabled === undefined) { this.valueAddedTaxEnabled = false; }
            if (this.furnitureCatalogViewedInTree === undefined) { this.furnitureCatalogViewedInTree = false; }
            if (this.navigationPanelVisible === undefined) { this.navigationPanelVisible = false; }
            if (this.editingIn3DViewEnabled === undefined) { this.editingIn3DViewEnabled = false; }
            if (this.aerialViewCenteredOnSelectionEnabled === undefined) { this.aerialViewCenteredOnSelectionEnabled = false; }
            if (this.observerCameraSelectedAtChange === undefined) { this.observerCameraSelectedAtChange = false; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.rulersVisible === undefined) { this.rulersVisible = false; }
            if (this.gridVisible === undefined) { this.gridVisible = false; }
            if (this.defaultFontName === undefined) { this.defaultFontName = null; }
            if (this.furnitureViewedFromTop === undefined) { this.furnitureViewedFromTop = false; }
            if (this.furnitureModelIconSize === undefined) { this.furnitureModelIconSize = 0; }
            if (this.roomFloorColoredOrTextured === undefined) { this.roomFloorColoredOrTextured = false; }
            if (this.wallPattern === undefined) { this.wallPattern = null; }
            if (this.newWallPattern === undefined) { this.newWallPattern = null; }
            if (this.newWallThickness === undefined) { this.newWallThickness = 0; }
            if (this.newWallHeight === undefined) { this.newWallHeight = 0; }
            if (this.newFloorThickness === undefined) { this.newFloorThickness = 0; }
            if (this.checkUpdatesEnabled === undefined) { this.checkUpdatesEnabled = false; }
            if (this.autoSaveDelayForRecovery === undefined) { this.autoSaveDelayForRecovery = 0; }
            if (this.autoSaveForRecoveryEnabled === undefined) { this.autoSaveForRecoveryEnabled = false; }
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.homeController = homeController;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.updateProperties();
        } else if (((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && homeController === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let homeController: any = null;
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.homeController === undefined) { this.homeController = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.userPreferencesView === undefined) { this.userPreferencesView = null; }
                if (this.language === undefined) { this.language = null; }
                if (this.unit === undefined) { this.unit = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.valueAddedTaxEnabled === undefined) { this.valueAddedTaxEnabled = false; }
                if (this.furnitureCatalogViewedInTree === undefined) { this.furnitureCatalogViewedInTree = false; }
                if (this.navigationPanelVisible === undefined) { this.navigationPanelVisible = false; }
                if (this.editingIn3DViewEnabled === undefined) { this.editingIn3DViewEnabled = false; }
                if (this.aerialViewCenteredOnSelectionEnabled === undefined) { this.aerialViewCenteredOnSelectionEnabled = false; }
                if (this.observerCameraSelectedAtChange === undefined) { this.observerCameraSelectedAtChange = false; }
                if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
                if (this.rulersVisible === undefined) { this.rulersVisible = false; }
                if (this.gridVisible === undefined) { this.gridVisible = false; }
                if (this.defaultFontName === undefined) { this.defaultFontName = null; }
                if (this.furnitureViewedFromTop === undefined) { this.furnitureViewedFromTop = false; }
                if (this.furnitureModelIconSize === undefined) { this.furnitureModelIconSize = 0; }
                if (this.roomFloorColoredOrTextured === undefined) { this.roomFloorColoredOrTextured = false; }
                if (this.wallPattern === undefined) { this.wallPattern = null; }
                if (this.newWallPattern === undefined) { this.newWallPattern = null; }
                if (this.newWallThickness === undefined) { this.newWallThickness = 0; }
                if (this.newWallHeight === undefined) { this.newWallHeight = 0; }
                if (this.newFloorThickness === undefined) { this.newFloorThickness = 0; }
                if (this.checkUpdatesEnabled === undefined) { this.checkUpdatesEnabled = false; }
                if (this.autoSaveDelayForRecovery === undefined) { this.autoSaveDelayForRecovery = 0; }
                if (this.autoSaveForRecoveryEnabled === undefined) { this.autoSaveForRecoveryEnabled = false; }
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.homeController = homeController;
                this.propertyChangeSupport = new PropertyChangeSupport(this);
                this.updateProperties();
            }
            this.preferences = preferences; this.viewFactory = viewFactory; this.propertyChangeSupport = new PropertyChangeSupport(this); this.updateProperties();
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.userPreferencesView == null) {
            this.userPreferencesView = this.viewFactory.createUserPreferencesView(this.preferences, this);
        }
        return this.userPreferencesView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates preferences properties edited by this controller.
     */
    updateProperties() {
        this.setLanguage(this.preferences.getLanguage());
        this.setUnit(this.preferences.getLengthUnit());
        this.setCurrency(this.preferences.getCurrency());
        this.setValueAddedTaxEnabled(this.preferences.isValueAddedTaxEnabled());
        this.setFurnitureCatalogViewedInTree(this.preferences.isFurnitureCatalogViewedInTree());
        this.setNavigationPanelVisible(this.preferences.isNavigationPanelVisible());
        this.setEditingIn3DViewEnabled(this.preferences.isEditingIn3DViewEnabled());
        this.setAerialViewCenteredOnSelectionEnabled(this.preferences.isAerialViewCenteredOnSelectionEnabled());
        this.setObserverCameraSelectedAtChange(this.preferences.isObserverCameraSelectedAtChange());
        this.setMagnetismEnabled(this.preferences.isMagnetismEnabled());
        this.setRulersVisible(this.preferences.isRulersVisible());
        this.setGridVisible(this.preferences.isGridVisible());
        this.setDefaultFontName(this.preferences.getDefaultFontName());
        this.setFurnitureViewedFromTop(this.preferences.isFurnitureViewedFromTop());
        this.setFurnitureModelIconSize(this.preferences.getFurnitureModelIconSize());
        this.setRoomFloorColoredOrTextured(this.preferences.isRoomFloorColoredOrTextured());
        this.setWallPattern(this.preferences.getWallPattern());
        this.setNewWallPattern(this.preferences.getNewWallPattern());
        const minimumLength: number = this.getUnit().getMinimumLength();
        const maximumLength: number = this.getUnit().getMaximumLength();
        this.setNewWallThickness(Math.min(Math.max(minimumLength, this.preferences.getNewWallThickness()), maximumLength / 10));
        this.setNewWallHeight(Math.min(Math.max(minimumLength, this.preferences.getNewWallHeight()), maximumLength));
        this.setNewFloorThickness(Math.min(Math.max(minimumLength, this.preferences.getNewFloorThickness()), maximumLength / 10));
        this.setCheckUpdatesEnabled(this.preferences.isCheckUpdatesEnabled());
        this.setAutoSaveDelayForRecovery(this.preferences.getAutoSaveDelayForRecovery());
        this.setAutoSaveForRecoveryEnabled(this.preferences.getAutoSaveDelayForRecovery() > 0);
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * The implementation of this method always returns <code>true</code> except for <code>LANGUAGE</code> if it's not editable.
     * @param {string} property
     * @return {boolean}
     */
    public isPropertyEditable(property: any): boolean {
        switch ((property)) {
            case "LANGUAGE":
                return this.preferences.isLanguageEditable();
            default:
                return true;
        }
    }

    /**
     * Sets the edited language.
     * @param {string} language
     */
    public setLanguage(language: string) {
        if (language !== this.language) {
            const oldLanguage: string = this.language;
            this.language = language;
            this.propertyChangeSupport.firePropertyChange(/* name */"LANGUAGE", oldLanguage, language);
        }
    }

    /**
     * Returns the edited language.
     * @return {string}
     */
    public getLanguage(): string {
        return this.language;
    }

    /**
     * Sets the edited unit.
     * @param {LengthUnit} unit
     */
    public setUnit(unit: any) {
        if (unit !== this.unit) {
            const oldUnit: any = this.unit;
            this.unit = unit;
            this.propertyChangeSupport.firePropertyChange(/* name */"UNIT", oldUnit, unit);
        }
    }

    /**
     * Returns the edited unit.
     * @return {LengthUnit}
     */
    public getUnit(): any {
        return this.unit;
    }

    /**
     * Sets the edited currency.
     * @param {string} currency
     */
    public setCurrency(currency: string) {
        if (currency !== this.currency) {
            const oldCurrency: string = this.currency;
            this.currency = currency;
            this.propertyChangeSupport.firePropertyChange(/* name */"CURRENCY", oldCurrency, currency);
            if (currency == null) {
                this.setValueAddedTaxEnabled(false);
            }
        }
    }

    /**
     * Returns the edited currency.
     * @return {string}
     */
    public getCurrency(): string {
        return this.currency;
    }

    /**
     * Sets whether Value Added Tax should be taken in account in prices.
     * @param {boolean} valueAddedTaxEnabled
     */
    public setValueAddedTaxEnabled(valueAddedTaxEnabled: boolean) {
        if (this.valueAddedTaxEnabled !== valueAddedTaxEnabled) {
            this.valueAddedTaxEnabled = valueAddedTaxEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"VALUE_ADDED_TAX_ENABLED", !valueAddedTaxEnabled, valueAddedTaxEnabled);
        }
    }

    /**
     * Returns <code>true</code> if Value Added Tax should be taken in account in prices.
     * @return {boolean}
     */
    public isValueAddedTaxEnabled(): boolean {
        return this.valueAddedTaxEnabled;
    }

    /**
     * Sets whether the furniture catalog should be viewed in a tree or a different way.
     * @param {boolean} furnitureCatalogViewedInTree
     */
    public setFurnitureCatalogViewedInTree(furnitureCatalogViewedInTree: boolean) {
        if (this.furnitureCatalogViewedInTree !== furnitureCatalogViewedInTree) {
            this.furnitureCatalogViewedInTree = furnitureCatalogViewedInTree;
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_CATALOG_VIEWED_IN_TREE", !furnitureCatalogViewedInTree, furnitureCatalogViewedInTree);
        }
    }

    /**
     * Returns <code>true</code> if furniture catalog should be viewed in a tree.
     * @return {boolean}
     */
    public isFurnitureCatalogViewedInTree(): boolean {
        return this.furnitureCatalogViewedInTree;
    }

    /**
     * Sets whether the navigation panel should be displayed or not.
     * @param {boolean} navigationPanelVisible
     */
    public setNavigationPanelVisible(navigationPanelVisible: boolean) {
        if (this.navigationPanelVisible !== navigationPanelVisible) {
            this.navigationPanelVisible = navigationPanelVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAVIGATION_PANEL_VISIBLE", !navigationPanelVisible, navigationPanelVisible);
        }
    }

    /**
     * Returns <code>true</code> if the navigation panel should be displayed.
     * @return {boolean}
     */
    public isNavigationPanelVisible(): boolean {
        return this.navigationPanelVisible;
    }

    /**
     * Sets whether interactive editing in 3D view is enabled or not.
     * @param {boolean} editingIn3DViewEnabled
     */
    public setEditingIn3DViewEnabled(editingIn3DViewEnabled: boolean) {
        if (editingIn3DViewEnabled !== this.editingIn3DViewEnabled) {
            this.editingIn3DViewEnabled = editingIn3DViewEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"EDITING_IN_3D_VIEW_ENABLED", !editingIn3DViewEnabled, editingIn3DViewEnabled);
        }
    }

    /**
     * Returns whether interactive editing in 3D view is enabled or not.
     * @return {boolean}
     */
    public isEditingIn3DViewEnabled(): boolean {
        return this.editingIn3DViewEnabled;
    }

    /**
     * Sets whether aerial view should be centered on selection or not.
     * @param {boolean} aerialViewCenteredOnSelectionEnabled
     */
    public setAerialViewCenteredOnSelectionEnabled(aerialViewCenteredOnSelectionEnabled: boolean) {
        if (aerialViewCenteredOnSelectionEnabled !== this.aerialViewCenteredOnSelectionEnabled) {
            this.aerialViewCenteredOnSelectionEnabled = aerialViewCenteredOnSelectionEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"AERIAL_VIEW_CENTERED_ON_SELECTION_ENABLED", !aerialViewCenteredOnSelectionEnabled, aerialViewCenteredOnSelectionEnabled);
        }
    }

    /**
     * Returns whether aerial view should be centered on selection or not.
     * @return {boolean}
     */
    public isAerialViewCenteredOnSelectionEnabled(): boolean {
        return this.aerialViewCenteredOnSelectionEnabled;
    }

    /**
     * Sets whether the observer camera should be selected at each change.
     * @param {boolean} observerCameraSelectedAtChange
     */
    public setObserverCameraSelectedAtChange(observerCameraSelectedAtChange: boolean) {
        if (observerCameraSelectedAtChange !== this.observerCameraSelectedAtChange) {
            this.observerCameraSelectedAtChange = observerCameraSelectedAtChange;
            this.propertyChangeSupport.firePropertyChange(/* name */"OBSERVER_CAMERA_SELECTED_AT_CHANGE", !observerCameraSelectedAtChange, observerCameraSelectedAtChange);
        }
    }

    /**
     * Returns whether the observer camera should be selected at each change.
     * @return {boolean}
     */
    public isObserverCameraSelectedAtChange(): boolean {
        return this.observerCameraSelectedAtChange;
    }

    /**
     * Sets whether magnetism is enabled or not.
     * @param {boolean} magnetismEnabled
     */
    public setMagnetismEnabled(magnetismEnabled: boolean) {
        if (magnetismEnabled !== this.magnetismEnabled) {
            this.magnetismEnabled = magnetismEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"MAGNETISM_ENABLED", !magnetismEnabled, magnetismEnabled);
        }
    }

    /**
     * Returns whether magnetism is enabled or not.
     * @return {boolean}
     */
    public isMagnetismEnabled(): boolean {
        return this.magnetismEnabled;
    }

    /**
     * Sets whether rulers are visible or not.
     * @param {boolean} rulersVisible
     */
    public setRulersVisible(rulersVisible: boolean) {
        if (rulersVisible !== this.rulersVisible) {
            this.rulersVisible = rulersVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"RULERS_VISIBLE", !rulersVisible, rulersVisible);
        }
    }

    /**
     * Returns whether rulers are visible or not.
     * @return {boolean}
     */
    public isRulersVisible(): boolean {
        return this.rulersVisible;
    }

    /**
     * Sets whether grid is visible or not.
     * @param {boolean} gridVisible
     */
    public setGridVisible(gridVisible: boolean) {
        if (gridVisible !== this.gridVisible) {
            this.gridVisible = gridVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"GRID_VISIBLE", !gridVisible, gridVisible);
        }
    }

    /**
     * Returns whether grid is visible or not.
     * @return {boolean}
     */
    public isGridVisible(): boolean {
        return this.gridVisible;
    }

    /**
     * Sets the name of the font that should be used by default.
     * @param {string} defaultFontName
     */
    public setDefaultFontName(defaultFontName: string) {
        if (defaultFontName !== this.defaultFontName && (defaultFontName == null || !(defaultFontName === this.defaultFontName))) {
            const oldName: string = this.defaultFontName;
            this.defaultFontName = defaultFontName;
            this.propertyChangeSupport.firePropertyChange(/* name */"DEFAULT_FONT_NAME", oldName, defaultFontName);
        }
    }

    /**
     * Returns the name of the font that should be used by default or <code>null</code>
     * if the default font should be the default one in the application.
     * @return {string}
     */
    public getDefaultFontName(): string {
        return this.defaultFontName;
    }

    /**
     * Sets how furniture should be displayed in plan.
     * @param {boolean} furnitureViewedFromTop
     */
    public setFurnitureViewedFromTop(furnitureViewedFromTop: boolean) {
        if (this.furnitureViewedFromTop !== furnitureViewedFromTop) {
            this.furnitureViewedFromTop = furnitureViewedFromTop;
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_VIEWED_FROM_TOP", !furnitureViewedFromTop, furnitureViewedFromTop);
        }
    }

    /**
     * Returns how furniture should be displayed in plan.
     * @return {boolean}
     */
    public isFurnitureViewedFromTop(): boolean {
        return this.furnitureViewedFromTop;
    }

    /**
     * Sets the size used to generate icons of furniture viewed from top.
     * @param {number} furnitureModelIconSize
     */
    public setFurnitureModelIconSize(furnitureModelIconSize: number) {
        if (furnitureModelIconSize !== this.furnitureModelIconSize) {
            const oldSize: number = this.furnitureModelIconSize;
            this.furnitureModelIconSize = furnitureModelIconSize;
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_MODEL_ICON_SIZE", oldSize, furnitureModelIconSize);
        }
    }

    /**
     * Returns the size used to generate icons of furniture viewed from top.
     * @return {number}
     */
    public getFurnitureModelIconSize(): number {
        return this.furnitureModelIconSize;
    }

    /**
     * Sets whether floor texture is visible in plan or not.
     * @param {boolean} floorTextureVisible
     */
    public setRoomFloorColoredOrTextured(floorTextureVisible: boolean) {
        if (this.roomFloorColoredOrTextured !== floorTextureVisible) {
            this.roomFloorColoredOrTextured = floorTextureVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"ROOM_FLOOR_COLORED_OR_TEXTURED", !floorTextureVisible, floorTextureVisible);
        }
    }

    /**
     * Returns <code>true</code> if floor texture is visible in plan.
     * @return {boolean}
     */
    public isRoomFloorColoredOrTextured(): boolean {
        return this.roomFloorColoredOrTextured;
    }

    /**
     * Sets default walls top pattern in plan, and notifies
     * listeners of this change.
     * @param {Object} wallPattern
     */
    public setWallPattern(wallPattern: TextureImage) {
        if (this.wallPattern !== wallPattern) {
            const oldWallPattern: TextureImage = this.wallPattern;
            this.wallPattern = wallPattern;
            this.propertyChangeSupport.firePropertyChange(/* name */"WALL_PATTERN", oldWallPattern, wallPattern);
        }
    }

    /**
     * Returns the default walls top pattern in plan.
     * @return {Object}
     */
    public getWallPattern(): TextureImage {
        return this.wallPattern;
    }

    /**
     * Sets the edited new wall top pattern in plan, and notifies
     * listeners of this change.
     * @param {Object} newWallPattern
     */
    public setNewWallPattern(newWallPattern: TextureImage) {
        if (this.newWallPattern !== newWallPattern) {
            const oldNewWallPattern: TextureImage = this.newWallPattern;
            this.newWallPattern = newWallPattern;
            this.propertyChangeSupport.firePropertyChange(/* name */"NEW_WALL_PATTERN", oldNewWallPattern, newWallPattern);
        }
    }

    /**
     * Returns the edited new wall top pattern in plan.
     * @return {Object}
     */
    public getNewWallPattern(): TextureImage {
        return this.newWallPattern;
    }

    /**
     * Sets the edited new wall thickness.
     * @param {number} newWallThickness
     */
    public setNewWallThickness(newWallThickness: number) {
        if (newWallThickness !== this.newWallThickness) {
            const oldNewWallThickness: number = this.newWallThickness;
            this.newWallThickness = newWallThickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"NEW_WALL_THICKNESS", oldNewWallThickness, newWallThickness);
        }
    }

    /**
     * Returns the edited new wall thickness.
     * @return {number}
     */
    public getNewWallThickness(): number {
        return this.newWallThickness;
    }

    /**
     * Sets the edited new wall height.
     * @param {number} newWallHeight
     */
    public setNewWallHeight(newWallHeight: number) {
        if (newWallHeight !== this.newWallHeight) {
            const oldNewWallHeight: number = this.newWallHeight;
            this.newWallHeight = newWallHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"NEW_WALL_HEIGHT", oldNewWallHeight, newWallHeight);
        }
    }

    /**
     * Returns the edited new wall height.
     * @return {number}
     */
    public getNewWallHeight(): number {
        return this.newWallHeight;
    }

    /**
     * Sets the edited new floor thickness.
     * @param {number} newFloorThickness
     */
    public setNewFloorThickness(newFloorThickness: number) {
        if (newFloorThickness !== this.newFloorThickness) {
            const oldNewFloorThickness: number = this.newFloorThickness;
            this.newFloorThickness = newFloorThickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"NEW_FLOOR_THICKNESS", oldNewFloorThickness, newFloorThickness);
        }
    }

    /**
     * Returns the edited new floor thickness.
     * @return {number}
     */
    public getNewFloorThickness(): number {
        return this.newFloorThickness;
    }

    /**
     * Sets whether updates should be checked or not.
     * @param {boolean} updatesChecked
     */
    public setCheckUpdatesEnabled(updatesChecked: boolean) {
        if (updatesChecked !== this.checkUpdatesEnabled) {
            this.checkUpdatesEnabled = updatesChecked;
            this.propertyChangeSupport.firePropertyChange(/* name */"CHECK_UPDATES_ENABLED", !updatesChecked, updatesChecked);
        }
    }

    /**
     * Returns <code>true</code> if updates should be checked.
     * @return {boolean}
     */
    public isCheckUpdatesEnabled(): boolean {
        return this.checkUpdatesEnabled;
    }

    /**
     * Sets the edited auto recovery save delay.
     * @param {number} autoSaveDelayForRecovery
     */
    public setAutoSaveDelayForRecovery(autoSaveDelayForRecovery: number) {
        if (autoSaveDelayForRecovery !== this.autoSaveDelayForRecovery) {
            const oldAutoSaveDelayForRecovery: number = this.autoSaveDelayForRecovery;
            this.autoSaveDelayForRecovery = autoSaveDelayForRecovery;
            this.propertyChangeSupport.firePropertyChange(/* name */"AUTO_SAVE_DELAY_FOR_RECOVERY", oldAutoSaveDelayForRecovery, autoSaveDelayForRecovery);
        }
    }

    /**
     * Returns the edited auto recovery save delay.
     * @return {number}
     */
    public getAutoSaveDelayForRecovery(): number {
        return this.autoSaveDelayForRecovery;
    }

    /**
     * Sets whether auto recovery save is enabled or not.
     * @param {boolean} autoSaveForRecoveryEnabled
     */
    public setAutoSaveForRecoveryEnabled(autoSaveForRecoveryEnabled: boolean) {
        if (autoSaveForRecoveryEnabled !== this.autoSaveForRecoveryEnabled) {
            this.autoSaveForRecoveryEnabled = autoSaveForRecoveryEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"AUTO_SAVE_FOR_RECOVERY_ENABLED", !autoSaveForRecoveryEnabled, autoSaveForRecoveryEnabled);
        }
    }

    /**
     * Returns <code>true</code> if auto recovery save is enabled.
     * @return {boolean}
     */
    public isAutoSaveForRecoveryEnabled(): boolean {
        return this.autoSaveForRecoveryEnabled;
    }

    /**
     * Resets the displayed flags of action tips.
     */
    public resetDisplayedActionTips() {
        this.preferences.resetIgnoredActionTips();
    }

    /**
     * Controls the modification of user preferences.
     */
    public modifyUserPreferences() {
        this.preferences.setLanguage(this.getLanguage());
        this.preferences.setUnit(this.getUnit());
        this.preferences.setCurrency(this.getCurrency());
        this.preferences.setValueAddedTaxEnabled(this.isValueAddedTaxEnabled());
        this.preferences.setFurnitureCatalogViewedInTree(this.isFurnitureCatalogViewedInTree());
        this.preferences.setNavigationPanelVisible(this.isNavigationPanelVisible());
        this.preferences.setEditingIn3DViewEnabled(this.isEditingIn3DViewEnabled());
        this.preferences.setAerialViewCenteredOnSelectionEnabled(this.isAerialViewCenteredOnSelectionEnabled());
        this.preferences.setObserverCameraSelectedAtChange(this.isObserverCameraSelectedAtChange());
        this.preferences.setMagnetismEnabled(this.isMagnetismEnabled());
        this.preferences.setRulersVisible(this.isRulersVisible());
        this.preferences.setGridVisible(this.isGridVisible());
        this.preferences.setDefaultFontName(this.getDefaultFontName());
        this.preferences.setFurnitureViewedFromTop(this.isFurnitureViewedFromTop());
        this.preferences.setFurnitureModelIconSize(this.getFurnitureModelIconSize());
        this.preferences.setFloorColoredOrTextured(this.isRoomFloorColoredOrTextured());
        this.preferences.setWallPattern(this.getWallPattern());
        this.preferences.setNewWallPattern(this.getNewWallPattern());
        this.preferences.setNewWallThickness(this.getNewWallThickness());
        this.preferences.setNewWallHeight(this.getNewWallHeight());
        this.preferences.setNewFloorThickness(this.getNewFloorThickness());
        this.preferences.setCheckUpdatesEnabled(this.isCheckUpdatesEnabled());
        this.preferences.setAutoSaveDelayForRecovery(this.isAutoSaveForRecoveryEnabled() ? this.getAutoSaveDelayForRecovery() : 0);
    }
}
UserPreferencesController["__class"] = "com.eteks.sweethome3d.viewcontroller.UserPreferencesController";
UserPreferencesController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



/**
 * A view able to export data in an output stream.
 * @author Emmanuel Puybaret
 * @class
 */
interface ExportableView extends View {
    /**
     * Returns <code>true</code> if this view is able to export at the given format.
     * @param {ExportableView.FormatType} formatType
     * @return {boolean}
     */
    isFormatTypeSupported(formatType: ExportableView.FormatType): boolean;
}

export namespace ExportableView {

    /**
     * Data types.
     * @class
     */
    export class FormatType {
        public static SVG: ExportableView.FormatType; public static SVG_$LI$(): ExportableView.FormatType { if (FormatType.SVG == null) { FormatType.SVG = new ExportableView.FormatType("SVG"); } return FormatType.SVG; }

        public static CSV: ExportableView.FormatType; public static CSV_$LI$(): ExportableView.FormatType { if (FormatType.CSV == null) { FormatType.CSV = new ExportableView.FormatType("CSV"); } return FormatType.CSV; }

        __name: string;

        constructor(name: string) {
            if (this.__name === undefined) { this.__name = null; }
            this.__name = name;
        }

        public name(): string {
            return this.__name;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.__name;
        }
    }
    FormatType["__class"] = "com.eteks.sweethome3d.viewcontroller.ExportableView.FormatType";

}


/**
 * A MVC controller for model materials choice.
 * @author Emmanuel Puybaret
 * @param {string} title
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 */
export class ModelMaterialsController implements Controller {
    /*private*/ title: string;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ materialsChoiceView: View;

    /*private*/ textureController: TextureChoiceController;

    /*private*/ model: Content;

    /*private*/ modelCreator: string;

    /*private*/ modelWidth: number;

    /*private*/ modelDepth: number;

    /*private*/ modelHeight: number;

    /*private*/ modelRotation: number[][];

    /*private*/ modelTransformations: Transformation[];

    /*private*/ modelFlags: number;

    /*private*/ materials: HomeMaterial[];

    public constructor(title: string, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager) {
        if (this.title === undefined) { this.title = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.materialsChoiceView === undefined) { this.materialsChoiceView = null; }
        if (this.textureController === undefined) { this.textureController = null; }
        if (this.model === undefined) { this.model = null; }
        if (this.modelCreator === undefined) { this.modelCreator = null; }
        if (this.modelWidth === undefined) { this.modelWidth = 0; }
        if (this.modelDepth === undefined) { this.modelDepth = 0; }
        if (this.modelHeight === undefined) { this.modelHeight = 0; }
        if (this.modelRotation === undefined) { this.modelRotation = null; }
        if (this.modelTransformations === undefined) { this.modelTransformations = null; }
        if (this.modelFlags === undefined) { this.modelFlags = 0; }
        if (this.materials === undefined) { this.materials = null; }
        this.title = title;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): View {
        if (this.materialsChoiceView == null) {
            this.materialsChoiceView = this.viewFactory.createModelMaterialsView(this.preferences, this);
        }
        return this.materialsChoiceView;
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Sets the 3D model which materials are displayed by the view
     * and fires a <code>PropertyChangeEvent</code>.
     * @param {Object} model
     */
    public setModel(model: Content) {
        if (this.model !== model) {
            const oldModel: Content = this.model;
            this.model = model;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL", oldModel, model);
        }
    }

    /**
     * Returns the 3D model which materials are displayed by the view.
     * @return {Object}
     */
    public getModel(): Content {
        return this.model;
    }

    /**
     * Sets the creator of the 3D model displayed by the view.
     * @param {string} modelCreator
     */
    public setModelCreator(modelCreator: string) {
        this.modelCreator = modelCreator;
    }

    /**
     * Returns the creator of the 3D model displayed by the view.
     * @return {string}
     */
    public getModelCreator(): string {
        return this.modelCreator;
    }

    /**
     * Sets the rotation of the 3D model used to preview materials change.
     * @param {float[][]} modelRotation
     * @private
     */
    setModelRotation(modelRotation: number[][]) {
        this.modelRotation = modelRotation;
    }

    /**
     * Returns the rotation of the 3D model used to preview materials change.
     * @return {float[][]}
     */
    public getModelRotation(): number[][] {
        return this.modelRotation;
    }

    /**
     * Sets the transformations of the 3D model used to preview materials change.
     * @param {com.eteks.sweethome3d.model.Transformation[]} modelTransformations
     * @private
     */
    setModelTransformations(modelTransformations: Transformation[]) {
        this.modelTransformations = modelTransformations;
    }

    /**
     * Returns the transformations of the 3D model used to preview materials change.
     * @return {com.eteks.sweethome3d.model.Transformation[]}
     */
    public getModelTransformations(): Transformation[] {
        return this.modelTransformations;
    }

    /**
     * Sets the size of the 3D model used to preview materials change.
     * @param {number} width
     * @param {number} depth
     * @param {number} height
     * @private
     */
    setModelSize(width: number, depth: number, height: number) {
        this.modelWidth = width;
        this.modelDepth = depth;
        this.modelHeight = height;
    }

    /**
     * Returns the width of the 3D model used to preview materials change.
     * @return {number}
     */
    public getModelWidth(): number {
        return this.modelWidth;
    }

    /**
     * Returns the depth of the 3D model used to preview materials change.
     * @return {number}
     */
    public getModelDepth(): number {
        return this.modelDepth;
    }

    /**
     * Returns the height of the 3D model used to preview materials change.
     * @return {number}
     */
    public getModelHeight(): number {
        return this.modelHeight;
    }

    /**
     * Sets whether the 3D model used to preview materials change should show back face.
     * @deprecated Prefer use {@link #setModelFlags} with {@link PieceOfFurniture#SHOW_BACK_FACE} flag.
     * @param {boolean} backFaceShown
     * @private
     */
    setBackFaceShown(backFaceShown: boolean) {
        this.setModelFlags((this.getModelFlags() & ~PieceOfFurniture.SHOW_BACK_FACE) | (backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0));
    }

    /**
     * Returns <code>true</code> if the 3D model used to preview materials change should show back face.
     * @return {boolean}
     */
    public isBackFaceShown(): boolean {
        return (this.modelFlags & PieceOfFurniture.SHOW_BACK_FACE) === PieceOfFurniture.SHOW_BACK_FACE;
    }

    /**
     * Sets the flags applied to the 3D model used to preview materials change.
     * @param {number} modelFlags
     */
    public setModelFlags(modelFlags: number) {
        this.modelFlags = modelFlags;
    }

    /**
     * Returns the flags applied to the 3D model used to preview materials change.
     * @return {number}
     */
    public getModelFlags(): number {
        return this.modelFlags;
    }

    /**
     * Sets the materials displayed by view and fires a <code>PropertyChangeEvent</code>.
     * @param {com.eteks.sweethome3d.model.HomeMaterial[]} materials
     */
    public setMaterials(materials: HomeMaterial[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(this.materials, materials)) {
            const oldMaterials: HomeMaterial[] = this.materials;
            this.materials = materials;
            this.propertyChangeSupport.firePropertyChange(/* name */"MATERIALS", oldMaterials, materials);
        }
    }

    /**
     * Returns the materials displayed by view.
     * @return {com.eteks.sweethome3d.model.HomeMaterial[]}
     */
    public getMaterials(): HomeMaterial[] {
        return this.materials;
    }

    /**
     * Returns the text that should be displayed as materials choice dialog title.
     * @return {string}
     */
    public getDialogTitle(): string {
        return this.title;
    }

    /**
     * Returns the texture controller of the model materials.
     * @return {TextureChoiceController}
     */
    public getTextureController(): TextureChoiceController {
        if (this.textureController == null) {
            this.textureController = new TextureChoiceController(this.preferences.getLocalizedString(ModelMaterialsController, "textureTitle"), this.preferences, this.viewFactory, this.contentManager);
        }
        return this.textureController;
    }
}
ModelMaterialsController["__class"] = "com.eteks.sweethome3d.viewcontroller.ModelMaterialsController";
ModelMaterialsController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



/**
 * The view that displays the plan of a home.
 * @author Emmanuel Puybaret
 * @class
 */
interface PlanView extends TransferableView, ExportableView {
    /**
     * Sets rectangle selection feedback coordinates.
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     */
    setRectangleFeedback(x0: number, y0: number, x1: number, y1: number);

    /**
     * Ensures selected items are visible at screen and moves
     * scroll bars if needed.
     */
    makeSelectionVisible();

    /**
     * Ensures the point at (<code>x</code>, <code>y</code>) is visible,
     * moving scroll bars if needed.
     * @param {number} x
     * @param {number} y
     */
    makePointVisible(x: number, y: number);

    /**
     * Returns the scale used to display the plan.
     * @return {number}
     */
    getScale(): number;

    /**
     * Sets the scale used to display the plan.
     * @param {number} scale
     */
    setScale(scale: number);

    /**
     * Returns the preferred scale to ensure it can be fully printed on the given print zone.
     * @param {number} preferredWidth  width of the zone in cm
     * @param {number} preferredHeight height of the zone in cm
     * @return {number}
     */
    getPrintPreferredScale(preferredWidth: number, preferredHeight: number): number;

    /**
     * Moves the view from (dx, dy) unit in the scrolling zone it belongs to.
     * @param {number} dx
     * @param {number} dy
     */
    moveView(dx: number, dy: number);

    /**
     * Returns <code>x</code> converted in model coordinates space.
     * @param {number} x
     * @return {number}
     */
    convertXPixelToModel(x: number): number;

    /**
     * Returns <code>y</code> converted in model coordinates space.
     * @param {number} y
     * @return {number}
     */
    convertYPixelToModel(y: number): number;

    /**
     * Returns <code>x</code> converted in screen coordinates space.
     * @param {number} x
     * @return {number}
     */
    convertXModelToScreen(x: number): number;

    /**
     * Returns <code>y</code> converted in screen coordinates space.
     * @param {number} y
     * @return {number}
     */
    convertYModelToScreen(y: number): number;

    /**
     * Returns the length in centimeters of a pixel with the current scale.
     * @return {number}
     */
    getPixelLength(): number;

    /**
     * Returns the coordinates of the bounding rectangle of the <code>text</code> displayed at
     * the point (<code>x</code>,<code>y</code>).
     * @param {string} text
     * @param {TextStyle} style
     * @param {number} x
     * @param {number} y
     * @param {number} angle
     * @return {float[][]}
     */
    getTextBounds(text: string, style: TextStyle, x: number, y: number, angle: number): number[][];

    /**
     * Sets the cursor of this component as rotation cursor.
     * @param {PlanView.CursorType} cursorType
     */
    setCursor(cursorType: PlanView.CursorType);

    /**
     * Sets tool tip text displayed as feedback.
     * @param {string} toolTipFeedback the text displayed in the tool tip
     * or <code>null</code> to make tool tip disappear.
     * @param {number} x
     * @param {number} y
     */
    setToolTipFeedback(toolTipFeedback: string, x: number, y: number);

    /**
     * Sets properties edited in tool tip.
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.EditableProperty[]} toolTipEditedProperties
     * @param {java.lang.Object[]} toolTipPropertyValues
     * @param {number} x
     * @param {number} y
     */
    setToolTipEditedProperties(toolTipEditedProperties: any[], toolTipPropertyValues: any[], x: number, y: number);

    /**
     * Sets the value of a property edited in tool tip.
     * @param {string} toolTipEditedProperty
     * @param {Object} toolTipPropertyValue
     */
    setToolTipEditedPropertyValue(toolTipEditedProperty: any, toolTipPropertyValue: any);

    /**
     * Deletes tool tip text from screen.
     */
    deleteToolTipFeedback();

    /**
     * Sets whether the resize indicator of selected wall or piece of furniture
     * should be visible or not.
     * @param {boolean} resizeIndicatorVisible
     */
    setResizeIndicatorVisible(resizeIndicatorVisible: boolean);

    /**
     * Sets the location point for alignment feedback.
     * @param {Object} alignedObjectClass
     * @param {Object} alignedObject
     * @param {number} x
     * @param {number} y
     * @param {boolean} showPoint
     */
    setAlignmentFeedback(alignedObjectClass: any, alignedObject: Selectable, x: number, y: number, showPoint: boolean);

    /**
     * Sets the points used to draw an angle in plan view.
     * @param {number} xCenter
     * @param {number} yCenter
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     */
    setAngleFeedback(xCenter: number, yCenter: number, x1: number, y1: number, x2: number, y2: number);

    /**
     * Sets the feedback of dragged items drawn during a drag and drop operation,
     * initiated from outside of plan view.
     * @param {*[]} draggedItems
     */
    setDraggedItemsFeedback(draggedItems: Array<Selectable>);

    /**
     * Sets the given dimension lines to be drawn as feedback.
     * @param {DimensionLine[]} dimensionLines
     */
    setDimensionLinesFeedback(dimensionLines: Array<DimensionLine>);

    /**
     * Deletes all elements shown as feedback.
     */
    deleteFeedback();

    /**
     * Returns the component used as an horizontal ruler for this plan.
     * @return {Object}
     */
    getHorizontalRuler(): View;

    /**
     * Returns the component used as a vertical ruler for this plan.
     * @return {Object}
     */
    getVerticalRuler(): View;

    /**
     * Returns <code>true</code> if this plan accepts to import dragged items at the given coordinates.
     * @param {*[]} items
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    canImportDraggedItems(items: Array<Selectable>, x: number, y: number): boolean;

    /**
     * Returns the size of the given piece of furniture in the horizontal plan.
     * @param {HomePieceOfFurniture} piece
     * @return {float[]}
     */
    getPieceOfFurnitureSizeInPlan(piece: HomePieceOfFurniture): number[];

    /**
     * Returns <code>true</code> if the view is able to compute the size of horizontally rotated furniture.
     * @return {boolean}
     */
    isFurnitureSizeInPlanSupported(): boolean;
}

export namespace PlanView {

    /**
     * The cursor types available in plan view.
     * @enum
     * @property {PlanView.CursorType} SELECTION
     * @property {PlanView.CursorType} PANNING
     * @property {PlanView.CursorType} DRAW
     * @property {PlanView.CursorType} ROTATION
     * @property {PlanView.CursorType} ELEVATION
     * @property {PlanView.CursorType} HEIGHT
     * @property {PlanView.CursorType} POWER
     * @property {PlanView.CursorType} RESIZE
     * @property {PlanView.CursorType} DUPLICATION
     * @property {PlanView.CursorType} MOVE
     * @class
     */
    export enum CursorType {
        SELECTION, PANNING, DRAW, ROTATION, ELEVATION, HEIGHT, POWER, RESIZE, DUPLICATION, MOVE
    }
}


/**
 * The view that displays the furniture of a home.
 * @author Emmanuel Puybaret
 * @class
 */
interface FurnitureView extends TransferableView, ExportableView {
    /**
     * Sets the filter applied to the furniture.
     * @param {Object} furnitureFilter
     */
    setFurnitureFilter(furnitureFilter: FurnitureView.FurnitureFilter);

    /**
     * Returns the filter applied to the furniture.
     * @return {Object}
     */
    getFurnitureFilter(): FurnitureView.FurnitureFilter;
}

export namespace FurnitureView {

    /**
     * The super type used to specify how furniture should be filtered in viewed furniture.
     * @class
     */
    export interface FurnitureFilter {
        /**
         * Returns <code>true</code> if the given <code>piece</code> should be shown,
         * otherwise returns <code>false</code> if the <code>piece</code> should be hidden.
         * @param {Home} home
         * @param {HomePieceOfFurniture} piece
         * @return {boolean}
         */
        include(home: Home, piece: HomePieceOfFurniture): boolean;
    }
}


/**
 * A MVC controller.
 * @author Emmanuel Puybaret
 * @class
 */
interface Controller {
    getView(): View;
}

/**
 * A factory that specifies how to create the views displayed in Sweet Home 3D.
 * @author Emmanuel Puybaret
 * @class
 */
interface ViewFactory {
    /**
     * Returns a new view that displays furniture <code>catalog</code>.
     * @param {FurnitureCatalog} catalog
     * @param {UserPreferences} preferences
     * @param {FurnitureCatalogController} furnitureCatalogController
     * @return {Object}
     */
    createFurnitureCatalogView(catalog: FurnitureCatalog, preferences: any, furnitureCatalogController: FurnitureCatalogController): View;

    /**
     * Returns a new view that displays <code>home</code> furniture list.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {FurnitureController} furnitureController
     * @return {Object}
     */
    createFurnitureView(home: Home, preferences: any, furnitureController: FurnitureController): View;

    /**
     * Returns a new view that displays <code>home</code> on a plan.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {PlanController} planController
     * @return {Object}
     */
    createPlanView(home: Home, preferences: any, planController: PlanController): PlanView;

    /**
     * Returns a new view that displays <code>home</code> in 3D.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {HomeController3D} homeController3D
     * @return {Object}
     */
    createView3D(home: Home, preferences: any, homeController3D: HomeController3D): View;

    /**
     * Returns a new view that displays <code>home</code> and its sub views.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {HomeController} homeController
     * @return {Object}
     */
    createHomeView(home: Home, preferences: any, homeController: HomeController): HomeView;

    /**
     * Returns a new view that displays a wizard.
     * @param {UserPreferences} preferences
     * @param {WizardController} wizardController
     * @return {Object}
     */
    createWizardView(preferences: any, wizardController: WizardController): DialogView;

    /**
     * Returns a new view that displays the different steps that helps the user to choose a background image.
     * @param {BackgroundImage} backgroundImage
     * @param {UserPreferences} preferences
     * @param {BackgroundImageWizardController} backgroundImageWizardController
     * @return {Object}
     */
    createBackgroundImageWizardStepsView(backgroundImage: BackgroundImage, preferences: any, backgroundImageWizardController: BackgroundImageWizardController): View;

    /**
     * Returns a new view that displays the different steps that helps the user to import furniture.
     * @param {CatalogPieceOfFurniture} piece
     * @param {string} modelName
     * @param {boolean} importHomePiece
     * @param {UserPreferences} preferences
     * @param {ImportedFurnitureWizardController} importedFurnitureWizardController
     * @return {Object}
     */
    createImportedFurnitureWizardStepsView(piece: CatalogPieceOfFurniture, modelName: string, importHomePiece: boolean, preferences: any, importedFurnitureWizardController: ImportedFurnitureWizardController): ImportedFurnitureWizardStepsView;

    /**
     * Returns a new view that displays the different steps that helps the user to import a texture.
     * @param {CatalogTexture} texture
     * @param {string} textureName
     * @param {UserPreferences} preferences
     * @param {ImportedTextureWizardController} importedTextureWizardController
     * @return {Object}
     */
    createImportedTextureWizardStepsView(texture: CatalogTexture, textureName: string, preferences: any, importedTextureWizardController: ImportedTextureWizardController): View;

    /**
     * Returns a new view that displays message for a threaded task.
     * @param {string} taskMessage
     * @param {UserPreferences} userPreferences
     * @param {ThreadedTaskController} threadedTaskController
     * @return {Object}
     */
    createThreadedTaskView(taskMessage: string, userPreferences: any, threadedTaskController: any): ThreadedTaskView;

    /**
     * Returns a new view that edits user preferences.
     * @param {UserPreferences} preferences
     * @param {UserPreferencesController} userPreferencesController
     * @return {Object}
     */
    createUserPreferencesView(preferences: any, userPreferencesController: UserPreferencesController): DialogView;

    /**
     * Returns a new view that edits level values.
     * @param {UserPreferences} preferences
     * @param {LevelController} levelController
     * @return {Object}
     */
    createLevelView(preferences: any, levelController: LevelController): DialogView;

    /**
     * Returns a new view that edits furniture values.
     * @param {UserPreferences} preferences
     * @param {HomeFurnitureController} homeFurnitureController
     * @return {Object}
     */
    createHomeFurnitureView(preferences: any, homeFurnitureController: HomeFurnitureController): DialogView;

    /**
     * Returns a new view that edits wall values.
     * @param {UserPreferences} preferences
     * @param {WallController} wallController
     * @return {Object}
     */
    createWallView(preferences: any, wallController: WallController): DialogView;

    /**
     * Returns a new view that edits room values.
     * @param {UserPreferences} preferences
     * @param {RoomController} roomController
     * @return {Object}
     */
    createRoomView(preferences: any, roomController: RoomController): DialogView;

    /**
     * Returns a new view that edits polyline values.
     * @param {UserPreferences} preferences
     * @param {PolylineController} polylineController
     * @return {Object}
     */
    createPolylineView(preferences: any, polylineController: PolylineController): DialogView;

    /**
     * Returns a new view that edits dimension line values.
     * @param {boolean} modification
     * @param {UserPreferences} preferences
     * @param {DimensionLineController} dimensionLineController
     * @return {Object}
     */
    createDimensionLineView(modification: boolean, preferences: any, dimensionLineController: DimensionLineController): DialogView;

    /**
     * Returns a new view that edits label values.
     * @param {boolean} modification
     * @param {UserPreferences} preferences
     * @param {LabelController} labelController
     * @return {Object}
     */
    createLabelView(modification: boolean, preferences: any, labelController: LabelController): DialogView;

    /**
     * Returns a new view that edits compass values.
     * @param {UserPreferences} preferences
     * @param {CompassController} compassController
     * @return {Object}
     */
    createCompassView(preferences: any, compassController: CompassController): DialogView;

    /**
     * Returns a new view that edits observer camera values.
     * @param {UserPreferences} preferences
     * @param {ObserverCameraController} home3DAttributesController
     * @return {Object}
     */
    createObserverCameraView(preferences: any, home3DAttributesController: ObserverCameraController): DialogView;

    /**
     * Returns a new view that edits 3D attributes.
     * @param {UserPreferences} preferences
     * @param {Home3DAttributesController} home3DAttributesController
     * @return {Object}
     */
    createHome3DAttributesView(preferences: any, home3DAttributesController: Home3DAttributesController): DialogView;

    /**
     * Returns a new view that edits the texture of its controller.
     * @param {UserPreferences} preferences
     * @param {TextureChoiceController} textureChoiceController
     * @return {Object}
     */
    createTextureChoiceView(preferences: any, textureChoiceController: TextureChoiceController): TextureChoiceView;

    /**
     * Returns a new view that edits the baseboard of its controller.
     * @param {UserPreferences} preferences
     * @param {BaseboardChoiceController} baseboardChoiceController
     * @return {Object}
     */
    createBaseboardChoiceView(preferences: any, baseboardChoiceController: BaseboardChoiceController): View;

    /**
     * Returns a new view that edits the materials of its controller.
     * @param {UserPreferences} preferences
     * @param {ModelMaterialsController} modelMaterialsController
     * @return {Object}
     */
    createModelMaterialsView(preferences: any, modelMaterialsController: ModelMaterialsController): View;

    /**
     * Creates a new view that edits page setup.
     * @param {UserPreferences} preferences
     * @param {PageSetupController} pageSetupController
     * @return {Object}
     */
    createPageSetupView(preferences: any, pageSetupController: PageSetupController): DialogView;

    /**
     * Returns a new view that displays home print preview.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {HomeController} homeController
     * @param {PrintPreviewController} printPreviewController
     * @return {Object}
     */
    createPrintPreviewView(home: Home, preferences: any, homeController: HomeController, printPreviewController: any): DialogView;

    /**
     * Returns a new view able to compute a photo realistic image of a home.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {PhotoController} photoController
     * @return {Object}
     */
    createPhotoView(home: Home, preferences: any, photoController: PhotoController): DialogView;

    /**
     * Returns a new view able to compute a photos of a home from its stored points of view.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {PhotosController} photosController
     * @return {Object}
     */
    createPhotosView(home: Home, preferences: any, photosController: PhotosController): DialogView;

    /**
     * Returns a new view able to compute a 3D video of a home.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {VideoController} videoController
     * @return {Object}
     */
    createVideoView(home: Home, preferences: any, videoController: VideoController): DialogView;
}

/**
 * The main view that displays a home.
 * @author Emmanuel Puybaret
 * @class
 */
interface HomeView extends View {
    /**
     * Enables or disables the action matching <code>actionType</code>.
     * @param {HomeView.ActionType} actionType
     * @param {boolean} enabled
     */
    setEnabled(actionType: HomeView.ActionType, enabled: boolean);

    /**
     * Enables or disables the action matching <code>actionKey</code>.
     * @param {string} actionKey
     * @param {boolean} enabled
     */
    setActionEnabled(actionKey: string, enabled: boolean);

    /**
     * Sets the name and tool tip of undo and redo actions. If a parameter is <code>null</code>,
     * the properties will be reset to their initial values.
     * @param {string} undoText
     * @param {string} redoText
     */
    setUndoRedoName(undoText: string, redoText: string);

    /**
     * Enables or disables transfer between components.
     * @param {boolean} enabled
     */
    setTransferEnabled(enabled: boolean);

    /**
     * Detaches the given <code>view</code> from home view.
     * @param {Object} view
     */
    detachView(view: View);

    /**
     * Attaches the given <code>view</code> to home view.
     * @param {Object} view
     */
    attachView(view: View);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     * @return {string}
     */
    showOpenDialog(): string;

    /**
     * Displays a dialog that lets user choose what he wants
     * to do with a damaged home he tries to open it.
     * @param {string} homeName
     * @param {Home} damagedHome
     * @param {*[]} invalidContent
     * @return {HomeView.OpenDamagedHomeAnswer}
     */
    confirmOpenDamagedHome(homeName: string, damagedHome: Home, invalidContent: Array<Content>): HomeView.OpenDamagedHomeAnswer;

    /**
     * Displays a dialog to let the user choose a home example.
     * @return {string}
     */
    showNewHomeFromExampleDialog(): string;

    /**
     * Displays a content chooser open dialog to choose a language library.
     * @return {string}
     */
    showImportLanguageLibraryDialog(): string;

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     * @param {string} languageLibraryName
     * @return {boolean}
     */
    confirmReplaceLanguageLibrary(languageLibraryName: string): boolean;

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     * @return {string}
     */
    showImportFurnitureLibraryDialog(): string;

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     * @param {string} furnitureLibraryName
     * @return {boolean}
     */
    confirmReplaceFurnitureLibrary(furnitureLibraryName: string): boolean;

    /**
     * Displays a content chooser open dialog to choose a textures library.
     * @return {string}
     */
    showImportTexturesLibraryDialog(): string;

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     * @param {string} texturesLibraryName
     * @return {boolean}
     */
    confirmReplaceTexturesLibrary(texturesLibraryName: string): boolean;

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     * @param {string} pluginName
     * @return {boolean}
     */
    confirmReplacePlugin(pluginName: string): boolean;

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     * @param {string} homeName
     * @return {string}
     */
    showSaveDialog(homeName: string): string;

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {HomeView.SaveAnswer} {@link SaveAnswer#SAVE} if user chose to save home,
     * {@link SaveAnswer#DO_NOT_SAVE} if user don't want to save home,
     * or {@link SaveAnswer#CANCEL} if doesn't want to continue current operation.
     * @param {string} homeName
     */
    confirmSave(homeName: string): HomeView.SaveAnswer;

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return {boolean} <code>true</code> if user confirmed to save.
     * @param {string} homeName
     */
    confirmSaveNewerHome(homeName: string): boolean;

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return {boolean} <code>true</code> if user confirmed to delete.
     */
    confirmDeleteCatalogSelection(): boolean;

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return {boolean} <code>true</code> if user confirmed to exit.
     */
    confirmExit(): boolean;

    /**
     * Displays <code>message</code> in an error message box.
     * @param {string} message
     */
    showError(message: string);

    /**
     * Displays <code>message</code> in a message box.
     * @param {string} message
     */
    showMessage(message: string);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     * @param {string} actionTipKey
     * @return {boolean}
     */
    showActionTipMessage(actionTipKey: string): boolean;

    /**
     * Displays an about dialog.
     */
    showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return {() => any} a print task to execute or <code>null</code> if the user canceled print.
     * The <code>call</code> method of the returned task may throw a
     * {@link RecorderException} exception if print failed
     * or an {@link InterruptedRecorderException}
     * exception if it was interrupted.
     */
    showPrintDialog(): () => any;

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     * @param {string} homeName
     * @return {string}
     */
    showPrintToPDFDialog(homeName: string): string;

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     * Caution !!! This method may be called from a threaded task.
     * @param {string} pdfFile
     */
    printToPDF(pdfFile: string);

    /**
     * Shows a content chooser save dialog to export furniture list in a CSV file.
     * @param {string} name
     * @return {string}
     */
    showExportToCSVDialog(name: string): string;

    /**
     * Exports furniture list to a given SVG file.
     * Caution !!! This method may be called from a threaded task.
     * @param {string} csvName
     */
    exportToCSV(csvName: string);

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     * @param {string} name
     * @return {string}
     */
    showExportToSVGDialog(name: string): string;

    /**
     * Exports the plan objects to a given SVG file.
     * Caution !!! This method may be called from a threaded task.
     * @param {string} svgName
     */
    exportToSVG(svgName: string);

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     * @param {string} homeName
     * @return {string}
     */
    showExportToOBJDialog(homeName: string): string;

    /**
     * Exports the 3D home objects to a given OBJ file.
     * Caution !!! This method may be called from a threaded task.
     * @param {string} objFile
     */
    exportToOBJ(objFile: string);

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @param {string} cameraName
     * @return {string}
     */
    showStoreCameraDialog(cameraName: string): string;

    /**
     * Displays a dialog showing the list of cameras stored in home
     * and returns the ones selected by the user to be deleted.
     * @return {Camera[]}
     */
    showDeletedCamerasDialog(): Array<Camera>;

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     * @return {boolean}
     */
    isClipboardEmpty(): boolean;

    /**
     * Returns the list of selectable items that are currently in clipboard
     * or <code>null</code> if clipboard doesn't contain any selectable item.
     * @return {*[]}
     */
    getClipboardItems(): Array<Selectable>;

    /**
     * Displays the given message and returns <code>false</code> if the user
     * doesn't want to be informed of the displayed updates and <code>showOnlyMessage</code> is <code>false</code>.
     * @param {string} updatesMessage
     * @param {boolean} showOnlyMessage
     * @return {boolean}
     */
    showUpdatesMessage(updatesMessage: string, showOnlyMessage: boolean): boolean;

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     * @param {() => void} runnable
     */
    invokeLater(runnable: () => void);
}

export namespace HomeView {

    export const SORT_HOME_FURNITURE_ADDITIONAL_PROPERTY_ACTION_PREFIX: string = "SORT_HOME_FURNITURE_ADDITIONAL_PROPERTY_BY_";

    export const DISPLAY_HOME_FURNITURE_ADDITIONAL_PROPERTY_ACTION_PREFIX: string = "DISPLAY_HOME_FURNITURE_ADDITIONAL_PROPERTY_";
}


export namespace HomeView {

    /**
     * The actions proposed by the view to user.
     * @enum
     * @property {HomeView.ActionType} NEW_HOME
     * @property {HomeView.ActionType} NEW_HOME_FROM_EXAMPLE
     * @property {HomeView.ActionType} CLOSE
     * @property {HomeView.ActionType} OPEN
     * @property {HomeView.ActionType} DELETE_RECENT_HOMES
     * @property {HomeView.ActionType} SAVE
     * @property {HomeView.ActionType} SAVE_AS
     * @property {HomeView.ActionType} SAVE_AND_COMPRESS
     * @property {HomeView.ActionType} PAGE_SETUP
     * @property {HomeView.ActionType} PRINT_PREVIEW
     * @property {HomeView.ActionType} PRINT
     * @property {HomeView.ActionType} PRINT_TO_PDF
     * @property {HomeView.ActionType} PREFERENCES
     * @property {HomeView.ActionType} EXIT
     * @property {HomeView.ActionType} UNDO
     * @property {HomeView.ActionType} REDO
     * @property {HomeView.ActionType} CUT
     * @property {HomeView.ActionType} COPY
     * @property {HomeView.ActionType} PASTE
     * @property {HomeView.ActionType} PASTE_TO_GROUP
     * @property {HomeView.ActionType} PASTE_STYLE
     * @property {HomeView.ActionType} DELETE
     * @property {HomeView.ActionType} SELECT_ALL
     * @property {HomeView.ActionType} SELECT_ALL_AT_ALL_LEVELS
     * @property {HomeView.ActionType} ADD_HOME_FURNITURE
     * @property {HomeView.ActionType} ADD_FURNITURE_TO_GROUP
     * @property {HomeView.ActionType} DELETE_HOME_FURNITURE
     * @property {HomeView.ActionType} MODIFY_FURNITURE
     * @property {HomeView.ActionType} IMPORT_FURNITURE
     * @property {HomeView.ActionType} IMPORT_FURNITURE_LIBRARY
     * @property {HomeView.ActionType} IMPORT_TEXTURE
     * @property {HomeView.ActionType} IMPORT_TEXTURES_LIBRARY
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_CATALOG_ID
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_NAME
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_DESCRIPTION
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_CREATOR
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_LICENSE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_WIDTH
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_DEPTH
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_HEIGHT
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_X
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_Y
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_ELEVATION
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_ANGLE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_LEVEL
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_MODEL_SIZE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_COLOR
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_TEXTURE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_MOVABILITY
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_TYPE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_VISIBILITY
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_PRICE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED
     * @property {HomeView.ActionType} SORT_HOME_FURNITURE_BY_DESCENDING_ORDER
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_CATALOG_ID
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_NAME
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_DESCRIPTION
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_CREATOR
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_LICENSE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_WIDTH
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_DEPTH
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_HEIGHT
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_X
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_Y
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_ELEVATION
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_ANGLE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_LEVEL
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_MODEL_SIZE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_COLOR
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_TEXTURE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_MOVABLE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_VISIBLE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_PRICE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX
     * @property {HomeView.ActionType} DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_TOP
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_BOTTOM
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_LEFT
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_RIGHT
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_FRONT_SIDE
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_BACK_SIDE
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_LEFT_SIDE
     * @property {HomeView.ActionType} ALIGN_FURNITURE_ON_RIGHT_SIDE
     * @property {HomeView.ActionType} ALIGN_FURNITURE_SIDE_BY_SIDE
     * @property {HomeView.ActionType} DISTRIBUTE_FURNITURE_HORIZONTALLY
     * @property {HomeView.ActionType} DISTRIBUTE_FURNITURE_VERTICALLY
     * @property {HomeView.ActionType} RESET_FURNITURE_ELEVATION
     * @property {HomeView.ActionType} GROUP_FURNITURE
     * @property {HomeView.ActionType} UNGROUP_FURNITURE
     * @property {HomeView.ActionType} EXPORT_TO_CSV
     * @property {HomeView.ActionType} SELECT
     * @property {HomeView.ActionType} PAN
     * @property {HomeView.ActionType} CREATE_WALLS
     * @property {HomeView.ActionType} CREATE_ROOMS
     * @property {HomeView.ActionType} CREATE_DIMENSION_LINES
     * @property {HomeView.ActionType} CREATE_POLYLINES
     * @property {HomeView.ActionType} CREATE_LABELS
     * @property {HomeView.ActionType} DELETE_SELECTION
     * @property {HomeView.ActionType} LOCK_BASE_PLAN
     * @property {HomeView.ActionType} UNLOCK_BASE_PLAN
     * @property {HomeView.ActionType} ENABLE_MAGNETISM
     * @property {HomeView.ActionType} DISABLE_MAGNETISM
     * @property {HomeView.ActionType} FLIP_HORIZONTALLY
     * @property {HomeView.ActionType} FLIP_VERTICALLY
     * @property {HomeView.ActionType} MODIFY_COMPASS
     * @property {HomeView.ActionType} MODIFY_WALL
     * @property {HomeView.ActionType} JOIN_WALLS
     * @property {HomeView.ActionType} REVERSE_WALL_DIRECTION
     * @property {HomeView.ActionType} SPLIT_WALL
     * @property {HomeView.ActionType} MODIFY_ROOM
     * @property {HomeView.ActionType} RECOMPUTE_ROOM_POINTS
     * @property {HomeView.ActionType} ADD_ROOM_POINT
     * @property {HomeView.ActionType} DELETE_ROOM_POINT
     * @property {HomeView.ActionType} MODIFY_POLYLINE
     * @property {HomeView.ActionType} MODIFY_DIMENSION_LINE
     * @property {HomeView.ActionType} MODIFY_LABEL
     * @property {HomeView.ActionType} INCREASE_TEXT_SIZE
     * @property {HomeView.ActionType} DECREASE_TEXT_SIZE
     * @property {HomeView.ActionType} TOGGLE_BOLD_STYLE
     * @property {HomeView.ActionType} TOGGLE_ITALIC_STYLE
     * @property {HomeView.ActionType} IMPORT_BACKGROUND_IMAGE
     * @property {HomeView.ActionType} MODIFY_BACKGROUND_IMAGE
     * @property {HomeView.ActionType} HIDE_BACKGROUND_IMAGE
     * @property {HomeView.ActionType} SHOW_BACKGROUND_IMAGE
     * @property {HomeView.ActionType} DELETE_BACKGROUND_IMAGE
     * @property {HomeView.ActionType} ADD_LEVEL
     * @property {HomeView.ActionType} ADD_LEVEL_AT_SAME_ELEVATION
     * @property {HomeView.ActionType} MAKE_LEVEL_VIEWABLE
     * @property {HomeView.ActionType} MAKE_LEVEL_UNVIEWABLE
     * @property {HomeView.ActionType} MAKE_LEVEL_ONLY_VIEWABLE_ONE
     * @property {HomeView.ActionType} MAKE_ALL_LEVELS_VIEWABLE
     * @property {HomeView.ActionType} MODIFY_LEVEL
     * @property {HomeView.ActionType} DELETE_LEVEL
     * @property {HomeView.ActionType} ZOOM_OUT
     * @property {HomeView.ActionType} ZOOM_IN
     * @property {HomeView.ActionType} EXPORT_TO_SVG
     * @property {HomeView.ActionType} SELECT_OBJECT
     * @property {HomeView.ActionType} TOGGLE_SELECTION
     * @property {HomeView.ActionType} VIEW_FROM_TOP
     * @property {HomeView.ActionType} VIEW_FROM_OBSERVER
     * @property {HomeView.ActionType} MODIFY_OBSERVER
     * @property {HomeView.ActionType} STORE_POINT_OF_VIEW
     * @property {HomeView.ActionType} DELETE_POINTS_OF_VIEW
     * @property {HomeView.ActionType} CREATE_PHOTOS_AT_POINTS_OF_VIEW
     * @property {HomeView.ActionType} DETACH_3D_VIEW
     * @property {HomeView.ActionType} ATTACH_3D_VIEW
     * @property {HomeView.ActionType} DISPLAY_ALL_LEVELS
     * @property {HomeView.ActionType} DISPLAY_SELECTED_LEVEL
     * @property {HomeView.ActionType} MODIFY_3D_ATTRIBUTES
     * @property {HomeView.ActionType} CREATE_PHOTO
     * @property {HomeView.ActionType} CREATE_VIDEO
     * @property {HomeView.ActionType} EXPORT_TO_OBJ
     * @property {HomeView.ActionType} HELP
     * @property {HomeView.ActionType} ABOUT
     * @class
     */
    export enum ActionType {
        NEW_HOME, NEW_HOME_FROM_EXAMPLE, CLOSE, OPEN, DELETE_RECENT_HOMES, SAVE, SAVE_AS, SAVE_AND_COMPRESS, PAGE_SETUP, PRINT_PREVIEW, PRINT, PRINT_TO_PDF, PREFERENCES, EXIT, UNDO, REDO, CUT, COPY, PASTE, PASTE_TO_GROUP, PASTE_STYLE, DELETE, SELECT_ALL, SELECT_ALL_AT_ALL_LEVELS, ADD_HOME_FURNITURE, ADD_FURNITURE_TO_GROUP, DELETE_HOME_FURNITURE, MODIFY_FURNITURE, IMPORT_FURNITURE, IMPORT_FURNITURE_LIBRARY, IMPORT_TEXTURE, IMPORT_TEXTURES_LIBRARY, SORT_HOME_FURNITURE_BY_CATALOG_ID, SORT_HOME_FURNITURE_BY_NAME, SORT_HOME_FURNITURE_BY_DESCRIPTION, SORT_HOME_FURNITURE_BY_CREATOR, SORT_HOME_FURNITURE_BY_LICENSE, SORT_HOME_FURNITURE_BY_WIDTH, SORT_HOME_FURNITURE_BY_DEPTH, SORT_HOME_FURNITURE_BY_HEIGHT, SORT_HOME_FURNITURE_BY_X, SORT_HOME_FURNITURE_BY_Y, SORT_HOME_FURNITURE_BY_ELEVATION, SORT_HOME_FURNITURE_BY_ANGLE, SORT_HOME_FURNITURE_BY_LEVEL, SORT_HOME_FURNITURE_BY_MODEL_SIZE, SORT_HOME_FURNITURE_BY_COLOR, SORT_HOME_FURNITURE_BY_TEXTURE, SORT_HOME_FURNITURE_BY_MOVABILITY, SORT_HOME_FURNITURE_BY_TYPE, SORT_HOME_FURNITURE_BY_VISIBILITY, SORT_HOME_FURNITURE_BY_PRICE, SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, DISPLAY_HOME_FURNITURE_CATALOG_ID, DISPLAY_HOME_FURNITURE_NAME, DISPLAY_HOME_FURNITURE_DESCRIPTION, DISPLAY_HOME_FURNITURE_CREATOR, DISPLAY_HOME_FURNITURE_LICENSE, DISPLAY_HOME_FURNITURE_WIDTH, DISPLAY_HOME_FURNITURE_DEPTH, DISPLAY_HOME_FURNITURE_HEIGHT, DISPLAY_HOME_FURNITURE_X, DISPLAY_HOME_FURNITURE_Y, DISPLAY_HOME_FURNITURE_ELEVATION, DISPLAY_HOME_FURNITURE_ANGLE, DISPLAY_HOME_FURNITURE_LEVEL, DISPLAY_HOME_FURNITURE_MODEL_SIZE, DISPLAY_HOME_FURNITURE_COLOR, DISPLAY_HOME_FURNITURE_TEXTURE, DISPLAY_HOME_FURNITURE_MOVABLE, DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, DISPLAY_HOME_FURNITURE_VISIBLE, DISPLAY_HOME_FURNITURE_PRICE, DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, ALIGN_FURNITURE_ON_TOP, ALIGN_FURNITURE_ON_BOTTOM, ALIGN_FURNITURE_ON_LEFT, ALIGN_FURNITURE_ON_RIGHT, ALIGN_FURNITURE_ON_FRONT_SIDE, ALIGN_FURNITURE_ON_BACK_SIDE, ALIGN_FURNITURE_ON_LEFT_SIDE, ALIGN_FURNITURE_ON_RIGHT_SIDE, ALIGN_FURNITURE_SIDE_BY_SIDE, DISTRIBUTE_FURNITURE_HORIZONTALLY, DISTRIBUTE_FURNITURE_VERTICALLY, RESET_FURNITURE_ELEVATION, GROUP_FURNITURE, UNGROUP_FURNITURE, EXPORT_TO_CSV, SELECT, PAN, CREATE_WALLS, CREATE_ROOMS, CREATE_DIMENSION_LINES, CREATE_POLYLINES, CREATE_LABELS, DELETE_SELECTION, LOCK_BASE_PLAN, UNLOCK_BASE_PLAN, ENABLE_MAGNETISM, DISABLE_MAGNETISM, FLIP_HORIZONTALLY, FLIP_VERTICALLY, MODIFY_COMPASS, MODIFY_WALL, JOIN_WALLS, REVERSE_WALL_DIRECTION, SPLIT_WALL, MODIFY_ROOM, RECOMPUTE_ROOM_POINTS, ADD_ROOM_POINT, DELETE_ROOM_POINT, MODIFY_POLYLINE, MODIFY_DIMENSION_LINE, MODIFY_LABEL, INCREASE_TEXT_SIZE, DECREASE_TEXT_SIZE, TOGGLE_BOLD_STYLE, TOGGLE_ITALIC_STYLE, IMPORT_BACKGROUND_IMAGE, MODIFY_BACKGROUND_IMAGE, HIDE_BACKGROUND_IMAGE, SHOW_BACKGROUND_IMAGE, DELETE_BACKGROUND_IMAGE, ADD_LEVEL, ADD_LEVEL_AT_SAME_ELEVATION, MAKE_LEVEL_VIEWABLE, MAKE_LEVEL_UNVIEWABLE, MAKE_LEVEL_ONLY_VIEWABLE_ONE, MAKE_ALL_LEVELS_VIEWABLE, MODIFY_LEVEL, DELETE_LEVEL, ZOOM_OUT, ZOOM_IN, EXPORT_TO_SVG, SELECT_OBJECT, TOGGLE_SELECTION, VIEW_FROM_TOP, VIEW_FROM_OBSERVER, MODIFY_OBSERVER, STORE_POINT_OF_VIEW, DELETE_POINTS_OF_VIEW, CREATE_PHOTOS_AT_POINTS_OF_VIEW, DETACH_3D_VIEW, ATTACH_3D_VIEW, DISPLAY_ALL_LEVELS, DISPLAY_SELECTED_LEVEL, MODIFY_3D_ATTRIBUTES, CREATE_PHOTO, CREATE_VIDEO, EXPORT_TO_OBJ, HELP, ABOUT
    }

    export enum SaveAnswer {
        SAVE, CANCEL, DO_NOT_SAVE
    }

    export enum OpenDamagedHomeAnswer {
        REMOVE_DAMAGED_ITEMS, REPLACE_DAMAGED_ITEMS, DO_NOT_OPEN_HOME
    }
}


/**
 * Creates a controller of the furniture catalog view.
 * @param {FurnitureCatalog} catalog the furniture catalog of the application
 * @param {UserPreferences} preferences application user preferences
 * @param {Object} viewFactory a factory able to create the furniture view managed by this controller
 * @param {Object} contentManager content manager for furniture import
 * @class
 * @author Emmanuel Puybaret
 */
export class FurnitureCatalogController implements Controller {
    /*private*/ catalog: FurnitureCatalog;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ selectionListeners: Array<SelectionListener>;

    /*private*/ selectedFurniture: Array<CatalogPieceOfFurniture>;

    /*private*/ catalogView: View;

    public constructor(catalog?: any, preferences?: any, viewFactory?: any, contentManager?: any) {
        if (((catalog != null && catalog instanceof <any>FurnitureCatalog) || catalog === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null)) {
            let __args = arguments;
            if (this.catalog === undefined) { this.catalog = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.selectedFurniture === undefined) { this.selectedFurniture = null; }
            if (this.catalogView === undefined) { this.catalogView = null; }
            this.catalog = catalog;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.contentManager = contentManager;
            this.selectionListeners = <any>([]);
            this.selectedFurniture = /* emptyList */[];
            this.catalog.addFurnitureListener(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(new FurnitureCatalogController.FurnitureCatalogChangeListener(this)));
            if (preferences != null) {
                preferences.addPropertyChangeListener("FURNITURE_CATALOG_VIEWED_IN_TREE", new FurnitureCatalogController.FurnitureCatalogViewChangeListener(this));
            }
        } else if (((catalog != null && catalog instanceof <any>FurnitureCatalog) || catalog === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && viewFactory === undefined && contentManager === undefined) {
            let __args = arguments;
            let viewFactory: any = __args[1];
            {
                let __args = arguments;
                let preferences: any = null;
                let contentManager: any = null;
                if (this.catalog === undefined) { this.catalog = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.selectionListeners === undefined) { this.selectionListeners = null; }
                if (this.selectedFurniture === undefined) { this.selectedFurniture = null; }
                if (this.catalogView === undefined) { this.catalogView = null; }
                this.catalog = catalog;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.selectionListeners = <any>([]);
                this.selectedFurniture = /* emptyList */[];
                this.catalog.addFurnitureListener(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(new FurnitureCatalogController.FurnitureCatalogChangeListener(this)));
                if (preferences != null) {
                    preferences.addPropertyChangeListener("FURNITURE_CATALOG_VIEWED_IN_TREE", new FurnitureCatalogController.FurnitureCatalogViewChangeListener(this));
                }
            }
            if (this.catalog === undefined) { this.catalog = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.selectedFurniture === undefined) { this.selectedFurniture = null; }
            if (this.catalogView === undefined) { this.catalogView = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): View {
        if (this.catalogView == null) {
            this.catalogView = this.viewFactory.createFurnitureCatalogView(this.catalog, this.preferences, this);
        }
        return this.catalogView;
    }

    /**
     * Adds the selection <code>listener</code> in parameter to this controller.
     * @param {Object} listener
     */
    public addSelectionListener(listener: SelectionListener) {
        /* add */(this.selectionListeners.push(listener) > 0);
    }

    /**
     * Removes the selection <code>listener</code> in parameter from this controller.
     * @param {Object} listener
     */
    public removeSelectionListener(listener: SelectionListener) {
        /* remove */(a => { let index = a.indexOf(listener); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.selectionListeners);
    }

    /**
     * Returns a list of the selected furniture in catalog.
     * @return {CatalogPieceOfFurniture[]}
     */
    public getSelectedFurniture(): Array<CatalogPieceOfFurniture> {
        return /* unmodifiableList */this.selectedFurniture.slice(0);
    }

    /**
     * Updates the selected furniture in catalog and notifies listeners selection change.
     * @param {CatalogPieceOfFurniture[]} selectedFurniture
     */
    public setSelectedFurniture(selectedFurniture: Array<CatalogPieceOfFurniture>) {
        this.selectedFurniture = <any>(selectedFurniture.slice(0));
        if (!/* isEmpty */(this.selectionListeners.length == 0)) {
            const selectionEvent: SelectionEvent = new SelectionEvent(this, this.getSelectedFurniture());
            const listeners: SelectionListener[] = /* toArray */this.selectionListeners.slice(0);
            for (let index = 0; index < listeners.length; index++) {
                let listener = listeners[index];
                {
                    listener.selectionChanged(selectionEvent);
                }
            }
        }
    }

    /**
     * Removes <code>piece</code> from selected furniture.
     * @param {CatalogPieceOfFurniture} piece
     * @private
     */
    deselectPieceOfFurniture(piece: CatalogPieceOfFurniture) {
        const pieceSelectionIndex: number = this.selectedFurniture.indexOf(piece);
        if (pieceSelectionIndex !== -1) {
            const selectedItems: Array<CatalogPieceOfFurniture> = <any>(this.getSelectedFurniture().slice(0));
            /* remove */selectedItems.splice(pieceSelectionIndex, 1)[0];
            this.setSelectedFurniture(selectedItems);
        }
    }

    /**
     * Displays the wizard that helps to change the selected piece of furniture.
     */
    public modifySelectedFurniture() {
        if (this.preferences != null) {
            if (/* size */(<number>this.selectedFurniture.length) > 0) {
                const piece: CatalogPieceOfFurniture = /* get */this.selectedFurniture[0];
                if (piece.isModifiable()) {
                    const addedFurnitureListener: FurnitureCatalogController.AddedFurnitureSelector = new FurnitureCatalogController.AddedFurnitureSelector(this);
                    this.preferences.getFurnitureCatalog().addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
                    new ImportedFurnitureWizardController(piece, this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
                    addedFurnitureListener.selectAddedFurniture();
                    this.preferences.getFurnitureCatalog().removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
                }
            }
        }
    }

    public importFurniture$() {
        if (this.preferences != null) {
            const addedFurnitureListener: FurnitureCatalogController.AddedFurnitureSelector = new FurnitureCatalogController.AddedFurnitureSelector(this);
            this.preferences.getFurnitureCatalog().addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
            new ImportedFurnitureWizardController(this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
            addedFurnitureListener.selectAddedFurniture();
            this.preferences.getFurnitureCatalog().removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
        }
    }

    public importFurniture$java_lang_String(modelName: string) {
        if (this.preferences != null) {
            new ImportedFurnitureWizardController(modelName, this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
        }
    }

    /**
     * Displays the wizard that helps to import furniture to catalog.
     * @param {string} modelName
     * @private
     */
    public importFurniture(modelName?: any) {
        if (((typeof modelName === 'string') || modelName === null)) {
            return <any>this.importFurniture$java_lang_String(modelName);
        } else if (modelName === undefined) {
            return <any>this.importFurniture$();
        } else throw new Error('invalid overload');
    }

    /**
     * Deletes selected catalog furniture.
     */
    public deleteSelection() {
        for (let index = 0; index < this.selectedFurniture.length; index++) {
            let piece = this.selectedFurniture[index];
            {
                if (piece.isModifiable()) {
                    this.catalog.delete(piece);
                }
            }
        }
    }

    /**
     * Adds dropped files to catalog.
     * @param {string[]} importableModels
     */
    public dropFiles(importableModels: Array<string>) {
        const addedFurnitureListener: FurnitureCatalogController.AddedFurnitureSelector = new FurnitureCatalogController.AddedFurnitureSelector(this);
        this.preferences.getFurnitureCatalog().addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
        for (let index = 0; index < importableModels.length; index++) {
            let model = importableModels[index];
            {
                this.importFurniture$java_lang_String(model);
            }
        }
        addedFurnitureListener.selectAddedFurniture();
        this.preferences.getFurnitureCatalog().removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
    }
}
FurnitureCatalogController["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureCatalogController";
FurnitureCatalogController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace FurnitureCatalogController {

    /**
     * Furniture catalog listener that deselects a piece removed from catalog.
     * @param {FurnitureCatalogController} furnitureCatalogController
     * @class
     */
    export class FurnitureCatalogChangeListener {
        furnitureCatalogController: FurnitureCatalogController;

        public constructor(furnitureCatalogController: FurnitureCatalogController) {
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            this.furnitureCatalogController = <any>(furnitureCatalogController);
        }

        public collectionChanged(ev: CollectionEvent<CatalogPieceOfFurniture>) {
            const controller: FurnitureCatalogController = /* get */this.furnitureCatalogController;
            if (controller == null) {
                (<FurnitureCatalog>ev.getSource()).removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this)));
            } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                controller.deselectPieceOfFurniture(ev.getItem());
            }
        }
    }
    FurnitureCatalogChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureCatalogController.FurnitureCatalogChangeListener";
    FurnitureCatalogChangeListener["__interfaces"] = ["com.eteks.sweethome3d.model.CollectionListener"];



    /**
     * Preferences listener that reset view when furniture catalog view should change.
     * @param {FurnitureCatalogController} controller
     * @class
     */
    export class FurnitureCatalogViewChangeListener {
        controller: FurnitureCatalogController;

        public constructor(controller: FurnitureCatalogController) {
            if (this.controller === undefined) { this.controller = null; }
            this.controller = <any>(controller);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: FurnitureCatalogController = /* get */this.controller;
            if (controller == null) {
                (ev.getSource()).removePropertyChangeListener("FURNITURE_CATALOG_VIEWED_IN_TREE", this);
            } else {
                controller.catalogView = null;
            }
        }
    }
    FurnitureCatalogViewChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureCatalogController.FurnitureCatalogViewChangeListener";


    /**
     * Listener that keeps track of the furniture added to catalog.
     * @class
     */
    export class AddedFurnitureSelector {
        public __parent: any;
        addedFurniture: Array<CatalogPieceOfFurniture>;

        public collectionChanged(ev: CollectionEvent<CatalogPieceOfFurniture>) {
            if (ev.getType() === CollectionEvent.Type.ADD) {
                /* add */(this.addedFurniture.push(ev.getItem()) > 0);
            }
        }

        public selectAddedFurniture() {
            if (/* size */(<number>this.addedFurniture.length) > 0) {
                this.__parent.setSelectedFurniture(this.addedFurniture);
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
            this.addedFurniture = <any>([]);
        }
    }
    AddedFurnitureSelector["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureCatalogController.AddedFurnitureSelector";
    AddedFurnitureSelector["__interfaces"] = ["com.eteks.sweethome3d.model.CollectionListener"];


}


/**
 * The view that displays a pane in a dialog.
 * @author Emmanuel Puybaret
 * @class
 */
interface DialogView extends View {
    /**
     * Displays this wizard view in a modal dialog.
     * @param {Object} parentView
     */
    displayView(parentView: View);
}

/**
 * A MVC controller for texture choice.
 * @author Emmanuel Puybaret
 * @param {string} title
 * @param {string} fitAreaText
 * @param {boolean} rotationSupported
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 */
export class TextureChoiceController implements Controller {
    static MAX_RECENT_TEXTURES: number = 15;

    /*private*/ title: string;

    /*private*/ fitAreaText: string;

    /*private*/ rotationSupported: boolean;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ textureChoiceView: TextureChoiceView;

    /*private*/ texture: HomeTexture;

    public constructor(title?: any, fitAreaText?: any, rotationSupported?: any, preferences?: any, viewFactory?: any, contentManager?: any) {
        if (((typeof title === 'string') || title === null) && ((typeof fitAreaText === 'string') || fitAreaText === null) && ((typeof rotationSupported === 'boolean') || rotationSupported === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null)) {
            let __args = arguments;
            if (this.title === undefined) { this.title = null; }
            if (this.fitAreaText === undefined) { this.fitAreaText = null; }
            if (this.rotationSupported === undefined) { this.rotationSupported = false; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
            if (this.texture === undefined) { this.texture = null; }
            this.title = title;
            this.fitAreaText = fitAreaText;
            this.rotationSupported = rotationSupported;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.contentManager = contentManager;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
        } else if (((typeof title === 'string') || title === null) && ((typeof fitAreaText === 'boolean') || fitAreaText === null) && ((rotationSupported != null && rotationSupported instanceof <any>UserPreferences) || rotationSupported === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && contentManager === undefined) {
            let __args = arguments;
            let rotationSupported: any = __args[1];
            let preferences: any = __args[2];
            let viewFactory: any = __args[3];
            let contentManager: any = __args[4];
            {
                let __args = arguments;
                let fitAreaText: any = null;
                if (this.title === undefined) { this.title = null; }
                if (this.fitAreaText === undefined) { this.fitAreaText = null; }
                if (this.rotationSupported === undefined) { this.rotationSupported = false; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
                if (this.texture === undefined) { this.texture = null; }
                this.title = title;
                this.fitAreaText = fitAreaText;
                this.rotationSupported = rotationSupported;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.propertyChangeSupport = new PropertyChangeSupport(this);
            }
            if (this.title === undefined) { this.title = null; }
            if (this.fitAreaText === undefined) { this.fitAreaText = null; }
            if (this.rotationSupported === undefined) { this.rotationSupported = false; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
            if (this.texture === undefined) { this.texture = null; }
        } else if (((typeof title === 'string') || title === null) && ((fitAreaText != null && fitAreaText instanceof <any>UserPreferences) || fitAreaText === null) && ((rotationSupported != null && (rotationSupported.constructor != null && rotationSupported.constructor["__interfaces"] != null && rotationSupported.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || rotationSupported === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || preferences === null) && viewFactory === undefined && contentManager === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let rotationSupported: any = true;
                {
                    let __args = arguments;
                    let fitAreaText: any = null;
                    if (this.title === undefined) { this.title = null; }
                    if (this.fitAreaText === undefined) { this.fitAreaText = null; }
                    if (this.rotationSupported === undefined) { this.rotationSupported = false; }
                    if (this.preferences === undefined) { this.preferences = null; }
                    if (this.viewFactory === undefined) { this.viewFactory = null; }
                    if (this.contentManager === undefined) { this.contentManager = null; }
                    if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                    if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
                    if (this.texture === undefined) { this.texture = null; }
                    this.title = title;
                    this.fitAreaText = fitAreaText;
                    this.rotationSupported = rotationSupported;
                    this.preferences = preferences;
                    this.viewFactory = viewFactory;
                    this.contentManager = contentManager;
                    this.propertyChangeSupport = new PropertyChangeSupport(this);
                }
                if (this.title === undefined) { this.title = null; }
                if (this.fitAreaText === undefined) { this.fitAreaText = null; }
                if (this.rotationSupported === undefined) { this.rotationSupported = false; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
                if (this.texture === undefined) { this.texture = null; }
            }
            if (this.title === undefined) { this.title = null; }
            if (this.fitAreaText === undefined) { this.fitAreaText = null; }
            if (this.rotationSupported === undefined) { this.rotationSupported = false; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.textureChoiceView === undefined) { this.textureChoiceView = null; }
            if (this.texture === undefined) { this.texture = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): TextureChoiceView {
        if (this.textureChoiceView == null) {
            this.textureChoiceView = this.viewFactory.createTextureChoiceView(this.preferences, this);
        }
        return this.textureChoiceView;
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Sets the texture displayed by view and fires a <code>PropertyChangeEvent</code>.
     * @param {HomeTexture} texture
     */
    public setTexture(texture: HomeTexture) {
        if (this.texture !== texture && (texture == null || !texture.equals(this.texture))) {
            const oldTexture: HomeTexture = this.texture;
            this.texture = texture;
            this.propertyChangeSupport.firePropertyChange(/* name */"TEXTURE", oldTexture, texture);
        }
    }

    /**
     * Returns the texture displayed by view.
     * @return {HomeTexture}
     */
    public getTexture(): HomeTexture {
        return this.texture;
    }

    /**
     * Returns the text that should be displayed as texture choice dialog title.
     * @return {string}
     */
    public getDialogTitle(): string {
        return this.title;
    }

    /**
     * Returns the text that should be displayed if fit area option is supported.
     * @return {string}
     */
    public getFitAreaText(): string {
        return this.fitAreaText;
    }

    /**
     * Returns <code>true</code> if the rotation of the edited texture is supported.
     * @return {boolean}
     */
    public isRotationSupported(): boolean {
        return this.rotationSupported;
    }

    public importTexture$() {
        new ImportedTextureWizardController(this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
    }

    public importTexture$java_lang_String(textureName: string) {
        new ImportedTextureWizardController(textureName, this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
    }

    /**
     * Controls the import of a texture with a given name.
     * @param {string} textureName
     */
    public importTexture(textureName?: any) {
        if (((typeof textureName === 'string') || textureName === null)) {
            return <any>this.importTexture$java_lang_String(textureName);
        } else if (textureName === undefined) {
            return <any>this.importTexture$();
        } else throw new Error('invalid overload');
    }

    /**
     * Controls the modification of a texture.
     * @param {CatalogTexture} texture
     */
    public modifyTexture(texture: CatalogTexture) {
        new ImportedTextureWizardController(texture, this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
    }

    /**
     * Controls the deletion of a texture.
     * @param {CatalogTexture} texture
     */
    public deleteTexture(texture: CatalogTexture) {
        if (this.getView().confirmDeleteSelectedCatalogTexture()) {
            this.preferences.getTexturesCatalog().delete(texture);
        }
    }

    /**
     * Adds the given <code>texture</code> to the recent textures set.
     * @param {Object} texture
     */
    public addRecentTexture(texture: TextureImage) {
        const recentTextures: Array<TextureImage> = <any>(this.preferences.getRecentTextures().slice(0));
        for (let i: number = 0; i < /* size */(<number>recentTextures.length); i++) {
            {
                const recentTexture: TextureImage = /* get */recentTextures[i];
                if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(recentTexture.getImage(), texture.getImage()))) {
                    if (i === 0) {
                        return;
                    } else {
                    /* remove */recentTextures.splice(i, 1)[0];
                        break;
                    }
                }
            };
        }
        /* add */recentTextures.splice(0, 0, texture);
        while ((/* size */(<number>recentTextures.length) > TextureChoiceController.MAX_RECENT_TEXTURES)) {
            {
            /* remove */recentTextures.splice(/* size */(<number>recentTextures.length) - 1, 1)[0];
            }
        };
        this.preferences.setRecentTextures(recentTextures);
    }
}
TextureChoiceController["__class"] = "com.eteks.sweethome3d.viewcontroller.TextureChoiceController";
TextureChoiceController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



/**
 * Content manager.
 * @author Emmanuel Puybaret
 * @class
 */
interface ContentManager {
    /**
     * Returns a {@link Content} object that references a given content location.
     * @param {string} contentLocation
     * @return {Object}
     */
    getContent(contentLocation: string): Content;

    /**
     * Returns a human readable string for a given content location.
     * @param {string} contentLocation
     * @param {ContentManager.ContentType} contentType
     * @return {string}
     */
    getPresentationName(contentLocation: string, contentType: ContentManager.ContentType): string;

    /**
     * Returns <code>true</code> if the content location in parameter is accepted
     * for <code>contentType</code>.
     * @param {string} contentLocation
     * @param {ContentManager.ContentType} contentType
     * @return {boolean}
     */
    isAcceptable(contentLocation: string, contentType: ContentManager.ContentType): boolean;

    /**
     * Returns the content location chosen by user with an open content dialog.
     * @return {string} the chosen content location or <code>null</code> if user canceled its choice.
     * @param {Object} parentView
     * @param {string} dialogTitle
     * @param {ContentManager.ContentType} contentType
     */
    showOpenDialog(parentView: View, dialogTitle: string, contentType: ContentManager.ContentType): string;

    /**
     * Returns the content location chosen by user with a save content dialog.
     * If the returned location already exists, this method should have confirmed
     * if the user wants to overwrite it before return.
     * @return {string} the chosen content location or <code>null</code> if user canceled its choice.
     * @param {Object} parentView
     * @param {string} dialogTitle
     * @param {ContentManager.ContentType} contentType
     * @param {string} location
     */
    showSaveDialog(parentView: View, dialogTitle: string, contentType: ContentManager.ContentType, location: string): string;
}

export namespace ContentManager {

    export enum ContentType {
        SWEET_HOME_3D, MODEL, IMAGE, CSV, SVG, OBJ, PNG, JPEG, MOV, PDF, LANGUAGE_LIBRARY, TEXTURES_LIBRARY, FURNITURE_LIBRARY, PLUGIN, PHOTOS_DIRECTORY, USER_DEFINED
    }
}


/**
 * An undoable edit able with a localized presentation name.
 * @author Emmanuel Puybaret
 * @param {UserPreferences} preferences
 * @param {Object} controllerClass
 * @param {string} presentationNameKey
 * @class
 * @extends javax.swing.undo.AbstractUndoableEdit
 * @private
 */
export class LocalizedUndoableEdit extends javax.swing.undo.AbstractUndoableEdit {
    /*private*/ preferences: any;

    /*private*/ controllerClass: any;

    /*private*/ presentationNameKey: string;

    public constructor(preferences: any, controllerClass: any, presentationNameKey: string) {
        super();
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.controllerClass === undefined) { this.controllerClass = null; }
        if (this.presentationNameKey === undefined) { this.presentationNameKey = null; }
        this.preferences = preferences;
        this.controllerClass = controllerClass;
        this.presentationNameKey = presentationNameKey;
    }

    /**
     * 
     * @return {string}
     */
    public getPresentationName(): string {
        return this.preferences.getLocalizedString(this.controllerClass, this.presentationNameKey);
    }
}
LocalizedUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.LocalizedUndoableEdit";
LocalizedUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



/**
 * Creates the controller of 3D view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @class
 * @author Emmanuel Puybaret
 */
export class ObserverCameraController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ observerCameraView: DialogView;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ elevation: number;

    /*private*/ minimumElevation: number;

    /*private*/ yawInDegrees: number;

    /*private*/ yaw: number;

    /*private*/ pitchInDegrees: number;

    /*private*/ pitch: number;

    /*private*/ fieldOfViewInDegrees: number;

    /*private*/ fieldOfView: number;

    /*private*/ elevationAdjusted: boolean;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.observerCameraView === undefined) { this.observerCameraView = null; }
        if (this.x === undefined) { this.x = 0; }
        if (this.y === undefined) { this.y = 0; }
        if (this.elevation === undefined) { this.elevation = 0; }
        if (this.minimumElevation === undefined) { this.minimumElevation = 0; }
        if (this.yawInDegrees === undefined) { this.yawInDegrees = 0; }
        if (this.yaw === undefined) { this.yaw = 0; }
        if (this.pitchInDegrees === undefined) { this.pitchInDegrees = 0; }
        if (this.pitch === undefined) { this.pitch = 0; }
        if (this.fieldOfViewInDegrees === undefined) { this.fieldOfViewInDegrees = 0; }
        if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
        if (this.elevationAdjusted === undefined) { this.elevationAdjusted = false; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.observerCameraView == null) {
            this.observerCameraView = this.viewFactory.createObserverCameraView(this.preferences, this);
        }
        return this.observerCameraView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from the 3D attributes of the home edited by this controller.
     */
    updateProperties() {
        const observerCamera: ObserverCamera = this.home.getObserverCamera();
        this.setX(observerCamera.getX());
        this.setY(observerCamera.getY());
        const levels: Array<Level> = this.home.getLevels();
        this.setMinimumElevation(/* size */(<number>levels.length) === 0 ? 10 : 10 + /* get */levels[0].getElevation());
        this.setElevation(observerCamera.getZ());
        this.setYaw(observerCamera.getYaw());
        this.setPitch(observerCamera.getPitch());
        this.setFieldOfView(observerCamera.getFieldOfView());
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        this.setElevationAdjusted(homeEnvironment.isObserverCameraElevationAdjusted());
    }

    /**
     * Sets the edited abscissa.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.propertyChangeSupport.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the edited abscissa.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the edited ordinate.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the edited ordinate.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the edited camera elevation.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldObserverCameraElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldObserverCameraElevation, elevation);
        }
    }

    /**
     * Returns the edited camera elevation.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Sets the minimum elevation.
     * @param {number} minimumElevation
     * @private
     */
    setMinimumElevation(minimumElevation: number) {
        if (minimumElevation !== this.minimumElevation) {
            const oldMinimumElevation: number = this.minimumElevation;
            this.minimumElevation = minimumElevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"MINIMUM_ELEVATION", oldMinimumElevation, minimumElevation);
        }
    }

    /**
     * Returns the minimum elevation.
     * @return {number}
     */
    public getMinimumElevation(): number {
        return this.minimumElevation;
    }

    /**
     * Returns <code>true</code> if the observer elevation should be adjusted according
     * to the elevation of the selected level.
     * @return {boolean}
     */
    public isElevationAdjusted(): boolean {
        return this.elevationAdjusted;
    }

    /**
     * Sets whether the observer elevation should be adjusted according
     * to the elevation of the selected level.
     * @param {boolean} observerCameraElevationAdjusted
     */
    public setElevationAdjusted(observerCameraElevationAdjusted: boolean) {
        if (this.elevationAdjusted !== observerCameraElevationAdjusted) {
            this.elevationAdjusted = observerCameraElevationAdjusted;
            this.propertyChangeSupport.firePropertyChange(/* name */"OBSERVER_CAMERA_ELEVATION_ADJUSTED", !observerCameraElevationAdjusted, observerCameraElevationAdjusted);
            const selectedLevel: Level = this.home.getSelectedLevel();
            if (selectedLevel != null) {
                if (observerCameraElevationAdjusted) {
                    this.setElevation(this.getElevation() - selectedLevel.getElevation());
                } else {
                    this.setElevation(this.getElevation() + selectedLevel.getElevation());
                }
            }
        }
    }

    /**
     * Returns <code>true</code> if the adjustment of the observer camera according to the current level is modifiable.
     * @return {boolean}
     */
    public isObserverCameraElevationAdjustedEditable(): boolean {
        return /* size */(<number>this.home.getLevels().length) > 1;
    }

    public setYawInDegrees(yawInDegrees: number, updateYaw: boolean = true) {
        if (yawInDegrees !== this.yawInDegrees) {
            const oldYawInDegrees: number = this.yawInDegrees;
            this.yawInDegrees = yawInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"YAW_IN_DEGREES", oldYawInDegrees, yawInDegrees);
            if (updateYaw) {
                this.setYaw(<number>/* toRadians */(x => x * Math.PI / 180)(yawInDegrees), false);
            }
        }
    }

    /**
     * Returns the edited yaw in degrees.
     * @return {number}
     */
    public getYawInDegrees(): number {
        return this.yawInDegrees;
    }

    public setYaw(yaw: number, updateYawInDegrees: boolean = true) {
        if (yaw !== this.yaw) {
            const oldYaw: number = this.yaw;
            this.yaw = yaw;
            this.propertyChangeSupport.firePropertyChange(/* name */"YAW", oldYaw, yaw);
            if (updateYawInDegrees) {
                this.setYawInDegrees((<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(yaw)) | 0), false);
            }
        }
    }

    /**
     * Returns the edited yaw in radians.
     * @return {number}
     */
    public getYaw(): number {
        return this.yaw;
    }

    public setPitchInDegrees(pitchInDegrees: number, updatePitch: boolean = true) {
        if (pitchInDegrees !== this.pitchInDegrees) {
            const oldPitchInDegrees: number = this.pitchInDegrees;
            this.pitchInDegrees = pitchInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"PITCH_IN_DEGREES", oldPitchInDegrees, pitchInDegrees);
            if (updatePitch) {
                this.setPitch(<number>/* toRadians */(x => x * Math.PI / 180)(pitchInDegrees), false);
            }
        }
    }

    /**
     * Returns the edited pitch in degrees.
     * @return {number}
     */
    public getPitchInDegrees(): number {
        return this.pitchInDegrees;
    }

    public setPitch(pitch: number, updatePitchInDegrees: boolean = true) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.propertyChangeSupport.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
            if (updatePitchInDegrees) {
                this.setPitchInDegrees((<number>(Math.round(/* toDegrees */(x => x * 180 / Math.PI)(pitch))) | 0), false);
            }
        }
    }

    /**
     * Returns the edited pitch in radians.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    public setFieldOfViewInDegrees(fieldOfViewInDegrees: number, updateFieldOfView: boolean = true) {
        if (fieldOfViewInDegrees !== this.fieldOfViewInDegrees) {
            const oldFieldOfViewInDegrees: number = this.fieldOfViewInDegrees;
            this.fieldOfViewInDegrees = fieldOfViewInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"FIELD_OF_VIEW_IN_DEGREES", oldFieldOfViewInDegrees, fieldOfViewInDegrees);
            if (updateFieldOfView) {
                this.setFieldOfView(<number>/* toRadians */(x => x * Math.PI / 180)(fieldOfViewInDegrees), false);
            }
        }
    }

    /**
     * Returns the edited observer field of view in degrees.
     * @return {number}
     */
    public getFieldOfViewInDegrees(): number {
        return this.fieldOfViewInDegrees;
    }

    public setFieldOfView(fieldOfView: number, updateFieldOfViewInDegrees: boolean = true) {
        if (fieldOfView !== this.fieldOfView) {
            const oldFieldOfView: number = this.fieldOfView;
            this.fieldOfView = fieldOfView;
            this.propertyChangeSupport.firePropertyChange(/* name */"FIELD_OF_VIEW", oldFieldOfView, fieldOfView);
            if (updateFieldOfViewInDegrees) {
                this.setFieldOfViewInDegrees((<number>(Math.round(/* toDegrees */(x => x * 180 / Math.PI)(fieldOfView))) | 0), false);
            }
        }
    }

    /**
     * Returns the edited observer field of view in radians.
     * @return {number}
     */
    public getFieldOfView(): number {
        return this.fieldOfView;
    }

    /**
     * Controls the modification of the observer camera of the edited home.
     */
    public modifyObserverCamera() {
        const x: number = this.getX();
        const y: number = this.getY();
        let z: number = this.getElevation();
        const observerCameraElevationAdjusted: boolean = this.isElevationAdjusted();
        const selectedLevel: Level = this.home.getSelectedLevel();
        if (observerCameraElevationAdjusted && selectedLevel != null) {
            z += selectedLevel.getElevation();
            const levels: Array<Level> = this.home.getLevels();
            z = Math.max(z, /* size */(<number>levels.length) === 0 ? 10 : 10 + /* get */levels[0].getElevation());
        }
        const yaw: number = this.getYaw();
        const pitch: number = this.getPitch();
        const fieldOfView: number = this.getFieldOfView();
        const observerCamera: ObserverCamera = this.home.getObserverCamera();
        observerCamera.setX(x);
        observerCamera.setY(y);
        observerCamera.setZ(z);
        observerCamera.setYaw(yaw);
        observerCamera.setPitch(pitch);
        observerCamera.setFieldOfView(fieldOfView);
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        homeEnvironment.setObserverCameraElevationAdjusted(observerCameraElevationAdjusted);
    }
}
ObserverCameraController["__class"] = "com.eteks.sweethome3d.viewcontroller.ObserverCameraController";
ObserverCameraController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



/**
 * An abstract MVC for a wizard view. Subclasses should create a set of wizard steps
 * with subclasses of <code>WizardControllerStepState</code> and
 * and choose the first step with a call to <code>setStepState</code>.
 * The {@link #finish() finish} method will be called if user completes the wizard
 * steps correctly.
 * @author Emmanuel Puybaret
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @class
 */
export abstract class WizardController implements Controller {
    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ stepStatePropertyChangeListener: PropertyChangeListener;

    /*private*/ wizardView: DialogView;

    /*private*/ stepState: WizardController.WizardControllerStepState;

    /*private*/ backStepEnabled: boolean;

    /*private*/ nextStepEnabled: boolean;

    /*private*/ lastStep: boolean;

    /*private*/ stepView: View;

    /*private*/ stepIcon: string;

    /*private*/ title: string;

    /*private*/ resizable: boolean;

    public constructor(preferences: any, viewFactory: ViewFactory) {
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.stepStatePropertyChangeListener === undefined) { this.stepStatePropertyChangeListener = null; }
        if (this.wizardView === undefined) { this.wizardView = null; }
        if (this.stepState === undefined) { this.stepState = null; }
        if (this.backStepEnabled === undefined) { this.backStepEnabled = false; }
        if (this.nextStepEnabled === undefined) { this.nextStepEnabled = false; }
        if (this.lastStep === undefined) { this.lastStep = false; }
        if (this.stepView === undefined) { this.stepView = null; }
        if (this.stepIcon === undefined) { this.stepIcon = null; }
        if (this.title === undefined) { this.title = null; }
        if (this.resizable === undefined) { this.resizable = false; }
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.stepStatePropertyChangeListener = new WizardController.WizardController$0(this);
        this.propertyChangeSupport = new PropertyChangeSupport(this);
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.wizardView == null) {
            this.wizardView = this.viewFactory.createWizardView(this.preferences, this);
        }
        return this.wizardView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Sets whether back step is enabled or not.
     * @param {boolean} backStepEnabled
     * @private
     */
    setBackStepEnabled(backStepEnabled: boolean) {
        if (backStepEnabled !== this.backStepEnabled) {
            this.backStepEnabled = backStepEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"BACK_STEP_ENABLED", !backStepEnabled, backStepEnabled);
        }
    }

    /**
     * Returns whether back step is enabled or not.
     * @return {boolean}
     */
    public isBackStepEnabled(): boolean {
        return this.backStepEnabled;
    }

    /**
     * Sets whether next step is enabled or not.
     * @param {boolean} nextStepEnabled
     * @private
     */
    setNextStepEnabled(nextStepEnabled: boolean) {
        if (nextStepEnabled !== this.nextStepEnabled) {
            this.nextStepEnabled = nextStepEnabled;
            this.propertyChangeSupport.firePropertyChange(/* name */"NEXT_STEP_ENABLED", !nextStepEnabled, nextStepEnabled);
        }
    }

    /**
     * Returns whether next step is enabled or not.
     * @return {boolean}
     */
    public isNextStepEnabled(): boolean {
        return this.nextStepEnabled;
    }

    /**
     * Sets whether this is the last step or not.
     * @param {boolean} lastStep
     * @private
     */
    setLastStep(lastStep: boolean) {
        if (lastStep !== this.lastStep) {
            this.lastStep = lastStep;
            this.propertyChangeSupport.firePropertyChange(/* name */"LAST_STEP", !lastStep, lastStep);
        }
    }

    /**
     * Returns whether this is the last step or not.
     * @return {boolean}
     */
    public isLastStep(): boolean {
        return this.lastStep;
    }

    /**
     * Sets the step view.
     * @param {Object} stepView
     * @private
     */
    setStepView(stepView: View) {
        if (stepView !== this.stepView) {
            const oldStepView: View = this.stepView;
            this.stepView = stepView;
            this.propertyChangeSupport.firePropertyChange(/* name */"STEP_VIEW", oldStepView, stepView);
        }
    }

    /**
     * Returns the current step view.
     * @return {Object}
     */
    public getStepView(): View {
        return this.stepView;
    }

    /**
     * Sets the step icon.
     * @param {string} stepIcon
     * @private
     */
    setStepIcon(stepIcon: string) {
        if (stepIcon !== this.stepIcon) {
            const oldStepIcon: string = this.stepIcon;
            this.stepIcon = stepIcon;
            this.propertyChangeSupport.firePropertyChange(/* name */"STEP_ICON", oldStepIcon, stepIcon);
        }
    }

    /**
     * Returns the current step icon.
     * @return {string}
     */
    public getStepIcon(): string {
        return this.stepIcon;
    }

    /**
     * Sets the wizard title.
     * @param {string} title
     */
    public setTitle(title: string) {
        if (title !== this.title) {
            const oldTitle: string = this.title;
            this.title = title;
            this.propertyChangeSupport.firePropertyChange(/* name */"TITLE", oldTitle, title);
        }
    }

    /**
     * Returns the wizard title.
     * @return {string}
     */
    public getTitle(): string {
        return this.title;
    }

    /**
     * Sets whether the wizard is resizable or not.
     * @param {boolean} resizable
     */
    public setResizable(resizable: boolean) {
        if (resizable !== this.resizable) {
            this.resizable = resizable;
            this.propertyChangeSupport.firePropertyChange(/* name */"RESIZABLE", !resizable, resizable);
        }
    }

    /**
     * Returns whether the wizard is resizable or not.
     * @return {boolean}
     */
    public isResizable(): boolean {
        return this.resizable;
    }

    /**
     * Changes current state of controller.
     * @param {WizardController.WizardControllerStepState} stepState
     */
    setStepState(stepState: WizardController.WizardControllerStepState) {
        if (this.stepState != null) {
            this.stepState.exit();
            this.stepState.removePropertyChangeListener(this.stepStatePropertyChangeListener);
        }
        this.stepState = stepState;
        this.setBackStepEnabled(!stepState.isFirstStep());
        this.setNextStepEnabled(stepState.isNextStepEnabled());
        this.setStepView(stepState.getView());
        this.setStepIcon(stepState.getIcon());
        this.setLastStep(stepState.isLastStep());
        this.stepState.addPropertyChangeListener(this.stepStatePropertyChangeListener);
        this.stepState.enter();
    }

    getStepState(): WizardController.WizardControllerStepState {
        return this.stepState;
    }

    /**
     * Requires to the current step to jump to next step.
     */
    public goToNextStep() {
        this.stepState.goToNextStep();
    }

    /**
     * Requires to the current step to go back to previous step.
     */
    public goBackToPreviousStep() {
        this.stepState.goBackToPreviousStep();
    }

    /**
     * Requires the wizard to finish.
     */
    public abstract finish();
}
WizardController["__class"] = "com.eteks.sweethome3d.viewcontroller.WizardController";
WizardController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace WizardController {

    /**
     * State of a step in wizard.
     * @class
     */
    export abstract class WizardControllerStepState {
        propertyChangeSupport: PropertyChangeSupport;

        firstStep: boolean;

        lastStep: boolean;

        nextStepEnabled: boolean;

        public constructor() {
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.firstStep === undefined) { this.firstStep = false; }
            if (this.lastStep === undefined) { this.lastStep = false; }
            if (this.nextStepEnabled === undefined) { this.nextStepEnabled = false; }
            this.propertyChangeSupport = new PropertyChangeSupport(this);
        }

        /**
         * Adds the property change <code>listener</code> in parameter to this home.
         * @param {PropertyChangeListener} listener
         * @private
         */
        addPropertyChangeListener(listener: PropertyChangeListener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        /**
         * Removes the property change <code>listener</code> in parameter from this home.
         * @param {PropertyChangeListener} listener
         * @private
         */
        removePropertyChangeListener(listener: PropertyChangeListener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public enter() {
        }

        public exit() {
        }

        public abstract getView(): View;

        public getIcon(): string {
            return null;
        }

        public goBackToPreviousStep() {
        }

        public goToNextStep() {
        }

        public isFirstStep(): boolean {
            return this.firstStep;
        }

        public setFirstStep(firstStep: boolean) {
            if (firstStep !== this.firstStep) {
                this.firstStep = firstStep;
                this.propertyChangeSupport.firePropertyChange(/* name */"FIRST_STEP", !firstStep, firstStep);
            }
        }

        public isLastStep(): boolean {
            return this.lastStep;
        }

        public setLastStep(lastStep: boolean) {
            if (lastStep !== this.lastStep) {
                this.lastStep = lastStep;
                this.propertyChangeSupport.firePropertyChange(/* name */"LAST_STEP", !lastStep, lastStep);
            }
        }

        public isNextStepEnabled(): boolean {
            return this.nextStepEnabled;
        }

        public setNextStepEnabled(nextStepEnabled: boolean) {
            if (nextStepEnabled !== this.nextStepEnabled) {
                this.nextStepEnabled = nextStepEnabled;
                this.propertyChangeSupport.firePropertyChange(/* name */"NEXT_STEP_ENABLED", !nextStepEnabled, nextStepEnabled);
            }
        }
    }
    WizardControllerStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.WizardController.WizardControllerStepState";


    export class WizardController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            switch ((/* valueOf */ev.getPropertyName())) {
                case "FIRST_STEP":
                    this.__parent.setBackStepEnabled(!this.__parent.stepState.isFirstStep());
                    break;
                case "LAST_STEP":
                    this.__parent.setLastStep(this.__parent.stepState.isLastStep());
                    break;
                case "NEXT_STEP_ENABLED":
                    this.__parent.setNextStepEnabled(this.__parent.stepState.isNextStepEnabled());
                    break;
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * Creates the controller of room view with undo support.
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 * @author Emmanuel Puybaret
 */
export class BaseboardChoiceController implements Controller {
    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ textureController: TextureChoiceController;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ view: View;

    /*private*/ visible: boolean;

    /*private*/ thickness: number;

    /*private*/ height: number;

    /*private*/ maxHeight: number;

    /*private*/ color: number;

    /*private*/ paint: BaseboardChoiceController.BaseboardPaint;

    public constructor(preferences: any, viewFactory: ViewFactory, contentManager: ContentManager) {
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.textureController === undefined) { this.textureController = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.view === undefined) { this.view = null; }
        if (this.visible === undefined) { this.visible = null; }
        if (this.thickness === undefined) { this.thickness = null; }
        if (this.height === undefined) { this.height = null; }
        if (this.maxHeight === undefined) { this.maxHeight = null; }
        if (this.color === undefined) { this.color = null; }
        if (this.paint === undefined) { this.paint = null; }
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
    }

    /**
     * Returns the texture controller of the baseboard.
     * @return {TextureChoiceController}
     */
    public getTextureController(): TextureChoiceController {
        if (this.textureController == null) {
            this.textureController = new TextureChoiceController(this.preferences.getLocalizedString(BaseboardChoiceController, "baseboardTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.textureController.addPropertyChangeListener("TEXTURE", new BaseboardChoiceController.BaseboardChoiceController$0(this));
        }
        return this.textureController;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): View {
        if (this.view == null) {
            this.view = this.viewFactory.createBaseboardChoiceView(this.preferences, this);
        }
        return this.view;
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Returns <code>true</code> if the baseboard should be visible.
     * @return {boolean}
     */
    public getVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether the baseboard should be visible.
     * @param {boolean} baseboardVisible
     */
    public setVisible(baseboardVisible: boolean) {
        if (baseboardVisible !== this.visible) {
            const oldVisible: boolean = this.visible;
            this.visible = baseboardVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"VISIBLE", oldVisible, baseboardVisible);
        }
    }

    /**
     * Sets the edited thickness of the baseboard.
     * @param {number} baseboardThickness
     */
    public setThickness(baseboardThickness: number) {
        if (baseboardThickness !== this.thickness) {
            const oldThickness: number = this.thickness;
            this.thickness = baseboardThickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"THICKNESS", oldThickness, baseboardThickness);
        }
    }

    /**
     * Returns the edited thickness of the baseboard.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Sets the edited height of the baseboard.
     * @param {number} baseboardHeight
     */
    public setHeight(baseboardHeight: number) {
        if (baseboardHeight !== this.height) {
            const oldHeight: number = this.height;
            this.height = baseboardHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, baseboardHeight);
        }
    }

    /**
     * Returns the edited height of the baseboard.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the maximum height allowed for the edited baseboard.
     * @param {number} maxHeight
     */
    public setMaxHeight(maxHeight: number) {
        if (this.maxHeight == null || maxHeight !== this.maxHeight) {
            const oldMaxHeight: number = this.maxHeight;
            this.maxHeight = maxHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"MAX_HEIGHT", oldMaxHeight, maxHeight);
        }
    }

    /**
     * Returns the maximum height allowed for the edited baseboard.
     * @return {number}
     */
    public getMaxHeight(): number {
        return this.maxHeight;
    }

    /**
     * Sets the edited color of the baseboard.
     * @param {number} baseboardColor
     */
    public setColor(baseboardColor: number) {
        if (baseboardColor !== this.color) {
            const oldColor: number = this.color;
            this.color = baseboardColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, baseboardColor);
            this.setPaint(BaseboardChoiceController.BaseboardPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the baseboard.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets whether the baseboard is as its wall, colored, textured or unknown painted.
     * @param {BaseboardChoiceController.BaseboardPaint} baseboardPaint
     */
    public setPaint(baseboardPaint: BaseboardChoiceController.BaseboardPaint) {
        if (baseboardPaint !== this.paint) {
            const oldPaint: BaseboardChoiceController.BaseboardPaint = this.paint;
            this.paint = baseboardPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"PAINT", oldPaint, baseboardPaint);
        }
    }

    /**
     * Returns whether the baseboard side is colored, textured or unknown painted.
     * @return {BaseboardChoiceController.BaseboardPaint} {@link BaseboardPaint#DEFAULT}, {@link BaseboardPaint#COLORED}, {@link BaseboardPaint#TEXTURED} or <code>null</code>
     */
    public getPaint(): BaseboardChoiceController.BaseboardPaint {
        return this.paint;
    }

    /**
     * Set controller properties from the given <code>baseboard</code>.
     * @param {Baseboard} baseboard
     */
    public setBaseboard(baseboard: Baseboard) {
        if (baseboard == null) {
            this.setVisible(false);
            this.setThickness(null);
            this.setHeight(null);
            this.setColor(null);
            this.getTextureController().setTexture(null);
            this.setPaint(null);
        } else {
            this.setVisible(true);
            this.setThickness(baseboard.getThickness());
            this.setHeight(baseboard.getHeight());
            if (baseboard.getTexture() != null) {
                this.setColor(null);
                this.getTextureController().setTexture(baseboard.getTexture());
                this.setPaint(BaseboardChoiceController.BaseboardPaint.TEXTURED);
            } else if (baseboard.getColor() != null) {
                this.getTextureController().setTexture(null);
                this.setColor(baseboard.getColor());
            } else {
                this.setColor(null);
                this.getTextureController().setTexture(null);
                this.setPaint(BaseboardChoiceController.BaseboardPaint.DEFAULT);
            }
        }
    }
}
BaseboardChoiceController["__class"] = "com.eteks.sweethome3d.viewcontroller.BaseboardChoiceController";
BaseboardChoiceController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace BaseboardChoiceController {

    /**
     * The possible values for {@linkplain #getPaint() paint type}.
     * @enum
     * @property {BaseboardChoiceController.BaseboardPaint} DEFAULT
     * @property {BaseboardChoiceController.BaseboardPaint} COLORED
     * @property {BaseboardChoiceController.BaseboardPaint} TEXTURED
     * @class
     */
    export enum BaseboardPaint {
        DEFAULT, COLORED, TEXTURED
    }

    export class BaseboardChoiceController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setPaint(BaseboardChoiceController.BaseboardPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * The view that displays the 3D view of a home.
 * @author Emmanuel Puybaret
 * @class
 */
interface View3D extends View {
    /**
     * Returns the closest {@link Selectable} object at component coordinates (x, y),
     * or <code>null</code> if not found.
     * @param {number} x
     * @param {number} y
     * @return {Object}
     */
    getClosestSelectableItemAt(x: number, y: number): Selectable;

    /**
     * Returns the coordinates of the 3D point matching the point (x, y) in component coordinates space.
     * @param {number} x
     * @param {number} y
     * @return {float[]}
     */
    convertPixelLocationToVirtualWorld(x: number, y: number): number[];

    /**
     * Returns the coordinates of the 3D point intersecting the plane at the given <code>elevation</code>
     * in the direction joining camera location and component coordinates (x, y).
     * @param {number} x
     * @param {number} y
     * @param {number} elevation
     * @return {float[]}
     */
    getVirtualWorldPointAt(x: number, y: number, elevation: number): number[];
}

/**
 * A view of a threaded task.
 * @author Emmanuel Puybaret
 * @class
 */
interface ThreadedTaskView extends View {
    /**
     * Executes <code>runnable</code> asynchronously in the toolkit event thread.
     * @param {() => void} runnable
     */
    invokeLater(runnable: () => void);

    /**
     * Sets the running status of the threaded task.
     * If <code>taskRunning</code> is <code>true</code>, a waiting dialog will be shown.
     * @param {boolean} taskRunning
     * @param {Object} executingView
     */
    setTaskRunning(taskRunning: boolean, executingView: View);
}

/**
 * The base class for controllers of photo creation views.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} view3D
 * @param {Object} contentManager
 * @class
 * @ignore
 */
export abstract class AbstractPhotoController implements Controller {
    /*private*/ home: Home;

    /*private*/ view3D: View;

    /*private*/ contentManager: ContentManager;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ aspectRatio: AspectRatio;

    /*private*/ width: number;

    /*private*/ height: number;

    /*private*/ quality: number;

    /*private*/ view3DAspectRatio: number;

    /*private*/ ceilingLightColor: number;

    public constructor(home: Home, preferences: any, view3D: View, contentManager: ContentManager) {
        if (this.home === undefined) { this.home = null; }
        if (this.view3D === undefined) { this.view3D = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.aspectRatio === undefined) { this.aspectRatio = null; }
        if (this.width === undefined) { this.width = 0; }
        if (this.height === undefined) { this.height = 0; }
        if (this.quality === undefined) { this.quality = 0; }
        if (this.view3DAspectRatio === undefined) { this.view3DAspectRatio = 0; }
        if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
        this.home = home;
        this.view3D = view3D;
        this.contentManager = contentManager;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.view3DAspectRatio = 1;
        const listener: AbstractPhotoController.EnvironmentChangeListener = new AbstractPhotoController.EnvironmentChangeListener(this);
        home.getEnvironment().addPropertyChangeListener("PHOTO_WIDTH", listener);
        home.getEnvironment().addPropertyChangeListener("PHOTO_HEIGHT", listener);
        home.getEnvironment().addPropertyChangeListener("PHOTO_ASPECT_RATIO", listener);
        home.getEnvironment().addPropertyChangeListener("PHOTO_QUALITY", listener);
        home.getEnvironment().addPropertyChangeListener("CEILING_LIGHT_COLOR", listener);
        this.updateProperties();
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from the photo creation preferences.
     */
    updateProperties() {
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        this.setAspectRatio(homeEnvironment.getPhotoAspectRatio());
        this.setWidth(homeEnvironment.getPhotoWidth(), false);
        this.setHeight(homeEnvironment.getPhotoHeight(), false);
        this.setQuality(homeEnvironment.getPhotoQuality());
        this.setCeilingLightColor(homeEnvironment.getCeillingLightColor());
    }

    /**
     * Sets the aspect ratio of the photo.
     * @param {AspectRatio} aspectRatio
     */
    public setAspectRatio(aspectRatio: AspectRatio) {
        if (this.aspectRatio !== aspectRatio) {
            const oldAspectRatio: AspectRatio = this.aspectRatio;
            this.aspectRatio = aspectRatio;
            this.propertyChangeSupport.firePropertyChange(/* name */"ASPECT_RATIO", oldAspectRatio, aspectRatio);
            this.home.getEnvironment().setPhotoAspectRatio(this.aspectRatio);
            if (this.aspectRatio === AspectRatio.VIEW_3D_RATIO) {
                if (this.view3DAspectRatio !== Infinity) {
                    this.setHeight(Math.round(this.width / this.view3DAspectRatio), false);
                }
            } else if ({ FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio] != null) {
                this.setHeight(Math.round(this.width / { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
            }
        }
    }

    /**
     * Returns the aspect ratio of the photo.
     * @return {AspectRatio}
     */
    public getAspectRatio(): AspectRatio {
        return this.aspectRatio;
    }

    public setWidth(width: number, updateHeight: boolean = true) {
        if (this.width !== width) {
            const oldWidth: number = this.width;
            this.width = width;
            this.propertyChangeSupport.firePropertyChange(/* name */"WIDTH", oldWidth, width);
            if (updateHeight) {
                if (this.aspectRatio === AspectRatio.VIEW_3D_RATIO) {
                    if (this.view3DAspectRatio !== Infinity) {
                        this.setHeight(Math.round(width / this.view3DAspectRatio), false);
                    }
                } else if ({ FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio] != null) {
                    this.setHeight(Math.round(width / { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
                }
            }
            this.home.getEnvironment().setPhotoWidth(this.width);
        }
    }

    /**
     * Returns the width of the photo.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    public setHeight(height: number, updateWidth: boolean = true) {
        if (this.height !== height) {
            const oldHeight: number = this.height;
            this.height = height;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
            if (updateWidth) {
                if (this.aspectRatio === AspectRatio.VIEW_3D_RATIO) {
                    if (this.view3DAspectRatio !== Infinity) {
                        this.setWidth(Math.round(height * this.view3DAspectRatio), false);
                    }
                } else if ({ FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio] != null) {
                    this.setWidth(Math.round(height * { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
                }
            }
            this.home.getEnvironment().setPhotoHeight(this.height);
        }
    }

    /**
     * Returns the height of the photo.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the rendering quality of the photo.
     * @param {number} quality
     */
    public setQuality(quality: number) {
        if (this.quality !== quality) {
            const oldQuality: number = this.quality;
            this.quality = Math.min(quality, this.getQualityLevelCount() - 1);
            this.propertyChangeSupport.firePropertyChange(/* name */"QUALITY", oldQuality, quality);
            this.home.getEnvironment().setPhotoQuality(this.quality);
        }
    }

    /**
     * Returns the rendering quality of the photo.
     * @return {number}
     */
    public getQuality(): number {
        return this.quality;
    }

    /**
     * Returns the maximum value for quality.
     * @return {number}
     */
    public getQualityLevelCount(): number {
        return 4;
    }

    /**
     * Sets the edited ceiling light color.
     * @param {number} ceilingLightColor
     */
    public setCeilingLightColor(ceilingLightColor: number) {
        if (this.ceilingLightColor !== ceilingLightColor) {
            const oldCeilingLightColor: number = this.ceilingLightColor;
            this.ceilingLightColor = ceilingLightColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_LIGHT_COLOR", oldCeilingLightColor, ceilingLightColor);
            this.home.getEnvironment().setCeillingLightColor(ceilingLightColor);
        }
    }

    /**
     * Returns the edited ceiling light color.
     * @return {number}
     */
    public getCeilingLightColor(): number {
        return this.ceilingLightColor;
    }

    /**
     * Sets the aspect ratio of the 3D view.
     * @param {number} view3DAspectRatio
     */
    public set3DViewAspectRatio(view3DAspectRatio: number) {
        if (this.view3DAspectRatio !== view3DAspectRatio) {
            const oldAspectRatio: number = this.view3DAspectRatio;
            this.view3DAspectRatio = view3DAspectRatio;
            this.propertyChangeSupport.firePropertyChange(/* name */"ASPECT_RATIO", oldAspectRatio, view3DAspectRatio);
            if (this.aspectRatio === AspectRatio.VIEW_3D_RATIO && this.view3DAspectRatio !== Infinity) {
                this.setHeight(Math.round(this.width / this.view3DAspectRatio), false);
            }
        }
    }

    /**
     * Returns the aspect ratio of the 3D view.
     * @return {number}
     */
    public get3DViewAspectRatio(): number {
        return this.view3DAspectRatio;
    }

    /**
     * Returns the 3D view used to compute aspect ratio bound to it.
     * @return {Object}
     */
    public get3DView(): View {
        return this.view3D;
    }

    /**
     * Controls the change of value of a visual property in home.
     * @deprecated {@link #setVisualProperty(String, Object) setVisualProperty} should be replaced by a call to
     * {@link #setHomeProperty(String, String)} to ensure the property can be easily saved and read.
     * @param {string} propertyName
     * @param {Object} propertyValue
     */
    public setVisualProperty(propertyName: string, propertyValue: any) {
        this.home.setVisualProperty(propertyName, propertyValue);
    }

    /**
     * Controls the change of value of a property in home.
     * @param {string} propertyName
     * @param {string} propertyValue
     */
    public setHomeProperty(propertyName: string, propertyValue: string) {
        this.home.setProperty(propertyName, propertyValue);
    }

    public abstract getView(): any;
}
AbstractPhotoController["__class"] = "com.eteks.sweethome3d.viewcontroller.AbstractPhotoController";
AbstractPhotoController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace AbstractPhotoController {

    /**
     * Home environment listener that updates ceiling light color. This listener is bound to this controller
     * with a weak reference to avoid strong link between home and this controller.
     * @param {AbstractPhotoController} photoController
     * @class
     */
    export class EnvironmentChangeListener {
        photoController: AbstractPhotoController;

        public constructor(photoController: AbstractPhotoController) {
            if (this.photoController === undefined) { this.photoController = null; }
            this.photoController = <any>(photoController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: AbstractPhotoController = /* get */this.photoController;
            if (controller == null) {
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("PHOTO_WIDTH", this);
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("PHOTO_HEIGHT", this);
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("PHOTO_ASPECT_RATIO", this);
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("PHOTO_QUALITY", this);
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("CEILING_LIGHT_COLOR", this);
            } else if (/* name */"PHOTO_WIDTH" === ev.getPropertyName()) {
                controller.setWidth(<number>ev.getNewValue(), false);
            } else if (/* name */"PHOTO_HEIGHT" === ev.getPropertyName()) {
                controller.setHeight(<number>ev.getNewValue(), false);
            } else if (/* name */"PHOTO_ASPECT_RATIO" === ev.getPropertyName()) {
                controller.setAspectRatio(<AspectRatio>ev.getNewValue());
            } else if (/* name */"PHOTO_QUALITY" === ev.getPropertyName()) {
                controller.setQuality(<number>ev.getNewValue());
            } else if (/* name */"CEILING_LIGHT_COLOR" === ev.getPropertyName()) {
                controller.setCeilingLightColor(<number>ev.getNewValue());
            }
        }
    }
    EnvironmentChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.AbstractPhotoController.EnvironmentChangeListener";

}


/**
 * Creates the controller of home 3D view.
 * @param {Home} home the home edited by this controller and its view
 * @param {PlanController} planController
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeController3D implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ planController: PlanController;

    /*private*/ home3DView: View;

    /*private*/ topCameraState: HomeController3D.CameraControllerState;

    /*private*/ observerCameraState: HomeController3D.CameraControllerState;

    /*private*/ cameraState: HomeController3D.CameraControllerState;

    public constructor(home?: any, planController?: any, preferences?: any, viewFactory?: any, contentManager?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((planController != null && planController instanceof <any>PlanController) || planController === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            {
                let __args = arguments;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.planController === undefined) { this.planController = null; }
                if (this.home3DView === undefined) { this.home3DView = null; }
                if (this.topCameraState === undefined) { this.topCameraState = null; }
                if (this.observerCameraState === undefined) { this.observerCameraState = null; }
                if (this.cameraState === undefined) { this.cameraState = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.undoSupport = undoSupport;
                this.topCameraState = new HomeController3D.TopCameraState(this, preferences);
                this.observerCameraState = new HomeController3D.ObserverCameraState(this);
                this.setCameraState(home.getCamera() === home.getTopCamera() ? this.topCameraState : this.observerCameraState);
                this.addModelListeners(home);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.home3DView === undefined) { this.home3DView = null; }
            if (this.topCameraState === undefined) { this.topCameraState = null; }
            if (this.observerCameraState === undefined) { this.observerCameraState = null; }
            if (this.cameraState === undefined) { this.cameraState = null; }
            (() => {
                this.planController = planController;
            })();
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((planController != null && planController instanceof <any>UserPreferences) || planController === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && ((contentManager != null && contentManager instanceof <any>javax.swing.undo.UndoableEditSupport) || contentManager === null) && undoSupport === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            let undoSupport: any = __args[4];
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.home3DView === undefined) { this.home3DView = null; }
            if (this.topCameraState === undefined) { this.topCameraState = null; }
            if (this.observerCameraState === undefined) { this.observerCameraState = null; }
            if (this.cameraState === undefined) { this.cameraState = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.contentManager = contentManager;
            this.undoSupport = undoSupport;
            this.topCameraState = new HomeController3D.TopCameraState(this, preferences);
            this.observerCameraState = new HomeController3D.ObserverCameraState(this);
            this.setCameraState(home.getCamera() === home.getTopCamera() ? this.topCameraState : this.observerCameraState);
            this.addModelListeners(home);
        } else throw new Error('invalid overload');
    }

    /**
     * Add listeners to model to update camera position accordingly.
     * @param {Home} home
     * @private
     */
    addModelListeners(home: Home) {
        home.addPropertyChangeListener("CAMERA", new HomeController3D.HomeController3D$0(this, home));
        const levelElevationChangeListener: PropertyChangeListener = new HomeController3D.HomeController3D$1(this, home);
        const selectedLevel: Level = home.getSelectedLevel();
        if (selectedLevel != null) {
            selectedLevel.addPropertyChangeListener(levelElevationChangeListener);
        }
        home.addPropertyChangeListener("SELECTED_LEVEL", new HomeController3D.HomeController3D$2(this, home, levelElevationChangeListener));
        const selectedLevelListener: PropertyChangeListener = new HomeController3D.HomeController3D$3(this, home);
        home.addPropertyChangeListener("SELECTED_LEVEL", selectedLevelListener);
        home.getEnvironment().addPropertyChangeListener("ALL_LEVELS_VISIBLE", selectedLevelListener);
    }

    getObserverCameraMinimumElevation(home: Home): number {
        const levels: Array<Level> = home.getLevels();
        const minimumElevation: number = /* size */(<number>levels.length) === 0 ? 10 : 10 + /* get */levels[0].getElevation();
        return minimumElevation;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): View {
        if (this.home3DView == null) {
            this.home3DView = this.viewFactory.createView3D(this.home, this.preferences, this);
        }
        return this.home3DView;
    }

    /**
     * Changes home camera for {@link Home#getTopCamera() top camera}.
     */
    public viewFromTop() {
        this.home.setCamera(this.home.getTopCamera());
    }

    /**
     * Changes home camera for {@link Home#getObserverCamera() observer camera}.
     */
    public viewFromObserver() {
        this.home.setCamera(this.home.getObserverCamera());
    }

    /**
     * Stores a clone of the current camera in home under the given <code>name</code>.
     * @param {string} name
     */
    public storeCamera(name: string) {
        const camera: Camera = <Camera>this.home.getCamera().duplicate();
        camera.setName(name);
        const homeStoredCameras: Array<Camera> = this.home.getStoredCameras();
        const storedCameras: Array<Camera> = <any>([]);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(storedCameras, homeStoredCameras);
        for (let i: number = /* size */(<number>storedCameras.length) - 1; i >= 0; i--) {
            {
                const storedCamera: Camera = /* get */storedCameras[i];
                if ((name === storedCamera.getName()) || (camera.getX() === storedCamera.getX() && camera.getY() === storedCamera.getY() && camera.getZ() === storedCamera.getZ() && camera.getPitch() === storedCamera.getPitch() && camera.getYaw() === storedCamera.getYaw() && camera.getFieldOfView() === storedCamera.getFieldOfView() && camera.getTime() === storedCamera.getTime() && camera.getLens() === storedCamera.getLens() && (camera.getRenderer() === storedCamera.getRenderer() || camera.getRenderer() != null && (camera.getRenderer() === storedCamera.getRenderer())))) {
                /* remove */storedCameras.splice(i, 1)[0];
                }
            };
        }
        /* add */storedCameras.splice(0, 0, camera);
        while ((/* size */(<number>storedCameras.length) > this.preferences.getStoredCamerasMaxCount())) {
            {
            /* remove */storedCameras.splice(/* size */(<number>storedCameras.length) - 1, 1)[0];
            }
        };
        this.home.setStoredCameras(storedCameras);
    }

    /**
     * Switches to observer or top camera and move camera to the values as the current camera.
     * @param {Camera} camera
     */
    public goToCamera(camera: Camera) {
        if (camera != null && camera instanceof <any>ObserverCamera) {
            this.viewFromObserver();
        } else {
            this.viewFromTop();
        }
        this.cameraState.goToCamera(camera);
        const storedCameras: Array<Camera> = <any>(this.home.getStoredCameras().slice(0));
        /* remove */(a => { let index = a.indexOf(camera); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(storedCameras);
        /* add */storedCameras.splice(0, 0, camera);
        this.home.setStoredCameras(storedCameras);
    }

    /**
     * Deletes the given list of cameras from the ones stored in home.
     * @param {Camera[]} cameras
     */
    public deleteCameras(cameras: Array<Camera>) {
        const homeStoredCameras: Array<Camera> = this.home.getStoredCameras();
        const storedCameras: Array<Camera> = <any>([]);
        for (let index = 0; index < homeStoredCameras.length; index++) {
            let camera = homeStoredCameras[index];
            {
                if (!/* contains */(cameras.indexOf(<any>(camera)) >= 0)) {
                    /* add */(storedCameras.push(camera) > 0);
                }
            }
        }
        this.home.setStoredCameras(storedCameras);
    }

    /**
     * Makes all levels visible.
     */
    public displayAllLevels() {
        this.home.getEnvironment().setAllLevelsVisible(true);
    }

    /**
     * Makes the selected level and below visible.
     */
    public displaySelectedLevel() {
        this.home.getEnvironment().setAllLevelsVisible(false);
    }

    /**
     * Controls the edition of 3D attributes.
     */
    public modifyAttributes() {
        new Home3DAttributesController(this.home, this.preferences, this.viewFactory, this.contentManager, this.undoSupport).displayView(this.getView());
    }

    /**
     * Changes current state of controller.
     * @param {HomeController3D.CameraControllerState} state
     */
    setCameraState(state: HomeController3D.CameraControllerState) {
        if (this.cameraState != null) {
            this.cameraState.exit();
        }
        this.cameraState = state;
        this.cameraState.enter();
    }

    /**
     * Moves home camera of <code>delta</code>.
     * @param {number} delta  the value in cm that the camera should move forward
     * (with a negative delta) or backward (with a positive delta)
     */
    public moveCamera(delta: number) {
        this.cameraState.moveCamera(delta);
    }

    /**
     * Moves home camera sideways of <code>delta</code>.
     * @param {number} delta  the value in cm that the camera should move left
     * (with a negative delta) or right (with a positive delta)
     */
    public moveCameraSideways(delta: number) {
        this.cameraState.moveCameraSideways(delta);
    }

    /**
     * Elevates home camera of <code>delta</code>.
     * @param {number} delta the value in cm that the camera should move down
     * (with a negative delta) or up (with a positive delta)
     */
    public elevateCamera(delta: number) {
        this.cameraState.elevateCamera(delta);
    }

    /**
     * Rotates home camera yaw angle of <code>delta</code> radians.
     * @param {number} delta  the value in rad that the camera should turn around yaw axis
     */
    public rotateCameraYaw(delta: number) {
        this.cameraState.rotateCameraYaw(delta);
    }

    /**
     * Rotates home camera pitch angle of <code>delta</code> radians.
     * @param {number} delta  the value in rad that the camera should turn around pitch axis
     */
    public rotateCameraPitch(delta: number) {
        this.cameraState.rotateCameraPitch(delta);
    }

    /**
     * Modifies home camera field of view of <code>delta</code>.
     * @param {number} delta  the value in rad that should be added the field of view
     * to get a narrower view (with a negative delta) or a wider view (with a positive delta)
     */
    public modifyFieldOfView(delta: number) {
        this.cameraState.modifyFieldOfView(delta);
    }

    /**
     * Processes a mouse button pressed event.
     * @param {number} x
     * @param {number} y
     * @param {number} clickCount
     * @param {boolean} shiftDown
     * @param {boolean} alignmentActivated
     * @param {boolean} duplicationActivated
     * @param {boolean} magnetismToggled
     * @param {View.PointerType} pointerType
     */
    public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, alignmentActivated: boolean, duplicationActivated: boolean, magnetismToggled: boolean, pointerType: View.PointerType) {
        this.cameraState.pressMouse(x, y, clickCount, shiftDown, alignmentActivated, duplicationActivated, magnetismToggled, pointerType);
    }

    /**
     * Processes a mouse button released event.
     * @param {number} x
     * @param {number} y
     */
    public releaseMouse(x: number, y: number) {
        this.cameraState.releaseMouse(x, y);
    }

    /**
     * Processes a mouse button moved event.
     * @param {number} x
     * @param {number} y
     */
    public moveMouse(x: number, y: number) {
        this.cameraState.moveMouse(x, y);
    }

    /**
     * Returns <code>true</code> if this controller is moving items.
     * @return {boolean}
     */
    public isEditingState(): boolean {
        return this.cameraState.isEditingState();
    }

    /**
     * Escapes of current editing action.
     */
    public escape() {
        this.cameraState.escape();
    }

    /**
     * Toggles temporary magnetism feature of user preferences during editing action.
     * @param {boolean} magnetismToggled if <code>true</code> then magnetism feature is toggled.
     */
    public toggleMagnetism(magnetismToggled: boolean) {
        this.cameraState.toggleMagnetism(magnetismToggled);
    }

    /**
     * Activates or deactivates alignment feature during editing action.
     * @param {boolean} alignmentActivated if <code>true</code> then alignment is active.
     */
    public setAlignmentActivated(alignmentActivated: boolean) {
        this.cameraState.setAlignmentActivated(alignmentActivated);
    }

    /**
     * Activates or deactivates duplication feature during editing action.
     * @param {boolean} duplicationActivated if <code>true</code> then duplication is active.
     */
    public setDuplicationActivated(duplicationActivated: boolean) {
        this.cameraState.setDuplicationActivated(duplicationActivated);
    }

    /**
     * Returns the observer camera state.
     * @return {HomeController3D.CameraControllerState}
     */
    getObserverCameraState(): HomeController3D.CameraControllerState {
        return this.observerCameraState;
    }

    /**
     * Returns the top camera state.
     * @return {HomeController3D.CameraControllerState}
     */
    getTopCameraState(): HomeController3D.CameraControllerState {
        return this.topCameraState;
    }
}
HomeController3D["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D";
HomeController3D["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace HomeController3D {

    /**
     * Controller state classes super class.
     * @class
     */
    export abstract class CameraControllerState {
        public enter() {
        }

        public exit() {
        }

        public moveCamera(delta: number) {
        }

        public moveCameraSideways(delta: number) {
        }

        public elevateCamera(delta: number) {
        }

        public rotateCameraYaw(delta: number) {
        }

        public rotateCameraPitch(delta: number) {
        }

        public modifyFieldOfView(delta: number) {
        }

        public goToCamera(camera: Camera) {
        }

        public isEditingState(): boolean {
            return false;
        }

        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, alignmentActivated: boolean, duplicationActivated: boolean, magnetismToggled: boolean, pointerType: View.PointerType) {
        }

        public releaseMouse(x: number, y: number) {
        }

        public moveMouse(x: number, y: number) {
        }

        public escape() {
        }

        public toggleMagnetism(magnetismToggled: boolean) {
        }

        public setAlignmentActivated(alignmentActivated: boolean) {
        }

        public setDuplicationActivated(duplicationActivated: boolean) {
        }

        public setEditionActivated(editionActivated: boolean) {
        }

        constructor() {
        }
    }
    CameraControllerState["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D.CameraControllerState";


    /**
     * Preferences property listener bound to top camera state with a weak reference to avoid
     * strong link between user preferences and top camera state.
     * @param {HomeController3D.TopCameraState} topCameraState
     * @class
     */
    export class UserPreferencesChangeListener {
        topCameraState: HomeController3D.TopCameraState;

        public constructor(topCameraState: HomeController3D.TopCameraState) {
            if (this.topCameraState === undefined) { this.topCameraState = null; }
            this.topCameraState = <any>(topCameraState);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const topCameraState: HomeController3D.TopCameraState = /* get */this.topCameraState;
            const preferences: any = ev.getSource();
            if (topCameraState == null) {
                preferences.removePropertyChangeListener(/* valueOf */ev.getPropertyName(), this);
            } else {
                topCameraState.setAerialViewCenteredOnSelectionEnabled(preferences.isAerialViewCenteredOnSelectionEnabled());
            }
        }
    }
    UserPreferencesChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D.UserPreferencesChangeListener";


    /**
     * Controller state handling mouse events to edit home items.
     * @extends HomeController3D.CameraControllerState
     * @class
     */
    export abstract class EditingCameraState extends HomeController3D.CameraControllerState {
        public __parent: any;
        cameraMoved: boolean;

        mouseMoved: boolean;

        elevationActivated: boolean;

        rotationActivated: boolean;

        lastMousePressedPoint3D: number[];

        distancesRatio: number;

        yLastMousePress: number;

        angleMousePress: number;

        alignmentActivated: boolean;

        duplicationActivated: boolean;

        magnetismToggled: boolean;

        pointerType: View.PointerType;

        movedItems: Array<HomePieceOfFurniture>;

        closestMovedPiece: HomePieceOfFurniture;

        movedItemsStartPoint: number[];

        movedItemsDeltaX: number;

        movedItemsDeltaY: number;

        /**
         * Returns <code>true</code> if this controller is moving items.
         * @return {boolean}
         */
        public isEditingState(): boolean {
            return this.movedItems != null;
        }

        public moveCamera(delta: number) {
            this.cameraMoved = true;
        }

        public moveCameraSideways(delta: number) {
            this.cameraMoved = true;
        }

        public elevateCamera(delta: number) {
            this.cameraMoved = true;
        }

        public rotateCameraYaw(delta: number) {
            this.cameraMoved = true;
        }

        public rotateCameraPitch(delta: number) {
            this.cameraMoved = true;
        }

        public modifyFieldOfView(delta: number) {
            this.cameraMoved = true;
        }

        public goToCamera(camera: Camera) {
            this.cameraMoved = true;
        }

        /**
         * Processes a mouse button pressed event.
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} alignmentActivated
         * @param {boolean} duplicationActivated
         * @param {boolean} magnetismToggled
         * @param {View.PointerType} pointerType
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, alignmentActivated: boolean, duplicationActivated: boolean, magnetismToggled: boolean, pointerType: View.PointerType) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled() && (this.__parent.getView() != null && (this.__parent.getView().constructor != null && this.__parent.getView().constructor["__interfaces"] != null && this.__parent.getView().constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.View3D") >= 0)) && !this.__parent.planController.isModificationState()) {
                if (clickCount === 1) {
                    const closestItem: Selectable = (<View3D><any>this.__parent.getView()).getClosestSelectableItemAt(Math.round(x), Math.round(y));
                    const allSelectedItems: Array<Selectable> = <any>([]);
                    const selectedItems: Array<Selectable> = this.__parent.home.getSelectedItems();
                    for (let index = 0; index < selectedItems.length; index++) {
                        let item = selectedItems[index];
                        {
                            if (item != null && item instanceof <any>HomeFurnitureGroup) {
                                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(allSelectedItems, (<HomeFurnitureGroup><any>item).getAllFurniture());
                            } else {
                                /* add */(allSelectedItems.push(item) > 0);
                            }
                        }
                    }
                    if (/* contains */(allSelectedItems.indexOf(<any>(closestItem)) >= 0) && this.__parent.planController.isItemMovable(closestItem) && (closestItem != null && closestItem instanceof <any>HomePieceOfFurniture)) {
                        this.movedItems = <any>([]);
                        for (let index = 0; index < selectedItems.length; index++) {
                            let item = selectedItems[index];
                            {
                                if (this.__parent.planController.isItemMovable(item) && (item != null && item instanceof <any>HomePieceOfFurniture)) {
                                    /* add */(this.movedItems.push(<HomePieceOfFurniture><any>item) > 0);
                                }
                            }
                        }
                        this.elevationActivated = !alignmentActivated && duplicationActivated;
                        this.rotationActivated = alignmentActivated && duplicationActivated;
                        if ((this.elevationActivated || this.rotationActivated) && (closestItem != null && closestItem instanceof <any>HomePieceOfFurniture)) {
                            if (/* size */(<number>selectedItems.length) > 1) {
                                this.elevationActivated = false;
                                this.rotationActivated = false;
                            }
                        }
                        if (this.movedItems != null) {
                            this.closestMovedPiece = <HomePieceOfFurniture><any>closestItem;
                            const elevationLastMousePressed: number = this.closestMovedPiece.getGroundElevation() + this.closestMovedPiece.getHeightInPlan() / 2 * <number>Math.cos(this.__parent.home.getCamera().getPitch());
                            this.lastMousePressedPoint3D = (<View3D><any>this.__parent.getView()).convertPixelLocationToVirtualWorld(Math.round(x), Math.round(y));
                            const cameraToClosestPieceDistance: number = <number>Math.sqrt((this.__parent.home.getCamera().getX() - this.closestMovedPiece.getX()) * (this.__parent.home.getCamera().getX() - this.closestMovedPiece.getX()) + (this.__parent.home.getCamera().getY() - this.closestMovedPiece.getY()) * (this.__parent.home.getCamera().getY() - this.closestMovedPiece.getY()) + (this.__parent.home.getCamera().getZ() - elevationLastMousePressed) * (this.__parent.home.getCamera().getZ() - elevationLastMousePressed));
                            const cameraToMousePressedPoint3DDistance: number = <number>Math.sqrt((this.__parent.home.getCamera().getX() - this.lastMousePressedPoint3D[0]) * (this.__parent.home.getCamera().getX() - this.lastMousePressedPoint3D[0]) + (this.__parent.home.getCamera().getY() - this.lastMousePressedPoint3D[1]) * (this.__parent.home.getCamera().getY() - this.lastMousePressedPoint3D[1]) + (this.__parent.home.getCamera().getZ() - this.lastMousePressedPoint3D[2]) * (this.__parent.home.getCamera().getZ() - this.lastMousePressedPoint3D[2]));
                            this.distancesRatio = cameraToClosestPieceDistance / cameraToMousePressedPoint3DDistance;
                        }
                        this.movedItemsDeltaX = null;
                        this.movedItemsDeltaY = null;
                    }
                } else if (clickCount === 2 && !/* isEmpty */(this.__parent.home.getSelectedItems().length == 0)) {
                    this.__parent.planController.modifySelectedItem();
                }
                this.mouseMoved = false;
                this.cameraMoved = false;
                this.yLastMousePress = y;
                this.alignmentActivated = alignmentActivated;
                this.duplicationActivated = duplicationActivated;
                this.magnetismToggled = magnetismToggled;
                this.pointerType = pointerType;
            }
        }

        /**
         * Processes a mouse button released event.
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled() && (this.__parent.getView() != null && (this.__parent.getView().constructor != null && this.__parent.getView().constructor["__interfaces"] != null && this.__parent.getView().constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.View3D") >= 0))) {
                if (this.movedItems != null && this.movedItemsDeltaY != null) {
                    this.__parent.planController.releaseMouse(this.movedItemsStartPoint[0] + this.movedItemsDeltaX, this.movedItemsStartPoint[1] + this.movedItemsDeltaY);
                    this.__parent.planController.setFeedbackDisplayed(true);
                } else if (!this.__parent.planController.isModificationState() && !this.mouseMoved && !this.cameraMoved) {
                    let item: Selectable = (<View3D><any>this.__parent.getView()).getClosestSelectableItemAt(Math.round(x), Math.round(y));
                    if (item != null && this.__parent.home.isBasePlanLocked() && this.__parent.planController.isItemPartOfBasePlan(item)) {
                        item = null;
                    }
                    if (this.alignmentActivated) {
                        if (item != null) {
                            const selectedItems: Array<Selectable> = <any>(this.__parent.home.getSelectedItems().slice(0));
                            if (/* contains */(selectedItems.indexOf(<any>(item)) >= 0)) {
                                this.__parent.home.deselectItem(item);
                            } else {
                                /* add */(selectedItems.push(item) > 0);
                                this.__parent.home.setSelectedItems(selectedItems);
                            }
                        }
                    } else {
                        if (item != null) {
                            this.__parent.home.setSelectedItems(/* asList */[item]);
                        } else {
                            const selectedItems: Array<Selectable> = /* emptyList */[];
                            this.__parent.home.setSelectedItems(selectedItems);
                        }
                    }
                }
                this.movedItems = null;
                this.closestMovedPiece = null;
                this.elevationActivated = false;
                this.rotationActivated = false;
            }
        }

        /**
         * Processes a mouse button moved event.
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled() && this.movedItems != null) {
                if (this.movedItemsDeltaY == null) {
                    this.movedItemsStartPoint = this.rotationActivated ? /* get */this.movedItems[0].getPoints()[0] : [this.closestMovedPiece.getX(), this.closestMovedPiece.getY()];
                    this.angleMousePress = null;
                    this.__parent.planController.setFeedbackDisplayed(false);
                    this.__parent.planController.moveMouse(this.movedItemsStartPoint[0], this.movedItemsStartPoint[1]);
                    this.__parent.planController.pressMouse$float$float$int$boolean$boolean$boolean$boolean(this.movedItemsStartPoint[0], this.movedItemsStartPoint[1], 1, false, false, this.duplicationActivated, this.magnetismToggled);
                    if (this.elevationActivated) {
                        this.__parent.planController.setState(this.__parent.planController.getPieceOfFurnitureElevationState());
                    } else if (this.rotationActivated) {
                        this.__parent.planController.setState(this.__parent.planController.getPieceOfFurnitureRotationState());
                    } else {
                        this.__parent.home.setSelectedItems(this.movedItems);
                        this.__parent.planController.setState(this.__parent.planController.getSelectionMoveState());
                        this.__parent.planController.setAlignmentActivated(this.alignmentActivated);
                    }
                }
                if (this.rotationActivated && this.angleMousePress == null) {
                    this.angleMousePress = <number>Math.atan2(this.movedItemsStartPoint[1] - /* get */this.movedItems[0].getY(), this.movedItemsStartPoint[0] - /* get */this.movedItems[0].getX());
                    if (this.pointerType === View.PointerType.TOUCH) {
                        this.lastMousePressedPoint3D = (<View3D><any>this.__parent.getView()).convertPixelLocationToVirtualWorld(Math.round(x), Math.round(y));
                    }
                }
                const point: number[] = (<View3D><any>this.__parent.getView()).convertPixelLocationToVirtualWorld(Math.round(x), Math.round(y));
                if (this.rotationActivated) {
                    const newAngle: number = this.angleMousePress - (point[0] - this.lastMousePressedPoint3D[0]) * this.distancesRatio / 50;
                    const indicatorCenterDistance: number = <number>java.awt.geom.Point2D.distance(/* get */this.movedItems[0].getX(), /* get */this.movedItems[0].getY(), this.movedItemsStartPoint[0], this.movedItemsStartPoint[1]);
                    this.movedItemsDeltaX = /* get */this.movedItems[0].getX() + indicatorCenterDistance * <number>Math.cos(newAngle) - this.movedItemsStartPoint[0];
                    this.movedItemsDeltaY = /* get */this.movedItems[0].getY() + indicatorCenterDistance * <number>Math.sin(newAngle) - this.movedItemsStartPoint[1];
                } else if (this.elevationActivated) {
                    this.movedItemsDeltaX = 0.0;
                    this.movedItemsDeltaY = (this.lastMousePressedPoint3D[2] - point[2]) * this.distancesRatio + (y - this.yLastMousePress) * <number>(1 - Math.cos(this.__parent.home.getCamera().getPitch()));
                } else {
                    this.movedItemsDeltaX = <number>(point[0] - this.lastMousePressedPoint3D[0]) * this.distancesRatio;
                    this.movedItemsDeltaY = <number>(point[1] - this.lastMousePressedPoint3D[1]) * this.distancesRatio;
                }
                this.__parent.planController.moveMouse(this.movedItemsStartPoint[0] + this.movedItemsDeltaX, this.movedItemsStartPoint[1] + this.movedItemsDeltaY);
            }
            this.mouseMoved = true;
        }

        /**
         * Escapes of current editing action.
         */
        public escape() {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled()) {
                this.movedItems = null;
                this.__parent.planController.escape();
            }
        }

        /**
         * Toggles temporary magnetism feature of user preferences during editing action.
         * @param {boolean} magnetismToggled if <code>true</code> then magnetism feature is toggled.
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled()) {
                this.magnetismToggled = magnetismToggled;
                this.__parent.planController.toggleMagnetism(magnetismToggled);
            }
        }

        /**
         * Activates or deactivates alignment feature during editing action.
         * @param {boolean} alignmentActivated if <code>true</code> then alignment is active.
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled()) {
                if (this.pointerType === View.PointerType.TOUCH && alignmentActivated && /* size */(<number>this.__parent.home.getSelectedItems().length) === 1 && !this.mouseMoved) {
                    this.elevationActivated = true;
                    this.rotationActivated = false;
                }
                this.alignmentActivated = alignmentActivated;
                this.__parent.planController.setAlignmentActivated(alignmentActivated);
            }
        }

        /**
         * Activates or deactivates duplication feature during editing action.
         * @param {boolean} duplicationActivated if <code>true</code> then duplication is active.
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            if (this.__parent.planController != null && this.__parent.preferences.isEditingIn3DViewEnabled()) {
                if (this.pointerType === View.PointerType.TOUCH && duplicationActivated && /* size */(<number>this.__parent.home.getSelectedItems().length) === 1) {
                    if (this.elevationActivated && !this.mouseMoved) {
                        this.elevationActivated = false;
                        this.rotationActivated = true;
                    } else {
                        this.movedItemsStartPoint[0] += this.movedItemsDeltaX;
                        this.movedItemsStartPoint[1] += this.movedItemsDeltaY;
                        this.angleMousePress = null;
                    }
                }
                this.duplicationActivated = duplicationActivated;
                if (!this.elevationActivated) {
                    this.__parent.planController.setDuplicationActivated(duplicationActivated);
                }
            }
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.cameraMoved === undefined) { this.cameraMoved = false; }
            if (this.mouseMoved === undefined) { this.mouseMoved = false; }
            if (this.elevationActivated === undefined) { this.elevationActivated = false; }
            if (this.rotationActivated === undefined) { this.rotationActivated = false; }
            if (this.lastMousePressedPoint3D === undefined) { this.lastMousePressedPoint3D = null; }
            if (this.distancesRatio === undefined) { this.distancesRatio = 0; }
            if (this.yLastMousePress === undefined) { this.yLastMousePress = 0; }
            if (this.angleMousePress === undefined) { this.angleMousePress = null; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.duplicationActivated === undefined) { this.duplicationActivated = false; }
            if (this.magnetismToggled === undefined) { this.magnetismToggled = false; }
            if (this.pointerType === undefined) { this.pointerType = null; }
            if (this.movedItems === undefined) { this.movedItems = null; }
            if (this.closestMovedPiece === undefined) { this.closestMovedPiece = null; }
            if (this.movedItemsStartPoint === undefined) { this.movedItemsStartPoint = null; }
            if (this.movedItemsDeltaX === undefined) { this.movedItemsDeltaX = null; }
            if (this.movedItemsDeltaY === undefined) { this.movedItemsDeltaY = null; }
        }
    }
    EditingCameraState["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D.EditingCameraState";


    /**
     * Top camera controller state.
     * @param {UserPreferences} preferences
     * @class
     * @extends HomeController3D.EditingCameraState
     */
    export class TopCameraState extends HomeController3D.EditingCameraState {
        public __parent: any;
        MIN_WIDTH: number;

        MIN_DEPTH: number;

        MIN_HEIGHT: number;

        topCamera: Camera;

        aerialViewBoundsLowerPoint: number[];

        aerialViewBoundsUpperPoint: number[];

        minDistanceToAerialViewCenter: number;

        maxDistanceToAerialViewCenter: number;

        aerialViewCenteredOnSelectionEnabled: boolean;

        previousSelectionEmpty: boolean;

        distanceToCenterWithSelection: number;

        objectChangeListener: PropertyChangeListener;

        levelsListener: CollectionListener<Level>;

        wallsListener: CollectionListener<Wall>;

        furnitureListener: CollectionListener<HomePieceOfFurniture>;

        roomsListener: CollectionListener<Room>;

        polylinesListener: CollectionListener<Polyline>;

        dimensionLinesListener: CollectionListener<DimensionLine>;

        labelsListener: CollectionListener<Label>;

        selectionListener: SelectionListener;

        userPreferencesChangeListener: HomeController3D.UserPreferencesChangeListener;

        public constructor(__parent: any, preferences: any) {
            super(__parent);
            this.__parent = __parent;
            this.MIN_WIDTH = 100;
            this.MIN_DEPTH = this.MIN_WIDTH;
            this.MIN_HEIGHT = 20;
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.aerialViewBoundsLowerPoint === undefined) { this.aerialViewBoundsLowerPoint = null; }
            if (this.aerialViewBoundsUpperPoint === undefined) { this.aerialViewBoundsUpperPoint = null; }
            if (this.minDistanceToAerialViewCenter === undefined) { this.minDistanceToAerialViewCenter = 0; }
            if (this.maxDistanceToAerialViewCenter === undefined) { this.maxDistanceToAerialViewCenter = 0; }
            if (this.aerialViewCenteredOnSelectionEnabled === undefined) { this.aerialViewCenteredOnSelectionEnabled = false; }
            if (this.previousSelectionEmpty === undefined) { this.previousSelectionEmpty = false; }
            this.distanceToCenterWithSelection = -1;
            this.objectChangeListener = new TopCameraState.TopCameraState$0(this);
            this.levelsListener = (ev: CollectionEvent<Level>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.wallsListener = (ev: CollectionEvent<Wall>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.furnitureListener = (ev: CollectionEvent<HomePieceOfFurniture>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    this.addPropertyChangeListener(ev.getItem(), this.objectChangeListener);
                    this.updateCameraFromHomeBounds(/* size */(<number>__parent.home.getFurniture().length) === 1 && /* isEmpty */(__parent.home.getWalls().length == 0) && /* isEmpty */(__parent.home.getRooms().length == 0), false);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    this.removePropertyChangeListener(ev.getItem(), this.objectChangeListener);
                    this.updateCameraFromHomeBounds(false, false);
                }
            };
            this.roomsListener = (ev: CollectionEvent<Room>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.polylinesListener = (ev: CollectionEvent<Polyline>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.dimensionLinesListener = (ev: CollectionEvent<DimensionLine>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.labelsListener = (ev: CollectionEvent<Label>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.objectChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.objectChangeListener);
                }
                this.updateCameraFromHomeBounds(false, false);
            };
            this.selectionListener = new TopCameraState.TopCameraState$1(this);
            if (this.userPreferencesChangeListener === undefined) { this.userPreferencesChangeListener = null; }
            this.userPreferencesChangeListener = new HomeController3D.UserPreferencesChangeListener(this);
        }

        addPropertyChangeListener(piece: HomePieceOfFurniture, listener: PropertyChangeListener) {
            if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                {
                    let array = (<HomeFurnitureGroup>piece).getFurniture();
                    for (let index = 0; index < array.length; index++) {
                        let child = array[index];
                        {
                            this.addPropertyChangeListener(child, listener);
                        }
                    }
                }
            } else {
                piece.addPropertyChangeListener(listener);
            }
        }

        removePropertyChangeListener(piece: HomePieceOfFurniture, listener: PropertyChangeListener) {
            if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                {
                    let array = (<HomeFurnitureGroup>piece).getFurniture();
                    for (let index = 0; index < array.length; index++) {
                        let child = array[index];
                        {
                            this.removePropertyChangeListener(child, listener);
                        }
                    }
                }
            } else {
                piece.removePropertyChangeListener(listener);
            }
        }

        /**
         * 
         */
        public enter() {
            this.topCamera = this.__parent.home.getCamera();
            this.previousSelectionEmpty = /* isEmpty */(this.__parent.home.getSelectedItems().length == 0);
            this.aerialViewCenteredOnSelectionEnabled = this.__parent.preferences.isAerialViewCenteredOnSelectionEnabled();
            this.updateCameraFromHomeBounds(false, false);
            {
                let array = this.__parent.home.getLevels();
                for (let index = 0; index < array.length; index++) {
                    let level = array[index];
                    {
                        level.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addLevelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.levelsListener)));
            {
                let array = this.__parent.home.getWalls();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        wall.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addWallsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.wallsListener)));
            {
                let array = this.__parent.home.getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let piece = array[index];
                    {
                        this.addPropertyChangeListener(piece, this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.furnitureListener)));
            {
                let array = this.__parent.home.getRooms();
                for (let index = 0; index < array.length; index++) {
                    let room = array[index];
                    {
                        room.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addRoomsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.roomsListener)));
            {
                let array = this.__parent.home.getPolylines();
                for (let index = 0; index < array.length; index++) {
                    let polyline = array[index];
                    {
                        polyline.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addPolylinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.polylinesListener)));
            {
                let array = this.__parent.home.getDimensionLines();
                for (let index = 0; index < array.length; index++) {
                    let dimensionLine = array[index];
                    {
                        dimensionLine.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addDimensionLinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.dimensionLinesListener)));
            {
                let array = this.__parent.home.getLabels();
                for (let index = 0; index < array.length; index++) {
                    let label = array[index];
                    {
                        label.addPropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.addLabelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.labelsListener)));
            this.__parent.home.addSelectionListener(this.selectionListener);
            this.__parent.preferences.addPropertyChangeListener("AERIAL_VIEW_CENTERED_ON_SELECTION_ENABLED", this.userPreferencesChangeListener);
        }

        /**
         * Sets whether aerial view should be centered on selection or not.
         * @param {boolean} aerialViewCenteredOnSelectionEnabled
         */
        public setAerialViewCenteredOnSelectionEnabled(aerialViewCenteredOnSelectionEnabled: boolean) {
            this.aerialViewCenteredOnSelectionEnabled = aerialViewCenteredOnSelectionEnabled;
            this.updateCameraFromHomeBounds(false, false);
        }

        /**
         * Updates camera location from home bounds.
         * @param {boolean} firstPieceOfFurnitureAddedToEmptyHome
         * @param {boolean} selectionChange
         * @private
         */
        updateCameraFromHomeBounds(firstPieceOfFurnitureAddedToEmptyHome: boolean, selectionChange: boolean) {
            if (!this.isEditingState()) {
                if (this.aerialViewBoundsLowerPoint == null) {
                    this.updateAerialViewBoundsFromHomeBounds(this.aerialViewCenteredOnSelectionEnabled);
                }
                let distanceToCenter: number;
                if (selectionChange && this.__parent.preferences.isAerialViewCenteredOnSelectionEnabled() && this.distanceToCenterWithSelection !== -1) {
                    distanceToCenter = this.distanceToCenterWithSelection;
                } else {
                    distanceToCenter = this.getCameraToAerialViewCenterDistance();
                }
                if (!/* isEmpty */(this.__parent.home.getSelectedItems().length == 0)) {
                    this.distanceToCenterWithSelection = distanceToCenter;
                }
                this.updateAerialViewBoundsFromHomeBounds(this.aerialViewCenteredOnSelectionEnabled);
                this.updateCameraIntervalToAerialViewCenter();
                this.placeCameraAt(distanceToCenter, firstPieceOfFurnitureAddedToEmptyHome);
            }
        }

        /**
         * Returns the distance between the current camera location and home bounds center.
         * @return {number}
         * @private
         */
        getCameraToAerialViewCenterDistance(): number {
            return <number>Math.sqrt(Math.pow((this.aerialViewBoundsLowerPoint[0] + this.aerialViewBoundsUpperPoint[0]) / 2 - this.topCamera.getX(), 2) + Math.pow((this.aerialViewBoundsLowerPoint[1] + this.aerialViewBoundsUpperPoint[1]) / 2 - this.topCamera.getY(), 2) + Math.pow((this.aerialViewBoundsLowerPoint[2] + this.aerialViewBoundsUpperPoint[2]) / 2 - this.topCamera.getZ(), 2));
        }

        /**
         * Sets the bounds that includes walls, furniture and rooms, or only selected items
         * if <code>centerOnSelection</code> is <code>true</code>.
         * @param {boolean} centerOnSelection
         * @private
         */
        updateAerialViewBoundsFromHomeBounds(centerOnSelection: boolean) {
            this.aerialViewBoundsLowerPoint = this.aerialViewBoundsUpperPoint = null;
            let selectedItems: Array<Selectable> = /* emptyList */[];
            if (centerOnSelection) {
                selectedItems = <any>([]);
                {
                    let array = this.__parent.home.getSelectedItems();
                    for (let index = 0; index < array.length; index++) {
                        let item = array[index];
                        {
                            if ((item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) && this.isItemAtVisibleLevel(<Elevatable><any>item) && (!(item != null && item instanceof <any>HomePieceOfFurniture) || (<HomePieceOfFurniture><any>item).isVisible()) && (!(item != null && item instanceof <any>Polyline) || (<Polyline><any>item).isVisibleIn3D()) && (!(item != null && item instanceof <any>DimensionLine) || (<DimensionLine><any>item).isVisibleIn3D()) && (!(item != null && item instanceof <any>Label) || (<Label><any>item).getPitch() != null)) {
                                /* add */(selectedItems.push(item) > 0);
                            }
                        }
                    }
                }
            }
            const selectionEmpty: boolean = /* size */(<number>selectedItems.length) === 0 || !centerOnSelection;
            let containsVisibleWalls: boolean = false;
            {
                let array = selectionEmpty ? this.__parent.home.getWalls() : Home.getWallsSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        if (this.isItemAtVisibleLevel(wall)) {
                            containsVisibleWalls = true;
                            const wallElevation: number = wall.getLevel() != null ? wall.getLevel().getElevation() : 0;
                            const minZ: number = selectionEmpty ? 0 : wallElevation;
                            const height: number = wall.getHeight();
                            let maxZ: number;
                            if (height != null) {
                                maxZ = wallElevation + height;
                            } else {
                                maxZ = wallElevation + this.__parent.home.getWallHeight();
                            }
                            const heightAtEnd: number = wall.getHeightAtEnd();
                            if (heightAtEnd != null) {
                                maxZ = Math.max(maxZ, wallElevation + heightAtEnd);
                            }
                            {
                                let array1 = wall.getPoints$();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                let array = selectionEmpty ? this.__parent.home.getFurniture() : Home.getFurnitureSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let piece = array[index];
                    {
                        if (piece.isVisible() && this.isItemAtVisibleLevel(piece)) {
                            let minZ: number;
                            let maxZ: number;
                            if (selectionEmpty) {
                                minZ = Math.max(0, piece.getGroundElevation());
                                maxZ = Math.max(0, piece.getGroundElevation() + piece.getHeightInPlan());
                            } else {
                                minZ = piece.getGroundElevation();
                                maxZ = piece.getGroundElevation() + piece.getHeightInPlan();
                            }
                            {
                                let array1 = piece.getPoints();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                let array = selectionEmpty ? this.__parent.home.getRooms() : Home.getRoomsSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let room = array[index];
                    {
                        if (this.isItemAtVisibleLevel(room)) {
                            let minZ: number = 0;
                            let maxZ: number = this.MIN_HEIGHT;
                            const roomLevel: Level = room.getLevel();
                            if (roomLevel != null) {
                                minZ = roomLevel.getElevation() - roomLevel.getFloorThickness();
                                maxZ = roomLevel.getElevation();
                                if (selectionEmpty) {
                                    minZ = Math.max(0, minZ);
                                    maxZ = Math.max(this.MIN_HEIGHT, roomLevel.getElevation());
                                }
                            }
                            {
                                let array1 = room.getPoints();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                let array = selectionEmpty ? this.__parent.home.getPolylines() : Home.getPolylinesSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let polyline = array[index];
                    {
                        if (polyline.isVisibleIn3D() && this.isItemAtVisibleLevel(polyline)) {
                            let minZ: number;
                            let maxZ: number;
                            if (selectionEmpty) {
                                minZ = Math.max(0, polyline.getGroundElevation());
                                maxZ = Math.max(this.MIN_HEIGHT, polyline.getGroundElevation());
                            } else {
                                minZ = maxZ = polyline.getGroundElevation();
                            }
                            {
                                let array1 = polyline.getPoints();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                let array = selectionEmpty ? this.__parent.home.getDimensionLines() : Home.getDimensionLinesSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let dimensionLine = array[index];
                    {
                        if (dimensionLine.isVisibleIn3D() && this.isItemAtVisibleLevel(dimensionLine)) {
                            const levelElevation: number = dimensionLine.getLevel() != null ? dimensionLine.getLevel().getElevation() : 0;
                            let minZ: number;
                            let maxZ: number;
                            if (selectionEmpty) {
                                minZ = Math.max(0, levelElevation + dimensionLine.getElevationStart());
                                maxZ = Math.max(this.MIN_HEIGHT, levelElevation + dimensionLine.getElevationEnd());
                            } else {
                                minZ = levelElevation + dimensionLine.getElevationStart();
                                maxZ = levelElevation + dimensionLine.getElevationEnd();
                            }
                            {
                                let array1 = dimensionLine.getPoints();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                let array = selectionEmpty ? this.__parent.home.getLabels() : Home.getLabelsSubList(selectedItems);
                for (let index = 0; index < array.length; index++) {
                    let label = array[index];
                    {
                        if (label.getPitch() != null && this.isItemAtVisibleLevel(label)) {
                            let minZ: number;
                            let maxZ: number;
                            if (selectionEmpty) {
                                minZ = Math.max(0, label.getGroundElevation());
                                maxZ = Math.max(this.MIN_HEIGHT, label.getGroundElevation());
                            } else {
                                minZ = maxZ = label.getGroundElevation();
                            }
                            {
                                let array1 = label.getPoints();
                                for (let index1 = 0; index1 < array1.length; index1++) {
                                    let point = array1[index1];
                                    {
                                        this.updateAerialViewBounds(point[0], point[1], minZ, maxZ);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (this.aerialViewBoundsLowerPoint == null) {
                this.aerialViewBoundsLowerPoint = [0, 0, 0];
                this.aerialViewBoundsUpperPoint = [this.MIN_WIDTH, this.MIN_DEPTH, this.MIN_HEIGHT];
            } else if (containsVisibleWalls && selectionEmpty) {
                if (this.MIN_WIDTH > this.aerialViewBoundsUpperPoint[0] - this.aerialViewBoundsLowerPoint[0]) {
                    this.aerialViewBoundsLowerPoint[0] = (this.aerialViewBoundsLowerPoint[0] + this.aerialViewBoundsUpperPoint[0]) / 2 - this.MIN_WIDTH / 2;
                    this.aerialViewBoundsUpperPoint[0] = this.aerialViewBoundsLowerPoint[0] + this.MIN_WIDTH;
                }
                if (this.MIN_DEPTH > this.aerialViewBoundsUpperPoint[1] - this.aerialViewBoundsLowerPoint[1]) {
                    this.aerialViewBoundsLowerPoint[1] = (this.aerialViewBoundsLowerPoint[1] + this.aerialViewBoundsUpperPoint[1]) / 2 - this.MIN_DEPTH / 2;
                    this.aerialViewBoundsUpperPoint[1] = this.aerialViewBoundsLowerPoint[1] + this.MIN_DEPTH;
                }
                if (this.MIN_HEIGHT > this.aerialViewBoundsUpperPoint[2] - this.aerialViewBoundsLowerPoint[2]) {
                    this.aerialViewBoundsLowerPoint[2] = (this.aerialViewBoundsLowerPoint[2] + this.aerialViewBoundsUpperPoint[2]) / 2 - this.MIN_HEIGHT / 2;
                    this.aerialViewBoundsUpperPoint[2] = this.aerialViewBoundsLowerPoint[2] + this.MIN_HEIGHT;
                }
            }
        }

        /**
         * Adds the point at the given coordinates to aerial view bounds.
         * @param {number} x
         * @param {number} y
         * @param {number} minZ
         * @param {number} maxZ
         * @private
         */
        updateAerialViewBounds(x: number, y: number, minZ: number, maxZ: number) {
            if (this.aerialViewBoundsLowerPoint == null) {
                this.aerialViewBoundsLowerPoint = [x, y, minZ];
                this.aerialViewBoundsUpperPoint = [x, y, maxZ];
            } else {
                this.aerialViewBoundsLowerPoint[0] = Math.min(this.aerialViewBoundsLowerPoint[0], x);
                this.aerialViewBoundsUpperPoint[0] = Math.max(this.aerialViewBoundsUpperPoint[0], x);
                this.aerialViewBoundsLowerPoint[1] = Math.min(this.aerialViewBoundsLowerPoint[1], y);
                this.aerialViewBoundsUpperPoint[1] = Math.max(this.aerialViewBoundsUpperPoint[1], y);
                this.aerialViewBoundsLowerPoint[2] = Math.min(this.aerialViewBoundsLowerPoint[2], minZ);
                this.aerialViewBoundsUpperPoint[2] = Math.max(this.aerialViewBoundsUpperPoint[2], maxZ);
            }
        }

        /**
         * Returns <code>true</code> if the given <code>item</code> is at a visible level.
         * @param {Object} item
         * @return {boolean}
         * @private
         */
        isItemAtVisibleLevel(item: Elevatable): boolean {
            return item.getLevel() == null || item.getLevel().isViewableAndVisible();
        }

        /**
         * Updates the minimum and maximum distances of the camera to the center of the aerial view.
         * @private
         */
        updateCameraIntervalToAerialViewCenter() {
            const homeBoundsWidth: number = this.aerialViewBoundsUpperPoint[0] - this.aerialViewBoundsLowerPoint[0];
            const homeBoundsDepth: number = this.aerialViewBoundsUpperPoint[1] - this.aerialViewBoundsLowerPoint[1];
            const homeBoundsHeight: number = this.aerialViewBoundsUpperPoint[2] - this.aerialViewBoundsLowerPoint[2];
            const halfDiagonal: number = <number>Math.sqrt(homeBoundsWidth * homeBoundsWidth + homeBoundsDepth * homeBoundsDepth + homeBoundsHeight * homeBoundsHeight) / 2;
            this.minDistanceToAerialViewCenter = halfDiagonal * 1.05;
            this.maxDistanceToAerialViewCenter = Math.max(5 * this.minDistanceToAerialViewCenter, 5000);
        }

        /**
         * 
         * @param {number} delta
         */
        public moveCamera(delta: number) {
            super.moveCamera(delta);
            delta *= 5;
            const newDistanceToCenter: number = this.getCameraToAerialViewCenterDistance() - delta;
            this.placeCameraAt(newDistanceToCenter, false);
        }

        public placeCameraAt(distanceToCenter: number, firstPieceOfFurnitureAddedToEmptyHome: boolean) {
            distanceToCenter = Math.max(distanceToCenter, this.minDistanceToAerialViewCenter);
            distanceToCenter = Math.min(distanceToCenter, this.maxDistanceToAerialViewCenter);
            if (firstPieceOfFurnitureAddedToEmptyHome) {
                distanceToCenter = Math.min(distanceToCenter, 3 * this.minDistanceToAerialViewCenter);
            }
            const distanceToCenterAtGroundLevel: number = distanceToCenter * Math.cos(this.topCamera.getPitch());
            this.topCamera.setX((this.aerialViewBoundsLowerPoint[0] + this.aerialViewBoundsUpperPoint[0]) / 2 + <number>(Math.sin(this.topCamera.getYaw()) * distanceToCenterAtGroundLevel));
            this.topCamera.setY((this.aerialViewBoundsLowerPoint[1] + this.aerialViewBoundsUpperPoint[1]) / 2 - <number>(Math.cos(this.topCamera.getYaw()) * distanceToCenterAtGroundLevel));
            this.topCamera.setZ((this.aerialViewBoundsLowerPoint[2] + this.aerialViewBoundsUpperPoint[2]) / 2 + <number>Math.sin(this.topCamera.getPitch()) * distanceToCenter);
        }

        /**
         * 
         * @param {number} delta
         */
        public rotateCameraYaw(delta: number) {
            super.rotateCameraYaw(delta);
            const newYaw: number = this.topCamera.getYaw() + delta;
            const distanceToCenterAtGroundLevel: number = this.getCameraToAerialViewCenterDistance() * Math.cos(this.topCamera.getPitch());
            this.topCamera.setYaw(newYaw);
            this.topCamera.setX((this.aerialViewBoundsLowerPoint[0] + this.aerialViewBoundsUpperPoint[0]) / 2 + <number>(Math.sin(newYaw) * distanceToCenterAtGroundLevel));
            this.topCamera.setY((this.aerialViewBoundsLowerPoint[1] + this.aerialViewBoundsUpperPoint[1]) / 2 - <number>(Math.cos(newYaw) * distanceToCenterAtGroundLevel));
        }

        /**
         * 
         * @param {number} delta
         */
        public rotateCameraPitch(delta: number) {
            super.rotateCameraPitch(delta);
            let newPitch: number = this.topCamera.getPitch() + delta;
            newPitch = Math.max(newPitch, <number>0);
            newPitch = Math.min(newPitch, <number>Math.PI / 2);
            const distanceToCenter: number = this.getCameraToAerialViewCenterDistance();
            const distanceToCenterAtGroundLevel: number = distanceToCenter * Math.cos(newPitch);
            this.topCamera.setPitch(newPitch);
            this.topCamera.setX((this.aerialViewBoundsLowerPoint[0] + this.aerialViewBoundsUpperPoint[0]) / 2 + <number>(Math.sin(this.topCamera.getYaw()) * distanceToCenterAtGroundLevel));
            this.topCamera.setY((this.aerialViewBoundsLowerPoint[1] + this.aerialViewBoundsUpperPoint[1]) / 2 - <number>(Math.cos(this.topCamera.getYaw()) * distanceToCenterAtGroundLevel));
            this.topCamera.setZ((this.aerialViewBoundsLowerPoint[2] + this.aerialViewBoundsUpperPoint[2]) / 2 + <number>(distanceToCenter * Math.sin(newPitch)));
        }

        /**
         * 
         * @param {Camera} camera
         */
        public goToCamera(camera: Camera) {
            super.goToCamera(camera);
            this.topCamera.setCamera(camera);
            this.topCamera.setTime(camera.getTime());
            this.topCamera.setLens(camera.getLens());
            this.topCamera.setRenderer(camera.getRenderer());
            this.updateCameraFromHomeBounds(false, false);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            super.releaseMouse(x, y);
            this.updateCameraFromHomeBounds(false, false);
        }

        /**
         * 
         */
        public exit() {
            this.topCamera = null;
            {
                let array = this.__parent.home.getWalls();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        wall.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeWallsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.wallsListener)));
            {
                let array = this.__parent.home.getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let piece = array[index];
                    {
                        this.removePropertyChangeListener(piece, this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.furnitureListener)));
            {
                let array = this.__parent.home.getRooms();
                for (let index = 0; index < array.length; index++) {
                    let room = array[index];
                    {
                        room.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeRoomsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.roomsListener)));
            {
                let array = this.__parent.home.getPolylines();
                for (let index = 0; index < array.length; index++) {
                    let polyline = array[index];
                    {
                        polyline.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removePolylinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.polylinesListener)));
            {
                let array = this.__parent.home.getDimensionLines();
                for (let index = 0; index < array.length; index++) {
                    let dimensionLine = array[index];
                    {
                        dimensionLine.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeDimensionLinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.dimensionLinesListener)));
            {
                let array = this.__parent.home.getLabels();
                for (let index = 0; index < array.length; index++) {
                    let label = array[index];
                    {
                        label.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeLabelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.labelsListener)));
            {
                let array = this.__parent.home.getLevels();
                for (let index = 0; index < array.length; index++) {
                    let level = array[index];
                    {
                        level.removePropertyChangeListener(this.objectChangeListener);
                    }
                }
            }
            this.__parent.home.removeLevelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.levelsListener)));
            this.__parent.home.removeSelectionListener(this.selectionListener);
            this.__parent.preferences.removePropertyChangeListener("AERIAL_VIEW_CENTERED_ON_SELECTION_ENABLED", this.userPreferencesChangeListener);
        }
    }
    TopCameraState["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D.TopCameraState";


    export namespace TopCameraState {

        export class TopCameraState$0 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.updateCameraFromHomeBounds(false, false);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class TopCameraState$1 implements SelectionListener {
            public __parent: any;
            public selectionChanged(ev: SelectionEvent) {
                const selectionEmpty: boolean = /* isEmpty */(ev.getSelectedItems().length == 0);
                this.__parent.updateCameraFromHomeBounds(false, this.__parent.previousSelectionEmpty && !selectionEmpty);
                this.__parent.previousSelectionEmpty = selectionEmpty;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        TopCameraState$1["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];


    }


    /**
     * Observer camera controller state.
     * @extends HomeController3D.EditingCameraState
     * @class
     */
    export class ObserverCameraState extends HomeController3D.EditingCameraState {
        public __parent: any;
        observerCamera: ObserverCamera;

        levelElevationChangeListener: PropertyChangeListener;

        levelsListener: CollectionListener<Level>;

        /**
         * 
         */
        public enter() {
            this.observerCamera = <ObserverCamera>this.__parent.home.getCamera();
            {
                let array = this.__parent.home.getLevels();
                for (let index = 0; index < array.length; index++) {
                    let level = array[index];
                    {
                        level.addPropertyChangeListener(this.levelElevationChangeListener);
                    }
                }
            }
            this.__parent.home.addLevelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.levelsListener)));
            this.selectCamera();
        }

        /**
         * Selects the camera in home if required conditions are met.
         * @private
         */
        selectCamera() {
            if (this.__parent.preferences.isObserverCameraSelectedAtChange()) {
                const selectedItems: Array<Selectable> = this.__parent.home.getSelectedItems();
                if (!this.__parent.preferences.isEditingIn3DViewEnabled() || /* isEmpty */(selectedItems.length == 0) || /* size */(<number>selectedItems.length) === 1 && /* get */selectedItems[0] === this.observerCamera) {
                    this.__parent.home.setSelectedItems(/* asList */[this.observerCamera].slice(0));
                }
            }
        }

        /**
         * 
         * @param {number} delta
         */
        public moveCamera(delta: number) {
            super.moveCamera(delta);
            this.observerCamera.setX(this.observerCamera.getX() - <number>Math.sin(this.observerCamera.getYaw()) * delta);
            this.observerCamera.setY(this.observerCamera.getY() + <number>Math.cos(this.observerCamera.getYaw()) * delta);
            this.selectCamera();
        }

        /**
         * 
         * @param {number} delta
         */
        public moveCameraSideways(delta: number) {
            super.moveCameraSideways(delta);
            this.observerCamera.setX(this.observerCamera.getX() - <number>Math.cos(this.observerCamera.getYaw()) * delta);
            this.observerCamera.setY(this.observerCamera.getY() - <number>Math.sin(this.observerCamera.getYaw()) * delta);
            this.selectCamera();
        }

        /**
         * 
         * @param {number} delta
         */
        public elevateCamera(delta: number) {
            super.elevateCamera(delta);
            let newElevation: number = this.observerCamera.getZ() + delta;
            newElevation = Math.min(Math.max(newElevation, this.getMinimumElevation()), this.__parent.preferences.getLengthUnit().getMaximumElevation());
            this.observerCamera.setZ(newElevation);
            this.selectCamera();
        }

        updateCameraMinimumElevation() {
            this.observerCamera.setZ(Math.max(this.observerCamera.getZ(), this.getMinimumElevation()));
        }

        public getMinimumElevation(): number {
            const levels: Array<Level> = this.__parent.home.getLevels();
            if (/* size */(<number>levels.length) > 0) {
                return 10 + /* get */levels[0].getElevation();
            } else {
                return 10;
            }
        }

        /**
         * 
         * @param {number} delta
         */
        public rotateCameraYaw(delta: number) {
            super.rotateCameraYaw(delta);
            this.observerCamera.setYaw(this.observerCamera.getYaw() + delta);
            this.selectCamera();
        }

        /**
         * 
         * @param {number} delta
         */
        public rotateCameraPitch(delta: number) {
            super.rotateCameraPitch(delta);
            let newPitch: number = this.observerCamera.getPitch() + delta;
            newPitch = Math.min(Math.max(-<number>Math.PI / 2, newPitch), <number>Math.PI / 2);
            this.observerCamera.setPitch(newPitch);
            this.selectCamera();
        }

        /**
         * 
         * @param {number} delta
         */
        public modifyFieldOfView(delta: number) {
            super.modifyFieldOfView(delta);
            let newFieldOfView: number = this.observerCamera.getFieldOfView() + delta;
            newFieldOfView = <number>Math.min(Math.max(/* toRadians */(x => x * Math.PI / 180)(2), newFieldOfView), /* toRadians */(x => x * Math.PI / 180)(120));
            this.observerCamera.setFieldOfView(newFieldOfView);
            this.selectCamera();
        }

        /**
         * 
         * @param {Camera} camera
         */
        public goToCamera(camera: Camera) {
            super.goToCamera(camera);
            this.observerCamera.setCamera(camera);
            this.observerCamera.setTime(camera.getTime());
            this.observerCamera.setLens(camera.getLens());
            this.observerCamera.setRenderer(camera.getRenderer());
        }

        /**
         * 
         */
        public exit() {
            let selectedItems: Array<Selectable> = this.__parent.home.getSelectedItems();
            if (/* contains */(selectedItems.indexOf(<any>(this.observerCamera)) >= 0)) {
                selectedItems = <any>(selectedItems.slice(0));
                /* remove */(a => { let index = a.indexOf(this.observerCamera); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems);
                this.__parent.home.setSelectedItems(selectedItems);
            }
            {
                let array = this.__parent.home.getLevels();
                for (let index = 0; index < array.length; index++) {
                    let level = array[index];
                    {
                        level.removePropertyChangeListener(this.levelElevationChangeListener);
                    }
                }
            }
            this.__parent.home.removeLevelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this.levelsListener)));
            this.observerCamera = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            this.levelElevationChangeListener = new ObserverCameraState.ObserverCameraState$0(this);
            this.levelsListener = (ev: CollectionEvent<Level>) => {
                if (ev.getType() === CollectionEvent.Type.ADD) {
                    ev.getItem().addPropertyChangeListener(this.levelElevationChangeListener);
                } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                    ev.getItem().removePropertyChangeListener(this.levelElevationChangeListener);
                }
                this.updateCameraMinimumElevation();
            };
        }
    }
    ObserverCameraState["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController3D.ObserverCameraState";


    export namespace ObserverCameraState {

        export class ObserverCameraState$0 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                if (/* name */"ELEVATION" === ev.getPropertyName()) {
                    this.__parent.updateCameraMinimumElevation();
                }
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    export class HomeController3D$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setCameraState(this.home.getCamera() === this.home.getTopCamera() ? this.__parent.topCameraState : this.__parent.observerCameraState);
        }

        constructor(__parent: any, private home: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController3D$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if ((/* name */"ELEVATION" === ev.getPropertyName()) && this.home.getEnvironment().isObserverCameraElevationAdjusted()) {
                this.home.getObserverCamera().setZ(Math.max(this.__parent.getObserverCameraMinimumElevation(this.home), this.home.getObserverCamera().getZ() + <number>ev.getNewValue() - <number>ev.getOldValue()));
            }
        }

        constructor(__parent: any, private home: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController3D$2 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const oldSelectedLevel: Level = <Level>ev.getOldValue();
            const selectedLevel: Level = this.home.getSelectedLevel();
            if (this.home.getEnvironment().isObserverCameraElevationAdjusted()) {
                this.home.getObserverCamera().setZ(Math.max(this.__parent.getObserverCameraMinimumElevation(this.home), this.home.getObserverCamera().getZ() + (selectedLevel == null ? 0 : selectedLevel.getElevation()) - (oldSelectedLevel == null ? 0 : oldSelectedLevel.getElevation())));
            }
            if (oldSelectedLevel != null) {
                oldSelectedLevel.removePropertyChangeListener(this.levelElevationChangeListener);
            }
            if (selectedLevel != null) {
                selectedLevel.addPropertyChangeListener(this.levelElevationChangeListener);
            }
        }

        constructor(__parent: any, private home: any, private levelElevationChangeListener: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController3D$3 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const levels: Array<Level> = this.home.getLevels();
            const selectedLevel: Level = this.home.getSelectedLevel();
            let visible: boolean = true;
            for (let i: number = 0; i < /* size */(<number>levels.length); i++) {
                {
                /* get */levels[i].setVisible(visible);
                    if (/* get */levels[i] === selectedLevel && !this.home.getEnvironment().isAllLevelsVisible()) {
                        visible = false;
                    }
                };
            }
        }

        constructor(__parent: any, private home: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * An MVC view created and controlled by a controller.
 * @author Emmanuel Puybaret
 * @class
 */
interface View { }

export namespace View {

    /**
     * The pointer types that the user may use to interact with the plan
     * @enum
     * @property {View.PointerType} MOUSE
     * @property {View.PointerType} TOUCH
     * @class
     */
    export enum PointerType {
        MOUSE, TOUCH
    }
}


/**
 * The controller of the video creation view.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 * @ignore
 */
export class VideoController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ videoView: DialogView;

    /*private*/ aspectRatio: AspectRatio;

    /*private*/ frameRate: number;

    /*private*/ width: number;

    /*private*/ height: number;

    /*private*/ quality: number;

    /*private*/ speed: number;

    /*private*/ cameraPath: Array<Camera>;

    /*private*/ time: number;

    /*private*/ renderer: string;

    /*private*/ ceilingLightColor: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.videoView === undefined) { this.videoView = null; }
        if (this.aspectRatio === undefined) { this.aspectRatio = null; }
        if (this.frameRate === undefined) { this.frameRate = 0; }
        if (this.width === undefined) { this.width = 0; }
        if (this.height === undefined) { this.height = 0; }
        if (this.quality === undefined) { this.quality = 0; }
        if (this.speed === undefined) { this.speed = 0; }
        if (this.cameraPath === undefined) { this.cameraPath = null; }
        if (this.time === undefined) { this.time = 0; }
        if (this.renderer === undefined) { this.renderer = null; }
        if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
        home.getEnvironment().addPropertyChangeListener("CEILING_LIGHT_COLOR", new VideoController.HomeEnvironmentChangeListener(this));
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.videoView == null) {
            this.videoView = this.viewFactory.createVideoView(this.home, this.preferences, this);
        }
        return this.videoView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from the video creation preferences.
     */
    updateProperties() {
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        this.setFrameRate(homeEnvironment.getVideoFrameRate());
        this.setWidth(homeEnvironment.getVideoWidth(), false);
        this.setHeight(homeEnvironment.getVideoHeight(), false);
        this.setAspectRatio(homeEnvironment.getVideoAspectRatio());
        this.setQuality(homeEnvironment.getVideoQuality());
        this.setSpeed(homeEnvironment.getVideoSpeed());
        const videoCameraPath: Array<Camera> = homeEnvironment.getVideoCameraPath();
        this.setCameraPath(videoCameraPath);
        this.setTime(/* isEmpty */(videoCameraPath.length == 0) ? this.home.getCamera().getTime() : /* get */videoCameraPath[0].getTime());
        let renderer: string = this.home.getCamera().getRenderer();
        if (renderer == null) {
            renderer = this.preferences.getPhotoRenderer();
        }
        this.setRenderer(renderer, false);
        this.setCeilingLightColor(homeEnvironment.getCeillingLightColor());
    }

    /**
     * Sets the aspect ratio of the video.
     * @param {AspectRatio} aspectRatio
     */
    public setAspectRatio(aspectRatio: AspectRatio) {
        if (this.aspectRatio !== aspectRatio) {
            const oldAspectRatio: AspectRatio = this.aspectRatio;
            this.aspectRatio = aspectRatio;
            this.propertyChangeSupport.firePropertyChange(/* name */"ASPECT_RATIO", oldAspectRatio, aspectRatio);
            this.home.getEnvironment().setVideoAspectRatio(this.aspectRatio);
            this.setHeight(Math.round(this.width / { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
        }
    }

    /**
     * Returns the aspect ratio of the video.
     * @return {AspectRatio}
     */
    public getAspectRatio(): AspectRatio {
        return this.aspectRatio;
    }

    /**
     * Sets the frame rate of the video.
     * @param {number} frameRate
     */
    public setFrameRate(frameRate: number) {
        if (this.frameRate !== frameRate) {
            const oldFrameRate: number = this.frameRate;
            this.frameRate = frameRate;
            this.propertyChangeSupport.firePropertyChange(/* name */"QUALITY", oldFrameRate, frameRate);
            this.home.getEnvironment().setVideoFrameRate(this.frameRate);
        }
    }

    /**
     * Returns the frame rate of the video.
     * @return {number}
     */
    public getFrameRate(): number {
        return this.frameRate;
    }

    public setWidth(width: number, updateHeight: boolean = true) {
        if (this.width !== width) {
            const oldWidth: number = this.width;
            this.width = width;
            this.propertyChangeSupport.firePropertyChange(/* name */"WIDTH", oldWidth, width);
            if (updateHeight) {
                this.setHeight(Math.round(width / { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
            }
            this.home.getEnvironment().setVideoWidth(this.width);
        }
    }

    /**
     * Returns the width of the video.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    public setHeight(height: number, updateWidth: boolean = true) {
        if (this.height !== height) {
            const oldHeight: number = this.height;
            this.height = height;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
            if (updateWidth) {
                this.setWidth(Math.round(height * { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.aspectRatio]), false);
            }
        }
    }

    /**
     * Returns the height of the video.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the rendering quality of the video.
     * @param {number} quality
     */
    public setQuality(quality: number) {
        if (this.quality !== quality) {
            const oldQuality: number = this.quality;
            this.quality = Math.min(quality, this.getQualityLevelCount() - 1);
            this.propertyChangeSupport.firePropertyChange(/* name */"QUALITY", oldQuality, quality);
            this.home.getEnvironment().setVideoQuality(this.quality);
        }
    }

    /**
     * Returns the rendering quality of the video.
     * @return {number}
     */
    public getQuality(): number {
        return this.quality;
    }

    /**
     * Sets the preferred speed of movements in the video in m/s.
     * @param {number} speed
     */
    public setSpeed(speed: number) {
        if (this.speed !== speed) {
            const oldSpeed: number = this.speed;
            this.speed = speed;
            this.propertyChangeSupport.firePropertyChange(/* name */"SPEED", oldSpeed, speed);
            this.home.getEnvironment().setVideoSpeed(this.speed);
        }
    }

    /**
     * Returns the preferred speed of movements in the video in m/s.
     * @return {number}
     */
    public getSpeed(): number {
        return this.speed;
    }

    /**
     * Returns the maximum value for quality.
     * @return {number}
     */
    public getQualityLevelCount(): number {
        return 4;
    }

    /**
     * Returns the camera path of the video.
     * @return {Camera[]}
     */
    public getCameraPath(): Array<Camera> {
        return this.cameraPath;
    }

    /**
     * Sets the camera locations of the video.
     * @param {Camera[]} cameraPath
     */
    public setCameraPath(cameraPath: Array<Camera>) {
        if (this.cameraPath !== cameraPath) {
            const oldCameraPath: Array<Camera> = this.cameraPath;
            this.cameraPath = cameraPath;
            this.propertyChangeSupport.firePropertyChange(/* name */"CAMERA_PATH", oldCameraPath, cameraPath);
            this.home.getEnvironment().setVideoCameraPath(this.cameraPath);
        }
    }

    /**
     * Sets the edited time in UTC time zone.
     * @param {number} time
     */
    public setTime(time: number) {
        if (this.time !== time) {
            const oldTime: number = this.time;
            this.time = time;
            this.propertyChangeSupport.firePropertyChange(/* name */"TIME", oldTime, time);
            this.home.getCamera().setTime(time);
        }
    }

    /**
     * Returns the edited time in UTC time zone.
     * @return {number}
     */
    public getTime(): number {
        return this.time;
    }

    public setRenderer(renderer: string, updatePreferences: boolean = true) {
        if (this.renderer !== renderer) {
            const oldRenderer: string = this.renderer;
            this.renderer = renderer;
            this.propertyChangeSupport.firePropertyChange(/* name */"RENDERER", oldRenderer, renderer);
            let cameraPath: Array<Camera> = this.home.getEnvironment().getVideoCameraPath();
            if (!/* isEmpty */(cameraPath.length == 0)) {
                cameraPath = <any>(cameraPath.slice(0));
                /* get */cameraPath[0].setRenderer(renderer);
                this.setCameraPath(cameraPath);
            }
            if (updatePreferences) {
                this.preferences.setPhotoRenderer(renderer);
            }
        }
    }

    /**
     * Returns the edited camera rendering engine.
     * @return {string}
     */
    public getRenderer(): string {
        return this.renderer;
    }

    /**
     * Sets the edited ceiling light color.
     * @param {number} ceilingLightColor
     */
    public setCeilingLightColor(ceilingLightColor: number) {
        if (this.ceilingLightColor !== ceilingLightColor) {
            const oldCeilingLightColor: number = this.ceilingLightColor;
            this.ceilingLightColor = ceilingLightColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_LIGHT_COLOR", oldCeilingLightColor, ceilingLightColor);
            this.home.getEnvironment().setCeillingLightColor(ceilingLightColor);
        }
    }

    /**
     * Returns the edited ceiling light color.
     * @return {number}
     */
    public getCeilingLightColor(): number {
        return this.ceilingLightColor;
    }

    /**
     * Controls the change of value of a visual property in home.
     * @deprecated {@link #setVisualProperty(String, Object) setVisualProperty} should be replaced by a call to
     * {@link #setHomeProperty(String, String) setHomeProperty} to ensure the property can be easily saved and read.
     * @param {string} propertyName
     * @param {Object} propertyValue
     */
    public setVisualProperty(propertyName: string, propertyValue: any) {
        this.home.setVisualProperty(propertyName, propertyValue);
    }

    /**
     * Controls the change of value of a property in home.
     * @param {string} propertyName
     * @param {string} propertyValue
     */
    public setHomeProperty(propertyName: string, propertyValue: string) {
        this.home.setProperty(propertyName, propertyValue);
    }
}
VideoController["__class"] = "com.eteks.sweethome3d.viewcontroller.VideoController";
VideoController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace VideoController {

    /**
     * Home environment listener that updates properties. This listener is bound to this controller
     * with a weak reference to avoid strong link between home and this controller.
     * @param {VideoController} videoController
     * @class
     */
    export class HomeEnvironmentChangeListener {
        videoController: VideoController;

        public constructor(videoController: VideoController) {
            if (this.videoController === undefined) { this.videoController = null; }
            this.videoController = <any>(videoController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: VideoController = /* get */this.videoController;
            if (controller == null) {
                (<HomeEnvironment>ev.getSource()).removePropertyChangeListener("CEILING_LIGHT_COLOR", this);
            } else {
                controller.updateProperties();
            }
        }
    }
    HomeEnvironmentChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.VideoController.HomeEnvironmentChangeListener";

}


/**
 * Exporter for home instances. Homes will be written using the DTD given in {@link HomeXMLHandler} class.
 * @author Emmanuel Puybaret
 * @class
 * @extends ObjectXMLExporter
 */
export class HomeXMLExporter extends ObjectXMLExporter<Home> {
    /*private*/ savedContentNames: any;

    /*private*/ levelIds: any;

    /*private*/ wallIds: any;

    /**
     * Sets the names that will be saved as XML attribute values for each content.
     * @param {Object} savedContentNames
     * @private
     */
    setSavedContentNames(savedContentNames: any) {
        this.savedContentNames = savedContentNames;
    }

    /**
     * Returns the XML id of the given <code>object</code> that can be referenced by other elements.
     * @throws IllegalArgumentException if the <code>object</code> has no associated id.
     * @param {Object} object
     * @return {string}
     */
    getId(object: any): string {
        if (object == null) {
            return null;
        } else if (object != null && object instanceof <any>Level) {
            return /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>this.levelIds, object);
        } else if (object != null && object instanceof <any>Wall) {
            return /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>this.wallIds, object);
        } else {
            throw new IllegalArgumentException("No Id provided for object of class " + /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>object.constructor)));
        }
    }

    public writeElement$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer: XMLWriter, home: Home) {
        {
            let array = home.getLevels();
            for (let index = 0; index < array.length; index++) {
                let level = array[index];
                {
                    /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>this.levelIds, level, level.getId());
                }
            }
        }
        {
            let array = home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>this.wallIds, wall, wall.getId());
                }
            }
        }
        super.writeElement(writer, home);
    }

    /**
     * Writes in XML the <code>home</code> object and the objects that depends on it with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Home} home
     */
    public writeElement(writer?: any, home?: any) {
        if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null && home instanceof <any>Home) || home === null)) {
            return <any>this.writeElement$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer, home);
        } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null) || home === null)) {
            super.writeElement(writer, home);
        } else throw new Error('invalid overload');
    }

    public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer: XMLWriter, home: Home) {
        home.setVersion(Home.CURRENT_VERSION);
        writer.writeAttribute$java_lang_String$java_lang_String("version", /* valueOf */String(home.getVersion()).toString());
        writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("name", home.getName(), null);
        writer.writeAttribute$java_lang_String$java_lang_String("camera", home.getCamera() === home.getObserverCamera() ? "observerCamera" : "topCamera");
        writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("selectedLevel", this.getId(home.getSelectedLevel()), null);
        writer.writeFloatAttribute$java_lang_String$float("wallHeight", home.getWallHeight());
        writer.writeBooleanAttribute("basePlanLocked", home.isBasePlanLocked(), false);
        if (home.getFurnitureSortedPropertyName() != null) {
            writer.writeAttribute$java_lang_String$java_lang_String("furnitureSortedProperty", home.getFurnitureSortedPropertyName());
        }
        writer.writeBooleanAttribute("furnitureDescendingSorted", home.isFurnitureDescendingSorted(), false);
    }

    /**
     * Writes as XML attributes some data of <code>home</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Home} home
     */
    public writeAttributes(writer?: any, home?: any) {
        if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null && home instanceof <any>Home) || home === null)) {
            return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer, home);
        } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null) || home === null)) {
            super.writeAttributes(writer, home);
        } else throw new Error('invalid overload');
    }

    public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer: XMLWriter, home: Home) {
        const propertiesNames: Array<string> = <any>(home.getPropertyNames().slice(0));
        /* sort */propertiesNames.sort();
        for (let index = 0; index < propertiesNames.length; index++) {
            let propertyName = propertiesNames[index];
            {
                this.writeProperty(writer, home, propertyName, home.getProperty(propertyName), false);
            }
        }
        {
            let array = home.getFurnitureVisiblePropertyNames();
            for (let index = 0; index < array.length; index++) {
                let property = array[index];
                {
                    writer.writeStartElement("furnitureVisibleProperty");
                    writer.writeAttribute$java_lang_String$java_lang_String("name", property);
                    writer.writeEndElement();
                }
            }
        }
        this.writeEnvironment(writer, home.getEnvironment());
        this.writeBackgroundImage(writer, home.getBackgroundImage());
        this.writePrint(writer, home.getPrint());
        this.writeCompass(writer, home.getCompass());
        this.writeCamera(writer, home.getObserverCamera(), "observerCamera");
        this.writeCamera(writer, home.getTopCamera(), "topCamera");
        {
            let array = home.getStoredCameras();
            for (let index = 0; index < array.length; index++) {
                let camera = array[index];
                {
                    this.writeCamera(writer, camera, "storedCamera");
                }
            }
        }
        {
            let array = home.getLevels();
            for (let index = 0; index < array.length; index++) {
                let level = array[index];
                {
                    this.writeLevel(writer, level);
                }
            }
        }
        {
            let array = home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    this.writePieceOfFurniture(writer, piece);
                }
            }
        }
        {
            let array = home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    this.writeWall(writer, wall);
                }
            }
        }
        {
            let array = home.getRooms();
            for (let index = 0; index < array.length; index++) {
                let room = array[index];
                {
                    this.writeRoom(writer, room);
                }
            }
        }
        {
            let array = home.getPolylines();
            for (let index = 0; index < array.length; index++) {
                let polyline = array[index];
                {
                    this.writePolyline(writer, polyline);
                }
            }
        }
        {
            let array = home.getDimensionLines();
            for (let index = 0; index < array.length; index++) {
                let dimensionLine = array[index];
                {
                    this.writeDimensionLine(writer, dimensionLine);
                }
            }
        }
        {
            let array = home.getLabels();
            for (let index = 0; index < array.length; index++) {
                let label = array[index];
                {
                    this.writeLabel(writer, label);
                }
            }
        }
    }

    /**
     * Writes as XML elements some objects that depends on of <code>home</code> with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Home} home
     */
    public writeChildren(writer?: any, home?: any) {
        if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null && home instanceof <any>Home) || home === null)) {
            return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Home(writer, home);
        } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((home != null) || home === null)) {
            super.writeChildren(writer, home);
        } else throw new Error('invalid overload');
    }

    /**
     * Writes in XML the <code>environment</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomeEnvironment} environment
     */
    writeEnvironment(writer: XMLWriter, environment: HomeEnvironment) {
        new HomeXMLExporter.HomeXMLExporter$0(this).writeElement(writer, environment);
    }

    /**
     * Writes in XML the <code>background</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {BackgroundImage} backgroundImage
     */
    writeBackgroundImage(writer: XMLWriter, backgroundImage: BackgroundImage) {
        if (backgroundImage != null) {
            new HomeXMLExporter.HomeXMLExporter$1(this).writeElement(writer, backgroundImage);
        }
    }

    /**
     * Writes in XML the <code>print</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomePrint} print
     */
    writePrint(writer: XMLWriter, print: HomePrint) {
        if (print != null) {
            new HomeXMLExporter.HomeXMLExporter$2(this).writeElement(writer, print);
        }
    }

    /**
     * Writes in XML the <code>compass</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Compass} compass
     */
    writeCompass(writer: XMLWriter, compass: Compass) {
        new HomeXMLExporter.HomeXMLExporter$3(this).writeElement(writer, compass);
    }

    /**
     * Writes in XML the <code>camera</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Camera} camera
     * @param {string} attributeName
     */
    writeCamera(writer: XMLWriter, camera: Camera, attributeName: string) {
        if (camera != null) {
            new HomeXMLExporter.HomeXMLExporter$4(this, attributeName).writeElement(writer, camera);
        }
    }

    /**
     * Writes in XML the <code>level</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Level} level
     */
    writeLevel(writer: XMLWriter, level: Level) {
        new HomeXMLExporter.HomeXMLExporter$5(this).writeElement(writer, level);
    }

    /**
     * Writes in XML the <code>piece</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomePieceOfFurniture} piece
     */
    writePieceOfFurniture(writer: XMLWriter, piece: HomePieceOfFurniture) {
        new HomeXMLExporter.PieceOfFurnitureExporter(this).writeElement(writer, piece);
    }

    /**
     * Writes in XML the <code>material</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomeMaterial} material
     * @param {Object} model
     */
    writeMaterial(writer: XMLWriter, material: HomeMaterial, model: Content) {
        if (material != null) {
            new HomeXMLExporter.HomeXMLExporter$6(this).writeElement(writer, material);
        }
    }

    /**
     * Writes in XML the <code>wall</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Wall} wall
     */
    writeWall(writer: XMLWriter, wall: Wall) {
        new HomeXMLExporter.HomeXMLExporter$7(this).writeElement(writer, wall);
    }

    /**
     * Writes in XML the <code>room</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Room} room
     */
    writeRoom(writer: XMLWriter, room: Room) {
        new HomeXMLExporter.HomeXMLExporter$8(this).writeElement(writer, room);
    }

    /**
     * Writes in XML the <code>polyline</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Polyline} polyline
     */
    writePolyline(writer: XMLWriter, polyline: Polyline) {
        new HomeXMLExporter.HomeXMLExporter$9(this).writeElement(writer, polyline);
    }

    /**
     * Writes in XML the <code>dimensionLine</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {DimensionLine} dimensionLine
     */
    writeDimensionLine(writer: XMLWriter, dimensionLine: DimensionLine) {
        new HomeXMLExporter.HomeXMLExporter$10(this).writeElement(writer, dimensionLine);
    }

    /**
     * Writes in XML the <code>label</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Label} label
     */
    writeLabel(writer: XMLWriter, label: Label) {
        new HomeXMLExporter.HomeXMLExporter$11(this).writeElement(writer, label);
    }

    /**
     * Writes in XML the <code>textStyle</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {TextStyle} textStyle
     * @param {string} attributeName
     */
    writeTextStyle(writer: XMLWriter, textStyle: TextStyle, attributeName: string) {
        if (textStyle != null) {
            new HomeXMLExporter.HomeXMLExporter$12(this, attributeName).writeElement(writer, textStyle);
        }
    }

    /**
     * Writes in XML the <code>baseboard</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {Baseboard} baseboard
     * @param {string} attributeName
     */
    writeBaseboard(writer: XMLWriter, baseboard: Baseboard, attributeName: string) {
        if (baseboard != null) {
            new HomeXMLExporter.HomeXMLExporter$13(this, attributeName).writeElement(writer, baseboard);
        }
    }

    /**
     * Writes in XML the <code>texture</code> object with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomeTexture} texture
     * @param {string} attributeName
     */
    writeTexture(writer: XMLWriter, texture: HomeTexture, attributeName: string) {
        if (texture != null) {
            new HomeXMLExporter.HomeXMLExporter$14(this, attributeName).writeElement(writer, texture);
        }
    }

    /**
     * Writes in XML the properties of the <code>HomeObject</code> instance with the given <code>writer</code>.
     * @param {XMLWriter} writer
     * @param {HomeObject} object
     * @private
     */
    writeProperties(writer: XMLWriter, object: HomeObject) {
        const propertiesNames: Array<string> = <any>(object.getPropertyNames().slice(0));
        /* sort */propertiesNames.sort();
        for (let index = 0; index < propertiesNames.length; index++) {
            let propertyName = propertiesNames[index];
            {
                const propertyContent: boolean = object.isContentProperty(propertyName);
                this.writeProperty(writer, object, propertyName, propertyContent ? object.getContentProperty(propertyName) : object.getProperty(propertyName), propertyContent);
            }
        }
    }

    /**
     * Writes in XML the given property.
     * @param {XMLWriter} writer
     * @param {Object} object
     * @param {string} propertyName
     * @param {Object} propertyValue
     * @param {boolean} content
     * @private
     */
    writeProperty(writer: XMLWriter, object: any, propertyName: string, propertyValue: any, content: boolean) {
        if (propertyValue != null) {
            writer.writeStartElement("property");
            writer.writeAttribute$java_lang_String$java_lang_String("name", propertyName);
            writer.writeAttribute$java_lang_String$java_lang_String("value", content ? this.getExportedContentName(object, <Content><any>propertyValue) : propertyValue.toString());
            if (content) {
                writer.writeAttribute$java_lang_String$java_lang_String("type", /* Enum.name */ObjectProperty.Type[ObjectProperty.Type.CONTENT]);
            }
            writer.writeEndElement();
        }
    }

    /**
     * Returns the string value of the given float, except for -1.0, 1.0 or 0.0
     * where -1, 1 and 0 is returned.
     * @param {number} f
     * @return {string}
     * @private
     */
    static floatToString(f: number): string {
        if (Math.abs(f) < 1.0E-6) {
            return "0";
        } else if (Math.abs(f - 1.0) < 1.0E-6) {
            return "1";
        } else if (Math.abs(f + 1.0) < 1.0E-6) {
            return "-1";
        } else {
            return /* valueOf */String(f).toString();
        }
    }

    /**
     * Returns the saved name of the given <code>content</code> owned by an object.
     * @param {Object} owner
     * @param {Object} content
     * @return {string}
     */
    getExportedContentName(owner: any, content: Content): string {
        if (content == null) { return null; } else if (this.savedContentNames != null) { var contentName = this.savedContentNames[(content as URLContent).getURL()]; if (contentName != null) { return contentName; } } return (content as URLContent).getURL();
    }

    constructor() {
        super();
        if (this.savedContentNames === undefined) { this.savedContentNames = null; }
        this.levelIds = <any>({});
        this.wallIds = <any>({});
    }
}
HomeXMLExporter["__class"] = "com.eteks.sweethome3d.io.HomeXMLExporter";


export namespace HomeXMLExporter {

    /**
     * Default exporter class used to write a piece of furniture in XML.
     * @class
     * @extends ObjectXMLExporter
     */
    export class PieceOfFurnitureExporter extends ObjectXMLExporter<HomePieceOfFurniture> {
        public __parent: any;
        public constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }

        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePieceOfFurniture(writer: XMLWriter, piece: HomePieceOfFurniture) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", piece.getId());
            if (piece.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(piece.getLevel()));
            }
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("catalogId", piece.getCatalogId(), null);
            writer.writeAttribute$java_lang_String$java_lang_String("name", piece.getName());
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("creator", piece.getCreator(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("model", this.__parent.getExportedContentName(piece, piece.getModel()), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("icon", this.__parent.getExportedContentName(piece, piece.getIcon()), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("planIcon", this.__parent.getExportedContentName(piece, piece.getPlanIcon()), null);
            writer.writeFloatAttribute$java_lang_String$float("x", piece.getX());
            writer.writeFloatAttribute$java_lang_String$float("y", piece.getY());
            writer.writeFloatAttribute$java_lang_String$float$float("elevation", piece.getElevation(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("angle", piece.getAngle(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("pitch", piece.getPitch(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("roll", piece.getRoll(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float("width", piece.getWidth());
            writer.writeFloatAttribute$java_lang_String$float$float("widthInPlan", piece.getWidthInPlan(), piece.getWidth());
            writer.writeFloatAttribute$java_lang_String$float("depth", piece.getDepth());
            writer.writeFloatAttribute$java_lang_String$float$float("depthInPlan", piece.getDepthInPlan(), piece.getDepth());
            writer.writeFloatAttribute$java_lang_String$float("height", piece.getHeight());
            writer.writeFloatAttribute$java_lang_String$float$float("heightInPlan", piece.getHeightInPlan(), piece.getHeight());
            writer.writeIntegerAttribute$java_lang_String$int$int("modelFlags", piece.getModelFlags(), 0);
            writer.writeBooleanAttribute("modelMirrored", piece.isModelMirrored(), false);
            writer.writeBooleanAttribute("visible", piece.isVisible(), true);
            writer.writeColorAttribute("color", piece.getColor());
            if (piece.getShininess() != null) {
                writer.writeFloatAttribute$java_lang_String$java_lang_Float("shininess", piece.getShininess());
            }
            const modelRotation: number[][] = piece.getModelRotation();
            const modelRotationString: string = HomeXMLExporter.floatToString(modelRotation[0][0]) + " " + HomeXMLExporter.floatToString(modelRotation[0][1]) + " " + HomeXMLExporter.floatToString(modelRotation[0][2]) + " " + HomeXMLExporter.floatToString(modelRotation[1][0]) + " " + HomeXMLExporter.floatToString(modelRotation[1][1]) + " " + HomeXMLExporter.floatToString(modelRotation[1][2]) + " " + HomeXMLExporter.floatToString(modelRotation[2][0]) + " " + HomeXMLExporter.floatToString(modelRotation[2][1]) + " " + HomeXMLExporter.floatToString(modelRotation[2][2]);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("modelRotation", modelRotationString, "1 0 0 0 1 0 0 0 1");
            writer.writeBooleanAttribute("modelCenteredAtOrigin", piece.isModelCenteredAtOrigin(), true);
            writer.writeLongAttribute$java_lang_String$java_lang_Long("modelSize", piece.getModelSize());
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("description", piece.getDescription(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("information", piece.getInformation(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("license", piece.getLicense(), null);
            writer.writeBooleanAttribute("movable", piece.isMovable(), true);
            if (!(piece != null && piece instanceof <any>HomeFurnitureGroup)) {
                if (!(piece != null && piece instanceof <any>HomeDoorOrWindow)) {
                    writer.writeBooleanAttribute("doorOrWindow", piece.isDoorOrWindow(), false);
                    writer.writeBooleanAttribute("horizontallyRotatable", piece.isHorizontallyRotatable(), true);
                }
                writer.writeBooleanAttribute("resizable", piece.isResizable(), true);
                writer.writeBooleanAttribute("deformable", piece.isDeformable(), true);
                writer.writeBooleanAttribute("texturable", piece.isTexturable(), true);
            }
            if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                let price: Big = piece.getPrice();
                {
                    let array = (<HomeFurnitureGroup>piece).getFurniture();
                    for (let index = 0; index < array.length; index++) {
                        let groupPiece = array[index];
                        {
                            if (groupPiece.getPrice() != null) {
                                price = null;
                                break;
                            }
                        }
                    }
                }
                writer.writeBigDecimalAttribute("price", price);
            } else {
                writer.writeBigDecimalAttribute("price", piece.getPrice());
                writer.writeBigDecimalAttribute("valueAddedTaxPercentage", piece.getValueAddedTaxPercentage());
                writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("currency", piece.getCurrency(), null);
            }
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("staircaseCutOutShape", piece.getStaircaseCutOutShape(), null);
            writer.writeFloatAttribute$java_lang_String$float$float("dropOnTopElevation", piece.getDropOnTopElevation(), 1.0);
            writer.writeBooleanAttribute("nameVisible", piece.isNameVisible(), false);
            writer.writeFloatAttribute$java_lang_String$float$float("nameAngle", piece.getNameAngle(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("nameXOffset", piece.getNameXOffset(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("nameYOffset", piece.getNameYOffset(), 0.0);
            if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                writer.writeFloatAttribute$java_lang_String$float$float("wallThickness", doorOrWindow.getWallThickness(), 1.0);
                writer.writeFloatAttribute$java_lang_String$float$float("wallDistance", doorOrWindow.getWallDistance(), 0.0);
                writer.writeFloatAttribute$java_lang_String$float$float("wallWidth", doorOrWindow.getWallWidth(), 1.0);
                writer.writeFloatAttribute$java_lang_String$float$float("wallLeft", doorOrWindow.getWallLeft(), 0.0);
                writer.writeFloatAttribute$java_lang_String$float$float("wallHeight", doorOrWindow.getWallHeight(), 1.0);
                writer.writeFloatAttribute$java_lang_String$float$float("wallTop", doorOrWindow.getWallTop(), 0.0);
                writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("cutOutShape", doorOrWindow.getCutOutShape(), null);
                writer.writeBooleanAttribute("wallCutOutOnBothSides", doorOrWindow.isWallCutOutOnBothSides(), false);
                writer.writeBooleanAttribute("widthDepthDeformable", doorOrWindow.isWidthDepthDeformable(), true);
                writer.writeBooleanAttribute("boundToWall", doorOrWindow.isBoundToWall(), true);
            } else if (piece != null && piece instanceof <any>HomeLight) {
                writer.writeFloatAttribute$java_lang_String$float("power", (<HomeLight>piece).getPower());
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomePieceOfFurniture} piece
         */
        public writeAttributes(writer?: any, piece?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePieceOfFurniture(writer, piece);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((piece != null) || piece === null)) {
                super.writeAttributes(writer, piece);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePieceOfFurniture(writer: XMLWriter, piece: HomePieceOfFurniture) {
            if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                {
                    let array = (<HomeFurnitureGroup>piece).getFurniture();
                    for (let index = 0; index < array.length; index++) {
                        let groupPiece = array[index];
                        {
                            this.__parent.writePieceOfFurniture(writer, groupPiece);
                        }
                    }
                }
            } else if (piece != null && piece instanceof <any>HomeLight) {
                {
                    let array = (<HomeLight>piece).getLightSources();
                    for (let index = 0; index < array.length; index++) {
                        let lightSource = array[index];
                        {
                            writer.writeStartElement("lightSource");
                            writer.writeFloatAttribute$java_lang_String$float("x", lightSource.getX());
                            writer.writeFloatAttribute$java_lang_String$float("y", lightSource.getY());
                            writer.writeFloatAttribute$java_lang_String$float("z", lightSource.getZ());
                            writer.writeColorAttribute("color", lightSource.getColor());
                            writer.writeFloatAttribute$java_lang_String$java_lang_Float("diameter", lightSource.getDiameter());
                            writer.writeEndElement();
                        }
                    }
                }
                {
                    let array = (<HomeLight>piece).getLightSourceMaterialNames();
                    for (let index = 0; index < array.length; index++) {
                        let lightSourceMaterialName = array[index];
                        {
                            writer.writeStartElement("lightSourceMaterial");
                            writer.writeAttribute$java_lang_String$java_lang_String("name", lightSourceMaterialName);
                            writer.writeEndElement();
                        }
                    }
                }
            } else if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                {
                    let array = (<HomeDoorOrWindow>piece).getSashes();
                    for (let index = 0; index < array.length; index++) {
                        let sash = array[index];
                        {
                            writer.writeStartElement("sash");
                            writer.writeFloatAttribute$java_lang_String$float("xAxis", sash.getXAxis());
                            writer.writeFloatAttribute$java_lang_String$float("yAxis", sash.getYAxis());
                            writer.writeFloatAttribute$java_lang_String$float("width", sash.getWidth());
                            writer.writeFloatAttribute$java_lang_String$float("startAngle", sash.getStartAngle());
                            writer.writeFloatAttribute$java_lang_String$float("endAngle", sash.getEndAngle());
                            writer.writeEndElement();
                        }
                    }
                }
            } else if (piece != null && piece instanceof <any>HomeShelfUnit) {
                const shelf: HomeShelfUnit = <HomeShelfUnit>piece;
                const shelfElevations: number[] = shelf.getShelfElevations();
                if (shelfElevations != null) {
                    for (let i: number = 0; i < shelfElevations.length; i++) {
                        {
                            writer.writeStartElement("shelf");
                            writer.writeFloatAttribute$java_lang_String$float("elevation", shelfElevations[i]);
                            writer.writeEndElement();
                        };
                    }
                }
                const shelfBoxes: BoxBounds[] = shelf.getShelfBoxes();
                if (shelfBoxes != null) {
                    for (let i: number = 0; i < shelfBoxes.length; i++) {
                        {
                            writer.writeStartElement("shelf");
                            writer.writeFloatAttribute$java_lang_String$float("xLower", shelfBoxes[i].getXLower());
                            writer.writeFloatAttribute$java_lang_String$float("yLower", shelfBoxes[i].getYLower());
                            writer.writeFloatAttribute$java_lang_String$float("zLower", shelfBoxes[i].getZLower());
                            writer.writeFloatAttribute$java_lang_String$float("xUpper", shelfBoxes[i].getXUpper());
                            writer.writeFloatAttribute$java_lang_String$float("yUpper", shelfBoxes[i].getYUpper());
                            writer.writeFloatAttribute$java_lang_String$float("zUpper", shelfBoxes[i].getZUpper());
                            writer.writeEndElement();
                        };
                    }
                }
            }
            this.__parent.writeProperties(writer, piece);
            this.__parent.writeTextStyle(writer, piece.getNameStyle(), "nameStyle");
            this.__parent.writeTexture(writer, piece.getTexture(), null);
            if (piece.getModelMaterials() != null) {
                {
                    let array = piece.getModelMaterials();
                    for (let index = 0; index < array.length; index++) {
                        let material = array[index];
                        {
                            this.__parent.writeMaterial(writer, material, piece.getModel());
                        }
                    }
                }
            }
            if (piece.getModelTransformations() != null) {
                {
                    let array = piece.getModelTransformations();
                    for (let index = 0; index < array.length; index++) {
                        let transformation = array[index];
                        {
                            writer.writeStartElement("transformation");
                            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("name", transformation.getName(), null);
                            const matrix: number[][] = transformation.getMatrix();
                            const matrixString: string = HomeXMLExporter.floatToString(matrix[0][0]) + " " + HomeXMLExporter.floatToString(matrix[0][1]) + " " + HomeXMLExporter.floatToString(matrix[0][2]) + " " + HomeXMLExporter.floatToString(matrix[0][3]) + " " + HomeXMLExporter.floatToString(matrix[1][0]) + " " + HomeXMLExporter.floatToString(matrix[1][1]) + " " + HomeXMLExporter.floatToString(matrix[1][2]) + " " + HomeXMLExporter.floatToString(matrix[1][3]) + " " + HomeXMLExporter.floatToString(matrix[2][0]) + " " + HomeXMLExporter.floatToString(matrix[2][1]) + " " + HomeXMLExporter.floatToString(matrix[2][2]) + " " + HomeXMLExporter.floatToString(matrix[2][3]);
                            writer.writeAttribute$java_lang_String$java_lang_String("matrix", matrixString);
                            writer.writeEndElement();
                        }
                    }
                }
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomePieceOfFurniture} piece
         */
        public writeChildren(writer?: any, piece?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePieceOfFurniture(writer, piece);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((piece != null) || piece === null)) {
                super.writeChildren(writer, piece);
            } else throw new Error('invalid overload');
        }
    }
    PieceOfFurnitureExporter["__class"] = "com.eteks.sweethome3d.io.HomeXMLExporter.PieceOfFurnitureExporter";


    export class HomeXMLExporter$0 extends ObjectXMLExporter<HomeEnvironment> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeEnvironment(writer: XMLWriter, environment: HomeEnvironment) {
            writer.writeColorAttribute("groundColor", environment.getGroundColor());
            writer.writeBooleanAttribute("backgroundImageVisibleOnGround3D", environment.isBackgroundImageVisibleOnGround3D(), false);
            writer.writeColorAttribute("skyColor", environment.getSkyColor());
            writer.writeColorAttribute("lightColor", environment.getLightColor());
            writer.writeFloatAttribute$java_lang_String$float$float("wallsAlpha", environment.getWallsAlpha(), 0);
            writer.writeBooleanAttribute("allLevelsVisible", environment.isAllLevelsVisible(), false);
            writer.writeBooleanAttribute("observerCameraElevationAdjusted", environment.isObserverCameraElevationAdjusted(), true);
            writer.writeColorAttribute("ceillingLightColor", environment.getCeillingLightColor());
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("drawingMode", /* Enum.name */HomeEnvironment.DrawingMode[environment.getDrawingMode()], /* Enum.name */HomeEnvironment.DrawingMode[HomeEnvironment.DrawingMode.FILL]);
            writer.writeFloatAttribute$java_lang_String$float$float("subpartSizeUnderLight", environment.getSubpartSizeUnderLight(), 0);
            writer.writeIntegerAttribute$java_lang_String$int("photoWidth", environment.getPhotoWidth());
            writer.writeIntegerAttribute$java_lang_String$int("photoHeight", environment.getPhotoHeight());
            writer.writeAttribute$java_lang_String$java_lang_String("photoAspectRatio", /* Enum.name */AspectRatio[environment.getPhotoAspectRatio()]);
            writer.writeIntegerAttribute$java_lang_String$int("photoQuality", environment.getPhotoQuality());
            writer.writeIntegerAttribute$java_lang_String$int("videoWidth", environment.getVideoWidth());
            writer.writeAttribute$java_lang_String$java_lang_String("videoAspectRatio", /* Enum.name */AspectRatio[environment.getVideoAspectRatio()]);
            writer.writeIntegerAttribute$java_lang_String$int("videoQuality", environment.getVideoQuality());
            writer.writeFloatAttribute$java_lang_String$float$float("videoSpeed", environment.getVideoSpeed(), 2400.0 / 3600);
            writer.writeIntegerAttribute$java_lang_String$int("videoFrameRate", environment.getVideoFrameRate());
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomeEnvironment} environment
         */
        public writeAttributes(writer?: any, environment?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((environment != null && environment instanceof <any>HomeEnvironment) || environment === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeEnvironment(writer, environment);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((environment != null) || environment === null)) {
                super.writeAttributes(writer, environment);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeEnvironment(writer: XMLWriter, environment: HomeEnvironment) {
            this.__parent.writeProperties(writer, environment);
            if (!/* isEmpty */(environment.getVideoCameraPath().length == 0)) {
                {
                    let array = environment.getVideoCameraPath();
                    for (let index = 0; index < array.length; index++) {
                        let camera = array[index];
                        {
                            this.__parent.writeCamera(writer, camera, "cameraPath");
                        }
                    }
                }
            }
            this.__parent.writeTexture(writer, environment.getGroundTexture(), "groundTexture");
            this.__parent.writeTexture(writer, environment.getSkyTexture(), "skyTexture");
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomeEnvironment} environment
         */
        public writeChildren(writer?: any, environment?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((environment != null && environment instanceof <any>HomeEnvironment) || environment === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeEnvironment(writer, environment);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((environment != null) || environment === null)) {
                super.writeChildren(writer, environment);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$1 extends ObjectXMLExporter<BackgroundImage> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_BackgroundImage(writer: XMLWriter, backgroundImage: BackgroundImage) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("image", this.__parent.getExportedContentName(backgroundImage, backgroundImage.getImage()), null);
            writer.writeFloatAttribute$java_lang_String$float("scaleDistance", backgroundImage.getScaleDistance());
            writer.writeFloatAttribute$java_lang_String$float("scaleDistanceXStart", backgroundImage.getScaleDistanceXStart());
            writer.writeFloatAttribute$java_lang_String$float("scaleDistanceYStart", backgroundImage.getScaleDistanceYStart());
            writer.writeFloatAttribute$java_lang_String$float("scaleDistanceXEnd", backgroundImage.getScaleDistanceXEnd());
            writer.writeFloatAttribute$java_lang_String$float("scaleDistanceYEnd", backgroundImage.getScaleDistanceYEnd());
            writer.writeFloatAttribute$java_lang_String$float$float("xOrigin", backgroundImage.getXOrigin(), 0);
            writer.writeFloatAttribute$java_lang_String$float$float("yOrigin", backgroundImage.getYOrigin(), 0);
            writer.writeBooleanAttribute("visible", backgroundImage.isVisible(), true);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {BackgroundImage} backgroundImage
         */
        public writeAttributes(writer?: any, backgroundImage?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((backgroundImage != null && backgroundImage instanceof <any>BackgroundImage) || backgroundImage === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_BackgroundImage(writer, backgroundImage);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((backgroundImage != null) || backgroundImage === null)) {
                super.writeAttributes(writer, backgroundImage);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$2 extends ObjectXMLExporter<HomePrint> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePrint(writer: XMLWriter, print: HomePrint) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("headerFormat", print.getHeaderFormat(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("footerFormat", print.getFooterFormat(), null);
            writer.writeBooleanAttribute("furniturePrinted", print.isFurniturePrinted(), true);
            writer.writeBooleanAttribute("planPrinted", print.isPlanPrinted(), true);
            writer.writeBooleanAttribute("view3DPrinted", print.isView3DPrinted(), true);
            writer.writeFloatAttribute$java_lang_String$java_lang_Float("planScale", print.getPlanScale());
            writer.writeFloatAttribute$java_lang_String$float("paperWidth", print.getPaperWidth());
            writer.writeFloatAttribute$java_lang_String$float("paperHeight", print.getPaperHeight());
            writer.writeFloatAttribute$java_lang_String$float("paperTopMargin", print.getPaperTopMargin());
            writer.writeFloatAttribute$java_lang_String$float("paperLeftMargin", print.getPaperLeftMargin());
            writer.writeFloatAttribute$java_lang_String$float("paperBottomMargin", print.getPaperBottomMargin());
            writer.writeFloatAttribute$java_lang_String$float("paperRightMargin", print.getPaperRightMargin());
            writer.writeAttribute$java_lang_String$java_lang_String("paperOrientation", /* Enum.name */HomePrint.PaperOrientation[print.getPaperOrientation()]);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomePrint} print
         */
        public writeAttributes(writer?: any, print?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((print != null && print instanceof <any>HomePrint) || print === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePrint(writer, print);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((print != null) || print === null)) {
                super.writeAttributes(writer, print);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePrint(writer: XMLWriter, print: HomePrint) {
            const printedLevels: Array<Level> = print.getPrintedLevels();
            if (printedLevels != null) {
                for (let index = 0; index < printedLevels.length; index++) {
                    let level = printedLevels[index];
                    {
                        writer.writeStartElement("printedLevel");
                        writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(level));
                        writer.writeEndElement();
                    }
                }
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomePrint} print
         */
        public writeChildren(writer?: any, print?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((print != null && print instanceof <any>HomePrint) || print === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomePrint(writer, print);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((print != null) || print === null)) {
                super.writeChildren(writer, print);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$3 extends ObjectXMLExporter<Compass> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Compass(writer: XMLWriter, compass: Compass) {
            writer.writeFloatAttribute$java_lang_String$float("x", compass.getX());
            writer.writeFloatAttribute$java_lang_String$float("y", compass.getY());
            writer.writeFloatAttribute$java_lang_String$float("diameter", compass.getDiameter());
            writer.writeFloatAttribute$java_lang_String$float("northDirection", compass.getNorthDirection());
            writer.writeFloatAttribute$java_lang_String$float("longitude", compass.getLongitude());
            writer.writeFloatAttribute$java_lang_String$float("latitude", compass.getLatitude());
            writer.writeAttribute$java_lang_String$java_lang_String("timeZone", compass.getTimeZone());
            writer.writeBooleanAttribute("visible", compass.isVisible(), true);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Compass} compass
         */
        public writeAttributes(writer?: any, compass?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((compass != null && compass instanceof <any>Compass) || compass === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Compass(writer, compass);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((compass != null) || compass === null)) {
                super.writeAttributes(writer, compass);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Compass(writer: XMLWriter, compass: Compass) {
            this.__parent.writeProperties(writer, compass);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Compass} compass
         */
        public writeChildren(writer?: any, compass?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((compass != null && compass instanceof <any>Compass) || compass === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Compass(writer, compass);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((compass != null) || compass === null)) {
                super.writeChildren(writer, compass);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$4 extends ObjectXMLExporter<Camera> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Camera(writer: XMLWriter, camera: Camera) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("attribute", this.attributeName, null);
            if (!("observerCamera" === this.attributeName) && !("topCamera" === this.attributeName)) {
                writer.writeAttribute$java_lang_String$java_lang_String("id", camera.getId());
            }
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("name", camera.getName(), null);
            writer.writeAttribute$java_lang_String$java_lang_String("lens", /* Enum.name */Camera.Lens[camera.getLens()]);
            writer.writeFloatAttribute$java_lang_String$float("x", camera.getX());
            writer.writeFloatAttribute$java_lang_String$float("y", camera.getY());
            writer.writeFloatAttribute$java_lang_String$float("z", camera.getZ());
            writer.writeFloatAttribute$java_lang_String$float("yaw", camera.getYaw());
            writer.writeFloatAttribute$java_lang_String$float("pitch", camera.getPitch());
            writer.writeFloatAttribute$java_lang_String$float("fieldOfView", camera.getFieldOfView());
            writer.writeLongAttribute$java_lang_String$long("time", camera.getTime());
            if (camera != null && camera instanceof <any>ObserverCamera) {
                writer.writeBooleanAttribute("fixedSize", (<ObserverCamera>camera).isFixedSize(), false);
            }
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("renderer", camera.getRenderer(), null);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Camera} camera
         */
        public writeAttributes(writer?: any, camera?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((camera != null && camera instanceof <any>Camera) || camera === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Camera(writer, camera);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((camera != null) || camera === null)) {
                super.writeAttributes(writer, camera);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Camera(writer: XMLWriter, camera: Camera) {
            this.__parent.writeProperties(writer, camera);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Camera} camera
         */
        public writeChildren(writer?: any, camera?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((camera != null && camera instanceof <any>Camera) || camera === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Camera(writer, camera);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((camera != null) || camera === null)) {
                super.writeChildren(writer, camera);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any, private attributeName: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$5 extends ObjectXMLExporter<Level> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Level(writer: XMLWriter, level: Level) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", level.getId());
            writer.writeAttribute$java_lang_String$java_lang_String("name", level.getName());
            writer.writeFloatAttribute$java_lang_String$float("elevation", level.getElevation());
            writer.writeFloatAttribute$java_lang_String$float("floorThickness", level.getFloorThickness());
            writer.writeFloatAttribute$java_lang_String$float("height", level.getHeight());
            writer.writeIntegerAttribute$java_lang_String$int("elevationIndex", level.getElevationIndex());
            writer.writeBooleanAttribute("visible", level.isVisible(), true);
            writer.writeBooleanAttribute("viewable", level.isViewable(), true);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Level} level
         */
        public writeAttributes(writer?: any, level?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((level != null && level instanceof <any>Level) || level === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Level(writer, level);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((level != null) || level === null)) {
                super.writeAttributes(writer, level);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Level(writer: XMLWriter, level: Level) {
            this.__parent.writeProperties(writer, level);
            this.__parent.writeBackgroundImage(writer, level.getBackgroundImage());
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Level} level
         */
        public writeChildren(writer?: any, level?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((level != null && level instanceof <any>Level) || level === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Level(writer, level);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((level != null) || level === null)) {
                super.writeChildren(writer, level);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$6 extends ObjectXMLExporter<HomeMaterial> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeMaterial(writer: XMLWriter, material: HomeMaterial) {
            writer.writeAttribute$java_lang_String$java_lang_String("name", material.getName());
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("key", material.getKey(), null);
            writer.writeColorAttribute("color", material.getColor());
            if (material.getShininess() != null) {
                writer.writeFloatAttribute$java_lang_String$java_lang_Float("shininess", material.getShininess());
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomeMaterial} material
         */
        public writeAttributes(writer?: any, material?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((material != null && material instanceof <any>HomeMaterial) || material === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeMaterial(writer, material);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((material != null) || material === null)) {
                super.writeAttributes(writer, material);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeMaterial(writer: XMLWriter, material: HomeMaterial) {
            this.__parent.writeTexture(writer, material.getTexture(), null);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomeMaterial} material
         */
        public writeChildren(writer?: any, material?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((material != null && material instanceof <any>HomeMaterial) || material === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeMaterial(writer, material);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((material != null) || material === null)) {
                super.writeChildren(writer, material);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$7 extends ObjectXMLExporter<Wall> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Wall(writer: XMLWriter, wall: Wall) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", wall.getId());
            if (wall.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(wall.getLevel()));
            }
            if (wall.getWallAtStart() != null) {
                const id: string = this.__parent.getId(wall.getWallAtStart());
                if (id != null) {
                    writer.writeAttribute$java_lang_String$java_lang_String("wallAtStart", id);
                }
            }
            if (wall.getWallAtEnd() != null) {
                const id: string = this.__parent.getId(wall.getWallAtEnd());
                if (id != null) {
                    writer.writeAttribute$java_lang_String$java_lang_String("wallAtEnd", id);
                }
            }
            writer.writeFloatAttribute$java_lang_String$float("xStart", wall.getXStart());
            writer.writeFloatAttribute$java_lang_String$float("yStart", wall.getYStart());
            writer.writeFloatAttribute$java_lang_String$float("xEnd", wall.getXEnd());
            writer.writeFloatAttribute$java_lang_String$float("yEnd", wall.getYEnd());
            writer.writeFloatAttribute$java_lang_String$java_lang_Float("height", wall.getHeight());
            writer.writeFloatAttribute$java_lang_String$java_lang_Float("heightAtEnd", wall.getHeightAtEnd());
            writer.writeFloatAttribute$java_lang_String$float("thickness", wall.getThickness());
            writer.writeFloatAttribute$java_lang_String$java_lang_Float("arcExtent", wall.getArcExtent());
            if (wall.getPattern() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("pattern", wall.getPattern().getName());
            }
            writer.writeColorAttribute("topColor", wall.getTopColor());
            writer.writeColorAttribute("leftSideColor", wall.getLeftSideColor());
            writer.writeFloatAttribute$java_lang_String$float$float("leftSideShininess", wall.getLeftSideShininess(), 0);
            writer.writeColorAttribute("rightSideColor", wall.getRightSideColor());
            writer.writeFloatAttribute$java_lang_String$float$float("rightSideShininess", wall.getRightSideShininess(), 0);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Wall} wall
         */
        public writeAttributes(writer?: any, wall?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((wall != null && wall instanceof <any>Wall) || wall === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Wall(writer, wall);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((wall != null) || wall === null)) {
                super.writeAttributes(writer, wall);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Wall(writer: XMLWriter, wall: Wall) {
            this.__parent.writeProperties(writer, wall);
            this.__parent.writeTexture(writer, wall.getLeftSideTexture(), "leftSideTexture");
            this.__parent.writeTexture(writer, wall.getRightSideTexture(), "rightSideTexture");
            this.__parent.writeBaseboard(writer, wall.getLeftSideBaseboard(), "leftSideBaseboard");
            this.__parent.writeBaseboard(writer, wall.getRightSideBaseboard(), "rightSideBaseboard");
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Wall} wall
         */
        public writeChildren(writer?: any, wall?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((wall != null && wall instanceof <any>Wall) || wall === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Wall(writer, wall);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((wall != null) || wall === null)) {
                super.writeChildren(writer, wall);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$8 extends ObjectXMLExporter<Room> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Room(writer: XMLWriter, room: Room) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", room.getId());
            if (room.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(room.getLevel()));
            }
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("name", room.getName(), null);
            writer.writeFloatAttribute$java_lang_String$float$float("nameAngle", room.getNameAngle(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("nameXOffset", room.getNameXOffset(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("nameYOffset", room.getNameYOffset(), -40.0);
            writer.writeBooleanAttribute("areaVisible", room.isAreaVisible(), false);
            writer.writeFloatAttribute$java_lang_String$float$float("areaAngle", room.getAreaAngle(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("areaXOffset", room.getAreaXOffset(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("areaYOffset", room.getAreaYOffset(), 0.0);
            writer.writeBooleanAttribute("floorVisible", room.isFloorVisible(), true);
            writer.writeColorAttribute("floorColor", room.getFloorColor());
            writer.writeFloatAttribute$java_lang_String$float$float("floorShininess", room.getFloorShininess(), 0);
            writer.writeBooleanAttribute("ceilingVisible", room.isCeilingVisible(), true);
            writer.writeColorAttribute("ceilingColor", room.getCeilingColor());
            writer.writeFloatAttribute$java_lang_String$float$float("ceilingShininess", room.getCeilingShininess(), 0);
            writer.writeBooleanAttribute("ceilingFlat", room.isCeilingFlat(), false);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Room} room
         */
        public writeAttributes(writer?: any, room?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((room != null && room instanceof <any>Room) || room === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Room(writer, room);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((room != null) || room === null)) {
                super.writeAttributes(writer, room);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Room(writer: XMLWriter, room: Room) {
            this.__parent.writeProperties(writer, room);
            this.__parent.writeTextStyle(writer, room.getNameStyle(), "nameStyle");
            this.__parent.writeTextStyle(writer, room.getAreaStyle(), "areaStyle");
            this.__parent.writeTexture(writer, room.getFloorTexture(), "floorTexture");
            this.__parent.writeTexture(writer, room.getCeilingTexture(), "ceilingTexture");
            {
                let array = room.getPoints();
                for (let index = 0; index < array.length; index++) {
                    let point = array[index];
                    {
                        writer.writeStartElement("point");
                        writer.writeFloatAttribute$java_lang_String$float("x", point[0]);
                        writer.writeFloatAttribute$java_lang_String$float("y", point[1]);
                        writer.writeEndElement();
                    }
                }
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Room} room
         */
        public writeChildren(writer?: any, room?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((room != null && room instanceof <any>Room) || room === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Room(writer, room);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((room != null) || room === null)) {
                super.writeChildren(writer, room);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$9 extends ObjectXMLExporter<Polyline> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Polyline(writer: XMLWriter, polyline: Polyline) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", polyline.getId());
            if (polyline.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(polyline.getLevel()));
            }
            writer.writeFloatAttribute$java_lang_String$float$float("thickness", polyline.getThickness(), 1.0);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("capStyle", /* Enum.name */Polyline.CapStyle[polyline.getCapStyle()], /* Enum.name */Polyline.CapStyle[Polyline.CapStyle.BUTT]);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("joinStyle", /* Enum.name */Polyline.JoinStyle[polyline.getJoinStyle()], /* Enum.name */Polyline.JoinStyle[Polyline.JoinStyle.MITER]);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("dashStyle", /* Enum.name */Polyline.DashStyle[polyline.getDashStyle()], /* Enum.name */Polyline.DashStyle[Polyline.DashStyle.SOLID]);
            if (polyline.getDashStyle() === Polyline.DashStyle.CUSTOMIZED) {
                const dashPattern: { str: string, toString: Function } = { str: "", toString: function () { return this.str; } };
                {
                    let array = polyline.getDashPattern();
                    for (let index = 0; index < array.length; index++) {
                        let dashPart = array[index];
                        {
                            /* append */(sb => { sb.str += <any>HomeXMLExporter.floatToString(dashPart); return sb; })(dashPattern);
                            /* append */(sb => { sb.str += <any>" "; return sb; })(dashPattern);
                        }
                    }
                }
                /* setLength */((sb, length) => sb.str = sb.str.substring(0, length))(dashPattern, /* length */dashPattern.str.length - 1);
                writer.writeAttribute$java_lang_String$java_lang_String("dashPattern", /* toString */dashPattern.str);
            }
            writer.writeFloatAttribute$java_lang_String$float$float("dashOffset", polyline.getDashOffset(), 0.0);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("startArrowStyle", /* Enum.name */Polyline.ArrowStyle[polyline.getStartArrowStyle()], /* Enum.name */Polyline.ArrowStyle[Polyline.ArrowStyle.NONE]);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("endArrowStyle", /* Enum.name */Polyline.ArrowStyle[polyline.getEndArrowStyle()], /* Enum.name */Polyline.ArrowStyle[Polyline.ArrowStyle.NONE]);
            if (polyline.isVisibleIn3D()) {
                writer.writeFloatAttribute$java_lang_String$float("elevation", polyline.getElevation());
            }
            writer.writeColorAttribute("color", polyline.getColor());
            writer.writeBooleanAttribute("closedPath", polyline.isClosedPath(), false);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Polyline} polyline
         */
        public writeAttributes(writer?: any, polyline?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((polyline != null && polyline instanceof <any>Polyline) || polyline === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Polyline(writer, polyline);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((polyline != null) || polyline === null)) {
                super.writeAttributes(writer, polyline);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Polyline(writer: XMLWriter, polyline: Polyline) {
            this.__parent.writeProperties(writer, polyline);
            {
                let array = polyline.getPoints();
                for (let index = 0; index < array.length; index++) {
                    let point = array[index];
                    {
                        writer.writeStartElement("point");
                        writer.writeFloatAttribute$java_lang_String$float("x", point[0]);
                        writer.writeFloatAttribute$java_lang_String$float("y", point[1]);
                        writer.writeEndElement();
                    }
                }
            }
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Polyline} polyline
         */
        public writeChildren(writer?: any, polyline?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((polyline != null && polyline instanceof <any>Polyline) || polyline === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Polyline(writer, polyline);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((polyline != null) || polyline === null)) {
                super.writeChildren(writer, polyline);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$10 extends ObjectXMLExporter<DimensionLine> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_DimensionLine(writer: XMLWriter, dimensionLine: DimensionLine) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", dimensionLine.getId());
            if (dimensionLine.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(dimensionLine.getLevel()));
            }
            writer.writeFloatAttribute$java_lang_String$float("xStart", dimensionLine.getXStart());
            writer.writeFloatAttribute$java_lang_String$float("yStart", dimensionLine.getYStart());
            writer.writeFloatAttribute$java_lang_String$float$float("elevationStart", dimensionLine.getElevationStart(), 0);
            writer.writeFloatAttribute$java_lang_String$float("xEnd", dimensionLine.getXEnd());
            writer.writeFloatAttribute$java_lang_String$float("yEnd", dimensionLine.getYEnd());
            writer.writeFloatAttribute$java_lang_String$float$float("elevationEnd", dimensionLine.getElevationEnd(), 0);
            writer.writeFloatAttribute$java_lang_String$float("offset", dimensionLine.getOffset());
            writer.writeFloatAttribute$java_lang_String$float$float("endMarkSize", dimensionLine.getEndMarkSize(), 10);
            writer.writeFloatAttribute$java_lang_String$float$float("pitch", dimensionLine.getPitch(), 0);
            writer.writeColorAttribute("color", dimensionLine.getColor());
            writer.writeBooleanAttribute("visibleIn3D", dimensionLine.isVisibleIn3D(), false);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {DimensionLine} dimensionLine
         */
        public writeAttributes(writer?: any, dimensionLine?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((dimensionLine != null && dimensionLine instanceof <any>DimensionLine) || dimensionLine === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_DimensionLine(writer, dimensionLine);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((dimensionLine != null) || dimensionLine === null)) {
                super.writeAttributes(writer, dimensionLine);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_DimensionLine(writer: XMLWriter, dimensionLine: DimensionLine) {
            this.__parent.writeProperties(writer, dimensionLine);
            this.__parent.writeTextStyle(writer, dimensionLine.getLengthStyle(), "lengthStyle");
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {DimensionLine} dimensionLine
         */
        public writeChildren(writer?: any, dimensionLine?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((dimensionLine != null && dimensionLine instanceof <any>DimensionLine) || dimensionLine === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_DimensionLine(writer, dimensionLine);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((dimensionLine != null) || dimensionLine === null)) {
                super.writeChildren(writer, dimensionLine);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$11 extends ObjectXMLExporter<Label> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Label(writer: XMLWriter, label: Label) {
            writer.writeAttribute$java_lang_String$java_lang_String("id", label.getId());
            if (label.getLevel() != null) {
                writer.writeAttribute$java_lang_String$java_lang_String("level", this.__parent.getId(label.getLevel()));
            }
            writer.writeFloatAttribute$java_lang_String$float("x", label.getX());
            writer.writeFloatAttribute$java_lang_String$float("y", label.getY());
            writer.writeFloatAttribute$java_lang_String$float$float("angle", label.getAngle(), 0);
            writer.writeFloatAttribute$java_lang_String$float$float("elevation", label.getElevation(), 0);
            writer.writeFloatAttribute$java_lang_String$java_lang_Float("pitch", label.getPitch());
            writer.writeColorAttribute("color", label.getColor());
            writer.writeColorAttribute("outlineColor", label.getOutlineColor());
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Label} label
         */
        public writeAttributes(writer?: any, label?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((label != null && label instanceof <any>Label) || label === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Label(writer, label);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((label != null) || label === null)) {
                super.writeAttributes(writer, label);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Label(writer: XMLWriter, label: Label) {
            this.__parent.writeProperties(writer, label);
            this.__parent.writeTextStyle(writer, label.getStyle(), null);
            writer.writeStartElement("text");
            writer.writeText(label.getText());
            writer.writeEndElement();
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Label} label
         */
        public writeChildren(writer?: any, label?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((label != null && label instanceof <any>Label) || label === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Label(writer, label);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((label != null) || label === null)) {
                super.writeChildren(writer, label);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$12 extends ObjectXMLExporter<TextStyle> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_TextStyle(writer: XMLWriter, textStyle: TextStyle) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("attribute", this.attributeName, null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("fontName", textStyle.getFontName(), null);
            writer.writeFloatAttribute$java_lang_String$float("fontSize", textStyle.getFontSize());
            writer.writeBooleanAttribute("bold", textStyle.isBold(), false);
            writer.writeBooleanAttribute("italic", textStyle.isItalic(), false);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("alignment", /* Enum.name */TextStyle.Alignment[textStyle.getAlignment()], /* Enum.name */TextStyle.Alignment[TextStyle.Alignment.CENTER]);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {TextStyle} textStyle
         */
        public writeAttributes(writer?: any, textStyle?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((textStyle != null && textStyle instanceof <any>TextStyle) || textStyle === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_TextStyle(writer, textStyle);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((textStyle != null) || textStyle === null)) {
                super.writeAttributes(writer, textStyle);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any, private attributeName: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$13 extends ObjectXMLExporter<Baseboard> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Baseboard(writer: XMLWriter, baseboard: Baseboard) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("attribute", this.attributeName, null);
            writer.writeFloatAttribute$java_lang_String$float("thickness", baseboard.getThickness());
            writer.writeFloatAttribute$java_lang_String$float("height", baseboard.getHeight());
            writer.writeColorAttribute("color", baseboard.getColor());
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Baseboard} baseboard
         */
        public writeAttributes(writer?: any, baseboard?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((baseboard != null && baseboard instanceof <any>Baseboard) || baseboard === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Baseboard(writer, baseboard);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((baseboard != null) || baseboard === null)) {
                super.writeAttributes(writer, baseboard);
            } else throw new Error('invalid overload');
        }

        public writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Baseboard(writer: XMLWriter, baseboard: Baseboard) {
            this.__parent.writeTexture(writer, baseboard.getTexture(), null);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {Baseboard} baseboard
         */
        public writeChildren(writer?: any, baseboard?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((baseboard != null && baseboard instanceof <any>Baseboard) || baseboard === null)) {
                return <any>this.writeChildren$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_Baseboard(writer, baseboard);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((baseboard != null) || baseboard === null)) {
                super.writeChildren(writer, baseboard);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any, private attributeName: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeXMLExporter$14 extends ObjectXMLExporter<HomeTexture> {
        public __parent: any;
        public writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeTexture(writer: XMLWriter, texture: HomeTexture) {
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("attribute", this.attributeName, null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("name", texture.getName(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("creator", texture.getCreator(), null);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("catalogId", texture.getCatalogId(), null);
            writer.writeFloatAttribute$java_lang_String$float("width", texture.getWidth());
            writer.writeFloatAttribute$java_lang_String$float("height", texture.getHeight());
            writer.writeFloatAttribute$java_lang_String$float$float("xOffset", texture.getXOffset(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("yOffset", texture.getYOffset(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("angle", texture.getAngle(), 0.0);
            writer.writeFloatAttribute$java_lang_String$float$float("scale", texture.getScale(), 1.0);
            writer.writeBooleanAttribute("fittingArea", texture.isFittingArea(), false);
            writer.writeBooleanAttribute("leftToRightOriented", texture.isLeftToRightOriented(), true);
            writer.writeAttribute$java_lang_String$java_lang_String$java_lang_String("image", this.__parent.getExportedContentName(texture, texture.getImage()), null);
        }

        /**
         * 
         * @param {XMLWriter} writer
         * @param {HomeTexture} texture
         */
        public writeAttributes(writer?: any, texture?: any) {
            if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((texture != null && texture instanceof <any>HomeTexture) || texture === null)) {
                return <any>this.writeAttributes$com_eteks_sweethome3d_io_XMLWriter$com_eteks_sweethome3d_model_HomeTexture(writer, texture);
            } else if (((writer != null && writer instanceof <any>XMLWriter) || writer === null) && ((texture != null) || texture === null)) {
                super.writeAttributes(writer, texture);
            } else throw new Error('invalid overload');
        }

        constructor(__parent: any, private attributeName: any) {
            super();
            this.__parent = __parent;
        }
    }

}


/**
 * Creates a catalog shelf unit of the default catalog.
 * @param {string} id    the id of the shelf unit or <code>null</code>
 * @param {string} name  the name of the shelf unit
 * @param {string} description the description of the shelf unit
 * @param {string} information additional information associated to the shelf unit
 * @param {string} license license of the shelf unit
 * @param {java.lang.String[]} tags tags associated to the shelf unit
 * @param {number} creationDate creation date of the shelf unit in milliseconds since the epoch
 * @param {number} grade grade of the piece of furniture or <code>null</code>
 * @param {Object} icon content of the icon of the shelf unit
 * @param {Object} planIcon content of the icon of the shelf unit displayed in plan
 * @param {Object} model content of the 3D model of the shelf unit
 * @param {number} width  the width in centimeters of the shelf unit
 * @param {number} depth  the depth in centimeters of the shelf unit
 * @param {number} height  the height in centimeters of the shelf unit
 * @param {number} elevation  the elevation in centimeters of the shelf unit
 * @param {number} dropOnTopElevation  a percentage of the height at which should be placed
 * an object dropped on the shelf unit
 * @param {float[]} shelfElevations shelf elevation(s) at which other objects can be placed on the shelf unit
 * @param {com.eteks.sweethome3d.model.BoxBounds[]} shelfBoxes coordinates of the shelf box(es) in which other objects can be placed in the shelf unit
 * @param {boolean} movable if <code>true</code>, the shelf unit is movable
 * @param {string} staircaseCutOutShape the shape used to cut out upper levels when they intersect
 * with the piece like a staircase
 * @param {float[][]} modelRotation the rotation 3 by 3 matrix applied to the piece model
 * @param {number} modelFlags flags which should be applied to piece model
 * @param {number} modelSize size of the 3D model of the shelf unit
 * @param {string} creator the creator of the model
 * @param {boolean} resizable if <code>true</code>, the size of the shelf unit may be edited
 * @param {boolean} deformable if <code>true</code>, the width, depth and height of the shelf unit may
 * change independently from each other
 * @param {boolean} texturable if <code>false</code> this piece should always keep the same color or texture
 * @param {boolean} horizontallyRotatable if <code>false</code> this piece
 * should not rotate around an horizontal axis
 * @param {Big} price the price of the shelf unit or <code>null</code>
 * @param {Big} valueAddedTaxPercentage the Value Added Tax percentage applied to the
 * price of the shelf unit or <code>null</code>
 * @param {string} currency the price currency, noted with ISO 4217 code, or <code>null</code>
 * @param {Object} properties additional properties associating a key to a value or <code>null</code>
 * @param {Object} contents   additional contents associating a key to a value or <code>null</code>
 * @class
 * @extends CatalogPieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class CatalogShelfUnit extends CatalogPieceOfFurniture implements ShelfUnit {
    static EMPTY_SHELF_ELEVATIONS: number[]; public static EMPTY_SHELF_ELEVATIONS_$LI$(): number[] { if (CatalogShelfUnit.EMPTY_SHELF_ELEVATIONS == null) { CatalogShelfUnit.EMPTY_SHELF_ELEVATIONS = []; } return CatalogShelfUnit.EMPTY_SHELF_ELEVATIONS; }

    static EMPTY_SHELF_BOXES: BoxBounds[]; public static EMPTY_SHELF_BOXES_$LI$(): BoxBounds[] { if (CatalogShelfUnit.EMPTY_SHELF_BOXES == null) { CatalogShelfUnit.EMPTY_SHELF_BOXES = []; } return CatalogShelfUnit.EMPTY_SHELF_BOXES; }

    /*private*/ shelfElevations: number[];

    /*private*/ shelfBoxes: BoxBounds[];

    public constructor(id: string, name: string, description: string, information: string, license: string, tags: string[], creationDate: number, grade: number, icon: Content, planIcon: Content, model: Content, width: number, depth: number, height: number, elevation: number, dropOnTopElevation: number, shelfElevations: number[], shelfBoxes: BoxBounds[], movable: boolean, staircaseCutOutShape: string, modelRotation: number[][], modelFlags: number, modelSize: number, creator: string, resizable: boolean, deformable: boolean, texturable: boolean, horizontallyRotatable: boolean, price: Big, valueAddedTaxPercentage: Big, currency: string, properties: any, contents: any) {
        super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, properties, contents);
        if (this.shelfElevations === undefined) { this.shelfElevations = null; }
        if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
        this.shelfElevations = shelfElevations != null && shelfElevations.length > 0 ? /* clone */shelfElevations.slice(0) : CatalogShelfUnit.EMPTY_SHELF_ELEVATIONS_$LI$();
        this.shelfBoxes = shelfBoxes != null && shelfBoxes.length > 0 ? /* clone */shelfBoxes.slice(0) : CatalogShelfUnit.EMPTY_SHELF_BOXES_$LI$();
    }

    /**
     * Returns the elevation(s) at which other objects can be placed on this shelf unit.
     * @return {float[]}
     */
    public getShelfElevations(): number[] {
        return this.shelfElevations != null ? /* clone */this.shelfElevations.slice(0) : null;
    }

    /**
     * Returns the coordinates of the shelf box(es) in which other objects can be placed in this shelf unit.
     * @return {com.eteks.sweethome3d.model.BoxBounds[]}
     */
    public getShelfBoxes(): BoxBounds[] {
        return /* clone */this.shelfBoxes.slice(0);
    }
}
CatalogShelfUnit["__class"] = "com.eteks.sweethome3d.model.CatalogShelfUnit";
CatalogShelfUnit["__interfaces"] = ["com.eteks.sweethome3d.model.CatalogItem", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.ShelfUnit"];



/**
 * Creates a catalog light of the default catalog.
 * @param {string} id    the id of the new light, or <code>null</code>
 * @param {string} name  the name of the new light
 * @param {string} description the description of the new light
 * @param {string} information additional information associated to the new light
 * @param {string} license license of the new light
 * @param {java.lang.String[]} tags tags associated to the new light
 * @param {number} creationDate creation date of the new light in milliseconds since the epoch
 * @param {number} grade grade of the new light or <code>null</code>
 * @param {Object} icon content of the icon of the new light
 * @param {Object} planIcon content of the icon of the new piece displayed in plan
 * @param {Object} model content of the 3D model of the new light
 * @param {number} width  the width in centimeters of the new light
 * @param {number} depth  the depth in centimeters of the new light
 * @param {number} height  the height in centimeters of the new light
 * @param {number} dropOnTopElevation a percentage of the height at which should be placed
 * an object dropped on the new piece
 * @param {number} elevation  the elevation in centimeters of the new light
 * @param {boolean} movable if <code>true</code>, the new light is movable
 * @param {com.eteks.sweethome3d.model.LightSource[]} lightSources the light sources of the new light
 * @param {java.lang.String[]} lightSourceMaterialNames the material names of the light source in the 3D model of the new light
 * @param {string} staircaseCutOutShape the shape used to cut out upper levels when they intersect
 * with the piece like a staircase
 * @param {float[][]} modelRotation the rotation 3 by 3 matrix applied to the light model
 * @param {number} modelFlags flags which should be applied to piece model
 * @param {number} modelSize size of the 3D model of the new light
 * @param {string} creator the creator of the model
 * @param {boolean} resizable if <code>true</code>, the size of the new light may be edited
 * @param {boolean} deformable if <code>true</code>, the width, depth and height of the new piece may
 * change independently from each other
 * @param {boolean} texturable if <code>false</code> this piece should always keep the same color or texture
 * @param {boolean} horizontallyRotatable if <code>false</code> this piece
 * should not rotate around an horizontal axis
 * @param {Big} price the price of the new light, or <code>null</code>
 * @param {Big} valueAddedTaxPercentage the Value Added Tax percentage applied to the
 * price of the new light or <code>null</code>
 * @param {string} currency the price currency, noted with ISO 4217 code, or <code>null</code>
 * @param {Object} properties additional properties associating a key to a value or <code>null</code>
 * @param {Object} contents   additional contents associating a key to a value or <code>null</code>
 * @class
 * @extends CatalogPieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class CatalogLight extends CatalogPieceOfFurniture implements Light {
    static EMPTY_LIGHT_SOURCES: LightSource[]; public static EMPTY_LIGHT_SOURCES_$LI$(): LightSource[] { if (CatalogLight.EMPTY_LIGHT_SOURCES == null) { CatalogLight.EMPTY_LIGHT_SOURCES = []; } return CatalogLight.EMPTY_LIGHT_SOURCES; }

    static EMPTY_LIGHT_SOURCE_MATERIAL_NAMES: string[]; public static EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$(): string[] { if (CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES == null) { CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES = []; } return CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES; }

    /*private*/ lightSources: LightSource[];

    /*private*/ lightSourceMaterialNames: string[];

    public constructor(id?: any, name?: any, description?: any, information?: any, license?: any, tags?: any, creationDate?: any, grade?: any, icon?: any, planIcon?: any, model?: any, width?: any, depth?: any, height?: any, elevation?: any, dropOnTopElevation?: any, movable?: any, lightSources?: any, lightSourceMaterialNames?: any, staircaseCutOutShape?: any, modelRotation?: any, modelFlags?: any, modelSize?: any, creator?: any, resizable?: any, deformable?: any, texturable?: any, horizontallyRotatable?: any, price?: any, valueAddedTaxPercentage?: any, currency?: any, properties?: any, contents?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((typeof license === 'string') || license === null) && ((tags != null && tags instanceof <any>Array && (tags.length == 0 || tags[0] == null || (typeof tags[0] === 'string'))) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((model != null && (model.constructor != null && model.constructor["__interfaces"] != null && model.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'number') || dropOnTopElevation === null) && ((typeof movable === 'boolean') || movable === null) && ((lightSources != null && lightSources instanceof <any>Array && (lightSources.length == 0 || lightSources[0] == null || (lightSources[0] != null && lightSources[0] instanceof <any>LightSource))) || lightSources === null) && ((lightSourceMaterialNames != null && lightSourceMaterialNames instanceof <any>Array && (lightSourceMaterialNames.length == 0 || lightSourceMaterialNames[0] == null || (typeof lightSourceMaterialNames[0] === 'string'))) || lightSourceMaterialNames === null) && ((typeof staircaseCutOutShape === 'string') || staircaseCutOutShape === null) && ((modelRotation != null && modelRotation instanceof <any>Array && (modelRotation.length == 0 || modelRotation[0] == null || modelRotation[0] instanceof Array)) || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'number') || modelSize === null) && ((typeof creator === 'string') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((typeof texturable === 'boolean') || texturable === null) && ((typeof horizontallyRotatable === 'boolean') || horizontallyRotatable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((valueAddedTaxPercentage != null && valueAddedTaxPercentage instanceof <any>Big) || valueAddedTaxPercentage === null) && ((typeof currency === 'string') || currency === null) && ((properties != null && (properties instanceof Object)) || properties === null) && ((contents != null && (contents instanceof Object)) || contents === null)) {
            let __args = arguments;
            super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, properties, contents);
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            this.lightSources = lightSources != null && lightSources.length > 0 ? /* clone */lightSources.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCES_$LI$();
            this.lightSourceMaterialNames = lightSourceMaterialNames != null && lightSourceMaterialNames.length > 0 ? /* clone */lightSourceMaterialNames.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$();
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((movable != null && movable instanceof <any>Array && (movable.length == 0 || movable[0] == null || (movable[0] != null && movable[0] instanceof <any>LightSource))) || movable === null) && ((lightSources != null && lightSources instanceof <any>Array && (lightSources.length == 0 || lightSources[0] == null || (typeof lightSources[0] === 'string'))) || lightSources === null) && ((typeof lightSourceMaterialNames === 'string') || lightSourceMaterialNames === null) && ((staircaseCutOutShape != null && staircaseCutOutShape instanceof <any>Array && (staircaseCutOutShape.length == 0 || staircaseCutOutShape[0] == null || staircaseCutOutShape[0] instanceof Array)) || staircaseCutOutShape === null) && ((typeof modelRotation === 'number') || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'string') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((typeof texturable === 'boolean') || texturable === null) && ((horizontallyRotatable != null && horizontallyRotatable instanceof <any>Big) || horizontallyRotatable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((typeof valueAddedTaxPercentage === 'string') || valueAddedTaxPercentage === null) && ((currency != null && (currency instanceof Object)) || currency === null) && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let lightSources: any = __args[16];
            let lightSourceMaterialNames: any = __args[17];
            let staircaseCutOutShape: any = __args[18];
            let modelRotation: any = __args[19];
            let modelFlags: any = __args[20];
            let modelSize: any = __args[21];
            let creator: any = __args[22];
            let resizable: any = __args[23];
            let deformable: any = __args[24];
            let texturable: any = __args[25];
            let horizontallyRotatable: any = __args[26];
            let price: any = __args[27];
            let valueAddedTaxPercentage: any = __args[28];
            let currency: any = __args[29];
            let properties: any = __args[30];
            {
                let __args = arguments;
                let license: any = null;
                let contents: any = null;
                super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, properties, contents);
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                this.lightSources = lightSources != null && lightSources.length > 0 ? /* clone */lightSources.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCES_$LI$();
                this.lightSourceMaterialNames = lightSourceMaterialNames != null && lightSourceMaterialNames.length > 0 ? /* clone */lightSourceMaterialNames.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$();
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((movable != null && movable instanceof <any>Array && (movable.length == 0 || movable[0] == null || (movable[0] != null && movable[0] instanceof <any>LightSource))) || movable === null) && ((typeof lightSources === 'string') || lightSources === null) && ((lightSourceMaterialNames != null && lightSourceMaterialNames instanceof <any>Array && (lightSourceMaterialNames.length == 0 || lightSourceMaterialNames[0] == null || lightSourceMaterialNames[0] instanceof Array)) || lightSourceMaterialNames === null) && ((typeof staircaseCutOutShape === 'boolean') || staircaseCutOutShape === null) && ((typeof modelRotation === 'number') || modelRotation === null) && ((typeof modelFlags === 'string') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((horizontallyRotatable != null && horizontallyRotatable instanceof <any>Big) || horizontallyRotatable === null) && ((typeof price === 'string') || price === null) && ((valueAddedTaxPercentage != null && (valueAddedTaxPercentage instanceof Object)) || valueAddedTaxPercentage === null) && currency === undefined && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let lightSources: any = __args[16];
            let staircaseCutOutShape: any = __args[17];
            let modelRotation: any = __args[18];
            let backFaceShown: any = __args[19];
            let modelSize: any = __args[20];
            let creator: any = __args[21];
            let resizable: any = __args[22];
            let deformable: any = __args[23];
            let texturable: any = __args[24];
            let horizontallyRotatable: any = __args[25];
            let price: any = __args[26];
            let valueAddedTaxPercentage: any = __args[27];
            let currency: any = __args[28];
            let properties: any = __args[29];
            {
                let __args = arguments;
                let lightSourceMaterialNames: any = null;
                let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                {
                    let __args = arguments;
                    let license: any = null;
                    let contents: any = null;
                    super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, properties, contents);
                    if (this.lightSources === undefined) { this.lightSources = null; }
                    if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                    this.lightSources = lightSources != null && lightSources.length > 0 ? /* clone */lightSources.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCES_$LI$();
                    this.lightSourceMaterialNames = lightSourceMaterialNames != null && lightSourceMaterialNames.length > 0 ? /* clone */lightSourceMaterialNames.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$();
                }
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((movable != null && movable instanceof <any>Array && (movable.length == 0 || movable[0] == null || (movable[0] != null && movable[0] instanceof <any>LightSource))) || movable === null) && ((typeof lightSources === 'string') || lightSources === null) && ((lightSourceMaterialNames != null && lightSourceMaterialNames instanceof <any>Array && (lightSourceMaterialNames.length == 0 || lightSourceMaterialNames[0] == null || lightSourceMaterialNames[0] instanceof Array)) || lightSourceMaterialNames === null) && ((typeof staircaseCutOutShape === 'boolean') || staircaseCutOutShape === null) && ((typeof modelRotation === 'number') || modelRotation === null) && ((typeof modelFlags === 'string') || modelFlags === null) && ((typeof modelSize === 'boolean') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((horizontallyRotatable != null && horizontallyRotatable instanceof <any>Big) || horizontallyRotatable === null) && ((typeof price === 'string') || price === null) && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let lightSources: any = __args[16];
            let staircaseCutOutShape: any = __args[17];
            let modelRotation: any = __args[18];
            let backFaceShown: any = __args[19];
            let modelSize: any = __args[20];
            let creator: any = __args[21];
            let resizable: any = __args[22];
            let deformable: any = __args[23];
            let texturable: any = __args[24];
            let horizontallyRotatable: any = __args[25];
            let price: any = __args[26];
            let valueAddedTaxPercentage: any = __args[27];
            let currency: any = __args[28];
            {
                let __args = arguments;
                let properties: any = null;
                {
                    let __args = arguments;
                    let lightSourceMaterialNames: any = null;
                    let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                    {
                        let __args = arguments;
                        let license: any = null;
                        let contents: any = null;
                        super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, staircaseCutOutShape, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, horizontallyRotatable, price, valueAddedTaxPercentage, currency, properties, contents);
                        if (this.lightSources === undefined) { this.lightSources = null; }
                        if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                        this.lightSources = lightSources != null && lightSources.length > 0 ? /* clone */lightSources.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCES_$LI$();
                        this.lightSourceMaterialNames = lightSourceMaterialNames != null && lightSourceMaterialNames.length > 0 ? /* clone */lightSourceMaterialNames.slice(0) : CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$();
                    }
                    if (this.lightSources === undefined) { this.lightSources = null; }
                    if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                }
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the sources managed by this light. Each light source point
     * is a percentage of the width, the depth and the height of this light,
     * with the abscissa origin at the left side of the piece,
     * the ordinate origin at the front side of the piece
     * and the elevation origin at the bottom side of the piece.
     * @return {com.eteks.sweethome3d.model.LightSource[]} a copy of light sources array.
     */
    public getLightSources(): LightSource[] {
        if (this.lightSources.length === 0) {
            return this.lightSources;
        } else {
            return /* clone */this.lightSources.slice(0);
        }
    }

    /**
     * Returns the material names of the light sources in the 3D model managed by this light.
     * @return {java.lang.String[]} a copy of light source material names array.
     */
    public getLightSourceMaterialNames(): string[] {
        if (this.lightSourceMaterialNames.length === 0) {
            return this.lightSourceMaterialNames;
        } else {
            return /* clone */this.lightSourceMaterialNames.slice(0);
        }
    }
}
CatalogLight["__class"] = "com.eteks.sweethome3d.model.CatalogLight";
CatalogLight["__interfaces"] = ["com.eteks.sweethome3d.model.CatalogItem", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.Light"];



/**
 * Creates a catalog door or window of the default catalog.
 * @param {string} id    the id of the new door or window, or <code>null</code>
 * @param {string} name  the name of the new door or window
 * @param {string} description the description of the new door or window
 * @param {string} information additional information associated to the new door or window
 * @param {string} license license of the new door or window
 * @param {java.lang.String[]} tags tags associated to the new door or window
 * @param {number} creationDate creation date of the new door or window in milliseconds since the epoch
 * @param {number} grade grade of the new door or window or <code>null</code>
 * @param {Object} icon content of the icon of the new door or window
 * @param {Object} planIcon content of the icon of the new piece displayed in plan
 * @param {Object} model content of the 3D model of the new door or window
 * @param {number} width  the width in centimeters of the new door or window
 * @param {number} depth  the depth in centimeters of the new door or window
 * @param {number} height  the height in centimeters of the new door or window
 * @param {number} elevation  the elevation in centimeters of the new door or window
 * @param {number} dropOnTopElevation a percentage of the height at which should be placed
 * an object dropped on the new piece
 * @param {boolean} movable if <code>true</code>, the new door or window is movable
 * @param {string} cutOutShape the shape used to cut out walls that intersect the new door or window
 * @param {number} wallThickness a value in percentage of the depth of the new door or window
 * @param {number} wallDistance a distance in percentage of the depth of the new door or window
 * @param {boolean} wallCutOutOnBothSides  if <code>true</code> the new door or window should cut out
 * the both sides of the walls it intersects
 * @param {boolean} widthDepthDeformable if <code>false</code>, the width and depth of the new door or window may
 * not be changed independently from each other
 * @param {com.eteks.sweethome3d.model.Sash[]} sashes the sashes attached to the new door or window
 * @param {float[][]} modelRotation the rotation 3 by 3 matrix applied to the door or window model
 * @param {number} modelFlags flags which should be applied to piece model
 * @param {number} modelSize size of the 3D model of the new light
 * @param {string} creator the creator of the model
 * @param {boolean} resizable if <code>true</code>, the size of the new door or window may be edited
 * @param {boolean} deformable if <code>true</code>, the width, depth and height of the new piece may
 * change independently from each other
 * @param {boolean} texturable if <code>false</code> this piece should always keep the same color or texture.
 * @param {Big} price the price of the new door or window, or <code>null</code>
 * @param {Big} valueAddedTaxPercentage the Value Added Tax percentage applied to the
 * price of the new door or window or <code>null</code>
 * @param {string} currency the price currency, noted with ISO 4217 code, or <code>null</code>
 * @param {Object} properties additional properties associating a key to a value or <code>null</code>
 * @param {Object} contents   additional contents associating a key to a value or <code>null</code>
 * @class
 * @extends CatalogPieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class CatalogDoorOrWindow extends CatalogPieceOfFurniture implements DoorOrWindow {
    /*private*/ wallThickness: number;

    /*private*/ wallDistance: number;

    /*private*/ wallCutOutOnBothSides: boolean;

    /*private*/ widthDepthDeformable: boolean;

    /*private*/ sashes: Sash[];

    /*private*/ cutOutShape: string;

    public constructor(id?: any, name?: any, description?: any, information?: any, license?: any, tags?: any, creationDate?: any, grade?: any, icon?: any, planIcon?: any, model?: any, width?: any, depth?: any, height?: any, elevation?: any, dropOnTopElevation?: any, movable?: any, cutOutShape?: any, wallThickness?: any, wallDistance?: any, wallCutOutOnBothSides?: any, widthDepthDeformable?: any, sashes?: any, modelRotation?: any, modelFlags?: any, modelSize?: any, creator?: any, resizable?: any, deformable?: any, texturable?: any, price?: any, valueAddedTaxPercentage?: any, currency?: any, properties?: any, contents?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((typeof license === 'string') || license === null) && ((tags != null && tags instanceof <any>Array && (tags.length == 0 || tags[0] == null || (typeof tags[0] === 'string'))) || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((model != null && (model.constructor != null && model.constructor["__interfaces"] != null && model.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'number') || dropOnTopElevation === null) && ((typeof movable === 'boolean') || movable === null) && ((typeof cutOutShape === 'string') || cutOutShape === null) && ((typeof wallThickness === 'number') || wallThickness === null) && ((typeof wallDistance === 'number') || wallDistance === null) && ((typeof wallCutOutOnBothSides === 'boolean') || wallCutOutOnBothSides === null) && ((typeof widthDepthDeformable === 'boolean') || widthDepthDeformable === null) && ((sashes != null && sashes instanceof <any>Array && (sashes.length == 0 || sashes[0] == null || (sashes[0] != null && sashes[0] instanceof <any>Sash))) || sashes === null) && ((modelRotation != null && modelRotation instanceof <any>Array && (modelRotation.length == 0 || modelRotation[0] == null || modelRotation[0] instanceof Array)) || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'number') || modelSize === null) && ((typeof creator === 'string') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((typeof texturable === 'boolean') || texturable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((valueAddedTaxPercentage != null && valueAddedTaxPercentage instanceof <any>Big) || valueAddedTaxPercentage === null) && ((typeof currency === 'string') || currency === null) && ((properties != null && (properties instanceof Object)) || properties === null) && ((contents != null && (contents instanceof Object)) || contents === null)) {
            let __args = arguments;
            super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, null, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, false, price, valueAddedTaxPercentage, currency, properties, contents);
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            this.cutOutShape = cutOutShape;
            this.wallThickness = wallThickness;
            this.wallDistance = wallDistance;
            this.wallCutOutOnBothSides = wallCutOutOnBothSides;
            this.widthDepthDeformable = widthDepthDeformable;
            this.sashes = sashes;
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((typeof cutOutShape === 'number') || cutOutShape === null) && ((typeof wallThickness === 'number') || wallThickness === null) && ((typeof wallDistance === 'boolean') || wallDistance === null) && ((typeof wallCutOutOnBothSides === 'boolean') || wallCutOutOnBothSides === null) && ((widthDepthDeformable != null && widthDepthDeformable instanceof <any>Array && (widthDepthDeformable.length == 0 || widthDepthDeformable[0] == null || (widthDepthDeformable[0] != null && widthDepthDeformable[0] instanceof <any>Sash))) || widthDepthDeformable === null) && ((sashes != null && sashes instanceof <any>Array && (sashes.length == 0 || sashes[0] == null || sashes[0] instanceof Array)) || sashes === null) && ((typeof modelRotation === 'boolean') || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'string') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((typeof valueAddedTaxPercentage === 'string') || valueAddedTaxPercentage === null) && ((currency != null && (currency instanceof Object)) || currency === null) && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let cutOutShape: any = __args[16];
            let wallThickness: any = __args[17];
            let wallDistance: any = __args[18];
            let wallCutOutOnBothSides: any = __args[19];
            let widthDepthDeformable: any = __args[20];
            let sashes: any = __args[21];
            let modelRotation: any = __args[22];
            let backFaceShown: any = __args[23];
            let modelSize: any = __args[24];
            let creator: any = __args[25];
            let resizable: any = __args[26];
            let deformable: any = __args[27];
            let texturable: any = __args[28];
            let price: any = __args[29];
            let valueAddedTaxPercentage: any = __args[30];
            let currency: any = __args[31];
            let properties: any = __args[32];
            {
                let __args = arguments;
                let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                {
                    let __args = arguments;
                    let license: any = null;
                    let contents: any = null;
                    super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, null, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, false, price, valueAddedTaxPercentage, currency, properties, contents);
                    if (this.wallThickness === undefined) { this.wallThickness = 0; }
                    if (this.wallDistance === undefined) { this.wallDistance = 0; }
                    if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                    if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                    if (this.sashes === undefined) { this.sashes = null; }
                    if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                    this.cutOutShape = cutOutShape;
                    this.wallThickness = wallThickness;
                    this.wallDistance = wallDistance;
                    this.wallCutOutOnBothSides = wallCutOutOnBothSides;
                    this.widthDepthDeformable = widthDepthDeformable;
                    this.sashes = sashes;
                }
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((typeof cutOutShape === 'number') || cutOutShape === null) && ((typeof wallThickness === 'number') || wallThickness === null) && ((typeof wallDistance === 'boolean') || wallDistance === null) && ((typeof wallCutOutOnBothSides === 'boolean') || wallCutOutOnBothSides === null) && ((widthDepthDeformable != null && widthDepthDeformable instanceof <any>Array && (widthDepthDeformable.length == 0 || widthDepthDeformable[0] == null || (widthDepthDeformable[0] != null && widthDepthDeformable[0] instanceof <any>Sash))) || widthDepthDeformable === null) && ((sashes != null && sashes instanceof <any>Array && (sashes.length == 0 || sashes[0] == null || sashes[0] instanceof Array)) || sashes === null) && ((typeof modelRotation === 'number') || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'string') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((typeof valueAddedTaxPercentage === 'string') || valueAddedTaxPercentage === null) && ((currency != null && (currency instanceof Object)) || currency === null) && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let cutOutShape: any = __args[16];
            let wallThickness: any = __args[17];
            let wallDistance: any = __args[18];
            let wallCutOutOnBothSides: any = __args[19];
            let widthDepthDeformable: any = __args[20];
            let sashes: any = __args[21];
            let modelRotation: any = __args[22];
            let modelFlags: any = __args[23];
            let modelSize: any = __args[24];
            let creator: any = __args[25];
            let resizable: any = __args[26];
            let deformable: any = __args[27];
            let texturable: any = __args[28];
            let price: any = __args[29];
            let valueAddedTaxPercentage: any = __args[30];
            let currency: any = __args[31];
            let properties: any = __args[32];
            {
                let __args = arguments;
                let license: any = null;
                let contents: any = null;
                super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, null, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, false, price, valueAddedTaxPercentage, currency, properties, contents);
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                this.cutOutShape = cutOutShape;
                this.wallThickness = wallThickness;
                this.wallDistance = wallDistance;
                this.wallCutOutOnBothSides = wallCutOutOnBothSides;
                this.widthDepthDeformable = widthDepthDeformable;
                this.sashes = sashes;
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((typeof information === 'string') || information === null) && ((license != null && license instanceof <any>Array && (license.length == 0 || license[0] == null || (typeof license[0] === 'string'))) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((grade != null && (grade.constructor != null && grade.constructor["__interfaces"] != null && grade.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || grade === null) && ((icon != null && (icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || icon === null) && ((planIcon != null && (planIcon.constructor != null && planIcon.constructor["__interfaces"] != null && planIcon.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((typeof movable === 'string') || movable === null) && ((typeof cutOutShape === 'number') || cutOutShape === null) && ((typeof wallThickness === 'number') || wallThickness === null) && ((typeof wallDistance === 'boolean') || wallDistance === null) && ((typeof wallCutOutOnBothSides === 'boolean') || wallCutOutOnBothSides === null) && ((widthDepthDeformable != null && widthDepthDeformable instanceof <any>Array && (widthDepthDeformable.length == 0 || widthDepthDeformable[0] == null || (widthDepthDeformable[0] != null && widthDepthDeformable[0] instanceof <any>Sash))) || widthDepthDeformable === null) && ((sashes != null && sashes instanceof <any>Array && (sashes.length == 0 || sashes[0] == null || sashes[0] instanceof Array)) || sashes === null) && ((typeof modelRotation === 'boolean') || modelRotation === null) && ((typeof modelFlags === 'number') || modelFlags === null) && ((typeof modelSize === 'string') || modelSize === null) && ((typeof creator === 'boolean') || creator === null) && ((typeof resizable === 'boolean') || resizable === null) && ((typeof deformable === 'boolean') || deformable === null) && ((texturable != null && texturable instanceof <any>Big) || texturable === null) && ((price != null && price instanceof <any>Big) || price === null) && ((typeof valueAddedTaxPercentage === 'string') || valueAddedTaxPercentage === null) && currency === undefined && properties === undefined && contents === undefined) {
            let __args = arguments;
            let tags: any = __args[4];
            let creationDate: any = __args[5];
            let grade: any = __args[6];
            let icon: any = __args[7];
            let planIcon: any = __args[8];
            let model: any = __args[9];
            let width: any = __args[10];
            let depth: any = __args[11];
            let height: any = __args[12];
            let elevation: any = __args[13];
            let dropOnTopElevation: any = __args[14];
            let movable: any = __args[15];
            let cutOutShape: any = __args[16];
            let wallThickness: any = __args[17];
            let wallDistance: any = __args[18];
            let wallCutOutOnBothSides: any = __args[19];
            let widthDepthDeformable: any = __args[20];
            let sashes: any = __args[21];
            let modelRotation: any = __args[22];
            let backFaceShown: any = __args[23];
            let modelSize: any = __args[24];
            let creator: any = __args[25];
            let resizable: any = __args[26];
            let deformable: any = __args[27];
            let texturable: any = __args[28];
            let price: any = __args[29];
            let valueAddedTaxPercentage: any = __args[30];
            let currency: any = __args[31];
            {
                let __args = arguments;
                let properties: any = null;
                {
                    let __args = arguments;
                    let modelFlags: any = backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0;
                    {
                        let __args = arguments;
                        let license: any = null;
                        let contents: any = null;
                        super(id, name, description, information, license, tags, creationDate, grade, icon, planIcon, model, width, depth, height, elevation, dropOnTopElevation, movable, null, modelRotation, modelFlags, modelSize, creator, resizable, deformable, texturable, false, price, valueAddedTaxPercentage, currency, properties, contents);
                        if (this.wallThickness === undefined) { this.wallThickness = 0; }
                        if (this.wallDistance === undefined) { this.wallDistance = 0; }
                        if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                        if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                        if (this.sashes === undefined) { this.sashes = null; }
                        if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                        this.cutOutShape = cutOutShape;
                        this.wallThickness = wallThickness;
                        this.wallDistance = wallDistance;
                        this.wallCutOutOnBothSides = wallCutOutOnBothSides;
                        this.widthDepthDeformable = widthDepthDeformable;
                        this.sashes = sashes;
                    }
                    if (this.wallThickness === undefined) { this.wallThickness = 0; }
                    if (this.wallDistance === undefined) { this.wallDistance = 0; }
                    if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                    if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                    if (this.sashes === undefined) { this.sashes = null; }
                    if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                }
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
        } else if (((typeof id === 'string') || id === null) && ((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || name === null) && ((description != null && (description.constructor != null && description.constructor["__interfaces"] != null && description.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || description === null) && ((typeof information === 'number') || information === null) && ((typeof license === 'number') || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'boolean') || grade === null) && ((typeof icon === 'number') || icon === null) && ((typeof planIcon === 'number') || planIcon === null) && ((model != null && model instanceof <any>Array && (model.length == 0 || model[0] == null || (model[0] != null && model[0] instanceof <any>Sash))) || model === null) && ((typeof width === 'number') || width === null) && ((depth != null && depth instanceof <any>Array && (depth.length == 0 || depth[0] == null || depth[0] instanceof Array)) || depth === null) && ((typeof height === 'boolean') || height === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof dropOnTopElevation === 'string') || dropOnTopElevation === null) && ((typeof movable === 'number') || movable === null) && ((typeof cutOutShape === 'boolean') || cutOutShape === null) && wallThickness === undefined && wallDistance === undefined && wallCutOutOnBothSides === undefined && widthDepthDeformable === undefined && sashes === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let icon: any = __args[1];
            let model: any = __args[2];
            let width: any = __args[3];
            let depth: any = __args[4];
            let height: any = __args[5];
            let elevation: any = __args[6];
            let movable: any = __args[7];
            let wallThickness: any = __args[8];
            let wallDistance: any = __args[9];
            let sashes: any = __args[10];
            let color: any = __args[11];
            let modelRotation: any = __args[12];
            let backFaceShown: any = __args[13];
            let modelSize: any = __args[14];
            let creator: any = __args[15];
            let iconYaw: any = __args[16];
            let proportional: any = __args[17];
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof description === 'string') || description === null) && ((information != null && (information.constructor != null && information.constructor["__interfaces"] != null && information.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || information === null) && ((license != null && (license.constructor != null && license.constructor["__interfaces"] != null && license.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Content") >= 0)) || license === null) && ((typeof tags === 'number') || tags === null) && ((typeof creationDate === 'number') || creationDate === null) && ((typeof grade === 'number') || grade === null) && ((typeof icon === 'number') || icon === null) && ((typeof planIcon === 'boolean') || planIcon === null) && ((typeof model === 'number') || model === null) && ((typeof width === 'number') || width === null) && ((depth != null && depth instanceof <any>Array && (depth.length == 0 || depth[0] == null || (depth[0] != null && depth[0] instanceof <any>Sash))) || depth === null) && ((height != null && height instanceof <any>Array && (height.length == 0 || height[0] == null || height[0] instanceof Array)) || height === null) && ((typeof elevation === 'string') || elevation === null) && ((typeof dropOnTopElevation === 'boolean') || dropOnTopElevation === null) && ((movable != null && movable instanceof <any>Big) || movable === null) && ((cutOutShape != null && cutOutShape instanceof <any>Big) || cutOutShape === null) && wallThickness === undefined && wallDistance === undefined && wallCutOutOnBothSides === undefined && widthDepthDeformable === undefined && sashes === undefined && modelRotation === undefined && modelFlags === undefined && modelSize === undefined && creator === undefined && resizable === undefined && deformable === undefined && texturable === undefined && price === undefined && valueAddedTaxPercentage === undefined && currency === undefined && properties === undefined && contents === undefined) {
            let __args = arguments;
            let icon: any = __args[3];
            let model: any = __args[4];
            let width: any = __args[5];
            let depth: any = __args[6];
            let height: any = __args[7];
            let elevation: any = __args[8];
            let movable: any = __args[9];
            let wallThickness: any = __args[10];
            let wallDistance: any = __args[11];
            let sashes: any = __args[12];
            let modelRotation: any = __args[13];
            let creator: any = __args[14];
            let resizable: any = __args[15];
            let price: any = __args[16];
            let valueAddedTaxPercentage: any = __args[17];
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the default thickness of the wall in which this door or window should be placed.
     * @return {number} a value in percentage of the depth of the door or the window.
     */
    public getWallThickness(): number {
        return this.wallThickness;
    }

    /**
     * Returns the default distance that should lie at the back side of this door or window.
     * @return {number} a distance in percentage of the depth of the door or the window.
     */
    public getWallDistance(): number {
        return this.wallDistance;
    }

    /**
     * Returns <code>true</code> if this door or window should cut out the both sides
     * of the walls it intersects, even if its front or back side are within the wall thickness.
     * @return {boolean}
     */
    public isWallCutOutOnBothSides(): boolean {
        return this.wallCutOutOnBothSides;
    }

    /**
     * Returns <code>false</code> if the width and depth of the new door or window may
     * not be changed independently from each other.
     * @return {boolean}
     */
    public isWidthDepthDeformable(): boolean {
        return this.widthDepthDeformable;
    }

    /**
     * Returns a copy of the sashes attached to this door or window.
     * If no sash is defined an empty array is returned.
     * @return {com.eteks.sweethome3d.model.Sash[]}
     */
    public getSashes(): Sash[] {
        if (this.sashes.length === 0) {
            return this.sashes;
        } else {
            return /* clone */this.sashes.slice(0);
        }
    }

    /**
     * Returns the shape used to cut out walls that intersect this new door or window.
     * @return {string}
     */
    public getCutOutShape(): string {
        return this.cutOutShape;
    }

    /**
     * Returns always <code>true</code>.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return true;
    }

    /**
     * Returns always <code>false</code>.
     * @return {boolean}
     */
    public isHorizontallyRotatable(): boolean {
        return false;
    }
}
CatalogDoorOrWindow["__class"] = "com.eteks.sweethome3d.model.CatalogDoorOrWindow";
CatalogDoorOrWindow["__interfaces"] = ["com.eteks.sweethome3d.model.CatalogItem", "com.eteks.sweethome3d.model.DoorOrWindow", "com.eteks.sweethome3d.model.PieceOfFurniture"];



/**
 * Creates an exception for the given damaged home with the invalid content it may contains.
 * @param {Home} damagedHome
 * @param {*[]} invalidContent
 * @param {string} message
 * @class
 * @extends RecorderException
 * @author Emmanuel Puybaret
 * @ignore
 */
export class DamagedHomeRecorderException extends RecorderException {
    /*private*/ damagedHome: Home;

    /*private*/ invalidContent: Array<Content>;

    public constructor(damagedHome?: any, invalidContent?: any, message?: any) {
        if (((damagedHome != null && damagedHome instanceof <any>Home) || damagedHome === null) && ((invalidContent != null && (invalidContent instanceof Array)) || invalidContent === null) && ((typeof message === 'string') || message === null)) {
            let __args = arguments;
            super(message);
            if (this.damagedHome === undefined) { this.damagedHome = null; }
            if (this.invalidContent === undefined) { this.invalidContent = null; }
            this.damagedHome = damagedHome;
            this.invalidContent = invalidContent;
        } else if (((damagedHome != null && damagedHome instanceof <any>Home) || damagedHome === null) && ((invalidContent != null && (invalidContent instanceof Array)) || invalidContent === null) && message === undefined) {
            let __args = arguments;
            super();
            if (this.damagedHome === undefined) { this.damagedHome = null; }
            if (this.invalidContent === undefined) { this.invalidContent = null; }
            this.damagedHome = damagedHome;
            this.invalidContent = invalidContent;
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the damaged home containing some possible invalid content.
     * This home can be handled and saved correctly only once the invalid content will be removed.
     * @return {Home}
     */
    public getDamagedHome(): Home {
        return this.damagedHome;
    }

    /**
     * Returns the invalid content in the damaged home.
     * @return {*[]}
     */
    public getInvalidContent(): Array<Content> {
        return this.invalidContent;
    }
}
DamagedHomeRecorderException["__class"] = "com.eteks.sweethome3d.model.DamagedHomeRecorderException";


/**
 * Exception thrown when there's not enough space to save a home.
 * @author Emmanuel Puybaret
 * @param {string} message
 * @param {number} missingSpace
 * @class
 * @extends RecorderException
 * @ignore
 */
export class NotEnoughSpaceRecorderException extends RecorderException {
    /*private*/ missingSpace: number;

    public constructor(message: string, missingSpace: number) {
        super(message);
        (<any>Object).setPrototypeOf(this, NotEnoughSpaceRecorderException.prototype);
        if (this.missingSpace === undefined) { this.missingSpace = 0; }
        this.missingSpace = missingSpace;
    }

    /**
     * Returns the length of the missing space to save a home.
     * @return {number}
     */
    public getMissingSpace(): number {
        return this.missingSpace;
    }
}
NotEnoughSpaceRecorderException["__class"] = "com.eteks.sweethome3d.model.NotEnoughSpaceRecorderException";


/**
 * Creates a <code>InterruptedRecorderException</code> from its message.
 * @param {string} message
 * @class
 * @extends RecorderException
 * @author Emmanuel Puybaret
 * @ignore
 */
export class InterruptedRecorderException extends RecorderException {
    public constructor(message?: any) {
        if (((typeof message === 'string') || message === null)) {
            let __args = arguments;
            super(message);
        } else if (message === undefined) {
            let __args = arguments;
            super();
        } else throw new Error('invalid overload');
    }
}
InterruptedRecorderException["__class"] = "com.eteks.sweethome3d.model.InterruptedRecorderException";


/**
 * Creates a wall from (<code>xStart</code>,<code>yStart</code>)
 * to (<code>xEnd</code>, <code>yEnd</code>),
 * with given thickness, height and pattern.
 * Colors are <code>null</code>.
 * @param {string} id
 * @param {number} xStart
 * @param {number} yStart
 * @param {number} xEnd
 * @param {number} yEnd
 * @param {number} thickness
 * @param {number} height
 * @param {Object} pattern
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Wall extends HomeObject implements Selectable, Elevatable {
    /*private*/ xStart: number;

    /*private*/ yStart: number;

    /*private*/ xEnd: number;

    /*private*/ yEnd: number;

    /*private*/ arcExtent: number;

    /*private*/ wallAtStart: Wall;

    /*private*/ wallAtEnd: Wall;

    /*private*/ thickness: number;

    /*private*/ height: number;

    /*private*/ heightAtEnd: number;

    /*private*/ leftSideColor: number;

    /*private*/ leftSideTexture: HomeTexture;

    /*private*/ leftSideShininess: number;

    /*private*/ leftSideBaseboard: Baseboard;

    /*private*/ rightSideColor: number;

    /*private*/ rightSideTexture: HomeTexture;

    /*private*/ rightSideShininess: number;

    /*private*/ rightSideBaseboard: Baseboard;

    /*private*/ symmetric: boolean;

    /*private*/ pattern: TextureImage;

    /*private*/ topColor: number;

    /*private*/ level: Level;

    /*private*/ shapeCache: java.awt.Shape;

    /*private*/ arcCircleCenterCache: number[];

    /*private*/ pointsCache: number[][];

    /*private*/ pointsIncludingBaseboardsCache: number[][];

    public constructor(id?: any, xStart?: any, yStart?: any, xEnd?: any, yEnd?: any, thickness?: any, height?: any, pattern?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof thickness === 'number') || thickness === null) && ((typeof height === 'number') || height === null) && ((pattern != null && (pattern.constructor != null && pattern.constructor["__interfaces"] != null && pattern.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || pattern === null)) {
            let __args = arguments;
            super(id);
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
            this.symmetric = true;
            this.xStart = xStart;
            this.yStart = yStart;
            this.xEnd = xEnd;
            this.yEnd = yEnd;
            this.thickness = thickness;
            this.height = height;
            this.pattern = pattern;
        } else if (((typeof id === 'string') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof thickness === 'number') || thickness === null) && ((typeof height === 'number') || height === null) && pattern === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let pattern: any = null;
                super(id);
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.arcExtent === undefined) { this.arcExtent = null; }
                if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.height === undefined) { this.height = null; }
                if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                if (this.pattern === undefined) { this.pattern = null; }
                if (this.topColor === undefined) { this.topColor = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                if (this.pointsCache === undefined) { this.pointsCache = null; }
                if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                this.symmetric = true;
                this.xStart = xStart;
                this.yStart = yStart;
                this.xEnd = xEnd;
                this.yEnd = yEnd;
                this.thickness = thickness;
                this.height = height;
                this.pattern = pattern;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
            this.symmetric = true;
        } else if (((typeof id === 'number') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof thickness === 'number') || thickness === null) && ((height != null && (height.constructor != null && height.constructor["__interfaces"] != null && height.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.TextureImage") >= 0)) || height === null) && pattern === undefined) {
            let __args = arguments;
            let xStart: any = __args[0];
            let yStart: any = __args[1];
            let xEnd: any = __args[2];
            let yEnd: any = __args[3];
            let thickness: any = __args[4];
            let height: any = __args[5];
            let pattern: any = __args[6];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("wall");
                super(id);
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.arcExtent === undefined) { this.arcExtent = null; }
                if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.height === undefined) { this.height = null; }
                if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                if (this.pattern === undefined) { this.pattern = null; }
                if (this.topColor === undefined) { this.topColor = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                if (this.pointsCache === undefined) { this.pointsCache = null; }
                if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                this.symmetric = true;
                this.xStart = xStart;
                this.yStart = yStart;
                this.xEnd = xEnd;
                this.yEnd = yEnd;
                this.thickness = thickness;
                this.height = height;
                this.pattern = pattern;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
            this.symmetric = true;
        } else if (((typeof id === 'number') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof thickness === 'number') || thickness === null) && height === undefined && pattern === undefined) {
            let __args = arguments;
            let xStart: any = __args[0];
            let yStart: any = __args[1];
            let xEnd: any = __args[2];
            let yEnd: any = __args[3];
            let thickness: any = __args[4];
            let height: any = __args[5];
            {
                let __args = arguments;
                let pattern: any = null;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("wall");
                    super(id);
                    if (this.xStart === undefined) { this.xStart = 0; }
                    if (this.yStart === undefined) { this.yStart = 0; }
                    if (this.xEnd === undefined) { this.xEnd = 0; }
                    if (this.yEnd === undefined) { this.yEnd = 0; }
                    if (this.arcExtent === undefined) { this.arcExtent = null; }
                    if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                    if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                    if (this.thickness === undefined) { this.thickness = 0; }
                    if (this.height === undefined) { this.height = null; }
                    if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                    if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                    if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                    if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                    if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                    if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                    if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                    if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                    if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                    if (this.pattern === undefined) { this.pattern = null; }
                    if (this.topColor === undefined) { this.topColor = null; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                    if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                    if (this.pointsCache === undefined) { this.pointsCache = null; }
                    if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                    this.symmetric = true;
                    this.xStart = xStart;
                    this.yStart = yStart;
                    this.xEnd = xEnd;
                    this.yEnd = yEnd;
                    this.thickness = thickness;
                    this.height = height;
                    this.pattern = pattern;
                }
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.arcExtent === undefined) { this.arcExtent = null; }
                if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.height === undefined) { this.height = null; }
                if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                if (this.pattern === undefined) { this.pattern = null; }
                if (this.topColor === undefined) { this.topColor = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                if (this.pointsCache === undefined) { this.pointsCache = null; }
                if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                this.symmetric = true;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
            this.symmetric = true;
        } else if (((typeof id === 'number') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && thickness === undefined && height === undefined && pattern === undefined) {
            let __args = arguments;
            let xStart: any = __args[0];
            let yStart: any = __args[1];
            let xEnd: any = __args[2];
            let yEnd: any = __args[3];
            let thickness: any = __args[4];
            {
                let __args = arguments;
                let height: any = 0;
                {
                    let __args = arguments;
                    let pattern: any = null;
                    {
                        let __args = arguments;
                        let id: any = HomeObject.createId("wall");
                        super(id);
                        if (this.xStart === undefined) { this.xStart = 0; }
                        if (this.yStart === undefined) { this.yStart = 0; }
                        if (this.xEnd === undefined) { this.xEnd = 0; }
                        if (this.yEnd === undefined) { this.yEnd = 0; }
                        if (this.arcExtent === undefined) { this.arcExtent = null; }
                        if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                        if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                        if (this.thickness === undefined) { this.thickness = 0; }
                        if (this.height === undefined) { this.height = null; }
                        if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                        if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                        if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                        if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                        if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                        if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                        if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                        if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                        if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                        if (this.pattern === undefined) { this.pattern = null; }
                        if (this.topColor === undefined) { this.topColor = null; }
                        if (this.level === undefined) { this.level = null; }
                        if (this.shapeCache === undefined) { this.shapeCache = null; }
                        if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                        if (this.pointsCache === undefined) { this.pointsCache = null; }
                        if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                        this.symmetric = true;
                        this.xStart = xStart;
                        this.yStart = yStart;
                        this.xEnd = xEnd;
                        this.yEnd = yEnd;
                        this.thickness = thickness;
                        this.height = height;
                        this.pattern = pattern;
                    }
                    if (this.xStart === undefined) { this.xStart = 0; }
                    if (this.yStart === undefined) { this.yStart = 0; }
                    if (this.xEnd === undefined) { this.xEnd = 0; }
                    if (this.yEnd === undefined) { this.yEnd = 0; }
                    if (this.arcExtent === undefined) { this.arcExtent = null; }
                    if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                    if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                    if (this.thickness === undefined) { this.thickness = 0; }
                    if (this.height === undefined) { this.height = null; }
                    if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                    if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                    if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                    if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                    if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                    if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                    if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                    if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                    if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                    if (this.pattern === undefined) { this.pattern = null; }
                    if (this.topColor === undefined) { this.topColor = null; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                    if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                    if (this.pointsCache === undefined) { this.pointsCache = null; }
                    if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                    this.symmetric = true;
                }
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.arcExtent === undefined) { this.arcExtent = null; }
                if (this.wallAtStart === undefined) { this.wallAtStart = null; }
                if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.height === undefined) { this.height = null; }
                if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
                if (this.leftSideColor === undefined) { this.leftSideColor = null; }
                if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
                if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
                if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
                if (this.rightSideColor === undefined) { this.rightSideColor = null; }
                if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
                if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
                if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
                if (this.pattern === undefined) { this.pattern = null; }
                if (this.topColor === undefined) { this.topColor = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
                if (this.pointsCache === undefined) { this.pointsCache = null; }
                if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
                this.symmetric = true;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.arcCircleCenterCache === undefined) { this.arcCircleCenterCache = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.pointsIncludingBaseboardsCache === undefined) { this.pointsIncludingBaseboardsCache = null; }
            this.symmetric = true;
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the start point abscissa of this wall.
     * @return {number}
     */
    public getXStart(): number {
        return this.xStart;
    }

    /**
     * Sets the start point abscissa of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} xStart
     */
    public setXStart(xStart: number) {
        if (xStart !== this.xStart) {
            const oldXStart: number = this.xStart;
            this.xStart = xStart;
            this.clearPointsCache();
            this.arcCircleCenterCache = null;
            this.firePropertyChange(/* name */"X_START", oldXStart, xStart);
        }
    }

    /**
     * Returns the start point ordinate of this wall.
     * @return {number}
     */
    public getYStart(): number {
        return this.yStart;
    }

    /**
     * Sets the start point ordinate of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} yStart
     */
    public setYStart(yStart: number) {
        if (yStart !== this.yStart) {
            const oldYStart: number = this.yStart;
            this.yStart = yStart;
            this.clearPointsCache();
            this.arcCircleCenterCache = null;
            this.firePropertyChange(/* name */"Y_START", oldYStart, yStart);
        }
    }

    /**
     * Returns the end point abscissa of this wall.
     * @return {number}
     */
    public getXEnd(): number {
        return this.xEnd;
    }

    /**
     * Sets the end point abscissa of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} xEnd
     */
    public setXEnd(xEnd: number) {
        if (xEnd !== this.xEnd) {
            const oldXEnd: number = this.xEnd;
            this.xEnd = xEnd;
            this.clearPointsCache();
            this.arcCircleCenterCache = null;
            this.firePropertyChange(/* name */"X_END", oldXEnd, xEnd);
        }
    }

    /**
     * Returns the end point ordinate of this wall.
     * @return {number}
     */
    public getYEnd(): number {
        return this.yEnd;
    }

    /**
     * Sets the end point ordinate of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} yEnd
     */
    public setYEnd(yEnd: number) {
        if (yEnd !== this.yEnd) {
            const oldYEnd: number = this.yEnd;
            this.yEnd = yEnd;
            this.clearPointsCache();
            this.arcCircleCenterCache = null;
            this.firePropertyChange(/* name */"Y_END", oldYEnd, yEnd);
        }
    }

    /**
     * Returns the length of this wall.
     * @return {number}
     */
    public getLength(): number {
        if (this.arcExtent == null || /* floatValue */this.arcExtent === 0) {
            return <number>java.awt.geom.Point2D.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
        } else {
            const arcCircleCenter: number[] = this.getArcCircleCenter();
            const arcCircleRadius: number = <number>java.awt.geom.Point2D.distance(this.xStart, this.yStart, arcCircleCenter[0], arcCircleCenter[1]);
            return Math.abs(this.arcExtent) * arcCircleRadius;
        }
    }

    /**
     * Returns the distance from the start point of this wall to its end point.
     * @return {number}
     */
    public getStartPointToEndPointDistance(): number {
        return <number>java.awt.geom.Point2D.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }

    /**
     * Sets the arc extent of a round wall.
     * @param {number} arcExtent
     */
    public setArcExtent(arcExtent: number) {
        if (arcExtent !== this.arcExtent && (arcExtent == null || !(arcExtent === this.arcExtent))) {
            const oldArcExtent: number = this.arcExtent;
            this.arcExtent = arcExtent;
            this.clearPointsCache();
            this.arcCircleCenterCache = null;
            this.firePropertyChange(/* name */"ARC_EXTENT", oldArcExtent, arcExtent);
        }
    }

    /**
     * Returns the arc extent of a round wall or <code>null</code> if this wall isn't round.
     * @return {number}
     */
    public getArcExtent(): number {
        return this.arcExtent;
    }

    /**
     * Returns the abscissa of the arc circle center of this wall.
     * If the wall isn't round, the return abscissa is at the middle of the wall.
     * @return {number}
     */
    public getXArcCircleCenter(): number {
        if (this.arcExtent == null) {
            return (this.xStart + this.xEnd) / 2;
        } else {
            return this.getArcCircleCenter()[0];
        }
    }

    /**
     * Returns the ordinate of the arc circle center of this wall.
     * If the wall isn't round, the return ordinate is at the middle of the wall.
     * @return {number}
     */
    public getYArcCircleCenter(): number {
        if (this.arcExtent == null) {
            return (this.yStart + this.yEnd) / 2;
        } else {
            return this.getArcCircleCenter()[1];
        }
    }

    /**
     * Returns the coordinates of the arc circle center of this wall.
     * @return {float[]}
     * @private
     */
    getArcCircleCenter(): number[] {
        if (this.arcCircleCenterCache == null) {
            const startToEndPointsDistance: number = java.awt.geom.Point2D.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
            const wallToStartPointArcCircleCenterAngle: number = Math.abs(this.arcExtent) > Math.PI ? -(Math.PI + this.arcExtent) / 2 : (Math.PI - this.arcExtent) / 2;
            const arcCircleCenterToWallDistance: number = -<number>(Math.tan(wallToStartPointArcCircleCenterAngle) * startToEndPointsDistance / 2);
            const xMiddlePoint: number = (this.xStart + this.xEnd) / 2;
            const yMiddlePoint: number = (this.yStart + this.yEnd) / 2;
            const angle: number = Math.atan2(this.xStart - this.xEnd, this.yEnd - this.yStart);
            this.arcCircleCenterCache = [<number>(xMiddlePoint + arcCircleCenterToWallDistance * Math.cos(angle)), <number>(yMiddlePoint + arcCircleCenterToWallDistance * Math.sin(angle))];
        }
        return this.arcCircleCenterCache;
    }

    /**
     * Returns the wall joined to this wall at start point.
     * @return {Wall}
     */
    public getWallAtStart(): Wall {
        return this.wallAtStart;
    }

    public setWallAtStart(wallAtStart: Wall, detachJoinedWallAtStart: boolean = true) {
        if (wallAtStart !== this.wallAtStart) {
            const oldWallAtStart: Wall = this.wallAtStart;
            this.wallAtStart = wallAtStart;
            this.clearPointsCache();
            this.firePropertyChange(/* name */"WALL_AT_START", oldWallAtStart, wallAtStart);
            if (detachJoinedWallAtStart) {
                this.detachJoinedWall(oldWallAtStart);
            }
        }
    }

    /**
     * Returns the wall joined to this wall at end point.
     * @return {Wall}
     */
    public getWallAtEnd(): Wall {
        return this.wallAtEnd;
    }

    public setWallAtEnd(wallAtEnd: Wall, detachJoinedWallAtEnd: boolean = true) {
        if (wallAtEnd !== this.wallAtEnd) {
            const oldWallAtEnd: Wall = this.wallAtEnd;
            this.wallAtEnd = wallAtEnd;
            this.clearPointsCache();
            this.firePropertyChange(/* name */"WALL_AT_END", oldWallAtEnd, wallAtEnd);
            if (detachJoinedWallAtEnd) {
                this.detachJoinedWall(oldWallAtEnd);
            }
        }
    }

    /**
     * Detaches <code>joinedWall</code> from this wall.
     * @param {Wall} joinedWall
     * @private
     */
    detachJoinedWall(joinedWall: Wall) {
        if (joinedWall != null) {
            if (joinedWall.getWallAtStart() === this) {
                joinedWall.setWallAtStart(null, false);
            } else if (joinedWall.getWallAtEnd() === this) {
                joinedWall.setWallAtEnd(null, false);
            }
        }
    }

    /**
     * Returns the thickness of this wall.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Sets wall thickness. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} thickness
     */
    public setThickness(thickness: number) {
        if (thickness !== this.thickness) {
            const oldThickness: number = this.thickness;
            this.thickness = thickness;
            this.clearPointsCache();
            this.firePropertyChange(/* name */"THICKNESS", oldThickness, thickness);
        }
    }

    /**
     * Returns the height of this wall. If {@link #getHeightAtEnd() getHeightAtEnd}
     * returns a value not <code>null</code>, the returned height should be
     * considered as the height of this wall at its start point.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the height of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} height
     */
    public setHeight(height: number) {
        if (height !== this.height && (height == null || !(height === this.height))) {
            const oldHeight: number = this.height;
            this.height = height;
            this.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
        }
    }

    /**
     * Returns the height of this wall at its end point.
     * @return {number}
     */
    public getHeightAtEnd(): number {
        return this.heightAtEnd;
    }

    /**
     * Sets the height of this wall at its end point. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} heightAtEnd
     */
    public setHeightAtEnd(heightAtEnd: number) {
        if (heightAtEnd !== this.heightAtEnd && (heightAtEnd == null || !(heightAtEnd === this.heightAtEnd))) {
            const oldHeightAtEnd: number = this.heightAtEnd;
            this.heightAtEnd = heightAtEnd;
            this.firePropertyChange(/* name */"HEIGHT_AT_END", oldHeightAtEnd, heightAtEnd);
        }
    }

    /**
     * Returns <code>true</code> if the height of this wall is different
     * at its start and end points.
     * @return {boolean}
     */
    public isTrapezoidal(): boolean {
        return this.height != null && this.heightAtEnd != null && !(this.height === this.heightAtEnd);
    }

    /**
     * Returns left side color of this wall. This is the color of the left side
     * of this wall when you go through wall from start point to end point.
     * @return {number}
     */
    public getLeftSideColor(): number {
        return this.leftSideColor;
    }

    /**
     * Sets left side color of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} leftSideColor
     */
    public setLeftSideColor(leftSideColor: number) {
        if (leftSideColor !== this.leftSideColor && (leftSideColor == null || !(leftSideColor === this.leftSideColor))) {
            const oldLeftSideColor: number = this.leftSideColor;
            this.leftSideColor = leftSideColor;
            this.firePropertyChange(/* name */"LEFT_SIDE_COLOR", oldLeftSideColor, leftSideColor);
        }
    }

    /**
     * Returns right side color of this wall. This is the color of the right side
     * of this wall when you go through wall from start point to end point.
     * @return {number}
     */
    public getRightSideColor(): number {
        return this.rightSideColor;
    }

    /**
     * Sets right side color of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} rightSideColor
     */
    public setRightSideColor(rightSideColor: number) {
        if (rightSideColor !== this.rightSideColor && (rightSideColor == null || !(rightSideColor === this.rightSideColor))) {
            const oldLeftSideColor: number = this.rightSideColor;
            this.rightSideColor = rightSideColor;
            this.firePropertyChange(/* name */"RIGHT_SIDE_COLOR", oldLeftSideColor, rightSideColor);
        }
    }

    /**
     * Returns the left side texture of this wall.
     * @return {HomeTexture}
     */
    public getLeftSideTexture(): HomeTexture {
        return this.leftSideTexture;
    }

    /**
     * Sets the left side texture of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {HomeTexture} leftSideTexture
     */
    public setLeftSideTexture(leftSideTexture: HomeTexture) {
        if (leftSideTexture !== this.leftSideTexture && (leftSideTexture == null || !leftSideTexture.equals(this.leftSideTexture))) {
            const oldLeftSideTexture: HomeTexture = this.leftSideTexture;
            this.leftSideTexture = leftSideTexture;
            this.firePropertyChange(/* name */"LEFT_SIDE_TEXTURE", oldLeftSideTexture, leftSideTexture);
        }
    }

    /**
     * Returns the right side texture of this wall.
     * @return {HomeTexture}
     */
    public getRightSideTexture(): HomeTexture {
        return this.rightSideTexture;
    }

    /**
     * Sets the right side texture of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {HomeTexture} rightSideTexture
     */
    public setRightSideTexture(rightSideTexture: HomeTexture) {
        if (rightSideTexture !== this.rightSideTexture && (rightSideTexture == null || !rightSideTexture.equals(this.rightSideTexture))) {
            const oldLeftSideTexture: HomeTexture = this.rightSideTexture;
            this.rightSideTexture = rightSideTexture;
            this.firePropertyChange(/* name */"RIGHT_SIDE_TEXTURE", oldLeftSideTexture, rightSideTexture);
        }
    }

    /**
     * Returns the left side shininess of this wall.
     * @return {number} a value between 0 (matt) and 1 (very shiny)
     */
    public getLeftSideShininess(): number {
        return this.leftSideShininess;
    }

    /**
     * Sets the left side shininess of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} leftSideShininess
     */
    public setLeftSideShininess(leftSideShininess: number) {
        if (leftSideShininess !== this.leftSideShininess) {
            const oldLeftSideShininess: number = this.leftSideShininess;
            this.leftSideShininess = leftSideShininess;
            this.firePropertyChange(/* name */"LEFT_SIDE_SHININESS", oldLeftSideShininess, leftSideShininess);
        }
    }

    /**
     * Returns the right side shininess of this wall.
     * @return {number} a value between 0 (matt) and 1 (very shiny)
     */
    public getRightSideShininess(): number {
        return this.rightSideShininess;
    }

    /**
     * Sets the right side shininess of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {number} rightSideShininess
     */
    public setRightSideShininess(rightSideShininess: number) {
        if (rightSideShininess !== this.rightSideShininess) {
            const oldRightSideShininess: number = this.rightSideShininess;
            this.rightSideShininess = rightSideShininess;
            this.firePropertyChange(/* name */"RIGHT_SIDE_SHININESS", oldRightSideShininess, rightSideShininess);
        }
    }

    /**
     * Returns the left side baseboard of this wall.
     * @return {Baseboard}
     */
    public getLeftSideBaseboard(): Baseboard {
        return this.leftSideBaseboard;
    }

    /**
     * Sets the left side baseboard of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {Baseboard} leftSideBaseboard
     */
    public setLeftSideBaseboard(leftSideBaseboard: Baseboard) {
        if (leftSideBaseboard !== this.leftSideBaseboard && (leftSideBaseboard == null || !leftSideBaseboard.equals(this.leftSideBaseboard))) {
            const oldLeftSideBaseboard: Baseboard = this.leftSideBaseboard;
            this.leftSideBaseboard = leftSideBaseboard;
            this.clearPointsCache();
            this.firePropertyChange(/* name */"LEFT_SIDE_BASEBOARD", oldLeftSideBaseboard, leftSideBaseboard);
        }
    }

    /**
     * Returns the right side baseboard of this wall.
     * @return {Baseboard}
     */
    public getRightSideBaseboard(): Baseboard {
        return this.rightSideBaseboard;
    }

    /**
     * Sets the right side baseboard of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {Baseboard} rightSideBaseboard
     */
    public setRightSideBaseboard(rightSideBaseboard: Baseboard) {
        if (rightSideBaseboard !== this.rightSideBaseboard && (rightSideBaseboard == null || !rightSideBaseboard.equals(this.rightSideBaseboard))) {
            const oldRightSideBaseboard: Baseboard = this.rightSideBaseboard;
            this.rightSideBaseboard = rightSideBaseboard;
            this.clearPointsCache();
            this.firePropertyChange(/* name */"RIGHT_SIDE_BASEBOARD", oldRightSideBaseboard, rightSideBaseboard);
        }
    }

    /**
     * Returns the pattern of this wall in the plan.
     * @return {Object}
     */
    public getPattern(): TextureImage {
        return this.pattern;
    }

    /**
     * Sets the pattern of this wall in the plan, and notifies
     * listeners of this change.
     * @param {Object} pattern
     */
    public setPattern(pattern: TextureImage) {
        if (this.pattern !== pattern) {
            const oldPattern: TextureImage = this.pattern;
            this.pattern = pattern;
            this.firePropertyChange(/* name */"PATTERN", oldPattern, pattern);
        }
    }

    /**
     * Returns the color of the top of this wall in the 3D view.
     * @return {number}
     */
    public getTopColor(): number {
        return this.topColor;
    }

    /**
     * Sets the color of the top of this wall in the 3D view, and notifies
     * listeners of this change.
     * @param {number} topColor
     */
    public setTopColor(topColor: number) {
        if (this.topColor !== topColor && (topColor == null || !(topColor === this.topColor))) {
            const oldTopColor: number = this.topColor;
            this.topColor = topColor;
            this.firePropertyChange(/* name */"TOP_COLOR", oldTopColor, topColor);
        }
    }

    /**
     * Returns the level which this wall belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this wall. Once this wall is updated,
     * listeners added to this wall will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this wall is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index
     * or if the elevation of its highest point is higher than <code>level</code> elevation.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        if (this.level === level) {
            return true;
        } else if (this.level != null && level != null) {
            const wallLevelElevation: number = this.level.getElevation();
            const levelElevation: number = level.getElevation();
            return wallLevelElevation === levelElevation && this.level.getElevationIndex() < level.getElevationIndex() || wallLevelElevation < levelElevation && wallLevelElevation + this.getWallMaximumHeight() > levelElevation;
        } else {
            return false;
        }
    }

    /**
     * Returns the maximum height of the given wall.
     * @return {number}
     * @private
     */
    getWallMaximumHeight(): number {
        if (this.height == null) {
            return 0;
        } else if (this.isTrapezoidal()) {
            return Math.max(this.height, this.heightAtEnd);
        } else {
            return this.height;
        }
    }

    /**
     * Clears the points cache of this wall and of the walls attached to it.
     * @private
     */
    clearPointsCache() {
        this.shapeCache = null;
        this.pointsCache = null;
        this.pointsIncludingBaseboardsCache = null;
        if (this.wallAtStart != null) {
            this.wallAtStart.pointsCache = null;
            this.wallAtStart.pointsIncludingBaseboardsCache = null;
        }
        if (this.wallAtEnd != null) {
            this.wallAtEnd.pointsCache = null;
            this.wallAtEnd.pointsIncludingBaseboardsCache = null;
        }
    }

    public getPoints$(): number[][] {
        return this.getPoints$boolean(false);
    }

    public getPoints$boolean(includeBaseboards: boolean): number[][] {
        if (includeBaseboards && (this.leftSideBaseboard != null || this.rightSideBaseboard != null)) {
            if (this.pointsIncludingBaseboardsCache == null) {
                this.pointsIncludingBaseboardsCache = this.getShapePoints(true);
            }
            return this.clonePoints(this.pointsIncludingBaseboardsCache);
        } else {
            if (this.pointsCache == null) {
                this.pointsCache = this.getShapePoints(false);
            }
            return this.clonePoints(this.pointsCache);
        }
    }

    /**
     * Returns the points of each corner of a wall possibly including its baseboards.
     * @param {boolean} includeBaseboards
     * @return {float[][]}
     */
    public getPoints(includeBaseboards?: any): number[][] {
        if (((typeof includeBaseboards === 'boolean') || includeBaseboards === null)) {
            return <any>this.getPoints$boolean(includeBaseboards);
        } else if (includeBaseboards === undefined) {
            return <any>this.getPoints$();
        } else throw new Error('invalid overload');
    }

    /**
     * Return a clone of the given <code>points</code> array.
     * @param {float[][]} points
     * @return {float[][]}
     * @private
     */
    clonePoints(points: number[][]): number[][] {
        const clonedPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(points.length);
        for (let i: number = 0; i < points.length; i++) {
            {
                clonedPoints[i] = /* clone */points[i].slice(0);
            };
        }
        return clonedPoints;
    }

    /**
     * Returns the points of the wall possibly including baseboards thickness.
     * @param {boolean} includeBaseboards
     * @return {float[][]}
     * @private
     */
    getShapePoints(includeBaseboards: boolean): number[][] {
        const epsilon: number = 0.01;
        const wallPoints: number[][] = this.getUnjoinedShapePoints(includeBaseboards);
        const leftSideStartPointIndex: number = 0;
        const rightSideStartPointIndex: number = wallPoints.length - 1;
        const leftSideEndPointIndex: number = (wallPoints.length / 2 | 0) - 1;
        const rightSideEndPointIndex: number = (wallPoints.length / 2 | 0);
        if (this.wallAtStart != null) {
            const wallAtStartPoints: number[][] = this.wallAtStart.getUnjoinedShapePoints(includeBaseboards);
            const wallAtStartLeftSideStartPointIndex: number = 0;
            const wallAtStartRightSideStartPointIndex: number = wallAtStartPoints.length - 1;
            const wallAtStartLeftSideEndPointIndex: number = (wallAtStartPoints.length / 2 | 0) - 1;
            const wallAtStartRightSideEndPointIndex: number = (wallAtStartPoints.length / 2 | 0);
            const wallAtStartJoinedAtEnd: boolean = this.wallAtStart.getWallAtEnd() === this && (this.wallAtStart.getWallAtStart() !== this || (this.wallAtStart.xEnd === this.xStart && this.wallAtStart.yEnd === this.yStart));
            const wallAtStartJoinedAtStart: boolean = this.wallAtStart.getWallAtStart() === this && (this.wallAtStart.getWallAtEnd() !== this || (this.wallAtStart.xStart === this.xStart && this.wallAtStart.yStart === this.yStart));
            const wallAtStartPointsCache: number[][] = includeBaseboards ? this.wallAtStart.pointsIncludingBaseboardsCache : this.wallAtStart.pointsCache;
            const limit: number = 2 * Math.max(this.thickness, this.wallAtStart.getThickness());
            if (wallAtStartJoinedAtEnd) {
                this.computeIntersection(wallPoints[leftSideStartPointIndex], wallPoints[leftSideStartPointIndex + 1], wallAtStartPoints[wallAtStartLeftSideEndPointIndex], wallAtStartPoints[wallAtStartLeftSideEndPointIndex - 1], limit);
                this.computeIntersection(wallPoints[rightSideStartPointIndex], wallPoints[rightSideStartPointIndex - 1], wallAtStartPoints[wallAtStartRightSideEndPointIndex], wallAtStartPoints[wallAtStartRightSideEndPointIndex + 1], limit);
                if (wallAtStartPointsCache != null) {
                    if (Math.abs(wallPoints[leftSideStartPointIndex][0] - wallAtStartPointsCache[wallAtStartLeftSideEndPointIndex][0]) < epsilon && Math.abs(wallPoints[leftSideStartPointIndex][1] - wallAtStartPointsCache[wallAtStartLeftSideEndPointIndex][1]) < epsilon) {
                        wallPoints[leftSideStartPointIndex] = wallAtStartPointsCache[wallAtStartLeftSideEndPointIndex];
                    }
                    if (Math.abs(wallPoints[rightSideStartPointIndex][0] - wallAtStartPointsCache[wallAtStartRightSideEndPointIndex][0]) < epsilon && Math.abs(wallPoints[rightSideStartPointIndex][1] - wallAtStartPointsCache[wallAtStartRightSideEndPointIndex][1]) < epsilon) {
                        wallPoints[rightSideStartPointIndex] = wallAtStartPointsCache[wallAtStartRightSideEndPointIndex];
                    }
                }
            } else if (wallAtStartJoinedAtStart) {
                this.computeIntersection(wallPoints[leftSideStartPointIndex], wallPoints[leftSideStartPointIndex + 1], wallAtStartPoints[wallAtStartRightSideStartPointIndex], wallAtStartPoints[wallAtStartRightSideStartPointIndex - 1], limit);
                this.computeIntersection(wallPoints[rightSideStartPointIndex], wallPoints[rightSideStartPointIndex - 1], wallAtStartPoints[wallAtStartLeftSideStartPointIndex], wallAtStartPoints[wallAtStartLeftSideStartPointIndex + 1], limit);
                if (wallAtStartPointsCache != null) {
                    if (Math.abs(wallPoints[leftSideStartPointIndex][0] - wallAtStartPointsCache[wallAtStartRightSideStartPointIndex][0]) < epsilon && Math.abs(wallPoints[leftSideStartPointIndex][1] - wallAtStartPointsCache[wallAtStartRightSideStartPointIndex][1]) < epsilon) {
                        wallPoints[leftSideStartPointIndex] = wallAtStartPointsCache[wallAtStartRightSideStartPointIndex];
                    }
                    if (wallAtStartPointsCache != null && Math.abs(wallPoints[rightSideStartPointIndex][0] - wallAtStartPointsCache[wallAtStartLeftSideStartPointIndex][0]) < epsilon && Math.abs(wallPoints[rightSideStartPointIndex][1] - wallAtStartPointsCache[wallAtStartLeftSideStartPointIndex][1]) < epsilon) {
                        wallPoints[rightSideStartPointIndex] = wallAtStartPointsCache[wallAtStartLeftSideStartPointIndex];
                    }
                }
            }
        }
        if (this.wallAtEnd != null) {
            const wallAtEndPoints: number[][] = this.wallAtEnd.getUnjoinedShapePoints(includeBaseboards);
            const wallAtEndLeftSideStartPointIndex: number = 0;
            const wallAtEndRightSideStartPointIndex: number = wallAtEndPoints.length - 1;
            const wallAtEndLeftSideEndPointIndex: number = (wallAtEndPoints.length / 2 | 0) - 1;
            const wallAtEndRightSideEndPointIndex: number = (wallAtEndPoints.length / 2 | 0);
            const wallAtEndJoinedAtStart: boolean = this.wallAtEnd.getWallAtStart() === this && (this.wallAtEnd.getWallAtEnd() !== this || (this.wallAtEnd.xStart === this.xEnd && this.wallAtEnd.yStart === this.yEnd));
            const wallAtEndJoinedAtEnd: boolean = this.wallAtEnd.getWallAtEnd() === this && (this.wallAtEnd.getWallAtStart() !== this || (this.wallAtEnd.xEnd === this.xEnd && this.wallAtEnd.yEnd === this.yEnd));
            const wallAtEndPointsCache: number[][] = includeBaseboards ? this.wallAtEnd.pointsIncludingBaseboardsCache : this.wallAtEnd.pointsCache;
            const limit: number = 2 * Math.max(this.thickness, this.wallAtEnd.getThickness());
            if (wallAtEndJoinedAtStart) {
                this.computeIntersection(wallPoints[leftSideEndPointIndex], wallPoints[leftSideEndPointIndex - 1], wallAtEndPoints[wallAtEndLeftSideStartPointIndex], wallAtEndPoints[wallAtEndLeftSideStartPointIndex + 1], limit);
                this.computeIntersection(wallPoints[rightSideEndPointIndex], wallPoints[rightSideEndPointIndex + 1], wallAtEndPoints[wallAtEndRightSideStartPointIndex], wallAtEndPoints[wallAtEndRightSideStartPointIndex - 1], limit);
                if (wallAtEndPointsCache != null) {
                    if (Math.abs(wallPoints[leftSideEndPointIndex][0] - wallAtEndPointsCache[wallAtEndLeftSideStartPointIndex][0]) < epsilon && Math.abs(wallPoints[leftSideEndPointIndex][1] - wallAtEndPointsCache[wallAtEndLeftSideStartPointIndex][1]) < epsilon) {
                        wallPoints[leftSideEndPointIndex] = wallAtEndPointsCache[wallAtEndLeftSideStartPointIndex];
                    }
                    if (Math.abs(wallPoints[rightSideEndPointIndex][0] - wallAtEndPointsCache[wallAtEndRightSideStartPointIndex][0]) < epsilon && Math.abs(wallPoints[rightSideEndPointIndex][1] - wallAtEndPointsCache[wallAtEndRightSideStartPointIndex][1]) < epsilon) {
                        wallPoints[rightSideEndPointIndex] = wallAtEndPointsCache[wallAtEndRightSideStartPointIndex];
                    }
                }
            } else if (wallAtEndJoinedAtEnd) {
                this.computeIntersection(wallPoints[leftSideEndPointIndex], wallPoints[leftSideEndPointIndex - 1], wallAtEndPoints[wallAtEndRightSideEndPointIndex], wallAtEndPoints[wallAtEndRightSideEndPointIndex + 1], limit);
                this.computeIntersection(wallPoints[rightSideEndPointIndex], wallPoints[rightSideEndPointIndex + 1], wallAtEndPoints[wallAtEndLeftSideEndPointIndex], wallAtEndPoints[wallAtEndLeftSideEndPointIndex - 1], limit);
                if (wallAtEndPointsCache != null) {
                    if (Math.abs(wallPoints[leftSideEndPointIndex][0] - wallAtEndPointsCache[wallAtEndRightSideEndPointIndex][0]) < epsilon && Math.abs(wallPoints[leftSideEndPointIndex][1] - wallAtEndPointsCache[wallAtEndRightSideEndPointIndex][1]) < epsilon) {
                        wallPoints[leftSideEndPointIndex] = wallAtEndPointsCache[wallAtEndRightSideEndPointIndex];
                    }
                    if (Math.abs(wallPoints[rightSideEndPointIndex][0] - wallAtEndPointsCache[wallAtEndLeftSideEndPointIndex][0]) < epsilon && Math.abs(wallPoints[rightSideEndPointIndex][1] - wallAtEndPointsCache[wallAtEndLeftSideEndPointIndex][1]) < epsilon) {
                        wallPoints[rightSideEndPointIndex] = wallAtEndPointsCache[wallAtEndLeftSideEndPointIndex];
                    }
                }
            }
        }
        return wallPoints;
    }

    /**
     * Computes the rectangle or the circle arc of a wall according to its thickness
     * and possibly the thickness of its baseboards.
     * @param {boolean} includeBaseboards
     * @return {float[][]}
     * @private
     */
    getUnjoinedShapePoints(includeBaseboards: boolean): number[][] {
        if (this.arcExtent != null && /* floatValue */this.arcExtent !== 0 && java.awt.geom.Point2D.distanceSq(this.xStart, this.yStart, this.xEnd, this.yEnd) > 1.0E-10) {
            const arcCircleCenter: number[] = this.getArcCircleCenter();
            let startAngle: number = <number>Math.atan2(arcCircleCenter[1] - this.yStart, arcCircleCenter[0] - this.xStart);
            startAngle += 2 * <number>Math.atan2(this.yStart - this.yEnd, this.xEnd - this.xStart);
            const arcCircleRadius: number = <number>java.awt.geom.Point2D.distance(arcCircleCenter[0], arcCircleCenter[1], this.xStart, this.yStart);
            let exteriorArcRadius: number = arcCircleRadius + this.thickness / 2;
            let interiorArcRadius: number = Math.max(0, arcCircleRadius - this.thickness / 2);
            const exteriorArcLength: number = exteriorArcRadius * Math.abs(this.arcExtent);
            let angleDelta: number = this.arcExtent / <number>Math.sqrt(exteriorArcLength);
            let angleStepCount: number = (<number>(this.arcExtent / angleDelta) | 0);
            if (includeBaseboards) {
                if (angleDelta > 0) {
                    if (this.leftSideBaseboard != null) {
                        exteriorArcRadius += this.leftSideBaseboard.getThickness();
                    }
                    if (this.rightSideBaseboard != null) {
                        interiorArcRadius -= this.rightSideBaseboard.getThickness();
                    }
                } else {
                    if (this.leftSideBaseboard != null) {
                        interiorArcRadius -= this.leftSideBaseboard.getThickness();
                    }
                    if (this.rightSideBaseboard != null) {
                        exteriorArcRadius += this.rightSideBaseboard.getThickness();
                    }
                }
            }
            const wallPoints: Array<number[]> = <any>([]);
            if (this.symmetric) {
                if (Math.abs(this.arcExtent - angleStepCount * angleDelta) > 1.0E-6) {
                    angleDelta = this.arcExtent / ++angleStepCount;
                }
                for (let i: number = 0; i <= angleStepCount; i++) {
                    {
                        this.computeRoundWallShapePoint(wallPoints, startAngle + this.arcExtent - i * angleDelta, i, angleDelta, arcCircleCenter, exteriorArcRadius, interiorArcRadius);
                    };
                }
            } else {
                let i: number = 0;
                for (let angle: number = this.arcExtent; angleDelta > 0 ? angle >= angleDelta * 0.1 : angle <= -angleDelta * 0.1; angle -= angleDelta, i++) {
                    {
                        this.computeRoundWallShapePoint(wallPoints, startAngle + angle, i, angleDelta, arcCircleCenter, exteriorArcRadius, interiorArcRadius);
                    };
                }
                this.computeRoundWallShapePoint(wallPoints, startAngle, i, angleDelta, arcCircleCenter, exteriorArcRadius, interiorArcRadius);
            }
            return /* toArray */wallPoints.slice(0);
        } else {
            const angle: number = Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart);
            const sin: number = <number>Math.sin(angle);
            const cos: number = <number>Math.cos(angle);
            let leftSideTickness: number = this.thickness / 2;
            if (includeBaseboards && this.leftSideBaseboard != null) {
                leftSideTickness += this.leftSideBaseboard.getThickness();
            }
            const leftSideDx: number = sin * leftSideTickness;
            const leftSideDy: number = cos * leftSideTickness;
            let rightSideTickness: number = this.thickness / 2;
            if (includeBaseboards && this.rightSideBaseboard != null) {
                rightSideTickness += this.rightSideBaseboard.getThickness();
            }
            const rightSideDx: number = sin * rightSideTickness;
            const rightSideDy: number = cos * rightSideTickness;
            return [[this.xStart + leftSideDx, this.yStart - leftSideDy], [this.xEnd + leftSideDx, this.yEnd - leftSideDy], [this.xEnd - rightSideDx, this.yEnd + rightSideDy], [this.xStart - rightSideDx, this.yStart + rightSideDy]];
        }
    }

    /**
     * Computes the exterior and interior arc points of a round wall at the given <code>index</code>.
     * @param {float[][]} wallPoints
     * @param {number} angle
     * @param {number} index
     * @param {number} angleDelta
     * @param {float[]} arcCircleCenter
     * @param {number} exteriorArcRadius
     * @param {number} interiorArcRadius
     * @private
     */
    computeRoundWallShapePoint(wallPoints: Array<number[]>, angle: number, index: number, angleDelta: number, arcCircleCenter: number[], exteriorArcRadius: number, interiorArcRadius: number) {
        const cos: number = Math.cos(angle);
        const sin: number = Math.sin(angle);
        const interiorArcPoint: number[] = [<number>(arcCircleCenter[0] + interiorArcRadius * cos), <number>(arcCircleCenter[1] - interiorArcRadius * sin)];
        const exteriorArcPoint: number[] = [<number>(arcCircleCenter[0] + exteriorArcRadius * cos), <number>(arcCircleCenter[1] - exteriorArcRadius * sin)];
        if (angleDelta > 0) {
            /* add */wallPoints.splice(index, 0, interiorArcPoint);
            /* add */wallPoints.splice(/* size */(<number>wallPoints.length) - 1 - index, 0, exteriorArcPoint);
        } else {
            /* add */wallPoints.splice(index, 0, exteriorArcPoint);
            /* add */wallPoints.splice(/* size */(<number>wallPoints.length) - 1 - index, 0, interiorArcPoint);
        }
    }

    /**
     * Compute the intersection between the line that joins <code>point1</code> to <code>point2</code>
     * and the line that joins <code>point3</code> and <code>point4</code>, and stores the result
     * in <code>point1</code>.
     * @param {float[]} point1
     * @param {float[]} point2
     * @param {float[]} point3
     * @param {float[]} point4
     * @param {number} limit
     * @private
     */
    computeIntersection(point1: number[], point2: number[], point3: number[], point4: number[], limit: number) {
        const alpha1: number = (point2[1] - point1[1]) / (point2[0] - point1[0]);
        const alpha2: number = (point4[1] - point3[1]) / (point4[0] - point3[0]);
        if (alpha1 !== alpha2) {
            let x: number = point1[0];
            let y: number = point1[1];
            if (Math.abs(alpha1) > 4000) {
                if (Math.abs(alpha2) < 4000) {
                    x = point1[0];
                    const beta2: number = point4[1] - alpha2 * point4[0];
                    y = alpha2 * x + beta2;
                }
            } else if (Math.abs(alpha2) > 4000) {
                if (Math.abs(alpha1) < 4000) {
                    x = point3[0];
                    const beta1: number = point2[1] - alpha1 * point2[0];
                    y = alpha1 * x + beta1;
                }
            } else {
                const sameSignum: boolean = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(alpha1) === /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(alpha2);
                if (Math.abs(alpha1 - alpha2) > 1.0E-5 && (!sameSignum || (Math.abs(alpha1) > Math.abs(alpha2) ? alpha1 / alpha2 : alpha2 / alpha1) > 1.004)) {
                    const beta1: number = point2[1] - alpha1 * point2[0];
                    const beta2: number = point4[1] - alpha2 * point4[0];
                    x = (beta2 - beta1) / (alpha1 - alpha2);
                    y = alpha1 * x + beta1;
                }
            }
            if (java.awt.geom.Point2D.distanceSq(x, y, point1[0], point1[1]) < limit * limit) {
                point1[0] = x;
                point1[1] = y;
            }
        }
    }

    /**
     * Returns <code>true</code> if this wall intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape(false).intersects(rectangle);
    }

    public containsPoint$float$float$float(x: number, y: number, margin: number): boolean {
        return this.containsPoint$float$float$boolean$float(x, y, false, margin);
    }

    public containsPoint$float$float$boolean$float(x: number, y: number, includeBaseboards: boolean, margin: number): boolean {
        return this.containsShapeAtWithMargin(this.getShape(includeBaseboards), x, y, margin);
    }

    /**
     * Returns <code>true</code> if this wall contains the point at (<code>x</code>, <code>y</code>)
     * possibly including its baseboards, with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {boolean} includeBaseboards
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x?: any, y?: any, includeBaseboards?: any, margin?: any): boolean {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof includeBaseboards === 'boolean') || includeBaseboards === null) && ((typeof margin === 'number') || margin === null)) {
            return <any>this.containsPoint$float$float$boolean$float(x, y, includeBaseboards, margin);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof includeBaseboards === 'number') || includeBaseboards === null) && margin === undefined) {
            return <any>this.containsPoint$float$float$float(x, y, includeBaseboards);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns <code>true</code> if the middle point of this wall is the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isMiddlePointAt(x: number, y: number, margin: number): boolean {
        const wallPoints: number[][] = this.getPoints$();
        const leftSideMiddlePointIndex: number = (wallPoints.length / 4 | 0);
        const rightSideMiddlePointIndex: number = wallPoints.length - 1 - leftSideMiddlePointIndex;
        const middleLine: java.awt.geom.Line2D = wallPoints.length % 4 === 0 ? new java.awt.geom.Line2D.Float((wallPoints[leftSideMiddlePointIndex - 1][0] + wallPoints[leftSideMiddlePointIndex][0]) / 2, (wallPoints[leftSideMiddlePointIndex - 1][1] + wallPoints[leftSideMiddlePointIndex][1]) / 2, (wallPoints[rightSideMiddlePointIndex][0] + wallPoints[rightSideMiddlePointIndex + 1][0]) / 2, (wallPoints[rightSideMiddlePointIndex][1] + wallPoints[rightSideMiddlePointIndex + 1][1]) / 2) : new java.awt.geom.Line2D.Float(wallPoints[leftSideMiddlePointIndex][0], wallPoints[leftSideMiddlePointIndex][1], wallPoints[rightSideMiddlePointIndex][0], wallPoints[rightSideMiddlePointIndex][1]);
        return this.containsShapeAtWithMargin(middleLine, x, y, margin);
    }

    /**
     * Returns <code>true</code> if this wall start line contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code> around the wall start line.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsWallStartAt(x: number, y: number, margin: number): boolean {
        const wallPoints: number[][] = this.getPoints$();
        const startLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(wallPoints[0][0], wallPoints[0][1], wallPoints[wallPoints.length - 1][0], wallPoints[wallPoints.length - 1][1]);
        return this.containsShapeAtWithMargin(startLine, x, y, margin);
    }

    /**
     * Returns <code>true</code> if this wall end line contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code> around the wall end line.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsWallEndAt(x: number, y: number, margin: number): boolean {
        const wallPoints: number[][] = this.getPoints$();
        const endLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(wallPoints[(wallPoints.length / 2 | 0) - 1][0], wallPoints[(wallPoints.length / 2 | 0) - 1][1], wallPoints[(wallPoints.length / 2 | 0)][0], wallPoints[(wallPoints.length / 2 | 0)][1]);
        return this.containsShapeAtWithMargin(endLine, x, y, margin);
    }

    /**
     * Returns <code>true</code> if <code>shape</code> contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {Object} shape
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     * @private
     */
    containsShapeAtWithMargin(shape: java.awt.Shape, x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return shape.contains(x, y);
        } else {
            return shape.intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns the shape matching this wall.
     * @param {boolean} includeBaseboards
     * @return {Object}
     * @private
     */
    getShape(includeBaseboards: boolean): java.awt.Shape {
        if (this.shapeCache == null) {
            const wallPoints: number[][] = this.getPoints$boolean(includeBaseboards);
            const wallPath: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            wallPath.moveTo(wallPoints[0][0], wallPoints[0][1]);
            for (let i: number = 1; i < wallPoints.length; i++) {
                {
                    wallPath.lineTo(wallPoints[i][0], wallPoints[i][1]);
                };
            }
            wallPath.closePath();
            this.shapeCache = wallPath;
        }
        return this.shapeCache;
    }

    /**
     * Moves this wall of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setXStart(this.getXStart() + dx);
        this.setYStart(this.getYStart() + dy);
        this.setXEnd(this.getXEnd() + dx);
        this.setYEnd(this.getYEnd() + dy);
    }

    /**
     * Returns a duplicate of the <code>walls</code> list. All existing walls
     * are copied and their wall at start and end point are set with copied
     * walls only if they belong to the returned list.
     * The id of duplicated walls are regenerated.
     * @param {Wall[]} walls
     * @return {Wall[]}
     */
    public static duplicate(walls: Array<Wall>): Array<Wall> {
        const wallsCopy: Array<Wall> = <any>([]);
        for (let index = 0; index < walls.length; index++) {
            let wall = walls[index];
            {
                /* add */(wallsCopy.push(<Wall>wall.duplicate()) > 0);
            }
        }
        Wall.updateBoundWalls(wallsCopy, walls);
        return wallsCopy;
    }

    /**
     * Returns a clone of the <code>walls</code> list. All existing walls
     * are copied and their wall at start and end point are set with copied
     * walls only if they belong to the returned list.
     * @param {Wall[]} walls
     * @return {Wall[]}
     */
    public static clone(walls: Array<Wall>): Array<Wall> {
        const wallsCopy: Array<Wall> = <any>([]);
        for (let index = 0; index < walls.length; index++) {
            let wall = walls[index];
            {
                /* add */(wallsCopy.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(wall)) > 0);
            }
        }
        Wall.updateBoundWalls(wallsCopy, walls);
        return wallsCopy;
    }

    static updateBoundWalls(wallsCopy: Array<Wall>, walls: Array<Wall>) {
        for (let i: number = 0; i < /* size */(<number>walls.length); i++) {
            {
                const wall: Wall = /* get */walls[i];
                const wallAtStartIndex: number = walls.indexOf(wall.getWallAtStart());
                if (wallAtStartIndex !== -1) {
                /* get */wallsCopy[i].setWallAtStart(/* get */wallsCopy[wallAtStartIndex]);
                }
                const wallAtEndIndex: number = walls.indexOf(wall.getWallAtEnd());
                if (wallAtEndIndex !== -1) {
                /* get */wallsCopy[i].setWallAtEnd(/* get */wallsCopy[wallAtEndIndex]);
                }
            };
        }
    }

    /**
     * Returns a clone of this wall expected
     * its wall at start and wall at end aren't copied.
     * @return {Wall}
     */
    public clone(): Wall {
        const clone: Wall = <Wall>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.wallAtStart = null;
        clone.wallAtEnd = null;
        clone.level = null;
        clone.shapeCache = null;
        clone.pointsCache = null;
        clone.pointsIncludingBaseboardsCache = null;
        return clone;
    }
}
Wall["__class"] = "com.eteks.sweethome3d.model.Wall";
Wall["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.Elevatable"];

Wall['__transients'] = ['shapeCache', 'arcCircleCenterCache', 'pointsCache', 'pointsIncludingBaseboardsCache', 'propertyChangeSupport'];

/**
 * Creates home environment from parameters.
 * @param {string} id
 * @param {number} groundColor
 * @param {HomeTexture} groundTexture
 * @param {number} skyColor
 * @param {HomeTexture} skyTexture
 * @param {number} lightColor
 * @param {number} wallsAlpha
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class HomeEnvironment extends HomeObject {
    /*private*/ observerCameraElevationAdjusted: boolean;

    /*private*/ groundColor: number;

    /*private*/ groundTexture: HomeTexture;

    /*private*/ backgroundImageVisibleOnGround3D: boolean;

    /*private*/ skyColor: number;

    /*private*/ skyTexture: HomeTexture;

    /*private*/ lightColor: number;

    /*private*/ ceilingLightColor: number;

    /*private*/ wallsAlpha: number;

    /*private*/ drawingMode: HomeEnvironment.DrawingMode;

    /*private*/ subpartSizeUnderLight: number;

    /*private*/ allLevelsVisible: boolean;

    /*private*/ photoWidth: number;

    /*private*/ photoHeight: number;

    /*private*/ photoAspectRatio: AspectRatio;

    /*private*/ photoAspectRatioName: string;

    /*private*/ photoQuality: number;

    /*private*/ videoWidth: number;

    /*private*/ videoAspectRatio: AspectRatio;

    /*private*/ videoAspectRatioName: string;

    /*private*/ videoQuality: number;

    /*private*/ videoSpeed: number;

    /*private*/ videoFrameRate: number;

    /*private*/ cameraPath: Array<Camera>;

    public constructor(id?: any, groundColor?: any, groundTexture?: any, skyColor?: any, skyTexture?: any, lightColor?: any, wallsAlpha?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof groundColor === 'number') || groundColor === null) && ((groundTexture != null && groundTexture instanceof <any>HomeTexture) || groundTexture === null) && ((typeof skyColor === 'number') || skyColor === null) && ((skyTexture != null && skyTexture instanceof <any>HomeTexture) || skyTexture === null) && ((typeof lightColor === 'number') || lightColor === null) && ((typeof wallsAlpha === 'number') || wallsAlpha === null)) {
            let __args = arguments;
            super(id);
            if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.drawingMode === undefined) { this.drawingMode = null; }
            if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
            if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
            if (this.photoWidth === undefined) { this.photoWidth = 0; }
            if (this.photoHeight === undefined) { this.photoHeight = 0; }
            if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
            if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
            if (this.photoQuality === undefined) { this.photoQuality = 0; }
            if (this.videoWidth === undefined) { this.videoWidth = 0; }
            if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
            if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
            if (this.videoQuality === undefined) { this.videoQuality = 0; }
            if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
            if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
            if (this.cameraPath === undefined) { this.cameraPath = null; }
            this.observerCameraElevationAdjusted = true;
            this.groundColor = groundColor;
            this.groundTexture = groundTexture;
            this.skyColor = skyColor;
            this.skyTexture = skyTexture;
            this.lightColor = lightColor;
            this.ceilingLightColor = 13684944;
            this.wallsAlpha = wallsAlpha;
            this.drawingMode = HomeEnvironment.DrawingMode.FILL;
            this.photoWidth = 400;
            this.photoHeight = 300;
            this.photoAspectRatio = AspectRatio.VIEW_3D_RATIO;
            this.videoWidth = 320;
            this.videoAspectRatio = AspectRatio.RATIO_4_3;
            this.videoSpeed = 2400.0 / 3600;
            this.videoFrameRate = 25;
            this.cameraPath = /* emptyList */[];
        } else if (((typeof id === 'number') || id === null) && ((groundColor != null && groundColor instanceof <any>HomeTexture) || groundColor === null) && ((typeof groundTexture === 'number') || groundTexture === null) && ((skyColor != null && skyColor instanceof <any>HomeTexture) || skyColor === null) && ((typeof skyTexture === 'number') || skyTexture === null) && ((typeof lightColor === 'number') || lightColor === null) && wallsAlpha === undefined) {
            let __args = arguments;
            let groundColor: any = __args[0];
            let groundTexture: any = __args[1];
            let skyColor: any = __args[2];
            let skyTexture: any = __args[3];
            let lightColor: any = __args[4];
            let wallsAlpha: any = __args[5];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("environment");
                super(id);
                if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.skyTexture === undefined) { this.skyTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.drawingMode === undefined) { this.drawingMode = null; }
                if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                if (this.photoWidth === undefined) { this.photoWidth = 0; }
                if (this.photoHeight === undefined) { this.photoHeight = 0; }
                if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                if (this.photoQuality === undefined) { this.photoQuality = 0; }
                if (this.videoWidth === undefined) { this.videoWidth = 0; }
                if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                if (this.videoQuality === undefined) { this.videoQuality = 0; }
                if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                if (this.cameraPath === undefined) { this.cameraPath = null; }
                this.observerCameraElevationAdjusted = true;
                this.groundColor = groundColor;
                this.groundTexture = groundTexture;
                this.skyColor = skyColor;
                this.skyTexture = skyTexture;
                this.lightColor = lightColor;
                this.ceilingLightColor = 13684944;
                this.wallsAlpha = wallsAlpha;
                this.drawingMode = HomeEnvironment.DrawingMode.FILL;
                this.photoWidth = 400;
                this.photoHeight = 300;
                this.photoAspectRatio = AspectRatio.VIEW_3D_RATIO;
                this.videoWidth = 320;
                this.videoAspectRatio = AspectRatio.RATIO_4_3;
                this.videoSpeed = 2400.0 / 3600;
                this.videoFrameRate = 25;
                this.cameraPath = /* emptyList */[];
            }
            if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.drawingMode === undefined) { this.drawingMode = null; }
            if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
            if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
            if (this.photoWidth === undefined) { this.photoWidth = 0; }
            if (this.photoHeight === undefined) { this.photoHeight = 0; }
            if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
            if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
            if (this.photoQuality === undefined) { this.photoQuality = 0; }
            if (this.videoWidth === undefined) { this.videoWidth = 0; }
            if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
            if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
            if (this.videoQuality === undefined) { this.videoQuality = 0; }
            if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
            if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
            if (this.cameraPath === undefined) { this.cameraPath = null; }
        } else if (((typeof id === 'number') || id === null) && ((groundColor != null && groundColor instanceof <any>HomeTexture) || groundColor === null) && ((typeof groundTexture === 'number') || groundTexture === null) && ((typeof skyColor === 'number') || skyColor === null) && ((typeof skyTexture === 'number') || skyTexture === null) && lightColor === undefined && wallsAlpha === undefined) {
            let __args = arguments;
            let groundColor: any = __args[0];
            let groundTexture: any = __args[1];
            let skyColor: any = __args[2];
            let lightColor: any = __args[3];
            let wallsAlpha: any = __args[4];
            {
                let __args = arguments;
                let skyTexture: any = null;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("environment");
                    super(id);
                    if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                    if (this.groundColor === undefined) { this.groundColor = 0; }
                    if (this.groundTexture === undefined) { this.groundTexture = null; }
                    if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                    if (this.skyColor === undefined) { this.skyColor = 0; }
                    if (this.skyTexture === undefined) { this.skyTexture = null; }
                    if (this.lightColor === undefined) { this.lightColor = 0; }
                    if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                    if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                    if (this.drawingMode === undefined) { this.drawingMode = null; }
                    if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                    if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                    if (this.photoWidth === undefined) { this.photoWidth = 0; }
                    if (this.photoHeight === undefined) { this.photoHeight = 0; }
                    if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                    if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                    if (this.photoQuality === undefined) { this.photoQuality = 0; }
                    if (this.videoWidth === undefined) { this.videoWidth = 0; }
                    if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                    if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                    if (this.videoQuality === undefined) { this.videoQuality = 0; }
                    if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                    if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                    if (this.cameraPath === undefined) { this.cameraPath = null; }
                    this.observerCameraElevationAdjusted = true;
                    this.groundColor = groundColor;
                    this.groundTexture = groundTexture;
                    this.skyColor = skyColor;
                    this.skyTexture = skyTexture;
                    this.lightColor = lightColor;
                    this.ceilingLightColor = 13684944;
                    this.wallsAlpha = wallsAlpha;
                    this.drawingMode = HomeEnvironment.DrawingMode.FILL;
                    this.photoWidth = 400;
                    this.photoHeight = 300;
                    this.photoAspectRatio = AspectRatio.VIEW_3D_RATIO;
                    this.videoWidth = 320;
                    this.videoAspectRatio = AspectRatio.RATIO_4_3;
                    this.videoSpeed = 2400.0 / 3600;
                    this.videoFrameRate = 25;
                    this.cameraPath = /* emptyList */[];
                }
                if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.skyTexture === undefined) { this.skyTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.drawingMode === undefined) { this.drawingMode = null; }
                if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                if (this.photoWidth === undefined) { this.photoWidth = 0; }
                if (this.photoHeight === undefined) { this.photoHeight = 0; }
                if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                if (this.photoQuality === undefined) { this.photoQuality = 0; }
                if (this.videoWidth === undefined) { this.videoWidth = 0; }
                if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                if (this.videoQuality === undefined) { this.videoQuality = 0; }
                if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                if (this.cameraPath === undefined) { this.cameraPath = null; }
            }
            if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.drawingMode === undefined) { this.drawingMode = null; }
            if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
            if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
            if (this.photoWidth === undefined) { this.photoWidth = 0; }
            if (this.photoHeight === undefined) { this.photoHeight = 0; }
            if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
            if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
            if (this.photoQuality === undefined) { this.photoQuality = 0; }
            if (this.videoWidth === undefined) { this.videoWidth = 0; }
            if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
            if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
            if (this.videoQuality === undefined) { this.videoQuality = 0; }
            if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
            if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
            if (this.cameraPath === undefined) { this.cameraPath = null; }
        } else if (((typeof id === 'string') || id === null) && groundColor === undefined && groundTexture === undefined && skyColor === undefined && skyTexture === undefined && lightColor === undefined && wallsAlpha === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let groundColor: any = 11053224;
                let groundTexture: any = null;
                let skyColor: any = 13427964;
                let skyTexture: any = null;
                let lightColor: any = 13684944;
                let wallsAlpha: any = 0;
                super(id);
                if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.skyTexture === undefined) { this.skyTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.drawingMode === undefined) { this.drawingMode = null; }
                if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                if (this.photoWidth === undefined) { this.photoWidth = 0; }
                if (this.photoHeight === undefined) { this.photoHeight = 0; }
                if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                if (this.photoQuality === undefined) { this.photoQuality = 0; }
                if (this.videoWidth === undefined) { this.videoWidth = 0; }
                if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                if (this.videoQuality === undefined) { this.videoQuality = 0; }
                if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                if (this.cameraPath === undefined) { this.cameraPath = null; }
                this.observerCameraElevationAdjusted = true;
                this.groundColor = groundColor;
                this.groundTexture = groundTexture;
                this.skyColor = skyColor;
                this.skyTexture = skyTexture;
                this.lightColor = lightColor;
                this.ceilingLightColor = 13684944;
                this.wallsAlpha = wallsAlpha;
                this.drawingMode = HomeEnvironment.DrawingMode.FILL;
                this.photoWidth = 400;
                this.photoHeight = 300;
                this.photoAspectRatio = AspectRatio.VIEW_3D_RATIO;
                this.videoWidth = 320;
                this.videoAspectRatio = AspectRatio.RATIO_4_3;
                this.videoSpeed = 2400.0 / 3600;
                this.videoFrameRate = 25;
                this.cameraPath = /* emptyList */[];
            }
            if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.drawingMode === undefined) { this.drawingMode = null; }
            if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
            if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
            if (this.photoWidth === undefined) { this.photoWidth = 0; }
            if (this.photoHeight === undefined) { this.photoHeight = 0; }
            if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
            if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
            if (this.photoQuality === undefined) { this.photoQuality = 0; }
            if (this.videoWidth === undefined) { this.videoWidth = 0; }
            if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
            if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
            if (this.videoQuality === undefined) { this.videoQuality = 0; }
            if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
            if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
            if (this.cameraPath === undefined) { this.cameraPath = null; }
        } else if (id === undefined && groundColor === undefined && groundTexture === undefined && skyColor === undefined && skyTexture === undefined && lightColor === undefined && wallsAlpha === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let id: any = HomeObject.createId("environment");
                {
                    let __args = arguments;
                    let groundColor: any = 11053224;
                    let groundTexture: any = null;
                    let skyColor: any = 13427964;
                    let skyTexture: any = null;
                    let lightColor: any = 13684944;
                    let wallsAlpha: any = 0;
                    super(id);
                    if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                    if (this.groundColor === undefined) { this.groundColor = 0; }
                    if (this.groundTexture === undefined) { this.groundTexture = null; }
                    if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                    if (this.skyColor === undefined) { this.skyColor = 0; }
                    if (this.skyTexture === undefined) { this.skyTexture = null; }
                    if (this.lightColor === undefined) { this.lightColor = 0; }
                    if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                    if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                    if (this.drawingMode === undefined) { this.drawingMode = null; }
                    if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                    if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                    if (this.photoWidth === undefined) { this.photoWidth = 0; }
                    if (this.photoHeight === undefined) { this.photoHeight = 0; }
                    if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                    if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                    if (this.photoQuality === undefined) { this.photoQuality = 0; }
                    if (this.videoWidth === undefined) { this.videoWidth = 0; }
                    if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                    if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                    if (this.videoQuality === undefined) { this.videoQuality = 0; }
                    if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                    if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                    if (this.cameraPath === undefined) { this.cameraPath = null; }
                    this.observerCameraElevationAdjusted = true;
                    this.groundColor = groundColor;
                    this.groundTexture = groundTexture;
                    this.skyColor = skyColor;
                    this.skyTexture = skyTexture;
                    this.lightColor = lightColor;
                    this.ceilingLightColor = 13684944;
                    this.wallsAlpha = wallsAlpha;
                    this.drawingMode = HomeEnvironment.DrawingMode.FILL;
                    this.photoWidth = 400;
                    this.photoHeight = 300;
                    this.photoAspectRatio = AspectRatio.VIEW_3D_RATIO;
                    this.videoWidth = 320;
                    this.videoAspectRatio = AspectRatio.RATIO_4_3;
                    this.videoSpeed = 2400.0 / 3600;
                    this.videoFrameRate = 25;
                    this.cameraPath = /* emptyList */[];
                }
                if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.skyTexture === undefined) { this.skyTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.drawingMode === undefined) { this.drawingMode = null; }
                if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
                if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
                if (this.photoWidth === undefined) { this.photoWidth = 0; }
                if (this.photoHeight === undefined) { this.photoHeight = 0; }
                if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
                if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
                if (this.photoQuality === undefined) { this.photoQuality = 0; }
                if (this.videoWidth === undefined) { this.videoWidth = 0; }
                if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
                if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
                if (this.videoQuality === undefined) { this.videoQuality = 0; }
                if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
                if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
                if (this.cameraPath === undefined) { this.cameraPath = null; }
            }
            if (this.observerCameraElevationAdjusted === undefined) { this.observerCameraElevationAdjusted = false; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.ceilingLightColor === undefined) { this.ceilingLightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.drawingMode === undefined) { this.drawingMode = null; }
            if (this.subpartSizeUnderLight === undefined) { this.subpartSizeUnderLight = 0; }
            if (this.allLevelsVisible === undefined) { this.allLevelsVisible = false; }
            if (this.photoWidth === undefined) { this.photoWidth = 0; }
            if (this.photoHeight === undefined) { this.photoHeight = 0; }
            if (this.photoAspectRatio === undefined) { this.photoAspectRatio = null; }
            if (this.photoAspectRatioName === undefined) { this.photoAspectRatioName = null; }
            if (this.photoQuality === undefined) { this.photoQuality = 0; }
            if (this.videoWidth === undefined) { this.videoWidth = 0; }
            if (this.videoAspectRatio === undefined) { this.videoAspectRatio = null; }
            if (this.videoAspectRatioName === undefined) { this.videoAspectRatioName = null; }
            if (this.videoQuality === undefined) { this.videoQuality = 0; }
            if (this.videoSpeed === undefined) { this.videoSpeed = 0; }
            if (this.videoFrameRate === undefined) { this.videoFrameRate = 0; }
            if (this.cameraPath === undefined) { this.cameraPath = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns <code>true</code> if the observer elevation should be adjusted according
     * to the elevation of the selected level.
     * @return {boolean}
     */
    public isObserverCameraElevationAdjusted(): boolean {
        return this.observerCameraElevationAdjusted;
    }

    /**
     * Sets whether the observer elevation should be adjusted according
     * to the elevation of the selected level and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} observerCameraElevationAdjusted
     */
    public setObserverCameraElevationAdjusted(observerCameraElevationAdjusted: boolean) {
        if (this.observerCameraElevationAdjusted !== observerCameraElevationAdjusted) {
            this.observerCameraElevationAdjusted = observerCameraElevationAdjusted;
            this.firePropertyChange(/* name */"OBSERVER_CAMERA_ELEVATION_ADJUSTED", !observerCameraElevationAdjusted, observerCameraElevationAdjusted);
        }
    }

    /**
     * Returns the ground color of this environment.
     * @return {number}
     */
    public getGroundColor(): number {
        return this.groundColor;
    }

    /**
     * Sets the ground color of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {number} groundColor
     */
    public setGroundColor(groundColor: number) {
        if (groundColor !== this.groundColor) {
            const oldGroundColor: number = this.groundColor;
            this.groundColor = groundColor;
            this.firePropertyChange(/* name */"GROUND_COLOR", oldGroundColor, groundColor);
        }
    }

    /**
     * Returns the ground texture of this environment.
     * @return {HomeTexture}
     */
    public getGroundTexture(): HomeTexture {
        return this.groundTexture;
    }

    /**
     * Sets the ground texture of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {HomeTexture} groundTexture
     */
    public setGroundTexture(groundTexture: HomeTexture) {
        if (groundTexture !== this.groundTexture) {
            const oldGroundTexture: HomeTexture = this.groundTexture;
            this.groundTexture = groundTexture;
            this.firePropertyChange(/* name */"GROUND_TEXTURE", oldGroundTexture, groundTexture);
        }
    }

    /**
     * Returns <code>true</code> if the background image should be displayed on the ground in 3D.
     * @return {boolean}
     */
    public isBackgroundImageVisibleOnGround3D(): boolean {
        return this.backgroundImageVisibleOnGround3D;
    }

    /**
     * Sets whether the background image should be displayed on the ground in 3D and
     * fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} backgroundImageVisibleOnGround3D
     */
    public setBackgroundImageVisibleOnGround3D(backgroundImageVisibleOnGround3D: boolean) {
        if (this.backgroundImageVisibleOnGround3D !== backgroundImageVisibleOnGround3D) {
            this.backgroundImageVisibleOnGround3D = backgroundImageVisibleOnGround3D;
            this.firePropertyChange(/* name */"BACKGROUND_IMAGE_VISIBLE_ON_GROUND_3D", !backgroundImageVisibleOnGround3D, backgroundImageVisibleOnGround3D);
        }
    }

    /**
     * Returns the sky color of this environment.
     * @return {number}
     */
    public getSkyColor(): number {
        return this.skyColor;
    }

    /**
     * Sets the sky color of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {number} skyColor
     */
    public setSkyColor(skyColor: number) {
        if (skyColor !== this.skyColor) {
            const oldSkyColor: number = this.skyColor;
            this.skyColor = skyColor;
            this.firePropertyChange(/* name */"SKY_COLOR", oldSkyColor, skyColor);
        }
    }

    /**
     * Returns the sky texture of this environment.
     * @return {HomeTexture}
     */
    public getSkyTexture(): HomeTexture {
        return this.skyTexture;
    }

    /**
     * Sets the sky texture of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {HomeTexture} skyTexture
     */
    public setSkyTexture(skyTexture: HomeTexture) {
        if (skyTexture !== this.skyTexture) {
            const oldSkyTexture: HomeTexture = this.skyTexture;
            this.skyTexture = skyTexture;
            this.firePropertyChange(/* name */"SKY_TEXTURE", oldSkyTexture, skyTexture);
        }
    }

    /**
     * Returns the light color of this environment.
     * @return {number}
     */
    public getLightColor(): number {
        return this.lightColor;
    }

    /**
     * Sets the color that lights this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {number} lightColor
     */
    public setLightColor(lightColor: number) {
        if (lightColor !== this.lightColor) {
            const oldLightColor: number = this.lightColor;
            this.lightColor = lightColor;
            this.firePropertyChange(/* name */"LIGHT_COLOR", oldLightColor, lightColor);
        }
    }

    /**
     * Returns the color of ceiling lights.
     * @return {number}
     */
    public getCeillingLightColor(): number {
        return this.ceilingLightColor;
    }

    /**
     * Sets the color of ceiling lights and fires a <code>PropertyChangeEvent</code>.
     * @param {number} ceilingLightColor
     */
    public setCeillingLightColor(ceilingLightColor: number) {
        if (ceilingLightColor !== this.ceilingLightColor) {
            const oldCeilingLightColor: number = this.ceilingLightColor;
            this.ceilingLightColor = ceilingLightColor;
            this.firePropertyChange(/* name */"CEILING_LIGHT_COLOR", oldCeilingLightColor, ceilingLightColor);
        }
    }

    /**
     * Returns the walls transparency alpha factor of this environment.
     * @return {number}
     */
    public getWallsAlpha(): number {
        return this.wallsAlpha;
    }

    /**
     * Sets the walls transparency alpha of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {number} wallsAlpha a value between 0 and 1, 0 meaning opaque and 1 invisible.
     */
    public setWallsAlpha(wallsAlpha: number) {
        if (wallsAlpha !== this.wallsAlpha) {
            const oldWallsAlpha: number = this.wallsAlpha;
            this.wallsAlpha = wallsAlpha;
            this.firePropertyChange(/* name */"WALLS_ALPHA", oldWallsAlpha, wallsAlpha);
        }
    }

    /**
     * Returns the drawing mode of this environment.
     * @return {HomeEnvironment.DrawingMode}
     */
    public getDrawingMode(): HomeEnvironment.DrawingMode {
        return this.drawingMode;
    }

    /**
     * Sets the drawing mode of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {HomeEnvironment.DrawingMode} drawingMode
     */
    public setDrawingMode(drawingMode: HomeEnvironment.DrawingMode) {
        if (drawingMode !== this.drawingMode) {
            const oldDrawingMode: HomeEnvironment.DrawingMode = this.drawingMode;
            this.drawingMode = drawingMode;
            this.firePropertyChange(/* name */"DRAWING_MODE", oldDrawingMode, drawingMode);
        }
    }

    /**
     * Returns the size of subparts under home lights in this environment.
     * @return {number} a size in centimeters or 0 if home lights don't illuminate home.
     */
    public getSubpartSizeUnderLight(): number {
        return this.subpartSizeUnderLight;
    }

    /**
     * Sets the size of subparts under home lights of this environment and fires a <code>PropertyChangeEvent</code>.
     * @param {number} subpartSizeUnderLight
     */
    public setSubpartSizeUnderLight(subpartSizeUnderLight: number) {
        if (subpartSizeUnderLight !== this.subpartSizeUnderLight) {
            const oldSubpartWidthUnderLight: number = this.subpartSizeUnderLight;
            this.subpartSizeUnderLight = subpartSizeUnderLight;
            this.firePropertyChange(/* name */"SUBPART_SIZE_UNDER_LIGHT", oldSubpartWidthUnderLight, subpartSizeUnderLight);
        }
    }

    /**
     * Returns whether all levels should be visible or not.
     * @return {boolean}
     */
    public isAllLevelsVisible(): boolean {
        return this.allLevelsVisible;
    }

    /**
     * Sets whether all levels should be visible or not and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} allLevelsVisible
     */
    public setAllLevelsVisible(allLevelsVisible: boolean) {
        if (allLevelsVisible !== this.allLevelsVisible) {
            this.allLevelsVisible = allLevelsVisible;
            this.firePropertyChange(/* name */"ALL_LEVELS_VISIBLE", !allLevelsVisible, allLevelsVisible);
        }
    }

    /**
     * Returns the preferred photo width.
     * @return {number}
     */
    public getPhotoWidth(): number {
        return this.photoWidth;
    }

    /**
     * Sets the preferred photo width, and notifies
     * listeners of this change.
     * @param {number} photoWidth
     */
    public setPhotoWidth(photoWidth: number) {
        if (this.photoWidth !== photoWidth) {
            const oldPhotoWidth: number = this.photoWidth;
            this.photoWidth = photoWidth;
            this.firePropertyChange(/* name */"PHOTO_WIDTH", oldPhotoWidth, photoWidth);
        }
    }

    /**
     * Returns the preferred photo height.
     * @return {number}
     */
    public getPhotoHeight(): number {
        return this.photoHeight;
    }

    /**
     * Sets the preferred photo height, and notifies
     * listeners of this change.
     * @param {number} photoHeight
     */
    public setPhotoHeight(photoHeight: number) {
        if (this.photoHeight !== photoHeight) {
            const oldPhotoHeight: number = this.photoHeight;
            this.photoHeight = photoHeight;
            this.firePropertyChange(/* name */"PHOTO_HEIGHT", oldPhotoHeight, photoHeight);
        }
    }

    /**
     * Returns the preferred photo aspect ratio.
     * @return {AspectRatio}
     */
    public getPhotoAspectRatio(): AspectRatio {
        return this.photoAspectRatio;
    }

    /**
     * Sets the preferred photo aspect ratio, and notifies
     * listeners of this change.
     * @param {AspectRatio} photoAspectRatio
     */
    public setPhotoAspectRatio(photoAspectRatio: AspectRatio) {
        if (this.photoAspectRatio !== photoAspectRatio) {
            const oldPhotoAspectRatio: AspectRatio = this.photoAspectRatio;
            this.photoAspectRatio = photoAspectRatio;
            this.photoAspectRatioName = /* Enum.name */AspectRatio[this.photoAspectRatio];
            this.firePropertyChange(/* name */"PHOTO_ASPECT_RATIO", oldPhotoAspectRatio, photoAspectRatio);
        }
    }

    /**
     * Returns the preferred photo quality.
     * @return {number}
     */
    public getPhotoQuality(): number {
        return this.photoQuality;
    }

    /**
     * Sets preferred photo quality, and notifies
     * listeners of this change.
     * @param {number} photoQuality
     */
    public setPhotoQuality(photoQuality: number) {
        if (this.photoQuality !== photoQuality) {
            const oldPhotoQuality: number = this.photoQuality;
            this.photoQuality = photoQuality;
            this.firePropertyChange(/* name */"PHOTO_QUALITY", oldPhotoQuality, photoQuality);
        }
    }

    /**
     * Returns the preferred video width.
     * @return {number}
     */
    public getVideoWidth(): number {
        return this.videoWidth;
    }

    /**
     * Sets the preferred video width, and notifies
     * listeners of this change.
     * @param {number} videoWidth
     */
    public setVideoWidth(videoWidth: number) {
        if (this.videoWidth !== videoWidth) {
            const oldVideoWidth: number = this.videoWidth;
            this.videoWidth = videoWidth;
            this.firePropertyChange(/* name */"VIDEO_WIDTH", oldVideoWidth, videoWidth);
        }
    }

    /**
     * Returns the preferred video height.
     * @return {number}
     */
    public getVideoHeight(): number {
        return Math.round(this.getVideoWidth() / { FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[this.getVideoAspectRatio()]);
    }

    /**
     * Returns the preferred video aspect ratio.
     * @return {AspectRatio}
     */
    public getVideoAspectRatio(): AspectRatio {
        return this.videoAspectRatio;
    }

    /**
     * Sets the preferred video aspect ratio, and notifies
     * listeners of this change.
     * @param {AspectRatio} videoAspectRatio
     */
    public setVideoAspectRatio(videoAspectRatio: AspectRatio) {
        if (this.videoAspectRatio !== videoAspectRatio) {
            if ({ FREE_RATIO: null, VIEW_3D_RATIO: null, RATIO_4_3: 4 / 3, RATIO_3_2: 1.5, RATIO_16_9: 16 / 9, RATIO_2_1: 2 / 1, SQUARE_RATIO: 1 }[videoAspectRatio] == null) {
                throw new IllegalArgumentException("Unsupported aspect ratio " + videoAspectRatio);
            }
            const oldVideoAspectRatio: AspectRatio = this.videoAspectRatio;
            this.videoAspectRatio = videoAspectRatio;
            this.videoAspectRatioName = /* Enum.name */AspectRatio[this.videoAspectRatio];
            this.firePropertyChange(/* name */"VIDEO_ASPECT_RATIO", oldVideoAspectRatio, videoAspectRatio);
        }
    }

    /**
     * Returns preferred video quality.
     * @return {number}
     */
    public getVideoQuality(): number {
        return this.videoQuality;
    }

    /**
     * Sets the preferred video quality, and notifies
     * listeners of this change.
     * @param {number} videoQuality
     */
    public setVideoQuality(videoQuality: number) {
        if (this.videoQuality !== videoQuality) {
            const oldVideoQuality: number = this.videoQuality;
            this.videoQuality = videoQuality;
            this.firePropertyChange(/* name */"VIDEO_QUALITY", oldVideoQuality, videoQuality);
        }
    }

    /**
     * Returns the preferred speed of movements in videos in m/s.
     * @return {number}
     */
    public getVideoSpeed(): number {
        return this.videoSpeed;
    }

    /**
     * Sets the preferred speed of movements in videos in m/s.
     * @param {number} videoSpeed
     */
    public setVideoSpeed(videoSpeed: number) {
        if (this.videoSpeed !== videoSpeed) {
            const oldVideoSpeed: number = this.videoSpeed;
            this.videoSpeed = videoSpeed;
            this.firePropertyChange(/* name */"VIDEO_SPEED", oldVideoSpeed, videoSpeed);
        }
    }

    /**
     * Returns the preferred video frame rate.
     * @return {number}
     */
    public getVideoFrameRate(): number {
        return this.videoFrameRate;
    }

    /**
     * Sets the preferred video frame rate, and notifies
     * listeners of this change.
     * @param {number} videoFrameRate
     */
    public setVideoFrameRate(videoFrameRate: number) {
        if (this.videoFrameRate !== videoFrameRate) {
            const oldVideoFrameRate: number = this.videoFrameRate;
            this.videoFrameRate = videoFrameRate;
            this.firePropertyChange(/* name */"VIDEO_FRAME_RATE", oldVideoFrameRate, videoFrameRate);
        }
    }

    /**
     * Returns the preferred video camera path.
     * @return {Camera[]}
     */
    public getVideoCameraPath(): Array<Camera> {
        return /* unmodifiableList */this.cameraPath.slice(0);
    }

    /**
     * Sets the preferred video camera path, and notifies
     * listeners of this change.
     * @param {Camera[]} cameraPath
     */
    public setVideoCameraPath(cameraPath: Array<Camera>) {
        if (this.cameraPath !== cameraPath) {
            const oldCameraPath: Array<Camera> = this.cameraPath;
            if (cameraPath != null) {
                this.cameraPath = <any>(cameraPath.slice(0));
            } else {
                this.cameraPath = /* emptyList */[];
            }
            this.firePropertyChange(/* name */"VIDEO_CAMERA_PATH", oldCameraPath, cameraPath);
        }
    }

    /**
     * Returns a clone of this environment.
     * @return {HomeEnvironment}
     */
    public clone(): HomeEnvironment {
        const clone: HomeEnvironment = <HomeEnvironment>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.cameraPath = <any>([]);
        for (let index = 0; index < this.cameraPath.length; index++) {
            let camera = this.cameraPath[index];
            {
                /* add */(clone.cameraPath.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(camera)) > 0);
            }
        }
        return clone;
    }
}
HomeEnvironment["__class"] = "com.eteks.sweethome3d.model.HomeEnvironment";


export namespace HomeEnvironment {

    /**
     * The various modes used to draw home in 3D.
     * @enum
     * @property {HomeEnvironment.DrawingMode} FILL
     * @property {HomeEnvironment.DrawingMode} OUTLINE
     * @property {HomeEnvironment.DrawingMode} FILL_AND_OUTLINE
     * @class
     */
    export enum DrawingMode {
        FILL, OUTLINE, FILL_AND_OUTLINE
    }
}
HomeEnvironment['__transients'] = ['photoAspectRatio', 'videoAspectRatio', 'propertyChangeSupport'];

/**
 * Creates a compass drawn at the given point.
 * North direction is set to zero, time zone to default
 * and the latitude and the longitude of this new compass is equal
 * to the geographic point matching the default time zone.
 * @param {string} id
 * @param {number} x
 * @param {number} y
 * @param {number} diameter
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Compass extends HomeObject implements Selectable {
    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ diameter: number;

    /*private*/ visible: boolean;

    /*private*/ northDirection: number;

    /*private*/ latitude: number;

    /*private*/ longitude: number;

    /*private*/ timeZone: string;

    /*private*/ pointsCache: number[][];

    /*private*/ dateCache: Date;

    /*private*/ sunElevationCache: number;

    /*private*/ sunAzimuthCache: number;

    static timeZoneGeographicPointsReference: any = null;

    public constructor(id?: any, x?: any, y?: any, diameter?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof diameter === 'number') || diameter === null)) {
            let __args = arguments;
            super(id);
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.diameter === undefined) { this.diameter = 0; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.northDirection === undefined) { this.northDirection = 0; }
            if (this.latitude === undefined) { this.latitude = 0; }
            if (this.longitude === undefined) { this.longitude = 0; }
            if (this.timeZone === undefined) { this.timeZone = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.dateCache === undefined) { this.dateCache = null; }
            if (this.sunElevationCache === undefined) { this.sunElevationCache = 0; }
            if (this.sunAzimuthCache === undefined) { this.sunAzimuthCache = 0; }
            this.x = x;
            this.y = y;
            this.diameter = diameter;
            this.visible = true;
            this.timeZone = /* getDefault */"UTC";
            this.initGeographicPoint();
        } else if (((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && diameter === undefined) {
            let __args = arguments;
            let x: any = __args[0];
            let y: any = __args[1];
            let diameter: any = __args[2];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("compass");
                super(id);
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.diameter === undefined) { this.diameter = 0; }
                if (this.visible === undefined) { this.visible = false; }
                if (this.northDirection === undefined) { this.northDirection = 0; }
                if (this.latitude === undefined) { this.latitude = 0; }
                if (this.longitude === undefined) { this.longitude = 0; }
                if (this.timeZone === undefined) { this.timeZone = null; }
                if (this.pointsCache === undefined) { this.pointsCache = null; }
                if (this.dateCache === undefined) { this.dateCache = null; }
                if (this.sunElevationCache === undefined) { this.sunElevationCache = 0; }
                if (this.sunAzimuthCache === undefined) { this.sunAzimuthCache = 0; }
                this.x = x;
                this.y = y;
                this.diameter = diameter;
                this.visible = true;
                this.timeZone = /* getDefault */"UTC";
                this.initGeographicPoint();
            }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.diameter === undefined) { this.diameter = 0; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.northDirection === undefined) { this.northDirection = 0; }
            if (this.latitude === undefined) { this.latitude = 0; }
            if (this.longitude === undefined) { this.longitude = 0; }
            if (this.timeZone === undefined) { this.timeZone = null; }
            if (this.pointsCache === undefined) { this.pointsCache = null; }
            if (this.dateCache === undefined) { this.dateCache = null; }
            if (this.sunElevationCache === undefined) { this.sunElevationCache = 0; }
            if (this.sunAzimuthCache === undefined) { this.sunAzimuthCache = 0; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the abscissa of the center of this compass.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the abscissa of the center of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.pointsCache = null;
            this.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the ordinate of the center of this compass.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the ordinate of the center of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.pointsCache = null;
            this.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the diameter of this compass.
     * @return {number}
     */
    public getDiameter(): number {
        return this.diameter;
    }

    /**
     * Sets the diameter of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} diameter
     */
    public setDiameter(diameter: number) {
        if (diameter !== this.diameter) {
            const oldDiameter: number = this.diameter;
            this.diameter = diameter;
            this.pointsCache = null;
            this.firePropertyChange(/* name */"DIAMETER", oldDiameter, diameter);
        }
    }

    /**
     * Returns <code>true</code> if this compass is visible.
     * @return {boolean}
     */
    public isVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether this compass is visible or not. Once this compass is updated,
     * listeners added to this piece will receive a change notification.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        if (visible !== this.visible) {
            this.visible = visible;
            this.firePropertyChange(/* name */"VISIBLE", !visible, visible);
        }
    }

    /**
     * Returns the North direction angle of this compass in radians.
     * @return {number}
     */
    public getNorthDirection(): number {
        return this.northDirection;
    }

    /**
     * Sets the North direction angle of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} northDirection
     */
    public setNorthDirection(northDirection: number) {
        if (northDirection !== this.northDirection) {
            const oldNorthDirection: number = this.northDirection;
            this.northDirection = northDirection;
            this.pointsCache = null;
            this.firePropertyChange(/* name */"NORTH_DIRECTION", oldNorthDirection, northDirection);
        }
    }

    /**
     * Returns the latitude of this compass in radians.
     * @return {number}
     */
    public getLatitude(): number {
        return this.latitude;
    }

    /**
     * Sets the latitude of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} latitude
     */
    public setLatitude(latitude: number) {
        if (latitude !== this.latitude) {
            const oldLatitude: number = this.latitude;
            this.latitude = latitude;
            this.dateCache = null;
            this.firePropertyChange(/* name */"LATITUDE", oldLatitude, latitude);
        }
    }

    /**
     * Returns the longitude of this compass in radians.
     * @return {number}
     */
    public getLongitude(): number {
        return this.longitude;
    }

    /**
     * Sets the longitude of the center of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @param {number} longitude
     */
    public setLongitude(longitude: number) {
        if (longitude !== this.longitude) {
            const oldLongitude: number = this.longitude;
            this.longitude = longitude;
            this.dateCache = null;
            this.firePropertyChange(/* name */"LONGITUDE", oldLongitude, longitude);
        }
    }

    /**
     * Returns the time zone identifier of this compass.
     * @see java.util.TimeZone
     * @return {string}
     */
    public getTimeZone(): string {
        return /* getID */this.timeZone;
    }

    /**
     * Sets the time zone identifier of this compass. Once this compass is updated,
     * listeners added to this compass will receive a change notification.
     * @throws IllegalArgumentException if <code>timeZone</code> is <code>null</code> or contains an unknown identifier.
     * @see java.util.TimeZone
     * @param {string} timeZone
     */
    public setTimeZone(timeZone: string) {
        if (!(/* getID */this.timeZone === timeZone)) {
            if (timeZone == null) {
                throw new IllegalArgumentException("Time zone ID can\'t be null");
            }
            const oldTimeZone: string = /* getID */this.timeZone;
            this.timeZone = /* getTimeZone */timeZone;
            this.dateCache = null;
            this.firePropertyChange(/* name */"TIME_ZONE", oldTimeZone, timeZone);
        }
    }

    /**
     * Returns the corner points of the square that contains compass disc.
     * @return {float[][]}
     */
    public getPoints(): number[][] {
        if (this.pointsCache == null) {
            const pieceRectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(this.getX() - this.getDiameter() / 2, this.getY() - this.getDiameter() / 2, this.getDiameter(), this.getDiameter());
            const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(this.getNorthDirection(), this.getX(), this.getY());
            this.pointsCache = <any>(function (dims) { let allocate = function (dims) { if (dims.length === 0) { return 0; } else { let array = []; for (let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; } }; return allocate(dims); })([4, 2]);
            const it: java.awt.geom.PathIterator = pieceRectangle.getPathIterator(rotation);
            for (let i: number = 0; i < this.pointsCache.length; i++) {
                {
                    it.currentSegment(this.pointsCache[i]);
                    it.next();
                };
            }
        }
        return [/* clone */this.pointsCache[0].slice(0), /* clone */this.pointsCache[1].slice(0), /* clone */this.pointsCache[2].slice(0), /* clone */this.pointsCache[3].slice(0)];
    }

    /**
     * Returns <code>true</code> if the disc of this compass intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return new java.awt.geom.Ellipse2D.Float(this.getX() - this.getDiameter() / 2, this.getY() - this.getDiameter() / 2, this.getDiameter(), this.getDiameter()).intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if the disc of this compass contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        const shape: java.awt.geom.Ellipse2D = new java.awt.geom.Ellipse2D.Float(this.getX() - this.getDiameter() / 2, this.getY() - this.getDiameter() / 2, this.getDiameter(), this.getDiameter());
        if (margin === 0) {
            return shape.contains(x, y);
        } else {
            return shape.intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Moves this compass of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setX(this.getX() + dx);
        this.setY(this.getY() + dy);
    }

    /**
     * Returns a clone of this compass.
     * @return {Compass}
     */
    public clone(): Compass {
        return <Compass>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }

    computeJulianDay(year: number, month: number, day: number, hour: number, minute: number, second: number, timeZone: number, savingTime: number): number {
        const dayPart: number = day + hour / 24.0 + minute / 1440.0 + second / 86400.0;
        if (month === 1 || month === 2) {
            year -= 1;
            month += 12;
        }
        const a: number = (year / 100 | 0);
        const b: number = 2 - a + (a / 4 | 0);
        let julianDay: number = (<number>(365.25 * (year + 4716.0)) | 0) + (<number>((30.6001 * (month + 1))) | 0) + dayPart + b - 1524.5;
        julianDay -= (timeZone + savingTime) / 24.0;
        julianDay -= 2451545.0;
        return julianDay;
    }

    toSiderealTime(julianDay: number): number {
        const centuries: number = julianDay / 36525.0;
        const siderealTime: number = (24110.54841 + (8640184.812866 * centuries) + (0.093104 * Math.pow(centuries, 2.0)) - (6.2E-6 * Math.pow(centuries, 3.0))) / 3600.0;
        return ((siderealTime / 24.0) - (<number>(siderealTime / 24.0) | 0)) * 24.0;
    }

    /**
     * Inits the latitudeInDegrees and longitudeInDegrees where this compass is located from the id of the default time zone.
     * @private
     */
    initGeographicPoint() {
        let timeZoneGeographicPoints: any;
        if (Compass.timeZoneGeographicPointsReference != null) {
            timeZoneGeographicPoints = /* get */Compass.timeZoneGeographicPointsReference;
        } else {
            timeZoneGeographicPoints = null;
        }
        if (timeZoneGeographicPoints == null) {
            timeZoneGeographicPoints = <any>({});
            const apia: Compass.GeographicPoint = new Compass.GeographicPoint(-13.833333, -171.73334);
            /* put */(timeZoneGeographicPoints["Etc/GMT+11"] = apia);
            /* put */(timeZoneGeographicPoints["Pacific/Apia"] = apia);
            /* put */(timeZoneGeographicPoints["Pacific/Midway"] = new Compass.GeographicPoint(28.2, -177.35));
            /* put */(timeZoneGeographicPoints["Pacific/Niue"] = new Compass.GeographicPoint(-19.055, -169.92));
            /* put */(timeZoneGeographicPoints["Pacific/Pago_Pago"] = new Compass.GeographicPoint(-14.278055, -170.7025));
            /* put */(timeZoneGeographicPoints["Pacific/Samoa"] = apia);
            /* put */(timeZoneGeographicPoints["US/Samoa"] = apia);
            /* put */(timeZoneGeographicPoints["America/Adak"] = new Compass.GeographicPoint(51.88, -176.65805));
            /* put */(timeZoneGeographicPoints["America/Atka"] = new Compass.GeographicPoint(52.19611, -174.20056));
            const honolulu: Compass.GeographicPoint = new Compass.GeographicPoint(21.306944, -157.85834);
            /* put */(timeZoneGeographicPoints["Etc/GMT+10"] = honolulu);
            /* put */(timeZoneGeographicPoints["Pacific/Fakaofo"] = new Compass.GeographicPoint(-9.3653, -171.215));
            /* put */(timeZoneGeographicPoints["Pacific/Honolulu"] = honolulu);
            /* put */(timeZoneGeographicPoints["Pacific/Johnston"] = new Compass.GeographicPoint(16.75, -169.517));
            /* put */(timeZoneGeographicPoints["Pacific/Rarotonga"] = new Compass.GeographicPoint(-21.233, -159.783));
            /* put */(timeZoneGeographicPoints["Pacific/Tahiti"] = new Compass.GeographicPoint(-17.533333, -149.56667));
            /* put */(timeZoneGeographicPoints["SystemV/HST10"] = honolulu);
            /* put */(timeZoneGeographicPoints["US/Aleutian"] = new Compass.GeographicPoint(54.817, 164.033));
            /* put */(timeZoneGeographicPoints["US/Hawaii"] = honolulu);
            /* put */(timeZoneGeographicPoints["Pacific/Marquesas"] = new Compass.GeographicPoint(-9.45, -139.38));
            const anchorage: Compass.GeographicPoint = new Compass.GeographicPoint(61.218056, -149.90028);
            /* put */(timeZoneGeographicPoints["America/Anchorage"] = anchorage);
            /* put */(timeZoneGeographicPoints["America/Juneau"] = new Compass.GeographicPoint(58.301945, -134.41972));
            /* put */(timeZoneGeographicPoints["America/Nome"] = new Compass.GeographicPoint(64.501114, -165.40639));
            /* put */(timeZoneGeographicPoints["America/Yakutat"] = new Compass.GeographicPoint(59.546944, -139.72722));
            /* put */(timeZoneGeographicPoints["Etc/GMT+9"] = anchorage);
            /* put */(timeZoneGeographicPoints["Pacific/Gambier"] = new Compass.GeographicPoint(-23.1178, -134.97));
            /* put */(timeZoneGeographicPoints["SystemV/YST9"] = anchorage);
            /* put */(timeZoneGeographicPoints["SystemV/YST9YDT"] = anchorage);
            /* put */(timeZoneGeographicPoints["US/Alaska"] = anchorage);
            /* put */(timeZoneGeographicPoints["America/Dawson"] = new Compass.GeographicPoint(64.066666, -139.41667));
            /* put */(timeZoneGeographicPoints["America/Ensenada"] = new Compass.GeographicPoint(31.866667, -116.61667));
            const losAngeles: Compass.GeographicPoint = new Compass.GeographicPoint(34.052223, -118.242775);
            /* put */(timeZoneGeographicPoints["America/Los_Angeles"] = losAngeles);
            /* put */(timeZoneGeographicPoints["America/Santa_Isabel"] = new Compass.GeographicPoint(28.383333, -113.35));
            /* put */(timeZoneGeographicPoints["America/Tijuana"] = new Compass.GeographicPoint(32.533333, -117.01667));
            /* put */(timeZoneGeographicPoints["America/Vancouver"] = new Compass.GeographicPoint(49.25, -123.13333));
            /* put */(timeZoneGeographicPoints["America/Whitehorse"] = new Compass.GeographicPoint(60.716667, -135.05));
            /* put */(timeZoneGeographicPoints["Canada/Pacific"] = new Compass.GeographicPoint(49.25, -123.13333));
            /* put */(timeZoneGeographicPoints["Canada/Yukon"] = new Compass.GeographicPoint(60.716667, -135.05));
            /* put */(timeZoneGeographicPoints["Etc/GMT+8"] = losAngeles);
            /* put */(timeZoneGeographicPoints["Mexico/BajaNorte"] = new Compass.GeographicPoint(32.533333, -117.01667));
            /* put */(timeZoneGeographicPoints["Pacific/Pitcairn"] = new Compass.GeographicPoint(-25.0667, -130.1));
            /* put */(timeZoneGeographicPoints["SystemV/PST8"] = losAngeles);
            /* put */(timeZoneGeographicPoints["SystemV/PST8PDT"] = losAngeles);
            /* put */(timeZoneGeographicPoints["US/Pacific"] = losAngeles);
            /* put */(timeZoneGeographicPoints["US/Pacific-New"] = losAngeles);
            /* put */(timeZoneGeographicPoints["America/Boise"] = new Compass.GeographicPoint(43.61361, -116.2025));
            /* put */(timeZoneGeographicPoints["America/Cambridge_Bay"] = new Compass.GeographicPoint(69.11667, -105.03333));
            /* put */(timeZoneGeographicPoints["America/Chihuahua"] = new Compass.GeographicPoint(28.633333, -106.083336));
            /* put */(timeZoneGeographicPoints["America/Dawson_Creek"] = new Compass.GeographicPoint(55.766666, -120.23333));
            const denver: Compass.GeographicPoint = new Compass.GeographicPoint(39.739166, -104.98417);
            /* put */(timeZoneGeographicPoints["America/Denver"] = denver);
            /* put */(timeZoneGeographicPoints["America/Edmonton"] = new Compass.GeographicPoint(53.55, -113.5));
            /* put */(timeZoneGeographicPoints["America/Hermosillo"] = new Compass.GeographicPoint(29.066668, -110.96667));
            /* put */(timeZoneGeographicPoints["America/Inuvik"] = new Compass.GeographicPoint(68.35, -133.7));
            /* put */(timeZoneGeographicPoints["America/Mazatlan"] = new Compass.GeographicPoint(23.216667, -106.416664));
            /* put */(timeZoneGeographicPoints["America/Ojinaga"] = new Compass.GeographicPoint(29.566668, -104.416664));
            /* put */(timeZoneGeographicPoints["America/Phoenix"] = new Compass.GeographicPoint(33.448334, -112.07333));
            /* put */(timeZoneGeographicPoints["America/Shiprock"] = new Compass.GeographicPoint(36.785557, -108.686386));
            /* put */(timeZoneGeographicPoints["America/Yellowknife"] = new Compass.GeographicPoint(62.45, -114.35));
            /* put */(timeZoneGeographicPoints["Canada/Mountain"] = new Compass.GeographicPoint(53.55, -113.5));
            /* put */(timeZoneGeographicPoints["Etc/GMT+7"] = denver);
            /* put */(timeZoneGeographicPoints["Mexico/BajaSur"] = new Compass.GeographicPoint(32.567, -116.633));
            /* put */(timeZoneGeographicPoints["SystemV/MST7"] = denver);
            /* put */(timeZoneGeographicPoints["SystemV/MST7MDT"] = denver);
            /* put */(timeZoneGeographicPoints["US/Arizona"] = new Compass.GeographicPoint(33.448334, -112.07333));
            /* put */(timeZoneGeographicPoints["US/Mountain"] = denver);
            /* put */(timeZoneGeographicPoints["America/Belize"] = new Compass.GeographicPoint(17.483334, -88.183334));
            /* put */(timeZoneGeographicPoints["America/Cancun"] = new Compass.GeographicPoint(21.166668, -86.833336));
            const chicago: Compass.GeographicPoint = new Compass.GeographicPoint(41.85, -87.65);
            /* put */(timeZoneGeographicPoints["America/Chicago"] = chicago);
            /* put */(timeZoneGeographicPoints["America/Costa_Rica"] = new Compass.GeographicPoint(9.933333, -84.083336));
            /* put */(timeZoneGeographicPoints["America/El_Salvador"] = new Compass.GeographicPoint(13.7086115, -89.20306));
            /* put */(timeZoneGeographicPoints["America/Guatemala"] = new Compass.GeographicPoint(14.621111, -90.52695));
            /* put */(timeZoneGeographicPoints["America/Knox_IN"] = new Compass.GeographicPoint(41.295834, -86.625));
            /* put */(timeZoneGeographicPoints["America/Managua"] = new Compass.GeographicPoint(12.150833, -86.26833));
            /* put */(timeZoneGeographicPoints["America/Matamoros"] = new Compass.GeographicPoint(25.883333, -97.5));
            /* put */(timeZoneGeographicPoints["America/Menominee"] = new Compass.GeographicPoint(45.107777, -87.61417));
            /* put */(timeZoneGeographicPoints["America/Merida"] = new Compass.GeographicPoint(20.966667, -89.61667));
            /* put */(timeZoneGeographicPoints["America/Mexico_City"] = new Compass.GeographicPoint(19.434168, -99.13861));
            /* put */(timeZoneGeographicPoints["America/Monterrey"] = new Compass.GeographicPoint(25.666668, -100.316666));
            /* put */(timeZoneGeographicPoints["America/Rainy_River"] = new Compass.GeographicPoint(48.716667, -94.566666));
            /* put */(timeZoneGeographicPoints["America/Rankin_Inlet"] = new Compass.GeographicPoint(62.816666, -92.083336));
            /* put */(timeZoneGeographicPoints["America/Regina"] = new Compass.GeographicPoint(50.45, -104.61667));
            /* put */(timeZoneGeographicPoints["America/Swift_Current"] = new Compass.GeographicPoint(50.283333, -107.76667));
            /* put */(timeZoneGeographicPoints["America/Tegucigalpa"] = new Compass.GeographicPoint(14.1, -87.21667));
            /* put */(timeZoneGeographicPoints["America/Winnipeg"] = new Compass.GeographicPoint(49.88333, -97.166664));
            /* put */(timeZoneGeographicPoints["Canada/Central"] = new Compass.GeographicPoint(50.45, -104.61667));
            /* put */(timeZoneGeographicPoints["Canada/East-Saskatchewan"] = new Compass.GeographicPoint(51.216667, -102.46667));
            /* put */(timeZoneGeographicPoints["Canada/Saskatchewan"] = new Compass.GeographicPoint(50.45, -104.61667));
            /* put */(timeZoneGeographicPoints["Chile/EasterIsland"] = new Compass.GeographicPoint(-27.15, -109.425));
            /* put */(timeZoneGeographicPoints["Etc/GMT+6"] = chicago);
            /* put */(timeZoneGeographicPoints["Mexico/General"] = new Compass.GeographicPoint(19.434168, -99.13861));
            /* put */(timeZoneGeographicPoints["Pacific/Easter"] = new Compass.GeographicPoint(-27.15, -109.425));
            /* put */(timeZoneGeographicPoints["Pacific/Galapagos"] = new Compass.GeographicPoint(-0.667, -90.55));
            /* put */(timeZoneGeographicPoints["SystemV/CST6"] = chicago);
            /* put */(timeZoneGeographicPoints["SystemV/CST6CDT"] = chicago);
            /* put */(timeZoneGeographicPoints["US/Central"] = chicago);
            /* put */(timeZoneGeographicPoints["US/Indiana-Starke"] = new Compass.GeographicPoint(41.295834, -86.625));
            /* put */(timeZoneGeographicPoints["America/Atikokan"] = new Compass.GeographicPoint(48.75, -91.61667));
            /* put */(timeZoneGeographicPoints["America/Bogota"] = new Compass.GeographicPoint(4.6, -74.083336));
            /* put */(timeZoneGeographicPoints["America/Cayman"] = new Compass.GeographicPoint(19.3, -81.38333));
            /* put */(timeZoneGeographicPoints["America/Coral_Harbour"] = new Compass.GeographicPoint(64.13333, -83.166664));
            /* put */(timeZoneGeographicPoints["America/Detroit"] = new Compass.GeographicPoint(42.33139, -83.04583));
            /* put */(timeZoneGeographicPoints["America/Fort_Wayne"] = new Compass.GeographicPoint(41.130554, -85.12889));
            /* put */(timeZoneGeographicPoints["America/Grand_Turk"] = new Compass.GeographicPoint(21.466667, -71.13333));
            /* put */(timeZoneGeographicPoints["America/Guayaquil"] = new Compass.GeographicPoint(-2.1666667, -79.9));
            /* put */(timeZoneGeographicPoints["America/Havana"] = new Compass.GeographicPoint(23.131945, -82.36417));
            /* put */(timeZoneGeographicPoints["America/Indianapolis"] = new Compass.GeographicPoint(39.768333, -86.15806));
            /* put */(timeZoneGeographicPoints["America/Iqaluit"] = new Compass.GeographicPoint(63.733334, -68.5));
            /* put */(timeZoneGeographicPoints["America/Jamaica"] = new Compass.GeographicPoint(18.0, -76.8));
            /* put */(timeZoneGeographicPoints["America/Lima"] = new Compass.GeographicPoint(-12.05, -77.05));
            /* put */(timeZoneGeographicPoints["America/Louisville"] = new Compass.GeographicPoint(38.254166, -85.759445));
            /* put */(timeZoneGeographicPoints["America/Montreal"] = new Compass.GeographicPoint(45.5, -73.583336));
            /* put */(timeZoneGeographicPoints["America/Nassau"] = new Compass.GeographicPoint(25.083334, -77.35));
            const newYork: Compass.GeographicPoint = new Compass.GeographicPoint(40.71417, -74.006386);
            /* put */(timeZoneGeographicPoints["America/New_York"] = newYork);
            /* put */(timeZoneGeographicPoints["America/Nipigon"] = new Compass.GeographicPoint(49.016666, -88.25));
            /* put */(timeZoneGeographicPoints["America/Panama"] = new Compass.GeographicPoint(8.966667, -79.53333));
            /* put */(timeZoneGeographicPoints["America/Pangnirtung"] = new Compass.GeographicPoint(66.13333, -65.75));
            /* put */(timeZoneGeographicPoints["America/Port-au-Prince"] = new Compass.GeographicPoint(18.539167, -72.335));
            /* put */(timeZoneGeographicPoints["America/Resolute"] = new Compass.GeographicPoint(74.683334, -94.9));
            /* put */(timeZoneGeographicPoints["America/Thunder_Bay"] = new Compass.GeographicPoint(48.4, -89.23333));
            /* put */(timeZoneGeographicPoints["America/Toronto"] = new Compass.GeographicPoint(43.666668, -79.416664));
            /* put */(timeZoneGeographicPoints["Canada/Eastern"] = new Compass.GeographicPoint(43.666668, -79.416664));
            /* put */(timeZoneGeographicPoints["Etc/GMT+5"] = newYork);
            /* put */(timeZoneGeographicPoints["SystemV/EST5"] = newYork);
            /* put */(timeZoneGeographicPoints["SystemV/EST5EDT"] = newYork);
            /* put */(timeZoneGeographicPoints["US/East-Indiana"] = new Compass.GeographicPoint(36.8381, -84.85));
            /* put */(timeZoneGeographicPoints["US/Eastern"] = newYork);
            /* put */(timeZoneGeographicPoints["US/Michigan"] = new Compass.GeographicPoint(42.33139, -83.04583));
            /* put */(timeZoneGeographicPoints["America/Caracas"] = new Compass.GeographicPoint(10.5, -66.916664));
            /* put */(timeZoneGeographicPoints["America/Anguilla"] = new Compass.GeographicPoint(18.216667, -63.05));
            /* put */(timeZoneGeographicPoints["America/Antigua"] = new Compass.GeographicPoint(17.116667, -61.85));
            /* put */(timeZoneGeographicPoints["America/Aruba"] = new Compass.GeographicPoint(10.541111, -72.9175));
            /* put */(timeZoneGeographicPoints["America/Asuncion"] = new Compass.GeographicPoint(-25.266666, -57.666668));
            /* put */(timeZoneGeographicPoints["America/Barbados"] = new Compass.GeographicPoint(13.1, -59.616665));
            /* put */(timeZoneGeographicPoints["America/Blanc-Sablon"] = new Compass.GeographicPoint(51.433334, -57.11667));
            /* put */(timeZoneGeographicPoints["America/Boa_Vista"] = new Compass.GeographicPoint(2.8166666, -60.666668));
            /* put */(timeZoneGeographicPoints["America/Campo_Grande"] = new Compass.GeographicPoint(-20.45, -54.616665));
            /* put */(timeZoneGeographicPoints["America/Cuiaba"] = new Compass.GeographicPoint(-15.583333, -56.083332));
            /* put */(timeZoneGeographicPoints["America/Curacao"] = new Compass.GeographicPoint(12.1167, -68.933));
            /* put */(timeZoneGeographicPoints["America/Dominica"] = new Compass.GeographicPoint(15.3, -61.4));
            /* put */(timeZoneGeographicPoints["America/Eirunepe"] = new Compass.GeographicPoint(-6.6666665, -69.86667));
            /* put */(timeZoneGeographicPoints["America/Glace_Bay"] = new Compass.GeographicPoint(46.2, -59.966667));
            /* put */(timeZoneGeographicPoints["America/Goose_Bay"] = new Compass.GeographicPoint(53.333332, -60.416668));
            /* put */(timeZoneGeographicPoints["America/Grenada"] = new Compass.GeographicPoint(12.05, -61.75));
            /* put */(timeZoneGeographicPoints["America/Guadeloupe"] = new Compass.GeographicPoint(16.233334, -61.516666));
            /* put */(timeZoneGeographicPoints["America/Guyana"] = new Compass.GeographicPoint(6.8, -58.166668));
            /* put */(timeZoneGeographicPoints["America/Halifax"] = new Compass.GeographicPoint(44.65, -63.6));
            /* put */(timeZoneGeographicPoints["America/La_Paz"] = new Compass.GeographicPoint(-16.5, -68.15));
            /* put */(timeZoneGeographicPoints["America/Manaus"] = new Compass.GeographicPoint(-3.1133332, -60.025276));
            /* put */(timeZoneGeographicPoints["America/Marigot"] = new Compass.GeographicPoint(18.073, 63.0844));
            /* put */(timeZoneGeographicPoints["America/Martinique"] = new Compass.GeographicPoint(14.6, -61.083332));
            /* put */(timeZoneGeographicPoints["America/Moncton"] = new Compass.GeographicPoint(46.083332, -64.76667));
            /* put */(timeZoneGeographicPoints["America/Montserrat"] = new Compass.GeographicPoint(16.7, -62.216667));
            /* put */(timeZoneGeographicPoints["America/Port_of_Spain"] = new Compass.GeographicPoint(10.65, -61.516666));
            /* put */(timeZoneGeographicPoints["America/Porto_Acre"] = new Compass.GeographicPoint(-9.587778, -67.53555));
            /* put */(timeZoneGeographicPoints["America/Porto_Velho"] = new Compass.GeographicPoint(-8.766666, -63.9));
            /* put */(timeZoneGeographicPoints["America/Puerto_Rico"] = new Compass.GeographicPoint(18.467, 66.117));
            /* put */(timeZoneGeographicPoints["America/Rio_Branco"] = new Compass.GeographicPoint(-9.966667, -67.8));
            const santiago: Compass.GeographicPoint = new Compass.GeographicPoint(-33.45, -70.666664);
            /* put */(timeZoneGeographicPoints["America/Santiago"] = santiago);
            /* put */(timeZoneGeographicPoints["America/Santo_Domingo"] = new Compass.GeographicPoint(18.466667, -69.9));
            /* put */(timeZoneGeographicPoints["America/St_Barthelemy"] = new Compass.GeographicPoint(17.8978, -62.851));
            /* put */(timeZoneGeographicPoints["America/St_Kitts"] = new Compass.GeographicPoint(17.3, -62.733));
            /* put */(timeZoneGeographicPoints["America/St_Lucia"] = new Compass.GeographicPoint(14.0167, -60.9833));
            /* put */(timeZoneGeographicPoints["America/St_Thomas"] = new Compass.GeographicPoint(18.3333, -64.9167));
            /* put */(timeZoneGeographicPoints["America/St_Vincent"] = new Compass.GeographicPoint(13.1667, -61.2333));
            /* put */(timeZoneGeographicPoints["America/Thule"] = new Compass.GeographicPoint(-54.27667, -36.511665));
            /* put */(timeZoneGeographicPoints["America/Tortola"] = new Compass.GeographicPoint(18.416666, -64.61667));
            /* put */(timeZoneGeographicPoints["America/Virgin"] = new Compass.GeographicPoint(18.34389, -64.931114));
            /* put */(timeZoneGeographicPoints["Antarctica/Palmer"] = new Compass.GeographicPoint(-64.25, -62.833));
            /* put */(timeZoneGeographicPoints["Atlantic/Bermuda"] = new Compass.GeographicPoint(32.294167, -64.78389));
            /* put */(timeZoneGeographicPoints["Atlantic/Stanley"] = new Compass.GeographicPoint(-51.7, -57.85));
            /* put */(timeZoneGeographicPoints["Brazil/Acre"] = new Compass.GeographicPoint(-10.883333, -45.083332));
            /* put */(timeZoneGeographicPoints["Brazil/West"] = new Compass.GeographicPoint(-10.883333, -45.083332));
            /* put */(timeZoneGeographicPoints["Canada/Atlantic"] = new Compass.GeographicPoint(44.65, -63.6));
            /* put */(timeZoneGeographicPoints["Chile/Continental"] = santiago);
            /* put */(timeZoneGeographicPoints["Etc/GMT+4"] = santiago);
            /* put */(timeZoneGeographicPoints["SystemV/AST4"] = new Compass.GeographicPoint(44.65, -63.6));
            /* put */(timeZoneGeographicPoints["SystemV/AST4ADT"] = new Compass.GeographicPoint(44.65, -63.6));
            /* put */(timeZoneGeographicPoints["America/St_Johns"] = new Compass.GeographicPoint(47.5675, -52.7072));
            /* put */(timeZoneGeographicPoints["Canada/Newfoundland"] = new Compass.GeographicPoint(47.5675, -52.7072));
            /* put */(timeZoneGeographicPoints["America/Araguaina"] = new Compass.GeographicPoint(-7.16, -48.0575));
            /* put */(timeZoneGeographicPoints["America/Bahia"] = new Compass.GeographicPoint(-12.983334, -38.516666));
            /* put */(timeZoneGeographicPoints["America/Belem"] = new Compass.GeographicPoint(-1.45, -48.483334));
            /* put */(timeZoneGeographicPoints["America/Buenos_Aires"] = new Compass.GeographicPoint(-34.5875, -58.6725));
            /* put */(timeZoneGeographicPoints["America/Catamarca"] = new Compass.GeographicPoint(-28.466667, -65.78333));
            /* put */(timeZoneGeographicPoints["America/Cayenne"] = new Compass.GeographicPoint(4.9333334, -52.333332));
            /* put */(timeZoneGeographicPoints["America/Cordoba"] = new Compass.GeographicPoint(-31.4, -64.183334));
            /* put */(timeZoneGeographicPoints["America/Fortaleza"] = new Compass.GeographicPoint(-3.7166667, -38.5));
            /* put */(timeZoneGeographicPoints["America/Godthab"] = new Compass.GeographicPoint(64.183334, -51.75));
            /* put */(timeZoneGeographicPoints["America/Jujuy"] = new Compass.GeographicPoint(-24.183332, -65.3));
            /* put */(timeZoneGeographicPoints["America/Maceio"] = new Compass.GeographicPoint(-9.666667, -35.716667));
            /* put */(timeZoneGeographicPoints["America/Mendoza"] = new Compass.GeographicPoint(-32.883335, -68.816666));
            /* put */(timeZoneGeographicPoints["America/Miquelon"] = new Compass.GeographicPoint(47.0975, -56.38139));
            /* put */(timeZoneGeographicPoints["America/Montevideo"] = new Compass.GeographicPoint(-34.858055, -56.170834));
            /* put */(timeZoneGeographicPoints["America/Paramaribo"] = new Compass.GeographicPoint(5.8333335, -55.166668));
            /* put */(timeZoneGeographicPoints["America/Recife"] = new Compass.GeographicPoint(-8.05, -34.9));
            /* put */(timeZoneGeographicPoints["America/Rosario"] = new Compass.GeographicPoint(-32.95111, -60.66639));
            /* put */(timeZoneGeographicPoints["America/Santarem"] = new Compass.GeographicPoint(-2.4333334, -54.7));
            const saoPaulo: Compass.GeographicPoint = new Compass.GeographicPoint(-23.533333, -46.616665);
            /* put */(timeZoneGeographicPoints["America/Sao_Paulo"] = saoPaulo);
            /* put */(timeZoneGeographicPoints["Antarctica/Rothera"] = new Compass.GeographicPoint(67.567, 68.133));
            /* put */(timeZoneGeographicPoints["Brazil/East"] = saoPaulo);
            /* put */(timeZoneGeographicPoints["Etc/GMT+3"] = saoPaulo);
            /* put */(timeZoneGeographicPoints["America/Noronha"] = new Compass.GeographicPoint(3.85, 25.417));
            const southGeorgia: Compass.GeographicPoint = new Compass.GeographicPoint(54.25, 36.75);
            /* put */(timeZoneGeographicPoints["Atlantic/South_Georgia"] = southGeorgia);
            /* put */(timeZoneGeographicPoints["Brazil/DeNoronha"] = new Compass.GeographicPoint(3.85, 25.417));
            /* put */(timeZoneGeographicPoints["Etc/GMT+2"] = southGeorgia);
            /* put */(timeZoneGeographicPoints["America/Scoresbysund"] = new Compass.GeographicPoint(70.48333, -21.966667));
            const azores: Compass.GeographicPoint = new Compass.GeographicPoint(37.483334, -2.5666666);
            /* put */(timeZoneGeographicPoints["Atlantic/Azores"] = azores);
            /* put */(timeZoneGeographicPoints["Atlantic/Cape_Verde"] = new Compass.GeographicPoint(14.916667, -23.516666));
            /* put */(timeZoneGeographicPoints["Etc/GMT+1"] = azores);
            /* put */(timeZoneGeographicPoints["Africa/Abidjan"] = new Compass.GeographicPoint(5.341111, -4.028056));
            /* put */(timeZoneGeographicPoints["Africa/Accra"] = new Compass.GeographicPoint(5.55, -0.2166667));
            /* put */(timeZoneGeographicPoints["Africa/Bamako"] = new Compass.GeographicPoint(12.65, -8.0));
            /* put */(timeZoneGeographicPoints["Africa/Banjul"] = new Compass.GeographicPoint(13.453055, -16.5775));
            /* put */(timeZoneGeographicPoints["Africa/Bissau"] = new Compass.GeographicPoint(11.85, -15.583333));
            /* put */(timeZoneGeographicPoints["Africa/Casablanca"] = new Compass.GeographicPoint(33.593056, -7.616389));
            /* put */(timeZoneGeographicPoints["Africa/Conakry"] = new Compass.GeographicPoint(9.509167, -13.712222));
            /* put */(timeZoneGeographicPoints["Africa/Dakar"] = new Compass.GeographicPoint(14.670834, -17.438055));
            /* put */(timeZoneGeographicPoints["Africa/El_Aaiun"] = new Compass.GeographicPoint(27.15361, -13.203333));
            /* put */(timeZoneGeographicPoints["Africa/Freetown"] = new Compass.GeographicPoint(8.49, -13.234167));
            /* put */(timeZoneGeographicPoints["Africa/Lome"] = new Compass.GeographicPoint(6.131944, 1.2227778));
            /* put */(timeZoneGeographicPoints["Africa/Monrovia"] = new Compass.GeographicPoint(6.3105555, -10.804722));
            /* put */(timeZoneGeographicPoints["Africa/Nouakchott"] = new Compass.GeographicPoint(18.08639, -15.975278));
            /* put */(timeZoneGeographicPoints["Africa/Ouagadougou"] = new Compass.GeographicPoint(12.370277, -1.5247222));
            /* put */(timeZoneGeographicPoints["Africa/Sao_Tome"] = new Compass.GeographicPoint(0.3333333, 6.733333));
            /* put */(timeZoneGeographicPoints["Africa/Timbuktu"] = new Compass.GeographicPoint(16.766666, -3.0166667));
            /* put */(timeZoneGeographicPoints["America/Danmarkshavn"] = new Compass.GeographicPoint(76.767, 18.667));
            /* put */(timeZoneGeographicPoints["Atlantic/Canary"] = new Compass.GeographicPoint(28.45, -16.233334));
            /* put */(timeZoneGeographicPoints["Atlantic/Faeroe"] = new Compass.GeographicPoint(62.016666, -6.766667));
            /* put */(timeZoneGeographicPoints["Atlantic/Faroe"] = new Compass.GeographicPoint(62.016666, -6.766667));
            /* put */(timeZoneGeographicPoints["Atlantic/Madeira"] = new Compass.GeographicPoint(32.633335, -16.9));
            /* put */(timeZoneGeographicPoints["Atlantic/Reykjavik"] = new Compass.GeographicPoint(64.15, -21.95));
            /* put */(timeZoneGeographicPoints["Atlantic/St_Helena"] = new Compass.GeographicPoint(-15.933333, -5.7166667));
            const greenwich: Compass.GeographicPoint = new Compass.GeographicPoint(51.466667, 0.0);
            /* put */(timeZoneGeographicPoints["Etc/GMT"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/GMT+0"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/GMT-0"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/GMT0"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/Greenwich"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/UCT"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/UTC"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/Universal"] = greenwich);
            /* put */(timeZoneGeographicPoints["Etc/Zulu"] = greenwich);
            /* put */(timeZoneGeographicPoints["Europe/Belfast"] = new Compass.GeographicPoint(54.583332, -5.933333));
            /* put */(timeZoneGeographicPoints["Europe/Dublin"] = new Compass.GeographicPoint(53.333057, -6.248889));
            /* put */(timeZoneGeographicPoints["Europe/Guernsey"] = new Compass.GeographicPoint(49.45, -2.533));
            /* put */(timeZoneGeographicPoints["Europe/Isle_of_Man"] = new Compass.GeographicPoint(54.14521, -4.48172));
            /* put */(timeZoneGeographicPoints["Europe/Jersey"] = new Compass.GeographicPoint(49.2, -2.117));
            /* put */(timeZoneGeographicPoints["Europe/Lisbon"] = new Compass.GeographicPoint(38.716667, -9.133333));
            /* put */(timeZoneGeographicPoints["Europe/London"] = new Compass.GeographicPoint(51.5, -0.116667));
            /* put */(timeZoneGeographicPoints["Africa/Algiers"] = new Compass.GeographicPoint(36.763054, 3.0505557));
            /* put */(timeZoneGeographicPoints["Africa/Bangui"] = new Compass.GeographicPoint(4.366667, 18.583334));
            /* put */(timeZoneGeographicPoints["Africa/Brazzaville"] = new Compass.GeographicPoint(-4.2591667, 15.284722));
            /* put */(timeZoneGeographicPoints["Africa/Ceuta"] = new Compass.GeographicPoint(35.890278, -5.3075));
            /* put */(timeZoneGeographicPoints["Africa/Douala"] = new Compass.GeographicPoint(4.0502777, 9.7));
            /* put */(timeZoneGeographicPoints["Africa/Kinshasa"] = new Compass.GeographicPoint(-4.3, 15.3));
            /* put */(timeZoneGeographicPoints["Africa/Lagos"] = new Compass.GeographicPoint(6.4530554, 3.3958333));
            /* put */(timeZoneGeographicPoints["Africa/Libreville"] = new Compass.GeographicPoint(0.3833333, 9.45));
            /* put */(timeZoneGeographicPoints["Africa/Luanda"] = new Compass.GeographicPoint(-8.838333, 13.234445));
            /* put */(timeZoneGeographicPoints["Africa/Malabo"] = new Compass.GeographicPoint(3.75, 8.783333));
            /* put */(timeZoneGeographicPoints["Africa/Ndjamena"] = new Compass.GeographicPoint(12.113055, 15.049167));
            /* put */(timeZoneGeographicPoints["Africa/Niamey"] = new Compass.GeographicPoint(13.516666, 2.1166668));
            /* put */(timeZoneGeographicPoints["Africa/Porto-Novo"] = new Compass.GeographicPoint(6.483333, 2.6166668));
            /* put */(timeZoneGeographicPoints["Africa/Tunis"] = new Compass.GeographicPoint(36.802776, 10.179722));
            /* put */(timeZoneGeographicPoints["Africa/Windhoek"] = new Compass.GeographicPoint(-22.57, 17.08361));
            /* put */(timeZoneGeographicPoints["Arctic/Longyearbyen"] = new Compass.GeographicPoint(78.21667, 15.633333));
            /* put */(timeZoneGeographicPoints["Atlantic/Jan_Mayen"] = new Compass.GeographicPoint(71.0, -8.333));
            const paris: Compass.GeographicPoint = new Compass.GeographicPoint(48.86667, 2.333333);
            /* put */(timeZoneGeographicPoints["Etc/GMT-1"] = paris);
            /* put */(timeZoneGeographicPoints["Europe/Amsterdam"] = new Compass.GeographicPoint(52.35, 4.9166665));
            /* put */(timeZoneGeographicPoints["Europe/Andorra"] = new Compass.GeographicPoint(42.5, 1.5166667));
            /* put */(timeZoneGeographicPoints["Europe/Belgrade"] = new Compass.GeographicPoint(44.81861, 20.468056));
            /* put */(timeZoneGeographicPoints["Europe/Berlin"] = new Compass.GeographicPoint(52.516666, 13.4));
            /* put */(timeZoneGeographicPoints["Europe/Bratislava"] = new Compass.GeographicPoint(48.15, 17.116667));
            /* put */(timeZoneGeographicPoints["Europe/Brussels"] = new Compass.GeographicPoint(50.833332, 4.333333));
            /* put */(timeZoneGeographicPoints["Europe/Budapest"] = new Compass.GeographicPoint(47.5, 19.083334));
            /* put */(timeZoneGeographicPoints["Europe/Copenhagen"] = new Compass.GeographicPoint(55.666668, 12.583333));
            /* put */(timeZoneGeographicPoints["Europe/Gibraltar"] = new Compass.GeographicPoint(36.133335, -5.35));
            /* put */(timeZoneGeographicPoints["Europe/Ljubljana"] = new Compass.GeographicPoint(46.05528, 14.514444));
            /* put */(timeZoneGeographicPoints["Europe/Luxembourg"] = new Compass.GeographicPoint(49.611668, 6.13));
            /* put */(timeZoneGeographicPoints["Europe/Madrid"] = new Compass.GeographicPoint(40.4, -3.6833334));
            /* put */(timeZoneGeographicPoints["Europe/Malta"] = new Compass.GeographicPoint(35.899723, 14.514722));
            /* put */(timeZoneGeographicPoints["Europe/Monaco"] = new Compass.GeographicPoint(43.733334, 7.4166665));
            /* put */(timeZoneGeographicPoints["Europe/Oslo"] = new Compass.GeographicPoint(59.916668, 10.75));
            /* put */(timeZoneGeographicPoints["Europe/Paris"] = paris);
            /* put */(timeZoneGeographicPoints["Europe/Podgorica"] = new Compass.GeographicPoint(42.441113, 19.26361));
            /* put */(timeZoneGeographicPoints["Europe/Prague"] = new Compass.GeographicPoint(50.083332, 14.466667));
            /* put */(timeZoneGeographicPoints["Europe/Rome"] = new Compass.GeographicPoint(41.9, 12.483334));
            /* put */(timeZoneGeographicPoints["Europe/San_Marino"] = new Compass.GeographicPoint(43.933334, 12.45));
            /* put */(timeZoneGeographicPoints["Europe/Sarajevo"] = new Compass.GeographicPoint(43.85, 18.383333));
            /* put */(timeZoneGeographicPoints["Europe/Skopje"] = new Compass.GeographicPoint(42.0, 21.433332));
            /* put */(timeZoneGeographicPoints["Europe/Stockholm"] = new Compass.GeographicPoint(59.333332, 18.05));
            /* put */(timeZoneGeographicPoints["Europe/Tirane"] = new Compass.GeographicPoint(41.3275, 19.81889));
            /* put */(timeZoneGeographicPoints["Europe/Vaduz"] = new Compass.GeographicPoint(47.133335, 9.516666));
            /* put */(timeZoneGeographicPoints["Europe/Vatican"] = new Compass.GeographicPoint(41.9, 12.45));
            /* put */(timeZoneGeographicPoints["Europe/Vienna"] = new Compass.GeographicPoint(48.2, 16.366667));
            /* put */(timeZoneGeographicPoints["Europe/Warsaw"] = new Compass.GeographicPoint(52.25, 21.0));
            /* put */(timeZoneGeographicPoints["Europe/Zagreb"] = new Compass.GeographicPoint(45.8, 16.0));
            /* put */(timeZoneGeographicPoints["Europe/Zurich"] = new Compass.GeographicPoint(47.366665, 8.55));
            /* put */(timeZoneGeographicPoints["Africa/Blantyre"] = new Compass.GeographicPoint(-15.783333, 35.0));
            /* put */(timeZoneGeographicPoints["Africa/Bujumbura"] = new Compass.GeographicPoint(-3.376111, 29.36));
            /* put */(timeZoneGeographicPoints["Africa/Cairo"] = new Compass.GeographicPoint(30.05, 31.25));
            /* put */(timeZoneGeographicPoints["Africa/Gaborone"] = new Compass.GeographicPoint(-24.646389, 25.911945));
            /* put */(timeZoneGeographicPoints["Africa/Harare"] = new Compass.GeographicPoint(-17.817778, 31.044722));
            /* put */(timeZoneGeographicPoints["Africa/Johannesburg"] = new Compass.GeographicPoint(-26.2, 28.083334));
            /* put */(timeZoneGeographicPoints["Africa/Kigali"] = new Compass.GeographicPoint(-1.9536111, 30.060556));
            /* put */(timeZoneGeographicPoints["Africa/Lubumbashi"] = new Compass.GeographicPoint(-11.666667, 27.466667));
            /* put */(timeZoneGeographicPoints["Africa/Lusaka"] = new Compass.GeographicPoint(-15.416667, 28.283333));
            /* put */(timeZoneGeographicPoints["Africa/Maputo"] = new Compass.GeographicPoint(-25.965279, 32.58917));
            /* put */(timeZoneGeographicPoints["Africa/Maseru"] = new Compass.GeographicPoint(-29.316668, 27.483334));
            /* put */(timeZoneGeographicPoints["Africa/Mbabane"] = new Compass.GeographicPoint(-26.316668, 31.133333));
            /* put */(timeZoneGeographicPoints["Africa/Tripoli"] = new Compass.GeographicPoint(32.8925, 13.18));
            /* put */(timeZoneGeographicPoints["Asia/Amman"] = new Compass.GeographicPoint(31.95, 35.933334));
            /* put */(timeZoneGeographicPoints["Asia/Beirut"] = new Compass.GeographicPoint(33.871944, 35.509724));
            /* put */(timeZoneGeographicPoints["Asia/Damascus"] = new Compass.GeographicPoint(33.5, 36.3));
            /* put */(timeZoneGeographicPoints["Asia/Gaza"] = new Compass.GeographicPoint(31.5, 34.466667));
            /* put */(timeZoneGeographicPoints["Asia/Istanbul"] = new Compass.GeographicPoint(41.018612, 28.964722));
            /* put */(timeZoneGeographicPoints["Asia/Jerusalem"] = new Compass.GeographicPoint(31.78, 35.23));
            /* put */(timeZoneGeographicPoints["Asia/Nicosia"] = new Compass.GeographicPoint(35.166668, 33.366665));
            /* put */(timeZoneGeographicPoints["Asia/Tel_Aviv"] = new Compass.GeographicPoint(32.066666, 34.766666));
            const athens: Compass.GeographicPoint = new Compass.GeographicPoint(37.983334, 23.733334);
            /* put */(timeZoneGeographicPoints["Etc/GMT-2"] = athens);
            /* put */(timeZoneGeographicPoints["Europe/Athens"] = new Compass.GeographicPoint(37.983334, 23.733334));
            /* put */(timeZoneGeographicPoints["Europe/Bucharest"] = new Compass.GeographicPoint(44.433334, 26.1));
            /* put */(timeZoneGeographicPoints["Europe/Chisinau"] = new Compass.GeographicPoint(47.005554, 28.8575));
            /* put */(timeZoneGeographicPoints["Europe/Helsinki"] = new Compass.GeographicPoint(60.175556, 24.934166));
            /* put */(timeZoneGeographicPoints["Europe/Istanbul"] = new Compass.GeographicPoint(41.018612, 28.964722));
            /* put */(timeZoneGeographicPoints["Europe/Kaliningrad"] = new Compass.GeographicPoint(54.71, 20.5));
            /* put */(timeZoneGeographicPoints["Europe/Kiev"] = new Compass.GeographicPoint(50.433334, 30.516666));
            /* put */(timeZoneGeographicPoints["Europe/Mariehamn"] = new Compass.GeographicPoint(60.1, 19.95));
            /* put */(timeZoneGeographicPoints["Europe/Minsk"] = new Compass.GeographicPoint(53.9, 27.566668));
            /* put */(timeZoneGeographicPoints["Europe/Nicosia"] = new Compass.GeographicPoint(35.166668, 33.366665));
            /* put */(timeZoneGeographicPoints["Europe/Riga"] = new Compass.GeographicPoint(56.95, 24.1));
            /* put */(timeZoneGeographicPoints["Europe/Simferopol"] = new Compass.GeographicPoint(44.95, 34.1));
            /* put */(timeZoneGeographicPoints["Europe/Sofia"] = new Compass.GeographicPoint(42.683334, 23.316668));
            /* put */(timeZoneGeographicPoints["Europe/Tallinn"] = new Compass.GeographicPoint(59.433887, 24.728056));
            /* put */(timeZoneGeographicPoints["Europe/Tiraspol"] = new Compass.GeographicPoint(46.84028, 29.643333));
            /* put */(timeZoneGeographicPoints["Europe/Uzhgorod"] = new Compass.GeographicPoint(48.616665, 22.3));
            /* put */(timeZoneGeographicPoints["Europe/Vilnius"] = new Compass.GeographicPoint(54.683334, 25.316668));
            /* put */(timeZoneGeographicPoints["Europe/Zaporozhye"] = new Compass.GeographicPoint(47.833, 35.1667));
            /* put */(timeZoneGeographicPoints["Africa/Addis_Ababa"] = new Compass.GeographicPoint(9.033333, 38.7));
            /* put */(timeZoneGeographicPoints["Africa/Asmara"] = new Compass.GeographicPoint(15.333333, 38.933334));
            /* put */(timeZoneGeographicPoints["Africa/Asmera"] = new Compass.GeographicPoint(15.333333, 38.933334));
            /* put */(timeZoneGeographicPoints["Africa/Dar_es_Salaam"] = new Compass.GeographicPoint(-6.8, 39.283333));
            /* put */(timeZoneGeographicPoints["Africa/Djibouti"] = new Compass.GeographicPoint(11.595, 43.148056));
            /* put */(timeZoneGeographicPoints["Africa/Kampala"] = new Compass.GeographicPoint(0.3155556, 32.565556));
            /* put */(timeZoneGeographicPoints["Africa/Khartoum"] = new Compass.GeographicPoint(15.588056, 32.53417));
            /* put */(timeZoneGeographicPoints["Africa/Mogadishu"] = new Compass.GeographicPoint(2.0666666, 45.366665));
            /* put */(timeZoneGeographicPoints["Africa/Nairobi"] = new Compass.GeographicPoint(-1.2833333, 36.816666));
            /* put */(timeZoneGeographicPoints["Antarctica/Syowa"] = new Compass.GeographicPoint(-69.0, 39.5833));
            /* put */(timeZoneGeographicPoints["Asia/Aden"] = new Compass.GeographicPoint(12.779445, 45.036667));
            /* put */(timeZoneGeographicPoints["Asia/Baghdad"] = new Compass.GeographicPoint(33.33861, 44.39389));
            /* put */(timeZoneGeographicPoints["Asia/Bahrain"] = new Compass.GeographicPoint(26.23611, 50.583057));
            /* put */(timeZoneGeographicPoints["Asia/Kuwait"] = new Compass.GeographicPoint(29.369722, 47.978333));
            /* put */(timeZoneGeographicPoints["Asia/Qatar"] = new Compass.GeographicPoint(25.286667, 51.533333));
            /* put */(timeZoneGeographicPoints["Asia/Riyadh"] = new Compass.GeographicPoint(24.640833, 46.772778));
            const moscow: Compass.GeographicPoint = new Compass.GeographicPoint(55.752224, 37.615555);
            /* put */(timeZoneGeographicPoints["Etc/GMT-3"] = moscow);
            /* put */(timeZoneGeographicPoints["Europe/Moscow"] = moscow);
            /* put */(timeZoneGeographicPoints["Europe/Volgograd"] = new Compass.GeographicPoint(48.80472, 44.585835));
            /* put */(timeZoneGeographicPoints["Indian/Antananarivo"] = new Compass.GeographicPoint(-18.916666, 47.516666));
            /* put */(timeZoneGeographicPoints["Indian/Comoro"] = new Compass.GeographicPoint(-11.704166, 43.240276));
            /* put */(timeZoneGeographicPoints["Indian/Mayotte"] = new Compass.GeographicPoint(-12.779445, 45.227222));
            /* put */(timeZoneGeographicPoints["Asia/Riyadh87"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Asia/Riyadh88"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Asia/Riyadh89"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Mideast/Riyadh87"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Mideast/Riyadh88"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Mideast/Riyadh89"] = new Compass.GeographicPoint(24.640833, 46.772778));
            /* put */(timeZoneGeographicPoints["Asia/Tehran"] = new Compass.GeographicPoint(35.671944, 51.424446));
            /* put */(timeZoneGeographicPoints["Asia/Baku"] = new Compass.GeographicPoint(40.39528, 49.88222));
            const dubai: Compass.GeographicPoint = new Compass.GeographicPoint(25.252222, 55.28);
            /* put */(timeZoneGeographicPoints["Asia/Dubai"] = dubai);
            /* put */(timeZoneGeographicPoints["Asia/Muscat"] = new Compass.GeographicPoint(23.613333, 58.593334));
            /* put */(timeZoneGeographicPoints["Asia/Tbilisi"] = new Compass.GeographicPoint(41.725, 44.790833));
            /* put */(timeZoneGeographicPoints["Asia/Yerevan"] = new Compass.GeographicPoint(40.18111, 44.51361));
            /* put */(timeZoneGeographicPoints["Etc/GMT-4"] = dubai);
            /* put */(timeZoneGeographicPoints["Europe/Samara"] = new Compass.GeographicPoint(53.2, 50.15));
            /* put */(timeZoneGeographicPoints["Indian/Mahe"] = new Compass.GeographicPoint(-4.616667, 55.45));
            /* put */(timeZoneGeographicPoints["Indian/Mauritius"] = new Compass.GeographicPoint(-20.161945, 57.49889));
            /* put */(timeZoneGeographicPoints["Indian/Reunion"] = new Compass.GeographicPoint(-20.866667, 55.466667));
            /* put */(timeZoneGeographicPoints["Asia/Kabul"] = new Compass.GeographicPoint(34.516666, 69.183334));
            /* put */(timeZoneGeographicPoints["Antarctica/Davis"] = new Compass.GeographicPoint(-68.5764, 77.9689));
            /* put */(timeZoneGeographicPoints["Antarctica/Mawson"] = new Compass.GeographicPoint(-53.104, 73.514));
            /* put */(timeZoneGeographicPoints["Asia/Aqtau"] = new Compass.GeographicPoint(43.65, 51.2));
            /* put */(timeZoneGeographicPoints["Asia/Aqtobe"] = new Compass.GeographicPoint(50.298054, 57.18139));
            /* put */(timeZoneGeographicPoints["Asia/Ashgabat"] = new Compass.GeographicPoint(37.95, 58.383335));
            /* put */(timeZoneGeographicPoints["Asia/Ashkhabad"] = new Compass.GeographicPoint(37.95, 58.383335));
            /* put */(timeZoneGeographicPoints["Asia/Dushanbe"] = new Compass.GeographicPoint(38.56, 68.77389));
            /* put */(timeZoneGeographicPoints["Asia/Karachi"] = new Compass.GeographicPoint(24.866667, 67.05));
            /* put */(timeZoneGeographicPoints["Asia/Oral"] = new Compass.GeographicPoint(51.233334, 51.366665));
            /* put */(timeZoneGeographicPoints["Asia/Samarkand"] = new Compass.GeographicPoint(39.654167, 66.959724));
            /* put */(timeZoneGeographicPoints["Asia/Tashkent"] = new Compass.GeographicPoint(41.316666, 69.25));
            /* put */(timeZoneGeographicPoints["Asia/Yekaterinburg"] = new Compass.GeographicPoint(56.85, 60.6));
            const calcutta: Compass.GeographicPoint = new Compass.GeographicPoint(22.569721, 88.36972);
            /* put */(timeZoneGeographicPoints["Etc/GMT-5"] = calcutta);
            /* put */(timeZoneGeographicPoints["Indian/Kerguelen"] = new Compass.GeographicPoint(-49.25, 69.583));
            /* put */(timeZoneGeographicPoints["Indian/Maldives"] = new Compass.GeographicPoint(4.1666665, 73.5));
            /* put */(timeZoneGeographicPoints["Asia/Calcutta"] = calcutta);
            /* put */(timeZoneGeographicPoints["Asia/Colombo"] = new Compass.GeographicPoint(6.9319444, 79.84778));
            /* put */(timeZoneGeographicPoints["Asia/Kolkata"] = calcutta);
            /* put */(timeZoneGeographicPoints["Asia/Kathmandu"] = new Compass.GeographicPoint(27.716667, 85.316666));
            /* put */(timeZoneGeographicPoints["Asia/Katmandu"] = new Compass.GeographicPoint(27.716667, 85.316666));
            /* put */(timeZoneGeographicPoints["Antarctica/Vostok"] = new Compass.GeographicPoint(-78.4644, 106.8372));
            /* put */(timeZoneGeographicPoints["Asia/Almaty"] = new Compass.GeographicPoint(43.25, 76.95));
            /* put */(timeZoneGeographicPoints["Asia/Bishkek"] = new Compass.GeographicPoint(42.873055, 74.60028));
            const dacca: Compass.GeographicPoint = new Compass.GeographicPoint(23.723055, 90.40861);
            /* put */(timeZoneGeographicPoints["Asia/Dacca"] = dacca);
            /* put */(timeZoneGeographicPoints["Asia/Dhaka"] = dacca);
            /* put */(timeZoneGeographicPoints["Asia/Novokuznetsk"] = new Compass.GeographicPoint(53.75, 87.1));
            /* put */(timeZoneGeographicPoints["Asia/Novosibirsk"] = new Compass.GeographicPoint(55.04111, 82.93444));
            /* put */(timeZoneGeographicPoints["Asia/Omsk"] = new Compass.GeographicPoint(55.0, 73.4));
            /* put */(timeZoneGeographicPoints["Asia/Qyzylorda"] = new Compass.GeographicPoint(44.85278, 65.50916));
            /* put */(timeZoneGeographicPoints["Asia/Thimbu"] = new Compass.GeographicPoint(27.483334, 89.6));
            /* put */(timeZoneGeographicPoints["Asia/Thimphu"] = new Compass.GeographicPoint(27.483334, 89.6));
            /* put */(timeZoneGeographicPoints["Etc/GMT-6"] = dacca);
            /* put */(timeZoneGeographicPoints["Indian/Chagos"] = new Compass.GeographicPoint(-6.0, 71.5));
            /* put */(timeZoneGeographicPoints["Asia/Rangoon"] = new Compass.GeographicPoint(16.783333, 96.166664));
            /* put */(timeZoneGeographicPoints["Indian/Cocos"] = new Compass.GeographicPoint(-12.1167, 96.9));
            const bangkok: Compass.GeographicPoint = new Compass.GeographicPoint(13.75, 100.51667);
            /* put */(timeZoneGeographicPoints["Asia/Bangkok"] = bangkok);
            /* put */(timeZoneGeographicPoints["Asia/Ho_Chi_Minh"] = new Compass.GeographicPoint(10.75, 106.666664));
            /* put */(timeZoneGeographicPoints["Asia/Hovd"] = new Compass.GeographicPoint(48.016666, 91.63333));
            /* put */(timeZoneGeographicPoints["Asia/Jakarta"] = new Compass.GeographicPoint(-6.174444, 106.829445));
            /* put */(timeZoneGeographicPoints["Asia/Krasnoyarsk"] = new Compass.GeographicPoint(56.009724, 92.791664));
            /* put */(timeZoneGeographicPoints["Asia/Phnom_Penh"] = new Compass.GeographicPoint(11.55, 104.916664));
            /* put */(timeZoneGeographicPoints["Asia/Pontianak"] = new Compass.GeographicPoint(-0.0333333, 109.333336));
            /* put */(timeZoneGeographicPoints["Asia/Saigon"] = new Compass.GeographicPoint(10.75, 106.666664));
            /* put */(timeZoneGeographicPoints["Asia/Vientiane"] = new Compass.GeographicPoint(17.966667, 102.6));
            /* put */(timeZoneGeographicPoints["Etc/GMT-7"] = bangkok);
            /* put */(timeZoneGeographicPoints["Indian/Christmas"] = new Compass.GeographicPoint(-10.416667, 105.71667));
            /* put */(timeZoneGeographicPoints["Asia/Brunei"] = new Compass.GeographicPoint(4.883333, 114.933334));
            /* put */(timeZoneGeographicPoints["Asia/Choibalsan"] = new Compass.GeographicPoint(48.066666, 114.5));
            /* put */(timeZoneGeographicPoints["Asia/Chongqing"] = new Compass.GeographicPoint(29.562778, 106.55278));
            /* put */(timeZoneGeographicPoints["Asia/Chungking"] = new Compass.GeographicPoint(29.562778, 106.55278));
            /* put */(timeZoneGeographicPoints["Asia/Harbin"] = new Compass.GeographicPoint(45.75, 126.65));
            /* put */(timeZoneGeographicPoints["Asia/Hong_Kong"] = new Compass.GeographicPoint(22.283333, 114.15));
            /* put */(timeZoneGeographicPoints["Asia/Irkutsk"] = new Compass.GeographicPoint(52.266666, 104.333336));
            /* put */(timeZoneGeographicPoints["Asia/Kashgar"] = new Compass.GeographicPoint(39.391388, 76.04));
            /* put */(timeZoneGeographicPoints["Asia/Kuala_Lumpur"] = new Compass.GeographicPoint(3.1666667, 101.7));
            /* put */(timeZoneGeographicPoints["Asia/Kuching"] = new Compass.GeographicPoint(1.55, 110.333336));
            /* put */(timeZoneGeographicPoints["Asia/Macao"] = new Compass.GeographicPoint(22.2, 113.55));
            /* put */(timeZoneGeographicPoints["Asia/Macau"] = new Compass.GeographicPoint(22.2, 113.55));
            /* put */(timeZoneGeographicPoints["Asia/Makassar"] = new Compass.GeographicPoint(2.45, 99.78333));
            /* put */(timeZoneGeographicPoints["Asia/Manila"] = new Compass.GeographicPoint(14.604167, 120.98222));
            const shanghai: Compass.GeographicPoint = new Compass.GeographicPoint(31.005, 121.40861);
            /* put */(timeZoneGeographicPoints["Asia/Shanghai"] = shanghai);
            /* put */(timeZoneGeographicPoints["Asia/Singapore"] = new Compass.GeographicPoint(1.2930557, 103.855835));
            /* put */(timeZoneGeographicPoints["Asia/Taipei"] = new Compass.GeographicPoint(25.039167, 121.525));
            /* put */(timeZoneGeographicPoints["Asia/Ujung_Pandang"] = new Compass.GeographicPoint(-5.1305556, 119.406944));
            /* put */(timeZoneGeographicPoints["Asia/Ulaanbaatar"] = new Compass.GeographicPoint(47.916668, 106.916664));
            /* put */(timeZoneGeographicPoints["Asia/Ulan_Bator"] = new Compass.GeographicPoint(47.916668, 106.916664));
            /* put */(timeZoneGeographicPoints["Asia/Urumqi"] = new Compass.GeographicPoint(43.8, 87.583336));
            /* put */(timeZoneGeographicPoints["Australia/Perth"] = new Compass.GeographicPoint(-31.933332, 115.833336));
            /* put */(timeZoneGeographicPoints["Australia/West"] = new Compass.GeographicPoint(-31.933332, 115.833336));
            /* put */(timeZoneGeographicPoints["Etc/GMT-8"] = shanghai);
            /* put */(timeZoneGeographicPoints["Australia/Eucla"] = new Compass.GeographicPoint(-31.716667, 128.86667));
            /* put */(timeZoneGeographicPoints["Asia/Dili"] = new Compass.GeographicPoint(-8.55, 125.5833));
            /* put */(timeZoneGeographicPoints["Asia/Jayapura"] = new Compass.GeographicPoint(-2.5333333, 140.7));
            /* put */(timeZoneGeographicPoints["Asia/Pyongyang"] = new Compass.GeographicPoint(39.019444, 125.75472));
            /* put */(timeZoneGeographicPoints["Asia/Seoul"] = new Compass.GeographicPoint(37.566387, 126.999725));
            const tokyo: Compass.GeographicPoint = new Compass.GeographicPoint(35.685, 139.75139);
            /* put */(timeZoneGeographicPoints["Asia/Tokyo"] = tokyo);
            /* put */(timeZoneGeographicPoints["Asia/Yakutsk"] = new Compass.GeographicPoint(62.03389, 129.73306));
            /* put */(timeZoneGeographicPoints["Etc/GMT-9"] = tokyo);
            /* put */(timeZoneGeographicPoints["Pacific/Palau"] = new Compass.GeographicPoint(7.5, 134.6241));
            /* put */(timeZoneGeographicPoints["Australia/Adelaide"] = new Compass.GeographicPoint(-34.933334, 138.6));
            /* put */(timeZoneGeographicPoints["Australia/Broken_Hill"] = new Compass.GeographicPoint(-31.95, 141.43333));
            /* put */(timeZoneGeographicPoints["Australia/Darwin"] = new Compass.GeographicPoint(-12.466667, 130.83333));
            /* put */(timeZoneGeographicPoints["Australia/North"] = new Compass.GeographicPoint(-12.466667, 130.83333));
            /* put */(timeZoneGeographicPoints["Australia/South"] = new Compass.GeographicPoint(-34.933334, 138.6));
            /* put */(timeZoneGeographicPoints["Australia/Yancowinna"] = new Compass.GeographicPoint(-31.7581, 141.7178));
            /* put */(timeZoneGeographicPoints["Antarctica/DumontDUrville"] = new Compass.GeographicPoint(-66.66277, 140.0014));
            /* put */(timeZoneGeographicPoints["Asia/Sakhalin"] = new Compass.GeographicPoint(51.0, 143.0));
            /* put */(timeZoneGeographicPoints["Asia/Vladivostok"] = new Compass.GeographicPoint(43.133335, 131.9));
            /* put */(timeZoneGeographicPoints["Australia/ACT"] = new Compass.GeographicPoint(-35.283333, 149.21666));
            /* put */(timeZoneGeographicPoints["Australia/Brisbane"] = new Compass.GeographicPoint(-27.5, 153.01666));
            /* put */(timeZoneGeographicPoints["Australia/Canberra"] = new Compass.GeographicPoint(-35.283333, 149.21666));
            /* put */(timeZoneGeographicPoints["Australia/Currie"] = new Compass.GeographicPoint(-39.933334, 143.86667));
            /* put */(timeZoneGeographicPoints["Australia/Hobart"] = new Compass.GeographicPoint(-42.916668, 147.33333));
            /* put */(timeZoneGeographicPoints["Australia/Lindeman"] = new Compass.GeographicPoint(-20.45, 149.0333));
            /* put */(timeZoneGeographicPoints["Australia/Melbourne"] = new Compass.GeographicPoint(-37.816666, 144.96666));
            const sydney: Compass.GeographicPoint = new Compass.GeographicPoint(-33.88333, 151.21666);
            /* put */(timeZoneGeographicPoints["Australia/NSW"] = sydney);
            /* put */(timeZoneGeographicPoints["Australia/Queensland"] = new Compass.GeographicPoint(-27.5, 153.01666));
            /* put */(timeZoneGeographicPoints["Australia/Sydney"] = sydney);
            /* put */(timeZoneGeographicPoints["Australia/Tasmania"] = new Compass.GeographicPoint(-42.916668, 147.33333));
            /* put */(timeZoneGeographicPoints["Australia/Victoria"] = new Compass.GeographicPoint(-37.816666, 144.96666));
            /* put */(timeZoneGeographicPoints["Etc/GMT-10"] = sydney);
            /* put */(timeZoneGeographicPoints["Pacific/Guam"] = new Compass.GeographicPoint(13.467, 144.75));
            /* put */(timeZoneGeographicPoints["Pacific/Port_Moresby"] = new Compass.GeographicPoint(-9.464723, 147.1925));
            /* put */(timeZoneGeographicPoints["Pacific/Saipan"] = new Compass.GeographicPoint(15.1833, 145.75));
            /* put */(timeZoneGeographicPoints["Pacific/Truk"] = new Compass.GeographicPoint(7.4167, 151.7833));
            /* put */(timeZoneGeographicPoints["Pacific/Yap"] = new Compass.GeographicPoint(9.514444, 138.12917));
            /* put */(timeZoneGeographicPoints["Australia/LHI"] = new Compass.GeographicPoint(-31.55, 159.083));
            /* put */(timeZoneGeographicPoints["Australia/Lord_Howe"] = new Compass.GeographicPoint(-31.55, 159.083));
            /* put */(timeZoneGeographicPoints["Antarctica/Casey"] = new Compass.GeographicPoint(-66.2833, 110.5333));
            /* put */(timeZoneGeographicPoints["Asia/Magadan"] = new Compass.GeographicPoint(59.566666, 150.8));
            const noumea: Compass.GeographicPoint = new Compass.GeographicPoint(-22.266666, 166.45);
            /* put */(timeZoneGeographicPoints["Etc/GMT-11"] = noumea);
            /* put */(timeZoneGeographicPoints["Pacific/Efate"] = new Compass.GeographicPoint(-17.667, 168.417));
            /* put */(timeZoneGeographicPoints["Pacific/Guadalcanal"] = new Compass.GeographicPoint(-9.617, 160.183));
            /* put */(timeZoneGeographicPoints["Pacific/Kosrae"] = new Compass.GeographicPoint(5.317, 162.983));
            /* put */(timeZoneGeographicPoints["Pacific/Noumea"] = noumea);
            /* put */(timeZoneGeographicPoints["Pacific/Ponape"] = new Compass.GeographicPoint(6.963889, 158.20833));
            /* put */(timeZoneGeographicPoints["Pacific/Norfolk"] = new Compass.GeographicPoint(-29.05, 167.95));
            /* put */(timeZoneGeographicPoints["Antarctica/McMurdo"] = new Compass.GeographicPoint(-77.85, 166.667));
            /* put */(timeZoneGeographicPoints["Antarctica/South_Pole"] = new Compass.GeographicPoint(-90.0, 0.0));
            /* put */(timeZoneGeographicPoints["Asia/Anadyr"] = new Compass.GeographicPoint(64.75, 177.48334));
            /* put */(timeZoneGeographicPoints["Asia/Kamchatka"] = new Compass.GeographicPoint(57.0, 160.0));
            const auckland: Compass.GeographicPoint = new Compass.GeographicPoint(-36.86667, 174.76666);
            /* put */(timeZoneGeographicPoints["Etc/GMT-12"] = auckland);
            /* put */(timeZoneGeographicPoints["Pacific/Auckland"] = auckland);
            /* put */(timeZoneGeographicPoints["Pacific/Fiji"] = new Compass.GeographicPoint(-18.133333, 178.41667));
            /* put */(timeZoneGeographicPoints["Pacific/Funafuti"] = new Compass.GeographicPoint(-8.516666, 179.21666));
            /* put */(timeZoneGeographicPoints["Pacific/Kwajalein"] = new Compass.GeographicPoint(9.1939, 167.4597));
            /* put */(timeZoneGeographicPoints["Pacific/Majuro"] = new Compass.GeographicPoint(7.1, 171.38333));
            /* put */(timeZoneGeographicPoints["Pacific/Nauru"] = new Compass.GeographicPoint(-0.5322, 166.9328));
            /* put */(timeZoneGeographicPoints["Pacific/Tarawa"] = new Compass.GeographicPoint(1.4167, 173.0333));
            /* put */(timeZoneGeographicPoints["Pacific/Wake"] = new Compass.GeographicPoint(19.2833, 166.6));
            /* put */(timeZoneGeographicPoints["Pacific/Wallis"] = new Compass.GeographicPoint(-13.273, -176.205));
            /* put */(timeZoneGeographicPoints["Pacific/Chatham"] = new Compass.GeographicPoint(-43.883, -176.517));
            const enderbury: Compass.GeographicPoint = new Compass.GeographicPoint(-3.133, -171.0833);
            /* put */(timeZoneGeographicPoints["Etc/GMT-13"] = enderbury);
            /* put */(timeZoneGeographicPoints["Pacific/Enderbury"] = enderbury);
            /* put */(timeZoneGeographicPoints["Pacific/Tongatapu"] = new Compass.GeographicPoint(-21.2114, -175.153));
            const kiritimati: Compass.GeographicPoint = new Compass.GeographicPoint(1.883, -157.4);
            /* put */(timeZoneGeographicPoints["Etc/GMT-14"] = kiritimati);
            /* put */(timeZoneGeographicPoints["Pacific/Kiritimati"] = kiritimati);
            /* put */(timeZoneGeographicPoints["MIT"] = apia);
            /* put */(timeZoneGeographicPoints["HST"] = honolulu);
            /* put */(timeZoneGeographicPoints["PST"] = losAngeles);
            /* put */(timeZoneGeographicPoints["PST8PDT"] = losAngeles);
            /* put */(timeZoneGeographicPoints["MST"] = denver);
            /* put */(timeZoneGeographicPoints["MST7MDT"] = denver);
            /* put */(timeZoneGeographicPoints["Navajo"] = new Compass.GeographicPoint(35.6728, -109.0622));
            /* put */(timeZoneGeographicPoints["PNT"] = new Compass.GeographicPoint(33.448334, -112.07333));
            /* put */(timeZoneGeographicPoints["America/Indiana/Knox"] = new Compass.GeographicPoint(41.295834, -86.625));
            /* put */(timeZoneGeographicPoints["America/Indiana/Tell_City"] = new Compass.GeographicPoint(37.953, -86.7614));
            /* put */(timeZoneGeographicPoints["America/North_Dakota/Center"] = new Compass.GeographicPoint(47.115, -101.3003));
            /* put */(timeZoneGeographicPoints["America/North_Dakota/New_Salem"] = new Compass.GeographicPoint(46.843, 101.4119));
            /* put */(timeZoneGeographicPoints["CST"] = chicago);
            /* put */(timeZoneGeographicPoints["CST6CDT"] = chicago);
            /* put */(timeZoneGeographicPoints["America/Indiana/Indianapolis"] = new Compass.GeographicPoint(39.768333, -86.15806));
            /* put */(timeZoneGeographicPoints["America/Indiana/Marengo"] = new Compass.GeographicPoint(36.3706, -86.3433));
            /* put */(timeZoneGeographicPoints["America/Indiana/Petersburg"] = new Compass.GeographicPoint(38.4917, -87.2803));
            /* put */(timeZoneGeographicPoints["America/Indiana/Vevay"] = new Compass.GeographicPoint(38.7458, -85.0711));
            /* put */(timeZoneGeographicPoints["America/Indiana/Vincennes"] = new Compass.GeographicPoint(38.6783, -87.5164));
            /* put */(timeZoneGeographicPoints["America/Indiana/Winamac"] = new Compass.GeographicPoint(41.0525, -86.6044));
            /* put */(timeZoneGeographicPoints["America/Kentucky/Louisville"] = new Compass.GeographicPoint(38.2542, -85.7603));
            /* put */(timeZoneGeographicPoints["America/Kentucky/Monticello"] = new Compass.GeographicPoint(36.8381, -84.85));
            /* put */(timeZoneGeographicPoints["Cuba"] = new Compass.GeographicPoint(23.131945, -82.36417));
            /* put */(timeZoneGeographicPoints["EST"] = newYork);
            /* put */(timeZoneGeographicPoints["EST5EDT"] = newYork);
            /* put */(timeZoneGeographicPoints["IET"] = newYork);
            /* put */(timeZoneGeographicPoints["AST"] = new Compass.GeographicPoint(44.65, -63.6));
            /* put */(timeZoneGeographicPoints["Jamaica"] = new Compass.GeographicPoint(18.0, -76.8));
            /* put */(timeZoneGeographicPoints["America/Argentina/San_Luis"] = new Compass.GeographicPoint(-33.3, -66.333));
            /* put */(timeZoneGeographicPoints["PRT"] = new Compass.GeographicPoint(18.467, 66.117));
            /* put */(timeZoneGeographicPoints["CNT"] = new Compass.GeographicPoint(47.5675, -52.7072));
            /* put */(timeZoneGeographicPoints["AGT"] = new Compass.GeographicPoint(-34.5875, -58.6725));
            /* put */(timeZoneGeographicPoints["America/Argentina/Buenos_Aires"] = new Compass.GeographicPoint(-34.5875, -58.6725));
            /* put */(timeZoneGeographicPoints["America/Argentina/Catamarca"] = new Compass.GeographicPoint(-28.466667, -65.78333));
            /* put */(timeZoneGeographicPoints["America/Argentina/ComodRivadavia"] = new Compass.GeographicPoint(-42.7578, -65.0297));
            /* put */(timeZoneGeographicPoints["America/Argentina/Cordoba"] = new Compass.GeographicPoint(-31.4, -64.183334));
            /* put */(timeZoneGeographicPoints["America/Argentina/Jujuy"] = new Compass.GeographicPoint(-24.183332, -65.3));
            /* put */(timeZoneGeographicPoints["America/Argentina/La_Rioja"] = new Compass.GeographicPoint(-29.4144, -66.8552));
            /* put */(timeZoneGeographicPoints["America/Argentina/Mendoza"] = new Compass.GeographicPoint(-32.883335, -68.816666));
            /* put */(timeZoneGeographicPoints["America/Argentina/Rio_Gallegos"] = new Compass.GeographicPoint(-51.625, -69.2286));
            /* put */(timeZoneGeographicPoints["America/Argentina/Salta"] = new Compass.GeographicPoint(-24.783333, -65.416664));
            /* put */(timeZoneGeographicPoints["America/Argentina/San_Juan"] = new Compass.GeographicPoint(-31.5333, -68.5167));
            /* put */(timeZoneGeographicPoints["America/Argentina/Tucuman"] = new Compass.GeographicPoint(-26.8167, 65.2167));
            /* put */(timeZoneGeographicPoints["America/Argentina/Ushuaia"] = new Compass.GeographicPoint(-54.6, -68.3));
            /* put */(timeZoneGeographicPoints["BET"] = saoPaulo);
            /* put */(timeZoneGeographicPoints["Eire"] = new Compass.GeographicPoint(53.333057, -6.248889));
            /* put */(timeZoneGeographicPoints["GB"] = greenwich);
            /* put */(timeZoneGeographicPoints["GB-Eire"] = new Compass.GeographicPoint(53.333057, -6.248889));
            /* put */(timeZoneGeographicPoints["GMT"] = greenwich);
            /* put */(timeZoneGeographicPoints["GMT0"] = greenwich);
            /* put */(timeZoneGeographicPoints["Greenwich"] = greenwich);
            /* put */(timeZoneGeographicPoints["Iceland"] = new Compass.GeographicPoint(64.1333, -21.9333));
            /* put */(timeZoneGeographicPoints["Portugal"] = new Compass.GeographicPoint(38.716667, -9.133333));
            /* put */(timeZoneGeographicPoints["UCT"] = greenwich);
            /* put */(timeZoneGeographicPoints["UTC"] = greenwich);
            /* put */(timeZoneGeographicPoints["Universal"] = greenwich);
            /* put */(timeZoneGeographicPoints["WET"] = greenwich);
            /* put */(timeZoneGeographicPoints["Zulu"] = greenwich);
            /* put */(timeZoneGeographicPoints["CET"] = paris);
            /* put */(timeZoneGeographicPoints["ECT"] = paris);
            /* put */(timeZoneGeographicPoints["MET"] = new Compass.GeographicPoint(35.671944, 51.424446));
            /* put */(timeZoneGeographicPoints["Poland"] = new Compass.GeographicPoint(52.25, 21.0));
            /* put */(timeZoneGeographicPoints["ART"] = new Compass.GeographicPoint(-34.5875, -58.6725));
            /* put */(timeZoneGeographicPoints["CAT"] = new Compass.GeographicPoint(-1.9536111, 30.060556));
            /* put */(timeZoneGeographicPoints["EET"] = new Compass.GeographicPoint(37.983334, 23.733334));
            /* put */(timeZoneGeographicPoints["Egypt"] = new Compass.GeographicPoint(30.05, 31.25));
            /* put */(timeZoneGeographicPoints["Israel"] = new Compass.GeographicPoint(32.066666, 34.766666));
            /* put */(timeZoneGeographicPoints["Libya"] = new Compass.GeographicPoint(32.8925, 13.18));
            /* put */(timeZoneGeographicPoints["Turkey"] = new Compass.GeographicPoint(41.018612, 28.964722));
            /* put */(timeZoneGeographicPoints["EAT"] = new Compass.GeographicPoint(-1.2833333, 36.816666));
            /* put */(timeZoneGeographicPoints["W-SU"] = moscow);
            /* put */(timeZoneGeographicPoints["Iran"] = new Compass.GeographicPoint(35.671944, 51.424446));
            /* put */(timeZoneGeographicPoints["NET"] = new Compass.GeographicPoint(40.18111, 44.51361));
            /* put */(timeZoneGeographicPoints["PLT"] = new Compass.GeographicPoint(24.866667, 67.05));
            /* put */(timeZoneGeographicPoints["IST"] = calcutta);
            /* put */(timeZoneGeographicPoints["BST"] = dacca);
            /* put */(timeZoneGeographicPoints["VST"] = bangkok);
            /* put */(timeZoneGeographicPoints["CTT"] = shanghai);
            /* put */(timeZoneGeographicPoints["Hongkong"] = new Compass.GeographicPoint(22.283333, 114.15));
            /* put */(timeZoneGeographicPoints["PRC"] = shanghai);
            /* put */(timeZoneGeographicPoints["Singapore"] = new Compass.GeographicPoint(1.2930557, 103.855835));
            /* put */(timeZoneGeographicPoints["JST"] = tokyo);
            /* put */(timeZoneGeographicPoints["Japan"] = tokyo);
            /* put */(timeZoneGeographicPoints["ROK"] = new Compass.GeographicPoint(37.566387, 126.999725));
            /* put */(timeZoneGeographicPoints["ACT"] = new Compass.GeographicPoint(-35.283333, 149.21666));
            /* put */(timeZoneGeographicPoints["AET"] = sydney);
            /* put */(timeZoneGeographicPoints["SST"] = new Compass.GeographicPoint(-28.4667, 159.8167));
            /* put */(timeZoneGeographicPoints["Kwajalein"] = new Compass.GeographicPoint(9.1939, 167.4597));
            /* put */(timeZoneGeographicPoints["NST"] = auckland);
            /* put */(timeZoneGeographicPoints["NZ"] = auckland);
            /* put */(timeZoneGeographicPoints["NZ-CHAT"] = new Compass.GeographicPoint(-43.883, -176.517));
            Compass.timeZoneGeographicPointsReference = <any>(timeZoneGeographicPoints);
        }
        let point: Compass.GeographicPoint = /* get */((m, k) => m[k] === undefined ? null : m[k])(timeZoneGeographicPoints, /* getID *//* getDefault */"UTC");
        if (point == null) {
            point = /* get */((m, k) => m[k] === undefined ? null : m[k])(timeZoneGeographicPoints, "Etc/GMT");
        }
        this.latitude = <number>/* toRadians */(x => x * Math.PI / 180)(point.getLatitudeInDegrees());
        this.longitude = <number>/* toRadians */(x => x * Math.PI / 180)(point.getLongitudeInDegrees());
    }
}
Compass["__class"] = "com.eteks.sweethome3d.model.Compass";
Compass["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable"];



export namespace Compass {

    /**
     * A geographic point used to store known points.
     * @param {number} latitudeInDegrees
     * @param {number} longitudeInDegrees
     * @class
     */
    export class GeographicPoint {
        latitudeInDegrees: number;

        longitudeInDegrees: number;

        public constructor(latitudeInDegrees: number, longitudeInDegrees: number) {
            if (this.latitudeInDegrees === undefined) { this.latitudeInDegrees = 0; }
            if (this.longitudeInDegrees === undefined) { this.longitudeInDegrees = 0; }
            this.latitudeInDegrees = latitudeInDegrees;
            this.longitudeInDegrees = longitudeInDegrees;
        }

        public getLatitudeInDegrees(): number {
            return this.latitudeInDegrees;
        }

        public getLongitudeInDegrees(): number {
            return this.longitudeInDegrees;
        }
    }
    GeographicPoint["__class"] = "com.eteks.sweethome3d.model.Compass.GeographicPoint";

}
Compass['__transients'] = ['pointsCache', 'dateCache', 'sunElevationCache', 'sunAzimuthCache', 'propertyChangeSupport'];

/**
 * Creates a home piece of furniture from an existing piece.
 * @param {string} id    the ID of the piece
 * @param {Object} piece the piece from which data are copied
 * @param {java.lang.String[]} copiedProperties the names of the additional properties which should be copied from the existing piece
 * or <code>null</code> if all properties should be copied.
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class HomePieceOfFurniture extends HomeObject implements PieceOfFurniture, Selectable, Elevatable {
    static __static_initialized: boolean = false;
    static __static_initialize() { if (!HomePieceOfFurniture.__static_initialized) { HomePieceOfFurniture.__static_initialized = true; HomePieceOfFurniture.__static_initializer_0(); } }

    static TWICE_PI: number; public static TWICE_PI_$LI$(): number { HomePieceOfFurniture.__static_initialize(); if (HomePieceOfFurniture.TWICE_PI == null) { HomePieceOfFurniture.TWICE_PI = 2 * Math.PI; } return HomePieceOfFurniture.TWICE_PI; }

    static STRAIGHT_WALL_ANGLE_MARGIN: number; public static STRAIGHT_WALL_ANGLE_MARGIN_$LI$(): number { HomePieceOfFurniture.__static_initialize(); if (HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN == null) { HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN = /* toRadians */(x => x * Math.PI / 180)(1); } return HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN; }

    static ROUND_WALL_ANGLE_MARGIN: number; public static ROUND_WALL_ANGLE_MARGIN_$LI$(): number { HomePieceOfFurniture.__static_initialize(); if (HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN == null) { HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN = /* toRadians */(x => x * Math.PI / 180)(10); } return HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN; }

    static EMPTY_PROPERTY_ARRAY: string[]; public static EMPTY_PROPERTY_ARRAY_$LI$(): string[] { HomePieceOfFurniture.__static_initialize(); if (HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY == null) { HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY = []; } return HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY; }

    static SORTABLE_PROPERTY_COMPARATORS: any; public static SORTABLE_PROPERTY_COMPARATORS_$LI$(): any { HomePieceOfFurniture.__static_initialize(); return HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS; }

    static __static_initializer_0() {
        const collator: any = /* getInstance */{ compare: (o1, o2) => o1.toString().localeCompare(o2.toString()), equals: (o1, o2) => o1.toString().localeCompare(o2.toString()) === 0 };
        HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS = <any>({});
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "CATALOG_ID", new HomePieceOfFurniture.HomePieceOfFurniture$0(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "NAME", new HomePieceOfFurniture.HomePieceOfFurniture$1(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "DESCRIPTION", new HomePieceOfFurniture.HomePieceOfFurniture$2(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "CREATOR", new HomePieceOfFurniture.HomePieceOfFurniture$3(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "LICENSE", new HomePieceOfFurniture.HomePieceOfFurniture$4(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "WIDTH", new HomePieceOfFurniture.HomePieceOfFurniture$5());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "HEIGHT", new HomePieceOfFurniture.HomePieceOfFurniture$6());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "DEPTH", new HomePieceOfFurniture.HomePieceOfFurniture$7());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "MOVABLE", new HomePieceOfFurniture.HomePieceOfFurniture$8());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "DOOR_OR_WINDOW", new HomePieceOfFurniture.HomePieceOfFurniture$9());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "COLOR", new HomePieceOfFurniture.HomePieceOfFurniture$10());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "TEXTURE", new HomePieceOfFurniture.HomePieceOfFurniture$11(collator));
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "VISIBLE", new HomePieceOfFurniture.HomePieceOfFurniture$12());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "X", new HomePieceOfFurniture.HomePieceOfFurniture$13());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "Y", new HomePieceOfFurniture.HomePieceOfFurniture$14());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "ELEVATION", new HomePieceOfFurniture.HomePieceOfFurniture$15());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "ANGLE", new HomePieceOfFurniture.HomePieceOfFurniture$16());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "MODEL_SIZE", new HomePieceOfFurniture.HomePieceOfFurniture$17());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "LEVEL", new HomePieceOfFurniture.HomePieceOfFurniture$18());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "PRICE", new HomePieceOfFurniture.HomePieceOfFurniture$19());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "VALUE_ADDED_TAX_PERCENTAGE", new HomePieceOfFurniture.HomePieceOfFurniture$20());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "VALUE_ADDED_TAX", new HomePieceOfFurniture.HomePieceOfFurniture$21());
        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), "PRICE_VALUE_ADDED_TAX_INCLUDED", new HomePieceOfFurniture.HomePieceOfFurniture$22());
    }

    static compare$float$float(value1: number, value2: number): number {
        return /* compare */(value1 - value2);
    }

    static compare$boolean$boolean(value1: boolean, value2: boolean): number {
        return value1 === value2 ? 0 : (value1 ? -1 : 1);
    }

    public static compare$java_math_BigDecimal$java_math_BigDecimal(value1: Big, value2: Big): number {
        if (value1 === value2) {
            return 0;
        } else if (value1 == null) {
            return -1;
        } else if (value2 == null) {
            return 1;
        } else {
            return /* compareTo */value1.cmp(value2);
        }
    }

    public static compare(value1?: any, value2?: any): number {
        if (((value1 != null && value1 instanceof <any>Big) || value1 === null) && ((value2 != null && value2 instanceof <any>Big) || value2 === null)) {
            return <any>HomePieceOfFurniture.compare$java_math_BigDecimal$java_math_BigDecimal(value1, value2);
        } else if (((value1 != null && value1 instanceof <any>Level) || value1 === null) && ((value2 != null && value2 instanceof <any>Level) || value2 === null)) {
            return <any>HomePieceOfFurniture.compare$com_eteks_sweethome3d_model_Level$com_eteks_sweethome3d_model_Level(value1, value2);
        } else if (((typeof value1 === 'number') || value1 === null) && ((typeof value2 === 'number') || value2 === null)) {
            return <any>HomePieceOfFurniture.compare$float$float(value1, value2);
        } else if (((typeof value1 === 'boolean') || value1 === null) && ((typeof value2 === 'boolean') || value2 === null)) {
            return <any>HomePieceOfFurniture.compare$boolean$boolean(value1, value2);
        } else throw new Error('invalid overload');
    }

    static compare$com_eteks_sweethome3d_model_Level$com_eteks_sweethome3d_model_Level(level1: Level, level2: Level): number {
        if (level1 === level2) {
            return 0;
        } else if (level1 == null) {
            return -1;
        } else if (level2 == null) {
            return 1;
        } else {
            const elevationComparison: number = /* compare */(level1.getElevation() - level2.getElevation());
            if (elevationComparison !== 0) {
                return elevationComparison;
            } else {
                return level1.getElevationIndex() - level2.getElevationIndex();
            }
        }
    }

    static getComparableModelSize(piece: HomePieceOfFurniture): number {
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            let biggestModelSize: number = null;
            {
                let array = (<HomeFurnitureGroup>piece).getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        const modelSize: number = HomePieceOfFurniture.getComparableModelSize(childPiece);
                        if (modelSize != null && (biggestModelSize == null || /* longValue */biggestModelSize < /* longValue */modelSize)) {
                            biggestModelSize = modelSize;
                        }
                    }
                }
            }
            return biggestModelSize;
        } else {
            return piece.modelSize;
        }
    }

    /*private*/ catalogId: string;

    /*private*/ name: string;

    /*private*/ nameVisible: boolean;

    /*private*/ nameXOffset: number;

    /*private*/ nameYOffset: number;

    /*private*/ nameStyle: TextStyle;

    /*private*/ nameAngle: number;

    /*private*/ description: string;

    /*private*/ information: string;

    /*private*/ creator: string;

    /*private*/ license: string;

    /*private*/ icon: Content;

    /*private*/ planIcon: Content;

    /*private*/ model: Content;

    /*private*/ modelSize: number;

    /*private*/ width: number;

    /*private*/ widthInPlan: number;

    /*private*/ depth: number;

    /*private*/ depthInPlan: number;

    /*private*/ height: number;

    /*private*/ heightInPlan: number;

    /*private*/ elevation: number;

    /*private*/ dropOnTopElevation: number;

    /*private*/ movable: boolean;

    /*private*/ doorOrWindow: boolean;

    /*private*/ modelMaterials: HomeMaterial[];

    /*private*/ color: number;

    /*private*/ texture: HomeTexture;

    /*private*/ shininess: number;

    /*private*/ modelRotation: number[][];

    /*private*/ modelFlags: number;

    /*private*/ modelCenteredAtOrigin: boolean;

    /*private*/ modelTransformations: Transformation[];

    /*private*/ staircaseCutOutShape: string;

    /*private*/ backFaceShown: boolean;

    /*private*/ resizable: boolean;

    /*private*/ deformable: boolean;

    /*private*/ texturable: boolean;

    /*private*/ horizontallyRotatable: boolean;

    /*private*/ price: Big;

    /*private*/ valueAddedTaxPercentage: Big;

    /*private*/ currency: string;

    /*private*/ visible: boolean;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ angle: number;

    /*private*/ pitch: number;

    /*private*/ roll: number;

    /*private*/ modelMirrored: boolean;

    /*private*/ level: Level;

    /*private*/ shapeCache: java.awt.Shape;

    public constructor(id?: any, piece?: any, copiedProperties?: any) {
        if (((typeof id === 'string') || id === null) && ((piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.PieceOfFurniture") >= 0)) || piece === null) && ((copiedProperties != null && copiedProperties instanceof <any>Array && (copiedProperties.length == 0 || copiedProperties[0] == null || (typeof copiedProperties[0] === 'string'))) || copiedProperties === null)) {
            let __args = arguments;
            super(id);
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = false; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.roll === undefined) { this.roll = 0; }
            if (this.modelMirrored === undefined) { this.modelMirrored = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            this.name = piece.getName();
            this.description = piece.getDescription();
            this.information = piece.getInformation();
            this.creator = piece.getCreator();
            this.license = piece.getLicense();
            this.icon = piece.getIcon();
            this.planIcon = piece.getPlanIcon();
            this.model = piece.getModel();
            this.modelSize = piece.getModelSize();
            this.width = piece.getWidth();
            this.depth = piece.getDepth();
            this.height = piece.getHeight();
            this.elevation = piece.getElevation();
            this.dropOnTopElevation = piece.getDropOnTopElevation();
            this.movable = piece.isMovable();
            this.doorOrWindow = piece.isDoorOrWindow();
            this.color = piece.getColor();
            this.modelRotation = piece.getModelRotation();
            this.staircaseCutOutShape = piece.getStaircaseCutOutShape();
            this.modelFlags = piece.getModelFlags();
            this.resizable = piece.isResizable();
            this.deformable = piece.isDeformable();
            this.texturable = piece.isTexturable();
            this.horizontallyRotatable = piece.isHorizontallyRotatable();
            this.price = piece.getPrice();
            this.valueAddedTaxPercentage = piece.getValueAddedTaxPercentage();
            this.currency = piece.getCurrency();
            if (piece != null && piece instanceof <any>HomePieceOfFurniture) {
                const homePiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>piece;
                this.catalogId = homePiece.getCatalogId();
                this.nameVisible = homePiece.isNameVisible();
                this.nameXOffset = homePiece.getNameXOffset();
                this.nameYOffset = homePiece.getNameYOffset();
                this.nameAngle = homePiece.getNameAngle();
                this.nameStyle = homePiece.getNameStyle();
                this.visible = homePiece.isVisible();
                this.widthInPlan = homePiece.getWidthInPlan();
                this.depthInPlan = homePiece.getDepthInPlan();
                this.heightInPlan = homePiece.getHeightInPlan();
                this.modelCenteredAtOrigin = homePiece.isModelCenteredAtOrigin();
                this.modelTransformations = homePiece.getModelTransformations();
                this.angle = homePiece.getAngle();
                this.pitch = homePiece.getPitch();
                this.roll = homePiece.getRoll();
                this.x = homePiece.getX();
                this.y = homePiece.getY();
                this.modelMirrored = homePiece.isModelMirrored();
                this.texture = homePiece.getTexture();
                this.shininess = homePiece.getShininess();
                this.modelMaterials = homePiece.getModelMaterials();
                {
                    let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : homePiece.getPropertyNames();
                    for (let index = 0; index < array.length; index++) {
                        let property = array[index];
                        {
                            const value: any = homePiece.isContentProperty(property) ? homePiece.getContentProperty(property) : homePiece.getProperty(property);
                            if (value != null) {
                                this.setProperty$java_lang_String$java_lang_Object(property, value);
                            }
                        }
                    }
                }
            } else {
                if (piece != null && piece instanceof <any>CatalogPieceOfFurniture) {
                    const catalogPiece: CatalogPieceOfFurniture = <CatalogPieceOfFurniture><any>piece;
                    this.catalogId = catalogPiece.getId();
                    {
                        let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : catalogPiece.getPropertyNames();
                        for (let index = 0; index < array.length; index++) {
                            let property = array[index];
                            {
                                const value: any = catalogPiece.isContentProperty(property) ? catalogPiece.getContentProperty(property) : catalogPiece.getProperty(property);
                                if (value != null) {
                                    this.setProperty$java_lang_String$java_lang_Object(property, value);
                                }
                            }
                        }
                    }
                }
                this.visible = true;
                this.widthInPlan = this.width;
                this.depthInPlan = this.depth;
                this.heightInPlan = this.height;
                this.modelCenteredAtOrigin = true;
                this.x = this.width / 2;
                this.y = this.depth / 2;
            }
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.PieceOfFurniture") >= 0)) || id === null) && ((piece != null && piece instanceof <any>Array && (piece.length == 0 || piece[0] == null || (typeof piece[0] === 'string'))) || piece === null) && copiedProperties === undefined) {
            let __args = arguments;
            let piece: any = __args[0];
            let copiedProperties: any = __args[1];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("pieceOfFurniture");
                super(id);
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.nameVisible === undefined) { this.nameVisible = false; }
                if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
                if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
                if (this.nameStyle === undefined) { this.nameStyle = null; }
                if (this.nameAngle === undefined) { this.nameAngle = 0; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.modelMaterials === undefined) { this.modelMaterials = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.texture === undefined) { this.texture = null; }
                if (this.shininess === undefined) { this.shininess = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
                if (this.modelTransformations === undefined) { this.modelTransformations = null; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.visible === undefined) { this.visible = false; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.roll === undefined) { this.roll = 0; }
                if (this.modelMirrored === undefined) { this.modelMirrored = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.name = piece.getName();
                this.description = piece.getDescription();
                this.information = piece.getInformation();
                this.creator = piece.getCreator();
                this.license = piece.getLicense();
                this.icon = piece.getIcon();
                this.planIcon = piece.getPlanIcon();
                this.model = piece.getModel();
                this.modelSize = piece.getModelSize();
                this.width = piece.getWidth();
                this.depth = piece.getDepth();
                this.height = piece.getHeight();
                this.elevation = piece.getElevation();
                this.dropOnTopElevation = piece.getDropOnTopElevation();
                this.movable = piece.isMovable();
                this.doorOrWindow = piece.isDoorOrWindow();
                this.color = piece.getColor();
                this.modelRotation = piece.getModelRotation();
                this.staircaseCutOutShape = piece.getStaircaseCutOutShape();
                this.modelFlags = piece.getModelFlags();
                this.resizable = piece.isResizable();
                this.deformable = piece.isDeformable();
                this.texturable = piece.isTexturable();
                this.horizontallyRotatable = piece.isHorizontallyRotatable();
                this.price = piece.getPrice();
                this.valueAddedTaxPercentage = piece.getValueAddedTaxPercentage();
                this.currency = piece.getCurrency();
                if (piece != null && piece instanceof <any>HomePieceOfFurniture) {
                    const homePiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>piece;
                    this.catalogId = homePiece.getCatalogId();
                    this.nameVisible = homePiece.isNameVisible();
                    this.nameXOffset = homePiece.getNameXOffset();
                    this.nameYOffset = homePiece.getNameYOffset();
                    this.nameAngle = homePiece.getNameAngle();
                    this.nameStyle = homePiece.getNameStyle();
                    this.visible = homePiece.isVisible();
                    this.widthInPlan = homePiece.getWidthInPlan();
                    this.depthInPlan = homePiece.getDepthInPlan();
                    this.heightInPlan = homePiece.getHeightInPlan();
                    this.modelCenteredAtOrigin = homePiece.isModelCenteredAtOrigin();
                    this.modelTransformations = homePiece.getModelTransformations();
                    this.angle = homePiece.getAngle();
                    this.pitch = homePiece.getPitch();
                    this.roll = homePiece.getRoll();
                    this.x = homePiece.getX();
                    this.y = homePiece.getY();
                    this.modelMirrored = homePiece.isModelMirrored();
                    this.texture = homePiece.getTexture();
                    this.shininess = homePiece.getShininess();
                    this.modelMaterials = homePiece.getModelMaterials();
                    {
                        let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : homePiece.getPropertyNames();
                        for (let index = 0; index < array.length; index++) {
                            let property = array[index];
                            {
                                const value: any = homePiece.isContentProperty(property) ? homePiece.getContentProperty(property) : homePiece.getProperty(property);
                                if (value != null) {
                                    this.setProperty$java_lang_String$java_lang_Object(property, value);
                                }
                            }
                        }
                    }
                } else {
                    if (piece != null && piece instanceof <any>CatalogPieceOfFurniture) {
                        const catalogPiece: CatalogPieceOfFurniture = <CatalogPieceOfFurniture><any>piece;
                        this.catalogId = catalogPiece.getId();
                        {
                            let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : catalogPiece.getPropertyNames();
                            for (let index = 0; index < array.length; index++) {
                                let property = array[index];
                                {
                                    const value: any = catalogPiece.isContentProperty(property) ? catalogPiece.getContentProperty(property) : catalogPiece.getProperty(property);
                                    if (value != null) {
                                        this.setProperty$java_lang_String$java_lang_Object(property, value);
                                    }
                                }
                            }
                        }
                    }
                    this.visible = true;
                    this.widthInPlan = this.width;
                    this.depthInPlan = this.depth;
                    this.heightInPlan = this.height;
                    this.modelCenteredAtOrigin = true;
                    this.x = this.width / 2;
                    this.y = this.depth / 2;
                }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = false; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.roll === undefined) { this.roll = 0; }
            if (this.modelMirrored === undefined) { this.modelMirrored = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((typeof id === 'string') || id === null) && ((piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.PieceOfFurniture") >= 0)) || piece === null) && copiedProperties === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                super(id);
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.nameVisible === undefined) { this.nameVisible = false; }
                if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
                if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
                if (this.nameStyle === undefined) { this.nameStyle = null; }
                if (this.nameAngle === undefined) { this.nameAngle = 0; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.modelMaterials === undefined) { this.modelMaterials = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.texture === undefined) { this.texture = null; }
                if (this.shininess === undefined) { this.shininess = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
                if (this.modelTransformations === undefined) { this.modelTransformations = null; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.visible === undefined) { this.visible = false; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.roll === undefined) { this.roll = 0; }
                if (this.modelMirrored === undefined) { this.modelMirrored = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.name = piece.getName();
                this.description = piece.getDescription();
                this.information = piece.getInformation();
                this.creator = piece.getCreator();
                this.license = piece.getLicense();
                this.icon = piece.getIcon();
                this.planIcon = piece.getPlanIcon();
                this.model = piece.getModel();
                this.modelSize = piece.getModelSize();
                this.width = piece.getWidth();
                this.depth = piece.getDepth();
                this.height = piece.getHeight();
                this.elevation = piece.getElevation();
                this.dropOnTopElevation = piece.getDropOnTopElevation();
                this.movable = piece.isMovable();
                this.doorOrWindow = piece.isDoorOrWindow();
                this.color = piece.getColor();
                this.modelRotation = piece.getModelRotation();
                this.staircaseCutOutShape = piece.getStaircaseCutOutShape();
                this.modelFlags = piece.getModelFlags();
                this.resizable = piece.isResizable();
                this.deformable = piece.isDeformable();
                this.texturable = piece.isTexturable();
                this.horizontallyRotatable = piece.isHorizontallyRotatable();
                this.price = piece.getPrice();
                this.valueAddedTaxPercentage = piece.getValueAddedTaxPercentage();
                this.currency = piece.getCurrency();
                if (piece != null && piece instanceof <any>HomePieceOfFurniture) {
                    const homePiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>piece;
                    this.catalogId = homePiece.getCatalogId();
                    this.nameVisible = homePiece.isNameVisible();
                    this.nameXOffset = homePiece.getNameXOffset();
                    this.nameYOffset = homePiece.getNameYOffset();
                    this.nameAngle = homePiece.getNameAngle();
                    this.nameStyle = homePiece.getNameStyle();
                    this.visible = homePiece.isVisible();
                    this.widthInPlan = homePiece.getWidthInPlan();
                    this.depthInPlan = homePiece.getDepthInPlan();
                    this.heightInPlan = homePiece.getHeightInPlan();
                    this.modelCenteredAtOrigin = homePiece.isModelCenteredAtOrigin();
                    this.modelTransformations = homePiece.getModelTransformations();
                    this.angle = homePiece.getAngle();
                    this.pitch = homePiece.getPitch();
                    this.roll = homePiece.getRoll();
                    this.x = homePiece.getX();
                    this.y = homePiece.getY();
                    this.modelMirrored = homePiece.isModelMirrored();
                    this.texture = homePiece.getTexture();
                    this.shininess = homePiece.getShininess();
                    this.modelMaterials = homePiece.getModelMaterials();
                    {
                        let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : homePiece.getPropertyNames();
                        for (let index = 0; index < array.length; index++) {
                            let property = array[index];
                            {
                                const value: any = homePiece.isContentProperty(property) ? homePiece.getContentProperty(property) : homePiece.getProperty(property);
                                if (value != null) {
                                    this.setProperty$java_lang_String$java_lang_Object(property, value);
                                }
                            }
                        }
                    }
                } else {
                    if (piece != null && piece instanceof <any>CatalogPieceOfFurniture) {
                        const catalogPiece: CatalogPieceOfFurniture = <CatalogPieceOfFurniture><any>piece;
                        this.catalogId = catalogPiece.getId();
                        {
                            let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : catalogPiece.getPropertyNames();
                            for (let index = 0; index < array.length; index++) {
                                let property = array[index];
                                {
                                    const value: any = catalogPiece.isContentProperty(property) ? catalogPiece.getContentProperty(property) : catalogPiece.getProperty(property);
                                    if (value != null) {
                                        this.setProperty$java_lang_String$java_lang_Object(property, value);
                                    }
                                }
                            }
                        }
                    }
                    this.visible = true;
                    this.widthInPlan = this.width;
                    this.depthInPlan = this.depth;
                    this.heightInPlan = this.height;
                    this.modelCenteredAtOrigin = true;
                    this.x = this.width / 2;
                    this.y = this.depth / 2;
                }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = false; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.roll === undefined) { this.roll = 0; }
            if (this.modelMirrored === undefined) { this.modelMirrored = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.PieceOfFurniture") >= 0)) || id === null) && piece === undefined && copiedProperties === undefined) {
            let __args = arguments;
            let piece: any = __args[0];
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("pieceOfFurniture");
                    super(id);
                    if (this.catalogId === undefined) { this.catalogId = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.nameVisible === undefined) { this.nameVisible = false; }
                    if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
                    if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
                    if (this.nameStyle === undefined) { this.nameStyle = null; }
                    if (this.nameAngle === undefined) { this.nameAngle = 0; }
                    if (this.description === undefined) { this.description = null; }
                    if (this.information === undefined) { this.information = null; }
                    if (this.creator === undefined) { this.creator = null; }
                    if (this.license === undefined) { this.license = null; }
                    if (this.icon === undefined) { this.icon = null; }
                    if (this.planIcon === undefined) { this.planIcon = null; }
                    if (this.model === undefined) { this.model = null; }
                    if (this.modelSize === undefined) { this.modelSize = null; }
                    if (this.width === undefined) { this.width = 0; }
                    if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
                    if (this.depth === undefined) { this.depth = 0; }
                    if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
                    if (this.height === undefined) { this.height = 0; }
                    if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
                    if (this.elevation === undefined) { this.elevation = 0; }
                    if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                    if (this.movable === undefined) { this.movable = false; }
                    if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                    if (this.modelMaterials === undefined) { this.modelMaterials = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.texture === undefined) { this.texture = null; }
                    if (this.shininess === undefined) { this.shininess = null; }
                    if (this.modelRotation === undefined) { this.modelRotation = null; }
                    if (this.modelFlags === undefined) { this.modelFlags = 0; }
                    if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
                    if (this.modelTransformations === undefined) { this.modelTransformations = null; }
                    if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                    if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                    if (this.resizable === undefined) { this.resizable = false; }
                    if (this.deformable === undefined) { this.deformable = false; }
                    if (this.texturable === undefined) { this.texturable = false; }
                    if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                    if (this.price === undefined) { this.price = null; }
                    if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                    if (this.currency === undefined) { this.currency = null; }
                    if (this.visible === undefined) { this.visible = false; }
                    if (this.x === undefined) { this.x = 0; }
                    if (this.y === undefined) { this.y = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    if (this.pitch === undefined) { this.pitch = 0; }
                    if (this.roll === undefined) { this.roll = 0; }
                    if (this.modelMirrored === undefined) { this.modelMirrored = false; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                    this.name = piece.getName();
                    this.description = piece.getDescription();
                    this.information = piece.getInformation();
                    this.creator = piece.getCreator();
                    this.license = piece.getLicense();
                    this.icon = piece.getIcon();
                    this.planIcon = piece.getPlanIcon();
                    this.model = piece.getModel();
                    this.modelSize = piece.getModelSize();
                    this.width = piece.getWidth();
                    this.depth = piece.getDepth();
                    this.height = piece.getHeight();
                    this.elevation = piece.getElevation();
                    this.dropOnTopElevation = piece.getDropOnTopElevation();
                    this.movable = piece.isMovable();
                    this.doorOrWindow = piece.isDoorOrWindow();
                    this.color = piece.getColor();
                    this.modelRotation = piece.getModelRotation();
                    this.staircaseCutOutShape = piece.getStaircaseCutOutShape();
                    this.modelFlags = piece.getModelFlags();
                    this.resizable = piece.isResizable();
                    this.deformable = piece.isDeformable();
                    this.texturable = piece.isTexturable();
                    this.horizontallyRotatable = piece.isHorizontallyRotatable();
                    this.price = piece.getPrice();
                    this.valueAddedTaxPercentage = piece.getValueAddedTaxPercentage();
                    this.currency = piece.getCurrency();
                    if (piece != null && piece instanceof <any>HomePieceOfFurniture) {
                        const homePiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>piece;
                        this.catalogId = homePiece.getCatalogId();
                        this.nameVisible = homePiece.isNameVisible();
                        this.nameXOffset = homePiece.getNameXOffset();
                        this.nameYOffset = homePiece.getNameYOffset();
                        this.nameAngle = homePiece.getNameAngle();
                        this.nameStyle = homePiece.getNameStyle();
                        this.visible = homePiece.isVisible();
                        this.widthInPlan = homePiece.getWidthInPlan();
                        this.depthInPlan = homePiece.getDepthInPlan();
                        this.heightInPlan = homePiece.getHeightInPlan();
                        this.modelCenteredAtOrigin = homePiece.isModelCenteredAtOrigin();
                        this.modelTransformations = homePiece.getModelTransformations();
                        this.angle = homePiece.getAngle();
                        this.pitch = homePiece.getPitch();
                        this.roll = homePiece.getRoll();
                        this.x = homePiece.getX();
                        this.y = homePiece.getY();
                        this.modelMirrored = homePiece.isModelMirrored();
                        this.texture = homePiece.getTexture();
                        this.shininess = homePiece.getShininess();
                        this.modelMaterials = homePiece.getModelMaterials();
                        {
                            let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : homePiece.getPropertyNames();
                            for (let index = 0; index < array.length; index++) {
                                let property = array[index];
                                {
                                    const value: any = homePiece.isContentProperty(property) ? homePiece.getContentProperty(property) : homePiece.getProperty(property);
                                    if (value != null) {
                                        this.setProperty$java_lang_String$java_lang_Object(property, value);
                                    }
                                }
                            }
                        }
                    } else {
                        if (piece != null && piece instanceof <any>CatalogPieceOfFurniture) {
                            const catalogPiece: CatalogPieceOfFurniture = <CatalogPieceOfFurniture><any>piece;
                            this.catalogId = catalogPiece.getId();
                            {
                                let array = copiedProperties != null ? /* asList */copiedProperties.slice(0) : catalogPiece.getPropertyNames();
                                for (let index = 0; index < array.length; index++) {
                                    let property = array[index];
                                    {
                                        const value: any = catalogPiece.isContentProperty(property) ? catalogPiece.getContentProperty(property) : catalogPiece.getProperty(property);
                                        if (value != null) {
                                            this.setProperty$java_lang_String$java_lang_Object(property, value);
                                        }
                                    }
                                }
                            }
                        }
                        this.visible = true;
                        this.widthInPlan = this.width;
                        this.depthInPlan = this.depth;
                        this.heightInPlan = this.height;
                        this.modelCenteredAtOrigin = true;
                        this.x = this.width / 2;
                        this.y = this.depth / 2;
                    }
                }
                if (this.catalogId === undefined) { this.catalogId = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.nameVisible === undefined) { this.nameVisible = false; }
                if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
                if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
                if (this.nameStyle === undefined) { this.nameStyle = null; }
                if (this.nameAngle === undefined) { this.nameAngle = 0; }
                if (this.description === undefined) { this.description = null; }
                if (this.information === undefined) { this.information = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.license === undefined) { this.license = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.planIcon === undefined) { this.planIcon = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.modelSize === undefined) { this.modelSize = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.modelMaterials === undefined) { this.modelMaterials = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.texture === undefined) { this.texture = null; }
                if (this.shininess === undefined) { this.shininess = null; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.modelFlags === undefined) { this.modelFlags = 0; }
                if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
                if (this.modelTransformations === undefined) { this.modelTransformations = null; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.currency === undefined) { this.currency = null; }
                if (this.visible === undefined) { this.visible = false; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.roll === undefined) { this.roll = 0; }
                if (this.modelMirrored === undefined) { this.modelMirrored = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
            }
            if (this.catalogId === undefined) { this.catalogId = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = false; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.description === undefined) { this.description = null; }
            if (this.information === undefined) { this.information = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.license === undefined) { this.license = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.planIcon === undefined) { this.planIcon = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.modelSize === undefined) { this.modelSize = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.dropOnTopElevation === undefined) { this.dropOnTopElevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.modelFlags === undefined) { this.modelFlags = 0; }
            if (this.modelCenteredAtOrigin === undefined) { this.modelCenteredAtOrigin = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.horizontallyRotatable === undefined) { this.horizontallyRotatable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.roll === undefined) { this.roll = 0; }
            if (this.modelMirrored === undefined) { this.modelMirrored = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the catalog ID of this piece of furniture or <code>null</code> if it doesn't exist.
     * @return {string}
     */
    public getCatalogId(): string {
        return this.catalogId;
    }

    /**
     * Sets the catalog ID of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} catalogId
     */
    public setCatalogId(catalogId: string) {
        if (catalogId !== this.catalogId && (catalogId == null || !(catalogId === this.catalogId))) {
            const oldCatalogId: string = this.catalogId;
            this.catalogId = catalogId;
            this.firePropertyChange(/* name */"CATALOG_ID", oldCatalogId, catalogId);
        }
    }

    /**
     * Returns the name of this piece of furniture.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name && (name == null || !(name === this.name))) {
            const oldName: string = this.name;
            this.name = name;
            this.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns whether the name of this piece should be drawn or not.
     * @return {boolean}
     */
    public isNameVisible(): boolean {
        return this.nameVisible;
    }

    /**
     * Sets whether the name of this piece is visible or not. Once this piece of furniture
     * is updated, listeners added to this piece will receive a change notification.
     * @param {boolean} nameVisible
     */
    public setNameVisible(nameVisible: boolean) {
        if (nameVisible !== this.nameVisible) {
            this.nameVisible = nameVisible;
            this.firePropertyChange(/* name */"NAME_VISIBLE", !nameVisible, nameVisible);
        }
    }

    /**
     * Returns the distance along x axis applied to piece abscissa to display piece name.
     * @return {number}
     */
    public getNameXOffset(): number {
        return this.nameXOffset;
    }

    /**
     * Sets the distance along x axis applied to piece abscissa to display piece name.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} nameXOffset
     */
    public setNameXOffset(nameXOffset: number) {
        if (nameXOffset !== this.nameXOffset) {
            const oldNameXOffset: number = this.nameXOffset;
            this.nameXOffset = nameXOffset;
            this.firePropertyChange(/* name */"NAME_X_OFFSET", oldNameXOffset, nameXOffset);
        }
    }

    /**
     * Returns the distance along y axis applied to piece ordinate
     * to display piece name.
     * @return {number}
     */
    public getNameYOffset(): number {
        return this.nameYOffset;
    }

    /**
     * Sets the distance along y axis applied to piece ordinate to display piece name.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} nameYOffset
     */
    public setNameYOffset(nameYOffset: number) {
        if (nameYOffset !== this.nameYOffset) {
            const oldNameYOffset: number = this.nameYOffset;
            this.nameYOffset = nameYOffset;
            this.firePropertyChange(/* name */"NAME_Y_OFFSET", oldNameYOffset, nameYOffset);
        }
    }

    /**
     * Returns the text style used to display piece name.
     * @return {TextStyle}
     */
    public getNameStyle(): TextStyle {
        return this.nameStyle;
    }

    /**
     * Sets the text style used to display piece name.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {TextStyle} nameStyle
     */
    public setNameStyle(nameStyle: TextStyle) {
        if (nameStyle !== this.nameStyle) {
            const oldNameStyle: TextStyle = this.nameStyle;
            this.nameStyle = nameStyle;
            this.firePropertyChange(/* name */"NAME_STYLE", oldNameStyle, nameStyle);
        }
    }

    /**
     * Returns the angle in radians used to display the piece name.
     * @return {number}
     */
    public getNameAngle(): number {
        return this.nameAngle;
    }

    /**
     * Sets the angle in radians used to display the piece name. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} nameAngle
     */
    public setNameAngle(nameAngle: number) {
        nameAngle = <number>((nameAngle % HomePieceOfFurniture.TWICE_PI_$LI$() + HomePieceOfFurniture.TWICE_PI_$LI$()) % HomePieceOfFurniture.TWICE_PI_$LI$());
        if (nameAngle !== this.nameAngle) {
            const oldNameAngle: number = this.nameAngle;
            this.nameAngle = nameAngle;
            this.firePropertyChange(/* name */"NAME_ANGLE", oldNameAngle, nameAngle);
        }
    }

    /**
     * Returns the description of this piece of furniture.
     * The returned value may be <code>null</code>.
     * @return {string}
     */
    public getDescription(): string {
        return this.description;
    }

    /**
     * Sets the description of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} description
     */
    public setDescription(description: string) {
        if (description !== this.description && (description == null || !(description === this.description))) {
            const oldDescription: string = this.description;
            this.description = description;
            this.firePropertyChange(/* name */"DESCRIPTION", oldDescription, description);
        }
    }

    /**
     * Returns the additional information associated to this piece, or <code>null</code>.
     * @return {string}
     */
    public getInformation(): string {
        return this.information;
    }

    /**
     * Sets the additional information associated to this piece . Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} information
     */
    public setInformation(information: string) {
        if (information !== this.information && (information == null || !(information === this.information))) {
            const oldInformation: string = this.information;
            this.information = information;
            this.firePropertyChange(/* name */"INFORMATION", oldInformation, information);
        }
    }

    /**
     * Returns the creator of this piece.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Sets the creator of this piece. Once this piece is updated, listeners added to this piece
     * will receive a change notification.
     * @param {string} creator
     */
    public setCreator(creator: string) {
        if (creator !== this.creator && (creator == null || !(creator === this.creator))) {
            const oldCreator: string = this.creator;
            this.creator = creator;
            this.firePropertyChange(/* name */"CREATOR", oldCreator, creator);
        }
    }

    /**
     * Returns the license of this piece, or <code>null</code>.
     * @return {string}
     */
    public getLicense(): string {
        return this.license;
    }

    /**
     * Sets the the license of this piece . Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} license
     */
    public setLicense(license: string) {
        if (license !== this.license && (license == null || !(license === this.license))) {
            const oldLicense: string = this.license;
            this.license = license;
            this.firePropertyChange(/* name */"LICENSE", oldLicense, license);
        }
    }

    /**
     * Returns the depth of this piece of furniture.
     * @return {number}
     */
    public getDepth(): number {
        return this.depth;
    }

    /**
     * Sets the depth of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @throws IllegalStateException if this piece of furniture isn't resizable
     * @param {number} depth
     */
    public setDepth(depth: number) {
        if (this.isResizable()) {
            if (depth !== this.depth) {
                const oldDepth: number = this.depth;
                this.depth = depth;
                this.shapeCache = null;
                this.firePropertyChange(/* name */"DEPTH", oldDepth, depth);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t resizable");
        }
    }

    /**
     * Returns the depth of this piece of furniture in the horizontal plan (after pitch or roll is applied to it).
     * @return {number}
     */
    public getDepthInPlan(): number {
        return this.depthInPlan;
    }

    /**
     * Sets the depth of this piece of furniture in the horizontal plan (after pitch or roll is applied to it).
     * listeners added to this piece will receive a change notification.
     * @param {number} depthInPlan
     */
    public setDepthInPlan(depthInPlan: number) {
        if (depthInPlan !== this.depthInPlan) {
            const oldDepth: number = this.depthInPlan;
            this.depthInPlan = depthInPlan;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"DEPTH_IN_PLAN", oldDepth, depthInPlan);
        }
    }

    /**
     * Returns the height of this piece of furniture.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the height of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @throws IllegalStateException if this piece of furniture isn't resizable
     * @param {number} height
     */
    public setHeight(height: number) {
        if (this.isResizable()) {
            if (height !== this.height) {
                const oldHeight: number = this.height;
                this.height = height;
                this.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t resizable");
        }
    }

    /**
     * Returns the height of this piece of furniture from the horizontal plan (after pitch or roll is applied to it).
     * @return {number}
     */
    public getHeightInPlan(): number {
        return this.heightInPlan;
    }

    /**
     * Sets the height of this piece of furniture from the horizontal plan (after pitch or roll is applied to it).
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} heightInPlan
     */
    public setHeightInPlan(heightInPlan: number) {
        if (heightInPlan !== this.heightInPlan) {
            const oldHeight: number = this.heightInPlan;
            this.heightInPlan = heightInPlan;
            this.firePropertyChange(/* name */"HEIGHT_IN_PLAN", oldHeight, heightInPlan);
        }
    }

    /**
     * Returns the width of this piece of furniture.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Sets the width of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @throws IllegalStateException if this piece of furniture isn't resizable
     * @param {number} width
     */
    public setWidth(width: number) {
        if (this.isResizable()) {
            if (width !== this.width) {
                const oldWidth: number = this.width;
                this.width = width;
                this.shapeCache = null;
                this.firePropertyChange(/* name */"WIDTH", oldWidth, width);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t resizable");
        }
    }

    /**
     * Returns the width of this piece of furniture in the horizontal plan (after pitch or roll is applied to it).
     * @return {number}
     */
    public getWidthInPlan(): number {
        return this.widthInPlan;
    }

    /**
     * Sets the width of this piece of furniture in the horizontal plan (after pitch or roll is applied to it).
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} widthInPlan
     */
    public setWidthInPlan(widthInPlan: number) {
        if (widthInPlan !== this.widthInPlan) {
            const oldWidth: number = this.widthInPlan;
            this.widthInPlan = widthInPlan;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"WIDTH_IN_PLAN", oldWidth, widthInPlan);
        }
    }

    /**
     * Scales this piece of furniture with the given <code>scale</code>.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} scale
     */
    public scale(scale: number) {
        this.setWidth(this.getWidth() * scale);
        this.setDepth(this.getDepth() * scale);
        this.setHeight(this.getHeight() * scale);
    }

    /**
     * Returns the elevation of the bottom of this piece of furniture on its level.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Returns the elevation at which should be placed an object dropped on this piece.
     * @return {number} a percentage of the height of this piece. A negative value means that the piece
     * should be ignored when an object is dropped on it.
     */
    public getDropOnTopElevation(): number {
        return this.dropOnTopElevation;
    }

    /**
     * Returns the elevation of the bottom of this piece of furniture
     * from the ground according to the elevation of its level.
     * @return {number}
     */
    public getGroundElevation(): number {
        if (this.level != null) {
            return this.elevation + this.level.getElevation();
        } else {
            return this.elevation;
        }
    }

    /**
     * Sets the elevation of this piece of furniture on its level. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns <code>true</code> if this piece of furniture is movable.
     * @return {boolean}
     */
    public isMovable(): boolean {
        return this.movable;
    }

    /**
     * Sets whether this piece is movable or not.
     * @param {boolean} movable
     */
    public setMovable(movable: boolean) {
        if (movable !== this.movable) {
            this.movable = movable;
            this.firePropertyChange(/* name */"MOVABLE", !movable, movable);
        }
    }

    /**
     * Returns <code>true</code> if this piece of furniture is a door or a window.
     * As this method existed before {@linkplain HomeDoorOrWindow HomeDoorOrWindow} class,
     * you shouldn't rely on the value returned by this method to guess if a piece
     * is an instance of <code>DoorOrWindow</code> class.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return this.doorOrWindow;
    }

    /**
     * Returns the icon of this piece of furniture.
     * @return {Object}
     */
    public getIcon(): Content {
        return this.icon;
    }

    /**
     * Sets the icon of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {Object} icon
     */
    public setIcon(icon: Content) {
        if (icon !== this.icon && (icon == null || !/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(icon, this.icon)))) {
            const oldIcon: Content = this.icon;
            this.icon = icon;
            this.firePropertyChange(/* name */"ICON", oldIcon, icon);
        }
    }

    /**
     * Returns the icon of this piece of furniture displayed in plan or <code>null</code>.
     * @return {Object}
     */
    public getPlanIcon(): Content {
        return this.planIcon;
    }

    /**
     * Sets the plan icon of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {Object} planIcon
     */
    public setPlanIcon(planIcon: Content) {
        if (planIcon !== this.planIcon && (planIcon == null || !/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(planIcon, this.planIcon)))) {
            const oldPlanIcon: Content = this.planIcon;
            this.planIcon = planIcon;
            this.firePropertyChange(/* name */"PLAN_ICON", oldPlanIcon, planIcon);
        }
    }

    /**
     * Returns the 3D model of this piece of furniture.
     * @return {Object}
     */
    public getModel(): Content {
        return this.model;
    }

    /**
     * Sets the 3D model of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {Object} model
     */
    public setModel(model: Content) {
        if (model !== this.model && (model == null || !/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(model, this.model)))) {
            const oldModel: Content = this.model;
            this.model = model;
            this.firePropertyChange(/* name */"MODEL", oldModel, model);
        }
    }

    /**
     * Returns the size of the 3D model of this piece of furniture.
     * @return {number}
     */
    public getModelSize(): number {
        return this.modelSize;
    }

    /**
     * Sets the size of the 3D model of this piece of furniture.
     * This method should be called only to update a piece created with an older version.
     * @param {number} modelSize
     */
    public setModelSize(modelSize: number) {
        this.modelSize = modelSize;
    }

    /**
     * Returns the materials applied to the 3D model of this piece of furniture.
     * @return {com.eteks.sweethome3d.model.HomeMaterial[]} the materials of the 3D model or <code>null</code>
     * if the individual materials of the 3D model are not modified.
     */
    public getModelMaterials(): HomeMaterial[] {
        if (this.modelMaterials != null) {
            return /* clone */this.modelMaterials.slice(0);
        } else {
            return null;
        }
    }

    /**
     * Sets the materials of the 3D model of this piece of furniture.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {com.eteks.sweethome3d.model.HomeMaterial[]} modelMaterials the materials of the 3D model or <code>null</code> if they shouldn't be changed
     * @throws IllegalStateException if this piece of furniture isn't texturable
     */
    public setModelMaterials(modelMaterials: HomeMaterial[]) {
        if (this.isTexturable()) {
            if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(modelMaterials, this.modelMaterials)) {
                const oldModelMaterials: HomeMaterial[] = this.modelMaterials;
                this.modelMaterials = modelMaterials != null ? /* clone */modelMaterials.slice(0) : null;
                this.firePropertyChange(/* name */"MODEL_MATERIALS", oldModelMaterials, modelMaterials);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t texturable");
        }
    }

    /**
     * Returns the color of this piece of furniture.
     * @return {number} the color of the piece as RGB code or <code>null</code> if piece color is unchanged.
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the color of this piece of furniture.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} color the color of this piece of furniture or <code>null</code> if piece color is the default one
     * @throws IllegalStateException if this piece of furniture isn't texturable
     */
    public setColor(color: number) {
        if (this.isTexturable()) {
            if (color !== this.color && (color == null || !(color === this.color))) {
                const oldColor: number = this.color;
                this.color = color;
                this.firePropertyChange(/* name */"COLOR", oldColor, color);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t texturable");
        }
    }

    /**
     * Returns the texture of this piece of furniture.
     * @return {HomeTexture} the texture of the piece or <code>null</code> if piece texture is unchanged.
     */
    public getTexture(): HomeTexture {
        return this.texture;
    }

    /**
     * Sets the texture of this piece of furniture.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {HomeTexture} texture the texture of this piece of furniture or <code>null</code> if piece texture is the default one
     * @throws IllegalStateException if this piece of furniture isn't texturable
     */
    public setTexture(texture: HomeTexture) {
        if (this.isTexturable()) {
            if (texture !== this.texture && (texture == null || !texture.equals(this.texture))) {
                const oldTexture: HomeTexture = this.texture;
                this.texture = texture;
                this.firePropertyChange(/* name */"TEXTURE", oldTexture, texture);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t texturable");
        }
    }

    /**
     * Returns the shininess of this piece of furniture.
     * @return {number} a value between 0 (matt) and 1 (very shiny) or <code>null</code> if piece shininess is unchanged.
     */
    public getShininess(): number {
        return this.shininess;
    }

    /**
     * Sets the shininess of this piece of furniture or <code>null</code> if piece shininess is unchanged.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @throws IllegalStateException if this piece of furniture isn't texturable
     * @param {number} shininess
     */
    public setShininess(shininess: number) {
        if (this.isTexturable()) {
            if (shininess !== this.shininess && (shininess == null || !(shininess === this.shininess))) {
                const oldShininess: number = this.shininess;
                this.shininess = shininess;
                this.firePropertyChange(/* name */"SHININESS", oldShininess, shininess);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t texturable");
        }
    }

    /**
     * Returns <code>true</code> if this piece is resizable.
     * @return {boolean}
     */
    public isResizable(): boolean {
        return this.resizable;
    }

    /**
     * Returns <code>true</code> if this piece is deformable.
     * @return {boolean}
     */
    public isDeformable(): boolean {
        return this.deformable;
    }

    /**
     * Returns <code>true</code> if this piece is deformable.
     * @return {boolean}
     */
    public isWidthDepthDeformable(): boolean {
        return this.isDeformable();
    }

    /**
     * Returns <code>false</code> if this piece should always keep the same color or texture.
     * @return {boolean}
     */
    public isTexturable(): boolean {
        return this.texturable;
    }

    /**
     * Returns <code>false</code> if this piece should not rotate around an horizontal axis.
     * @return {boolean}
     */
    public isHorizontallyRotatable(): boolean {
        return this.horizontallyRotatable;
    }

    /**
     * Returns the price of this piece of furniture or <code>null</code>.
     * @return {Big}
     */
    public getPrice(): Big {
        return this.price;
    }

    /**
     * Sets the price of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {Big} price
     */
    public setPrice(price: Big) {
        if (price !== this.price && (price == null || !/* equals */((this.price) != null ? price.eq(this.price) : (price === (this.price))))) {
            const oldPrice: Big = this.price;
            this.price = price;
            this.firePropertyChange(/* name */"PRICE", oldPrice, price);
        }
    }

    /**
     * Returns the Value Added Tax percentage applied to the price of this piece of furniture.
     * @return {Big}
     */
    public getValueAddedTaxPercentage(): Big {
        return this.valueAddedTaxPercentage;
    }

    /**
     * Sets the Value Added Tax percentage applied to prices.
     * @param {Big} valueAddedTaxPercentage
     */
    public setValueAddedTaxPercentage(valueAddedTaxPercentage: Big) {
        if (valueAddedTaxPercentage !== this.valueAddedTaxPercentage && (valueAddedTaxPercentage == null || !/* equals */((this.valueAddedTaxPercentage) != null ? valueAddedTaxPercentage.eq(this.valueAddedTaxPercentage) : (valueAddedTaxPercentage === (this.valueAddedTaxPercentage))))) {
            const oldValueAddedTaxPercentage: Big = this.valueAddedTaxPercentage;
            this.valueAddedTaxPercentage = valueAddedTaxPercentage;
            this.firePropertyChange(/* name */"VALUE_ADDED_TAX_PERCENTAGE", oldValueAddedTaxPercentage, valueAddedTaxPercentage);
        }
    }

    /**
     * Returns the Value Added Tax applied to the price of this piece of furniture.
     * @return {Big}
     */
    public getValueAddedTax(): Big {
        if (this.price != null && this.valueAddedTaxPercentage != null) {
            return /* setScale *//* multiply */this.price.times(this.valueAddedTaxPercentage).round(/* scale */2);
        } else {
            return null;
        }
    }

    /**
     * Returns the price of this piece of furniture, Value Added Tax included.
     * @return {Big}
     */
    public getPriceValueAddedTaxIncluded(): Big {
        if (this.price != null && this.valueAddedTaxPercentage != null) {
            return /* add */this.price.plus(this.getValueAddedTax());
        } else {
            return this.price;
        }
    }

    /**
     * Returns the price currency, noted with ISO 4217 code, or <code>null</code>
     * if it has no price or default currency should be used.
     * @return {string}
     */
    public getCurrency(): string {
        return this.currency;
    }

    /**
     * Sets the price currency, noted with ISO 4217 code. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {string} currency
     */
    public setCurrency(currency: string) {
        if (currency !== this.currency && (currency == null || !(currency === this.currency))) {
            const oldCurrency: string = this.currency;
            this.currency = currency;
            this.firePropertyChange(/* name */"CURRENCY", oldCurrency, currency);
        }
    }

    /**
     * Returns <code>true</code> if this piece of furniture is visible.
     * @return {boolean}
     */
    public isVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether this piece of furniture is visible or not. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        if (visible !== this.visible) {
            this.visible = visible;
            this.firePropertyChange(/* name */"VISIBLE", !visible, visible);
        }
    }

    /**
     * Returns the abscissa of the center of this piece of furniture.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the abscissa of the center of this piece. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the ordinate of the center of this piece of furniture.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the ordinate of the center of this piece. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the angle in radians of this piece around vertical axis.
     * @return {number}
     */
    public getAngle(): number {
        return this.angle;
    }

    /**
     * Sets the angle of this piece around vertical axis. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} angle
     */
    public setAngle(angle: number) {
        angle = <number>((angle % HomePieceOfFurniture.TWICE_PI_$LI$() + HomePieceOfFurniture.TWICE_PI_$LI$()) % HomePieceOfFurniture.TWICE_PI_$LI$());
        if (angle !== this.angle) {
            const oldAngle: number = this.angle;
            this.angle = angle;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"ANGLE", oldAngle, angle);
        }
    }

    /**
     * Returns the pitch angle in radians of this piece of furniture.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Sets the pitch angle in radians of this piece and notifies listeners of this change.
     * Pitch axis is horizontal lateral (or transverse) axis.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (this.isHorizontallyRotatable()) {
            pitch = <number>((pitch % HomePieceOfFurniture.TWICE_PI_$LI$() + HomePieceOfFurniture.TWICE_PI_$LI$()) % HomePieceOfFurniture.TWICE_PI_$LI$());
            if (pitch !== this.pitch) {
                const oldPitch: number = this.pitch;
                this.pitch = pitch;
                this.shapeCache = null;
                this.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
            }
        } else {
            throw new IllegalStateException("Piece can\'t be rotated around an horizontal axis");
        }
    }

    /**
     * Returns the roll angle in radians of this piece of furniture.
     * @return {number}
     */
    public getRoll(): number {
        return this.roll;
    }

    /**
     * Sets the roll angle in radians of this piece and notifies listeners of this change.
     * Roll axis is horizontal longitudinal axis.
     * @param {number} roll
     */
    public setRoll(roll: number) {
        if (this.isHorizontallyRotatable()) {
            roll = <number>((roll % HomePieceOfFurniture.TWICE_PI_$LI$() + HomePieceOfFurniture.TWICE_PI_$LI$()) % HomePieceOfFurniture.TWICE_PI_$LI$());
            if (roll !== this.roll) {
                const oldRoll: number = this.roll;
                this.roll = roll;
                this.shapeCache = null;
                this.firePropertyChange(/* name */"ROLL", oldRoll, roll);
            }
        } else {
            throw new IllegalStateException("Piece can\'t be rotated around an horizontal axis");
        }
    }

    /**
     * Returns <code>true</code> if the pitch or roll angle of this piece is different from 0.
     * @return {boolean}
     */
    public isHorizontallyRotated(): boolean {
        return this.roll !== 0 || this.pitch !== 0;
    }

    /**
     * Returns the rotation 3 by 3 matrix of this piece of furniture that ensures
     * its model is correctly oriented.
     * @return {float[][]}
     */
    public getModelRotation(): number[][] {
        return CatalogPieceOfFurniture.deepClone(this.modelRotation);
    }

    /**
     * Sets the rotation 3 by 3 matrix of this piece of furniture and notifies listeners of this change.
     * @param {float[][]} modelRotation
     */
    public setModelRotation(modelRotation: number[][]) {
        if (!/* deepEquals */(JSON.stringify(modelRotation) === JSON.stringify(this.modelRotation))) {
            const oldModelRotation: number[][] = CatalogPieceOfFurniture.deepClone(this.modelRotation);
            this.modelRotation = CatalogPieceOfFurniture.deepClone(modelRotation);
            this.firePropertyChange(/* name */"MODEL_ROTATION", oldModelRotation, modelRotation);
        }
    }

    /**
     * Returns <code>true</code> if the model of this piece should be mirrored.
     * @return {boolean}
     */
    public isModelMirrored(): boolean {
        return this.modelMirrored;
    }

    /**
     * Sets whether the model of this piece of furniture is mirrored or not. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @throws IllegalStateException if this piece of furniture isn't resizable
     * @param {boolean} modelMirrored
     */
    public setModelMirrored(modelMirrored: boolean) {
        if (this.isResizable()) {
            if (modelMirrored !== this.modelMirrored) {
                this.modelMirrored = modelMirrored;
                this.firePropertyChange(/* name */"MODEL_MIRRORED", !modelMirrored, modelMirrored);
            }
        } else {
            throw new IllegalStateException("Piece isn\'t resizable");
        }
    }

    /**
     * Returns <code>true</code> if model center should be always centered at the origin
     * when model rotation isn't <code>null</code>.
     * @return {boolean} <code>false</code> by default if version < 5.5
     */
    public isModelCenteredAtOrigin(): boolean {
        return this.modelCenteredAtOrigin;
    }

    /**
     * Sets whether model center should be always centered at the origin
     * when model rotation isn't <code>null</code>.
     * This method should be called only to keep unchanged the (wrong) location
     * of a rotated model created with version < 5.5.
     * @param {boolean} modelCenteredAtOrigin
     */
    public setModelCenteredAtOrigin(modelCenteredAtOrigin: boolean) {
        this.modelCenteredAtOrigin = modelCenteredAtOrigin;
    }

    /**
     * Returns <code>true</code> if the back face of the piece of furniture
     * model should be displayed.
     * @return {boolean}
     */
    public isBackFaceShown(): boolean {
        return (this.modelFlags & PieceOfFurniture.SHOW_BACK_FACE) === PieceOfFurniture.SHOW_BACK_FACE;
    }

    /**
     * Sets whether the back face of the piece of furniture model should be displayed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @deprecated Prefer use {@link #setModelFlags} with {@link #SHOW_BACK_FACE} flag.
     * @param {boolean} backFaceShown
     */
    public setBackFaceShown(backFaceShown: boolean) {
        this.setModelFlags((this.getModelFlags() & ~PieceOfFurniture.SHOW_BACK_FACE) | (backFaceShown ? PieceOfFurniture.SHOW_BACK_FACE : 0));
    }

    /**
     * Returns the flags applied to the piece of furniture model.
     * @return {number}
     */
    public getModelFlags(): number {
        return this.modelFlags;
    }

    /**
     * Sets the flags applied to the piece of furniture model.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} modelFlags
     */
    public setModelFlags(modelFlags: number) {
        if (modelFlags !== this.modelFlags) {
            const oldModelFlags: number = this.modelFlags;
            this.modelFlags = modelFlags;
            this.backFaceShown = (modelFlags & PieceOfFurniture.SHOW_BACK_FACE) === PieceOfFurniture.SHOW_BACK_FACE;
            this.firePropertyChange(/* name */"MODEL_FLAGS", oldModelFlags, modelFlags);
        }
    }

    /**
     * Returns the transformations applied to the 3D model of this piece of furniture.
     * @return {com.eteks.sweethome3d.model.Transformation[]} the transformations of the 3D model or <code>null</code>
     * if the 3D model is not transformed.
     */
    public getModelTransformations(): Transformation[] {
        if (this.modelTransformations != null) {
            return /* clone */this.modelTransformations.slice(0);
        } else {
            return null;
        }
    }

    /**
     * Sets the transformations applied to some parts of the 3D model of this piece of furniture.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {com.eteks.sweethome3d.model.Transformation[]} modelTransformations the transformations of the 3D model or <code>null</code> if no transformation shouldn't be applied
     */
    public setModelTransformations(modelTransformations: Transformation[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(modelTransformations, this.modelTransformations)) {
            const oldModelTransformations: Transformation[] = this.modelTransformations;
            this.modelTransformations = modelTransformations != null && modelTransformations.length > 0 ? /* clone */modelTransformations.slice(0) : null;
            this.firePropertyChange(/* name */"MODEL_MATERIALS", oldModelTransformations, modelTransformations);
        }
    }

    /**
     * Returns the shape used to cut out upper levels when they intersect with the piece
     * like a staircase.
     * @return {string}
     */
    public getStaircaseCutOutShape(): string {
        return this.staircaseCutOutShape;
    }

    /**
     * Sets the shape used to cut out upper levels when they intersect with the piece
     * like a staircase. Once this piece is updated, listeners added to this piece
     * will receive a change notification.
     * @param {string} staircaseCutOutShape
     */
    public setStaircaseCutOutShape(staircaseCutOutShape: string) {
        if (staircaseCutOutShape !== this.staircaseCutOutShape && (staircaseCutOutShape == null || !(staircaseCutOutShape === this.staircaseCutOutShape))) {
            const oldCutOutShape: string = this.staircaseCutOutShape;
            this.staircaseCutOutShape = staircaseCutOutShape;
            this.firePropertyChange(/* name */"STAIRCASE_CUT_OUT_SHAPE", oldCutOutShape, staircaseCutOutShape);
        }
    }

    /**
     * Returns the level which this piece belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this piece of furniture. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this piece is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index
     * or if the elevation of its highest point is higher than <code>level</code> elevation.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        if (this.level === level) {
            return true;
        } else if (this.level != null && level != null) {
            const pieceLevelElevation: number = this.level.getElevation();
            const levelElevation: number = level.getElevation();
            return pieceLevelElevation === levelElevation && this.level.getElevationIndex() < level.getElevationIndex() || pieceLevelElevation < levelElevation && this.isTopAtLevel(level);
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the top of this piece is visible at the given level.
     * @param {Level} level
     * @return {boolean}
     * @private
     */
    isTopAtLevel(level: Level): boolean {
        const topElevation: number = this.level.getElevation() + this.elevation + this.heightInPlan;
        if (this.staircaseCutOutShape != null) {
            return topElevation >= level.getElevation();
        } else {
            return topElevation > level.getElevation();
        }
    }

    /**
     * Returns the points of each corner of a piece.
     * @return {float[][]} an array of the 4 (x,y) coordinates of the piece corners.
     */
    public getPoints(): number[][] {
        const piecePoints: number[][] = <any>(function (dims) { let allocate = function (dims) { if (dims.length === 0) { return 0; } else { let array = []; for (let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; } }; return allocate(dims); })([4, 2]);
        const it: java.awt.geom.PathIterator = this.getShape().getPathIterator(null);
        for (let i: number = 0; i < piecePoints.length; i++) {
            {
                it.currentSegment(piecePoints[i]);
                it.next();
            };
        }
        return piecePoints;
    }

    /**
     * Returns <code>true</code> if this piece intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape().intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if this piece contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return this.getShape().contains(x, y);
        } else {
            return this.getShape().intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns <code>true</code> if one of the corner of this piece is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isPointAt(x: number, y: number, margin: number): boolean {
        {
            let array = this.getPoints();
            for (let index = 0; index < array.length; index++) {
                let point = array[index];
                {
                    if (Math.abs(x - point[0]) <= margin && Math.abs(y - point[1]) <= margin) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Returns <code>true</code> if the top left point of this piece is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>,
     * and if that point is closer to top left point than to top right and bottom left points.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isTopLeftPointAt(x: number, y: number, margin: number): boolean {
        const points: number[][] = this.getPoints();
        const distanceSquareToTopLeftPoint: number = java.awt.geom.Point2D.distanceSq(x, y, points[0][0], points[0][1]);
        return distanceSquareToTopLeftPoint <= margin * margin && distanceSquareToTopLeftPoint < java.awt.geom.Point2D.distanceSq(x, y, points[1][0], points[1][1]) && distanceSquareToTopLeftPoint < java.awt.geom.Point2D.distanceSq(x, y, points[3][0], points[3][1]);
    }

    /**
     * Returns <code>true</code> if the top right point of this piece is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>,
     * and if that point is closer to top right point than to top left and bottom right points.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isTopRightPointAt(x: number, y: number, margin: number): boolean {
        const points: number[][] = this.getPoints();
        const distanceSquareToTopRightPoint: number = java.awt.geom.Point2D.distanceSq(x, y, points[1][0], points[1][1]);
        return distanceSquareToTopRightPoint <= margin * margin && distanceSquareToTopRightPoint < java.awt.geom.Point2D.distanceSq(x, y, points[0][0], points[0][1]) && distanceSquareToTopRightPoint < java.awt.geom.Point2D.distanceSq(x, y, points[2][0], points[2][1]);
    }

    /**
     * Returns <code>true</code> if the bottom left point of this piece is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>,
     * and if that point is closer to bottom left point than to top left and bottom right points.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isBottomLeftPointAt(x: number, y: number, margin: number): boolean {
        const points: number[][] = this.getPoints();
        const distanceSquareToBottomLeftPoint: number = java.awt.geom.Point2D.distanceSq(x, y, points[3][0], points[3][1]);
        return distanceSquareToBottomLeftPoint <= margin * margin && distanceSquareToBottomLeftPoint < java.awt.geom.Point2D.distanceSq(x, y, points[0][0], points[0][1]) && distanceSquareToBottomLeftPoint < java.awt.geom.Point2D.distanceSq(x, y, points[2][0], points[2][1]);
    }

    /**
     * Returns <code>true</code> if the bottom right point of this piece is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>,
     * and if that point is closer to top left point than to top right and bottom left points.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isBottomRightPointAt(x: number, y: number, margin: number): boolean {
        const points: number[][] = this.getPoints();
        const distanceSquareToBottomRightPoint: number = java.awt.geom.Point2D.distanceSq(x, y, points[2][0], points[2][1]);
        return distanceSquareToBottomRightPoint <= margin * margin && distanceSquareToBottomRightPoint < java.awt.geom.Point2D.distanceSq(x, y, points[1][0], points[1][1]) && distanceSquareToBottomRightPoint < java.awt.geom.Point2D.distanceSq(x, y, points[3][0], points[3][1]);
    }

    /**
     * Returns <code>true</code> if the center point at which is displayed the name
     * of this piece is equal to the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isNameCenterPointAt(x: number, y: number, margin: number): boolean {
        return Math.abs(x - this.getX() - this.getNameXOffset()) <= margin && Math.abs(y - this.getY() - this.getNameYOffset()) <= margin;
    }

    /**
     * Returns <code>true</code> if the front side of this piece is parallel to the given <code>wall</code>
     * with a margin.
     * @param {Wall} wall
     * @return {boolean}
     */
    public isParallelToWall(wall: Wall): boolean {
        if (wall.getArcExtent() == null) {
            const deltaY: number = wall.getYEnd() - wall.getYStart();
            const deltaX: number = wall.getXEnd() - wall.getXStart();
            if (deltaX === 0 && deltaY === 0) {
                return false;
            } else {
                const wallAngle: number = Math.atan2(deltaY, deltaX);
                const pieceWallAngle: number = Math.abs(wallAngle - this.getAngle()) % Math.PI;
                return pieceWallAngle <= HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN_$LI$() || (Math.PI - pieceWallAngle) <= HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN_$LI$();
            }
        } else {
            const tangentAngle: number = Math.PI / 2 + Math.atan2(wall.getYArcCircleCenter() - this.getY(), wall.getXArcCircleCenter() - this.getX());
            const pieceWallAngle: number = Math.abs(tangentAngle - this.getAngle()) % Math.PI;
            return pieceWallAngle <= HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN_$LI$() || (Math.PI - pieceWallAngle) <= HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN_$LI$();
        }
    }

    /**
     * Returns the shape matching this piece in the horizontal plan.
     * @return {Object}
     * @private
     */
    getShape(): java.awt.Shape {
        if (this.shapeCache == null) {
            const pieceRectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(this.getX() - this.getWidthInPlan() / 2, this.getY() - this.getDepthInPlan() / 2, this.getWidthInPlan(), this.getDepthInPlan());
            const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(this.getAngle(), this.getX(), this.getY());
            const it: java.awt.geom.PathIterator = pieceRectangle.getPathIterator(rotation);
            const pieceShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            pieceShape.append(it, false);
            this.shapeCache = pieceShape;
        }
        return this.shapeCache;
    }

    /**
     * Moves this piece of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setX(this.getX() + dx);
        this.setY(this.getY() + dy);
    }

    /**
     * Returns a clone of this piece.
     * @return {HomePieceOfFurniture}
     */
    public clone(): HomePieceOfFurniture {
        const clone: HomePieceOfFurniture = <HomePieceOfFurniture>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.level = null;
        return clone;
    }

    /**
     * Returns a comparator which compares furniture on a given <code>property</code> in ascending order.
     * @param {string} property
     * @return {Object}
     */
    public static getFurnitureComparator(property: any): any {
        return <any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1) })(/* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$(), property)));
    }
}
HomePieceOfFurniture["__class"] = "com.eteks.sweethome3d.model.HomePieceOfFurniture";
HomePieceOfFurniture["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.Elevatable"];



export namespace HomePieceOfFurniture {

    export class HomePieceOfFurniture$0 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.catalogId === piece2.catalogId) {
                return 0;
            } else if (piece1.catalogId == null) {
                return -1;
            } else if (piece2.catalogId == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.catalogId, piece2.catalogId);
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$1 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.name === piece2.name) {
                return 0;
            } else if (piece1.name == null) {
                return -1;
            } else if (piece2.name == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.name, piece2.name);
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$2 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.description === piece2.description) {
                return 0;
            } else if (piece1.description == null) {
                return -1;
            } else if (piece2.description == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.description, piece2.description);
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$3 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.creator === piece2.creator) {
                return 0;
            } else if (piece1.creator == null) {
                return -1;
            } else if (piece2.creator == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.creator, piece2.creator);
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$4 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.license === piece2.license) {
                return 0;
            } else if (piece1.license == null) {
                return -1;
            } else if (piece2.license == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.license, piece2.license);
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$5 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.width, piece2.width);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$6 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.height, piece2.height);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$7 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.depth, piece2.depth);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$8 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$boolean$boolean(piece1.movable, piece2.movable);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$9 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$boolean$boolean(piece1.doorOrWindow, piece2.doorOrWindow);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$10 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.color === piece2.color) {
                return 0;
            } else if (piece1.color == null) {
                return -1;
            } else if (piece2.color == null) {
                return 1;
            } else {
                return piece1.color - piece2.color;
            }
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$11 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            if (piece1.texture === piece2.texture) {
                return 0;
            } else if (piece1.texture == null) {
                return -1;
            } else if (piece2.texture == null) {
                return 1;
            } else {
                return this.collator.compare(piece1.texture.getName(), piece2.texture.getName());
            }
        }

        constructor(private collator: any) {
        }
    }


    export class HomePieceOfFurniture$12 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$boolean$boolean(piece1.visible, piece2.visible);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$13 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.x, piece2.x);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$14 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.y, piece2.y);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$15 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.elevation, piece2.elevation);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$16 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$float$float(piece1.angle, piece2.angle);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$17 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            const piece1ModelSize: number = HomePieceOfFurniture.getComparableModelSize(piece1);
            const piece2ModelSize: number = HomePieceOfFurniture.getComparableModelSize(piece2);
            if (piece1ModelSize === piece2ModelSize) {
                return 0;
            } else if (piece1ModelSize == null) {
                return -1;
            } else if (piece2ModelSize == null) {
                return 1;
            } else {
                return piece1ModelSize < piece2ModelSize ? -1 : (/* longValue */piece1ModelSize === /* longValue */piece2ModelSize ? 0 : 1);
            }
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$18 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$com_eteks_sweethome3d_model_Level$com_eteks_sweethome3d_model_Level(piece1.getLevel(), piece2.getLevel());
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$19 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$java_math_BigDecimal$java_math_BigDecimal(piece1.price, piece2.price);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$20 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$java_math_BigDecimal$java_math_BigDecimal(piece1.valueAddedTaxPercentage, piece2.valueAddedTaxPercentage);
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$21 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$java_math_BigDecimal$java_math_BigDecimal(piece1.getValueAddedTax(), piece2.getValueAddedTax());
        }

        constructor() {
        }
    }


    export class HomePieceOfFurniture$22 {
        public compare(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture): number {
            return HomePieceOfFurniture.compare$java_math_BigDecimal$java_math_BigDecimal(piece1.getPriceValueAddedTaxIncluded(), piece2.getPriceValueAddedTaxIncluded());
        }

        constructor() {
        }
    }

}
HomePieceOfFurniture['__transients'] = ['shapeCache', 'propertyChangeSupport'];

/**
 * Creates a dimension line from (<code>xStart</code>, <code>yStart</code>, <code>elevationStart</code>)
 * to (<code>xEnd</code>, <code>yEnd</code>, <code>elevationEnd</code>), with a given offset.
 * @param {string} id
 * @param {number} xStart
 * @param {number} yStart
 * @param {number} elevationStart
 * @param {number} xEnd
 * @param {number} yEnd
 * @param {number} elevationEnd
 * @param {number} offset
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class DimensionLine extends HomeObject implements Selectable, Elevatable {
    /*private*/ xStart: number;

    /*private*/ yStart: number;

    /*private*/ elevationStart: number;

    /*private*/ xEnd: number;

    /*private*/ yEnd: number;

    /*private*/ elevationEnd: number;

    /*private*/ offset: number;

    /*private*/ endMarkSize: number;

    /*private*/ pitch: number;

    /*private*/ lengthStyle: TextStyle;

    /*private*/ color: number;

    /*private*/ visibleIn3D: boolean;

    /*private*/ level: Level;

    /*private*/ shapeCache: java.awt.Shape;

    public constructor(id?: any, xStart?: any, yStart?: any, elevationStart?: any, xEnd?: any, yEnd?: any, elevationEnd?: any, offset?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof elevationStart === 'number') || elevationStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof elevationEnd === 'number') || elevationEnd === null) && ((typeof offset === 'number') || offset === null)) {
            let __args = arguments;
            super(id);
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.elevationStart === undefined) { this.elevationStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
            if (this.offset === undefined) { this.offset = 0; }
            if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.lengthStyle === undefined) { this.lengthStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            this.xStart = xStart;
            this.yStart = yStart;
            this.elevationStart = elevationStart;
            this.xEnd = xEnd;
            this.yEnd = yEnd;
            this.elevationEnd = elevationEnd;
            this.offset = offset;
            this.endMarkSize = 10;
        } else if (((typeof id === 'number') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof elevationStart === 'number') || elevationStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof elevationEnd === 'number') || elevationEnd === null) && offset === undefined) {
            let __args = arguments;
            let xStart: any = __args[0];
            let yStart: any = __args[1];
            let elevationStart: any = __args[2];
            let xEnd: any = __args[3];
            let yEnd: any = __args[4];
            let elevationEnd: any = __args[5];
            let offset: any = __args[6];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("dimensionLine");
                super(id);
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.elevationStart === undefined) { this.elevationStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
                if (this.offset === undefined) { this.offset = 0; }
                if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.lengthStyle === undefined) { this.lengthStyle = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.xStart = xStart;
                this.yStart = yStart;
                this.elevationStart = elevationStart;
                this.xEnd = xEnd;
                this.yEnd = yEnd;
                this.elevationEnd = elevationEnd;
                this.offset = offset;
                this.endMarkSize = 10;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.elevationStart === undefined) { this.elevationStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
            if (this.offset === undefined) { this.offset = 0; }
            if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.lengthStyle === undefined) { this.lengthStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof elevationStart === 'number') || elevationStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && elevationEnd === undefined && offset === undefined) {
            let __args = arguments;
            let xEnd: any = __args[3];
            let yEnd: any = __args[4];
            let offset: any = __args[5];
            {
                let __args = arguments;
                let elevationStart: any = 0;
                let elevationEnd: any = 0;
                super(id);
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.elevationStart === undefined) { this.elevationStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
                if (this.offset === undefined) { this.offset = 0; }
                if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.lengthStyle === undefined) { this.lengthStyle = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.xStart = xStart;
                this.yStart = yStart;
                this.elevationStart = elevationStart;
                this.xEnd = xEnd;
                this.yEnd = yEnd;
                this.elevationEnd = elevationEnd;
                this.offset = offset;
                this.endMarkSize = 10;
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.elevationStart === undefined) { this.elevationStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
            if (this.offset === undefined) { this.offset = 0; }
            if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.lengthStyle === undefined) { this.lengthStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((typeof id === 'number') || id === null) && ((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof elevationStart === 'number') || elevationStart === null) && ((typeof xEnd === 'number') || xEnd === null) && yEnd === undefined && elevationEnd === undefined && offset === undefined) {
            let __args = arguments;
            let xStart: any = __args[0];
            let yStart: any = __args[1];
            let xEnd: any = __args[2];
            let yEnd: any = __args[3];
            let offset: any = __args[4];
            {
                let __args = arguments;
                let elevationStart: any = 0;
                let elevationEnd: any = 0;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("dimensionLine");
                    super(id);
                    if (this.xStart === undefined) { this.xStart = 0; }
                    if (this.yStart === undefined) { this.yStart = 0; }
                    if (this.elevationStart === undefined) { this.elevationStart = 0; }
                    if (this.xEnd === undefined) { this.xEnd = 0; }
                    if (this.yEnd === undefined) { this.yEnd = 0; }
                    if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
                    if (this.offset === undefined) { this.offset = 0; }
                    if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
                    if (this.pitch === undefined) { this.pitch = 0; }
                    if (this.lengthStyle === undefined) { this.lengthStyle = null; }
                    if (this.color === undefined) { this.color = null; }
                    if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                    this.xStart = xStart;
                    this.yStart = yStart;
                    this.elevationStart = elevationStart;
                    this.xEnd = xEnd;
                    this.yEnd = yEnd;
                    this.elevationEnd = elevationEnd;
                    this.offset = offset;
                    this.endMarkSize = 10;
                }
                if (this.xStart === undefined) { this.xStart = 0; }
                if (this.yStart === undefined) { this.yStart = 0; }
                if (this.elevationStart === undefined) { this.elevationStart = 0; }
                if (this.xEnd === undefined) { this.xEnd = 0; }
                if (this.yEnd === undefined) { this.yEnd = 0; }
                if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
                if (this.offset === undefined) { this.offset = 0; }
                if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.lengthStyle === undefined) { this.lengthStyle = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
            }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.elevationStart === undefined) { this.elevationStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
            if (this.offset === undefined) { this.offset = 0; }
            if (this.endMarkSize === undefined) { this.endMarkSize = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.lengthStyle === undefined) { this.lengthStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the start point abscissa of this dimension line.
     * @return {number}
     */
    public getXStart(): number {
        return this.xStart;
    }

    /**
     * Sets the start point abscissa of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} xStart
     */
    public setXStart(xStart: number) {
        if (xStart !== this.xStart) {
            const oldXStart: number = this.xStart;
            this.xStart = xStart;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"X_START", oldXStart, xStart);
        }
    }

    /**
     * Returns the start point ordinate of this dimension line.
     * @return {number}
     */
    public getYStart(): number {
        return this.yStart;
    }

    /**
     * Sets the start point ordinate of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} yStart
     */
    public setYStart(yStart: number) {
        if (yStart !== this.yStart) {
            const oldYStart: number = this.yStart;
            this.yStart = yStart;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"Y_START", oldYStart, yStart);
        }
    }

    /**
     * Returns the start point elevation of this dimension line.
     * @return {number}
     */
    public getElevationStart(): number {
        return this.elevationStart;
    }

    /**
     * Sets the start point elevation of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} elevationStart
     */
    public setElevationStart(elevationStart: number) {
        if (elevationStart !== this.elevationStart) {
            const oldElevationStart: number = this.elevationStart;
            this.elevationStart = elevationStart;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"ELEVATION_START", oldElevationStart, elevationStart);
        }
    }

    /**
     * Returns the end point abscissa of this dimension line.
     * @return {number}
     */
    public getXEnd(): number {
        return this.xEnd;
    }

    /**
     * Sets the end point abscissa of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} xEnd
     */
    public setXEnd(xEnd: number) {
        if (xEnd !== this.xEnd) {
            const oldXEnd: number = this.xEnd;
            this.xEnd = xEnd;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"X_END", oldXEnd, xEnd);
        }
    }

    /**
     * Returns the end point ordinate of this dimension line.
     * @return {number}
     */
    public getYEnd(): number {
        return this.yEnd;
    }

    /**
     * Sets the end point ordinate of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} yEnd
     */
    public setYEnd(yEnd: number) {
        if (yEnd !== this.yEnd) {
            const oldYEnd: number = this.yEnd;
            this.yEnd = yEnd;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"Y_END", oldYEnd, yEnd);
        }
    }

    /**
     * Returns the end point elevation of this dimension line.
     * @return {number}
     */
    public getElevationEnd(): number {
        return this.elevationEnd;
    }

    /**
     * Sets the end point elevation of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} elevationEnd
     */
    public setElevationEnd(elevationEnd: number) {
        if (elevationEnd !== this.elevationEnd) {
            const oldElevationEnd: number = this.elevationEnd;
            this.elevationEnd = elevationEnd;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"ELEVATION_END", oldElevationEnd, elevationEnd);
        }
    }

    /**
     * Returns <code>true</code> if this dimension line is an elevation (vertical) dimension line.
     * @return {boolean}
     */
    public isElevationDimensionLine(): boolean {
        return this.xStart === this.xEnd && this.yStart === this.yEnd && this.elevationStart !== this.elevationEnd;
    }

    /**
     * Returns the offset of this dimension line.
     * @return {number}
     */
    public getOffset(): number {
        return this.offset;
    }

    /**
     * Sets the offset of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} offset
     */
    public setOffset(offset: number) {
        if (offset !== this.offset) {
            const oldOffset: number = this.offset;
            this.offset = offset;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"OFFSET", oldOffset, offset);
        }
    }

    /**
     * Returns the pitch angle in radians of this dimension line around its axis.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Sets the pitch angle of this dimension line. Once this dimension line
     * is updated, listeners added to this dimension line will receive a change notification.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
    }

    /**
     * Returns the length of this dimension line.
     * @return {number}
     */
    public getLength(): number {
        const deltaX: number = this.xEnd - this.xStart;
        const deltaY: number = this.yEnd - this.yStart;
        const deltaElevation: number = this.elevationEnd - this.elevationStart;
        return <number>Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaElevation * deltaElevation);
    }

    /**
     * Returns the text style used to display dimension line length.
     * @return {TextStyle}
     */
    public getLengthStyle(): TextStyle {
        return this.lengthStyle;
    }

    /**
     * Sets the text style used to display dimension line length.
     * Once this dimension line is updated, listeners added to it will receive a change notification.
     * @param {TextStyle} lengthStyle
     */
    public setLengthStyle(lengthStyle: TextStyle) {
        if (lengthStyle !== this.lengthStyle) {
            const oldLengthStyle: TextStyle = this.lengthStyle;
            this.lengthStyle = lengthStyle;
            this.firePropertyChange(/* name */"LENGTH_STYLE", oldLengthStyle, lengthStyle);
        }
    }

    /**
     * Returns the color used to display the text of this dimension line.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the color used to display the text of this dimension line.
     * Once this dimension line is updated, listeners added to this dimension line
     * will receive a change notification.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the size of marks drawn at the end of the dimension line.
     * @return {number}
     */
    public getEndMarkSize(): number {
        return this.endMarkSize;
    }

    /**
     * Sets the size of marks drawn at the end of the dimension line.
     * @param {number} endMarkSize
     */
    public setEndMarkSize(endMarkSize: number) {
        if (endMarkSize !== this.endMarkSize) {
            const oldEndMarkSize: number = this.endMarkSize;
            this.endMarkSize = endMarkSize;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"END_MARK_SIZE", oldEndMarkSize, endMarkSize);
        }
    }

    /**
     * Returns <code>true</code> if this dimension line should be displayed in 3D.
     * @return {boolean}
     */
    public isVisibleIn3D(): boolean {
        return this.visibleIn3D;
    }

    /**
     * Sets whether this dimension line should be displayed in 3D.
     * Once this dimension line is updated, listeners added to this dimension line
     * will receive a change notification.
     * @param {boolean} visibleIn3D
     */
    public setVisibleIn3D(visibleIn3D: boolean) {
        if (visibleIn3D !== this.visibleIn3D) {
            this.visibleIn3D = visibleIn3D;
            this.firePropertyChange(/* name */"VISIBLE_IN_3D", !visibleIn3D, visibleIn3D);
        }
    }

    /**
     * Returns the level which this dimension line belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this dimension line. Once this dimension line is updated,
     * listeners added to this dimension line will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this dimension line is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index
     * or if the elevation of its highest end is higher than <code>level</code> elevation.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        if (this.level === level) {
            return true;
        } else if (this.level != null && level != null) {
            const dimensionLineLevelElevation: number = this.level.getElevation();
            const levelElevation: number = level.getElevation();
            return dimensionLineLevelElevation === levelElevation && this.level.getElevationIndex() < level.getElevationIndex() || dimensionLineLevelElevation < levelElevation && dimensionLineLevelElevation + Math.max(this.elevationStart, this.elevationEnd) > levelElevation;
        } else {
            return false;
        }
    }

    /**
     * Returns the points of the rectangle surrounding
     * this dimension line and its extension lines.
     * @return {float[][]} an array of the 4 (x,y) coordinates of the rectangle.
     */
    public getPoints(): number[][] {
        const angle: number = this.isElevationDimensionLine() ? this.pitch : Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart);
        const dx: number = <number>-Math.sin(angle) * this.offset;
        const dy: number = <number>Math.cos(angle) * this.offset;
        return [[this.xStart, this.yStart], [this.xStart + dx, this.yStart + dy], [this.xEnd + dx, this.yEnd + dy], [this.xEnd, this.yEnd]];
    }

    /**
     * Returns <code>true</code> if this dimension line intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape().intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if this dimension line contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        return this.containsShapeAtWithMargin(this.getShape(), x, y, margin);
    }

    /**
     * Returns <code>true</code> if the middle point of this dimension line
     * is the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isMiddlePointAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart === this.elevationEnd) {
            const angle: number = Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart);
            const dx: number = <number>-Math.sin(angle) * this.offset;
            const dy: number = <number>Math.cos(angle) * this.offset;
            const xMiddle: number = (this.xStart + this.xEnd) / 2 + dx;
            const yMiddle: number = (this.yStart + this.yEnd) / 2 + dy;
            return Math.abs(x - xMiddle) <= margin && Math.abs(y - yMiddle) <= margin;
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the extension line at the start of this dimension line
     * contains the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code> around the extension line.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsStartExtensionLinetAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart === this.elevationEnd) {
            const angle: number = Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart);
            const startExtensionLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(this.xStart, this.yStart, this.xStart + <number>-Math.sin(angle) * this.offset, this.yStart + <number>Math.cos(angle) * this.offset);
            return this.containsShapeAtWithMargin(startExtensionLine, x, y, margin);
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the extension line at the end of this dimension line
     * contains the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code> around the extension line.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsEndExtensionLineAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart === this.elevationEnd) {
            const angle: number = Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart);
            const endExtensionLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(this.xEnd, this.yEnd, this.xEnd + <number>-Math.sin(angle) * this.offset, this.yEnd + <number>Math.cos(angle) * this.offset);
            return this.containsShapeAtWithMargin(endExtensionLine, x, y, margin);
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the top point of this dimension line is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isTopPointAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart !== this.elevationEnd) {
            const angle: number = this.yEnd !== this.yStart || this.xEnd !== this.xStart ? Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart) : this.pitch;
            const dx: number = <number>-Math.sin(angle) * (this.offset - this.endMarkSize / 2 * (/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset) === 0 ? -1 : /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset)));
            const dy: number = <number>Math.cos(angle) * (this.offset - this.endMarkSize / 2 * (/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset) === 0 ? -1 : /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset)));
            const distanceSquareToTopPoint: number = java.awt.geom.Point2D.distanceSq(x, y, this.xStart + dx, this.yStart + dy);
            return distanceSquareToTopPoint <= margin * margin;
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the right point of this dimension line is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isRightPointAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart !== this.elevationEnd) {
            const angle: number = this.yEnd !== this.yStart || this.xEnd !== this.xStart ? Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart) : this.pitch;
            const sin: number = <number>Math.sin(angle);
            const cos: number = <number>Math.cos(angle);
            const dx: number = -sin * this.offset + cos * this.endMarkSize / 2;
            const dy: number = cos * this.offset + sin * this.endMarkSize / 2;
            const distanceSquareToTopPoint: number = java.awt.geom.Point2D.distanceSq(x, y, this.xStart + dx, this.yStart + dy);
            return distanceSquareToTopPoint <= margin * margin;
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the bottom left point of this dimension line is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isBottomPointAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart !== this.elevationEnd) {
            const angle: number = this.yEnd !== this.yStart || this.xEnd !== this.xStart ? Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart) : this.pitch;
            const dx: number = <number>-Math.sin(angle) * (this.offset + this.endMarkSize / 2 * (/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset) === 0 ? -1 : /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset)));
            const dy: number = <number>Math.cos(angle) * (this.offset + this.endMarkSize / 2 * (/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset) === 0 ? -1 : /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.offset)));
            const distanceSquareToTopPoint: number = java.awt.geom.Point2D.distanceSq(x, y, this.xStart + dx, this.yStart + dy);
            return distanceSquareToTopPoint <= margin * margin;
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if the left point of this dimension line is
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isLeftPointAt(x: number, y: number, margin: number): boolean {
        if (this.elevationStart !== this.elevationEnd) {
            const angle: number = this.yEnd !== this.yStart || this.xEnd !== this.xStart ? Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart) : this.pitch;
            const sin: number = <number>Math.sin(angle);
            const cos: number = <number>Math.cos(angle);
            const dx: number = -sin * this.offset - cos * this.endMarkSize / 2;
            const dy: number = cos * this.offset - sin * this.endMarkSize / 2;
            const distanceSquareToTopPoint: number = java.awt.geom.Point2D.distanceSq(x, y, this.xStart + dx, this.yStart + dy);
            return distanceSquareToTopPoint <= margin * margin;
        } else {
            return false;
        }
    }

    /**
     * Returns <code>true</code> if <code>shape</code> contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {Object} shape
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     * @private
     */
    containsShapeAtWithMargin(shape: java.awt.Shape, x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return shape.contains(x, y);
        } else {
            return shape.intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns the shape matching this dimension line.
     * @return {Object}
     * @private
     */
    getShape(): java.awt.Shape {
        if (this.shapeCache == null) {
            const angle: number = this.yEnd !== this.yStart || this.xEnd !== this.xStart ? Math.atan2(this.yEnd - this.yStart, this.xEnd - this.xStart) : this.pitch;
            const horizontalDimensionLine: boolean = this.elevationStart === this.elevationEnd;
            const dx: number = <number>-Math.sin(angle) * this.offset;
            const dy: number = <number>Math.cos(angle) * this.offset;
            const dimensionLineShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            if (horizontalDimensionLine) {
                dimensionLineShape.append(new java.awt.geom.Line2D.Float(this.xStart + dx, this.yStart + dy, this.xEnd + dx, this.yEnd + dy), false);
                dimensionLineShape.append(new java.awt.geom.Line2D.Float(this.xEnd, this.yEnd, this.xEnd + dx, this.yEnd + dy), false);
            } else {
                dimensionLineShape.append(new java.awt.geom.Ellipse2D.Float(this.xStart + dx - this.endMarkSize / 2, this.yStart + dy - this.endMarkSize / 2, this.endMarkSize, this.endMarkSize), false);
            }
            dimensionLineShape.append(new java.awt.geom.Line2D.Float(this.xStart, this.yStart, this.xStart + dx, this.yStart + dy), false);
            this.shapeCache = dimensionLineShape;
        }
        return this.shapeCache;
    }

    /**
     * Moves this dimension line of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setXStart(this.getXStart() + dx);
        this.setYStart(this.getYStart() + dy);
        this.setXEnd(this.getXEnd() + dx);
        this.setYEnd(this.getYEnd() + dy);
    }

    /**
     * Returns a clone of this dimension line.
     * @return {DimensionLine}
     */
    public clone(): DimensionLine {
        const clone: DimensionLine = <DimensionLine>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.level = null;
        return clone;
    }
}
DimensionLine["__class"] = "com.eteks.sweethome3d.model.DimensionLine";
DimensionLine["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.Elevatable"];

DimensionLine['__transients'] = ['shapeCache', 'propertyChangeSupport'];

/**
 * Creates a home level.
 * @param {string} id    the ID of the level
 * @param {string} name  the name of the level
 * @param {number} elevation the elevation of the bottom of the level
 * @param {number} floorThickness the floor thickness of the level
 * @param {number} height the height of the level
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Level extends HomeObject {
    /*private*/ name: string;

    /*private*/ elevation: number;

    /*private*/ floorThickness: number;

    /*private*/ height: number;

    /*private*/ backgroundImage: BackgroundImage;

    /*private*/ visible: boolean;

    /*private*/ viewable: boolean;

    /*private*/ elevationIndex: number;

    public constructor(id?: any, name?: any, elevation?: any, floorThickness?: any, height?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof name === 'string') || name === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof floorThickness === 'number') || floorThickness === null) && ((typeof height === 'number') || height === null)) {
            let __args = arguments;
            super(id);
            if (this.name === undefined) { this.name = null; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.floorThickness === undefined) { this.floorThickness = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.viewable === undefined) { this.viewable = false; }
            if (this.elevationIndex === undefined) { this.elevationIndex = 0; }
            this.name = name;
            this.elevation = elevation;
            this.floorThickness = floorThickness;
            this.height = height;
            this.visible = true;
            this.viewable = true;
            this.elevationIndex = -1;
        } else if (((typeof id === 'string') || id === null) && ((typeof name === 'number') || name === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof floorThickness === 'number') || floorThickness === null) && height === undefined) {
            let __args = arguments;
            let name: any = __args[0];
            let elevation: any = __args[1];
            let floorThickness: any = __args[2];
            let height: any = __args[3];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("level");
                super(id);
                if (this.name === undefined) { this.name = null; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.floorThickness === undefined) { this.floorThickness = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                if (this.visible === undefined) { this.visible = false; }
                if (this.viewable === undefined) { this.viewable = false; }
                if (this.elevationIndex === undefined) { this.elevationIndex = 0; }
                this.name = name;
                this.elevation = elevation;
                this.floorThickness = floorThickness;
                this.height = height;
                this.visible = true;
                this.viewable = true;
                this.elevationIndex = -1;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.floorThickness === undefined) { this.floorThickness = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.viewable === undefined) { this.viewable = false; }
            if (this.elevationIndex === undefined) { this.elevationIndex = 0; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the name of this level.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of this level. Once this level
     * is updated, listeners added to this level will receive a change notification.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name && (name == null || !(name === this.name))) {
            const oldName: string = this.name;
            this.name = name;
            this.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns the elevation of the bottom of this level.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Sets the elevation of this level. Once this level is updated,
     * listeners added to this level will receive a change notification.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns the floor thickness of this level.
     * @return {number}
     */
    public getFloorThickness(): number {
        return this.floorThickness;
    }

    /**
     * Sets the floor thickness of this level. Once this level is updated,
     * listeners added to this level will receive a change notification.
     * @param {number} floorThickness
     */
    public setFloorThickness(floorThickness: number) {
        if (floorThickness !== this.floorThickness) {
            const oldFloorThickness: number = this.floorThickness;
            this.floorThickness = floorThickness;
            this.firePropertyChange(/* name */"FLOOR_THICKNESS", oldFloorThickness, floorThickness);
        }
    }

    /**
     * Returns the height of this level.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the height of this level. Once this level is updated,
     * listeners added to this level will receive a change notification.
     * @param {number} height
     */
    public setHeight(height: number) {
        if (height !== this.height) {
            const oldHeight: number = this.height;
            this.height = height;
            this.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
        }
    }

    /**
     * Returns the plan background image of this level.
     * @return {BackgroundImage}
     */
    public getBackgroundImage(): BackgroundImage {
        return this.backgroundImage;
    }

    /**
     * Sets the plan background image of this level and fires a <code>PropertyChangeEvent</code>.
     * @param {BackgroundImage} backgroundImage
     */
    public setBackgroundImage(backgroundImage: BackgroundImage) {
        if (backgroundImage !== this.backgroundImage) {
            const oldBackgroundImage: BackgroundImage = this.backgroundImage;
            this.backgroundImage = backgroundImage;
            this.firePropertyChange(/* name */"BACKGROUND_IMAGE", oldBackgroundImage, backgroundImage);
        }
    }

    /**
     * Returns <code>true</code> if this level is visible.
     * @return {boolean}
     */
    public isVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether this level is visible or not. Once this level is updated,
     * listeners added to this level will receive a change notification.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        if (visible !== this.visible) {
            this.visible = visible;
            this.firePropertyChange(/* name */"VISIBLE", !visible, visible);
        }
    }

    /**
     * Returns <code>true</code> if this level is viewable.
     * @return {boolean}
     */
    public isViewable(): boolean {
        return this.viewable;
    }

    /**
     * Sets whether this level is viewable or not. Once this level is updated,
     * listeners added to this level will receive a change notification.
     * @param {boolean} viewable
     */
    public setViewable(viewable: boolean) {
        if (viewable !== this.viewable) {
            this.viewable = viewable;
            this.firePropertyChange(/* name */"VIEWABLE", !viewable, viewable);
        }
    }

    /**
     * Returns <code>true</code> if this level is viewable and visible.
     * @return {boolean}
     */
    public isViewableAndVisible(): boolean {
        return this.viewable && this.visible;
    }

    /**
     * Returns the index of this level used to order levels at the same elevation.
     * @return {number}
     */
    public getElevationIndex(): number {
        return this.elevationIndex;
    }

    /**
     * Sets the index of this level used to order levels at the same elevation.
     * @param {number} elevationIndex
     */
    public setElevationIndex(elevationIndex: number) {
        if (elevationIndex !== this.elevationIndex) {
            const oldElevationIndex: number = this.elevationIndex;
            this.elevationIndex = elevationIndex;
            this.firePropertyChange(/* name */"ELEVATION_INDEX", oldElevationIndex, elevationIndex);
        }
    }

    /**
     * Returns a clone of this level.
     * @return {Level}
     */
    public clone(): Level {
        return <Level>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }
}
Level["__class"] = "com.eteks.sweethome3d.model.Level";
Level['__transients'] = ['propertyChangeSupport'];

/**
 * Creates a camera at given location and angles.
 * @param {string} id
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {number} yaw
 * @param {number} pitch
 * @param {number} fieldOfView
 * @param {number} time
 * @param {Camera.Lens} lens
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Camera extends HomeObject {
    /*private*/ name: string;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ z: number;

    /*private*/ yaw: number;

    /*private*/ pitch: number;

    /*private*/ fieldOfView: number;

    /*private*/ time: number;

    /*private*/ lens: Camera.Lens;

    /*private*/ lensName: string;

    /*private*/ renderer: string;

    public constructor(id?: any, x?: any, y?: any, z?: any, yaw?: any, pitch?: any, fieldOfView?: any, time?: any, lens?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && ((typeof fieldOfView === 'number') || fieldOfView === null) && ((typeof time === 'number') || time === null) && ((typeof lens === 'number') || lens === null)) {
            let __args = arguments;
            super(id);
            if (this.name === undefined) { this.name = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.yaw === undefined) { this.yaw = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
            if (this.time === undefined) { this.time = 0; }
            if (this.lens === undefined) { this.lens = null; }
            if (this.lensName === undefined) { this.lensName = null; }
            if (this.renderer === undefined) { this.renderer = null; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.yaw = yaw;
            this.pitch = pitch;
            this.fieldOfView = fieldOfView;
            this.time = time;
            this.lens = lens;
        } else if (((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && ((typeof fieldOfView === 'number') || fieldOfView === null) && ((typeof time === 'number') || time === null) && lens === undefined) {
            let __args = arguments;
            let x: any = __args[0];
            let y: any = __args[1];
            let z: any = __args[2];
            let yaw: any = __args[3];
            let pitch: any = __args[4];
            let fieldOfView: any = __args[5];
            let time: any = __args[6];
            let lens: any = __args[7];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("camera");
                super(id);
                if (this.name === undefined) { this.name = null; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.z === undefined) { this.z = 0; }
                if (this.yaw === undefined) { this.yaw = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
                if (this.time === undefined) { this.time = 0; }
                if (this.lens === undefined) { this.lens = null; }
                if (this.lensName === undefined) { this.lensName = null; }
                if (this.renderer === undefined) { this.renderer = null; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.yaw = yaw;
                this.pitch = pitch;
                this.fieldOfView = fieldOfView;
                this.time = time;
                this.lens = lens;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.yaw === undefined) { this.yaw = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
            if (this.time === undefined) { this.time = 0; }
            if (this.lens === undefined) { this.lens = null; }
            if (this.lensName === undefined) { this.lensName = null; }
            if (this.renderer === undefined) { this.renderer = null; }
        } else if (((typeof id === 'string') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && ((typeof fieldOfView === 'number') || fieldOfView === null) && time === undefined && lens === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let time: any = Camera.midday();
                let lens: any = Camera.Lens.PINHOLE;
                super(id);
                if (this.name === undefined) { this.name = null; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.z === undefined) { this.z = 0; }
                if (this.yaw === undefined) { this.yaw = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
                if (this.time === undefined) { this.time = 0; }
                if (this.lens === undefined) { this.lens = null; }
                if (this.lensName === undefined) { this.lensName = null; }
                if (this.renderer === undefined) { this.renderer = null; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.yaw = yaw;
                this.pitch = pitch;
                this.fieldOfView = fieldOfView;
                this.time = time;
                this.lens = lens;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.yaw === undefined) { this.yaw = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
            if (this.time === undefined) { this.time = 0; }
            if (this.lens === undefined) { this.lens = null; }
            if (this.lensName === undefined) { this.lensName = null; }
            if (this.renderer === undefined) { this.renderer = null; }
        } else if (((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && fieldOfView === undefined && time === undefined && lens === undefined) {
            let __args = arguments;
            let x: any = __args[0];
            let y: any = __args[1];
            let z: any = __args[2];
            let yaw: any = __args[3];
            let pitch: any = __args[4];
            let fieldOfView: any = __args[5];
            {
                let __args = arguments;
                let time: any = Camera.midday();
                let lens: any = Camera.Lens.PINHOLE;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("camera");
                    super(id);
                    if (this.name === undefined) { this.name = null; }
                    if (this.x === undefined) { this.x = 0; }
                    if (this.y === undefined) { this.y = 0; }
                    if (this.z === undefined) { this.z = 0; }
                    if (this.yaw === undefined) { this.yaw = 0; }
                    if (this.pitch === undefined) { this.pitch = 0; }
                    if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
                    if (this.time === undefined) { this.time = 0; }
                    if (this.lens === undefined) { this.lens = null; }
                    if (this.lensName === undefined) { this.lensName = null; }
                    if (this.renderer === undefined) { this.renderer = null; }
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.yaw = yaw;
                    this.pitch = pitch;
                    this.fieldOfView = fieldOfView;
                    this.time = time;
                    this.lens = lens;
                }
                if (this.name === undefined) { this.name = null; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.z === undefined) { this.z = 0; }
                if (this.yaw === undefined) { this.yaw = 0; }
                if (this.pitch === undefined) { this.pitch = 0; }
                if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
                if (this.time === undefined) { this.time = 0; }
                if (this.lens === undefined) { this.lens = null; }
                if (this.lensName === undefined) { this.lensName = null; }
                if (this.renderer === undefined) { this.renderer = null; }
            }
            if (this.name === undefined) { this.name = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.z === undefined) { this.z = 0; }
            if (this.yaw === undefined) { this.yaw = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.fieldOfView === undefined) { this.fieldOfView = 0; }
            if (this.time === undefined) { this.time = 0; }
            if (this.lens === undefined) { this.lens = null; }
            if (this.lensName === undefined) { this.lensName = null; }
            if (this.renderer === undefined) { this.renderer = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the time of midday today in milliseconds since the Epoch in UTC time zone.
     * @return {number}
     * @private
     */
    static midday(): number {
        const midday: Date = new Date();
        /* set */((d, p) => d["UTC"] ? d.setUTCHours(p) : d.setHours(p))(midday, 12);
        /* set */((d, p) => d["UTC"] ? d.setUTCMinutes(p) : d.setMinutes(p))(midday, 0);
        /* set */((d, p) => d["UTC"] ? d.setUTCSeconds(p) : d.setSeconds(p))(midday, 0);
        /* set */((d, p) => d["UTC"] ? d.setUTCMilliseconds(p) : d.setMilliseconds(p))(midday, 0);
        return /* getTimeInMillis */midday.getTime();
    }

    /**
     * Returns the name of this camera.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of this camera and notifies listeners of this change.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name && (name == null || !(name === this.name))) {
            const oldName: string = this.name;
            this.name = name;
            this.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns the yaw angle in radians of this camera.
     * @return {number}
     */
    public getYaw(): number {
        return this.yaw;
    }

    /**
     * Sets the yaw angle in radians of this camera and notifies listeners of this change.
     * Yaw axis is vertical axis.
     * @param {number} yaw
     */
    public setYaw(yaw: number) {
        if (yaw !== this.yaw) {
            const oldYaw: number = this.yaw;
            this.yaw = yaw;
            this.firePropertyChange(/* name */"YAW", oldYaw, yaw);
        }
    }

    /**
     * Returns the pitch angle in radians of this camera.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Sets the pitch angle in radians of this camera and notifies listeners of this change.
     * Pitch axis is horizontal transverse axis.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
    }

    /**
     * Returns the field of view in radians of this camera.
     * @return {number}
     */
    public getFieldOfView(): number {
        return this.fieldOfView;
    }

    /**
     * Sets the field of view in radians of this camera and notifies listeners of this change.
     * @param {number} fieldOfView
     */
    public setFieldOfView(fieldOfView: number) {
        if (fieldOfView !== this.fieldOfView) {
            const oldFieldOfView: number = this.fieldOfView;
            this.fieldOfView = fieldOfView;
            this.firePropertyChange(/* name */"FIELD_OF_VIEW", oldFieldOfView, fieldOfView);
        }
    }

    /**
     * Returns the abscissa of this camera.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the abscissa of this camera and notifies listeners of this change.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the ordinate of this camera.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the ordinate of this camera and notifies listeners of this change.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the elevation of this camera.
     * @return {number}
     */
    public getZ(): number {
        return this.z;
    }

    /**
     * Sets the elevation of this camera and notifies listeners of this change.
     * @param {number} z
     */
    public setZ(z: number) {
        if (z !== this.z) {
            const oldZ: number = this.z;
            this.z = z;
            this.firePropertyChange(/* name */"Z", oldZ, z);
        }
    }

    /**
     * Returns the time in milliseconds when this camera is used.
     * @return {number} a time in milliseconds since the Epoch in UTC time zone
     */
    public getTime(): number {
        return this.time;
    }

    /**
     * Sets the use time in milliseconds since the Epoch in UTC time zone,
     * and notifies listeners of this change.
     * @param {number} time
     */
    public setTime(time: number) {
        if (this.time !== time) {
            const oldTime: number = this.time;
            this.time = time;
            this.firePropertyChange(/* name */"TIME", oldTime, time);
        }
    }

    /**
     * Returns a time expressed in UTC time zone converted to the given time zone.
     * @param {number} utcTime
     * @param {string} timeZone
     * @return {number}
     */
    public static convertTimeToTimeZone(utcTime: number, timeZone: string): number {
        const utcCalendar: Date = new Date();
        /* setTimeInMillis */utcCalendar.setTime(utcTime);
        const convertedCalendar: Date = new Date();
        /* set */((d, p) => d["UTC"] ? d.setUTCFullYear(p) : d.setFullYear(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCFullYear() : d.getFullYear())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCMonth(p) : d.setMonth(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCMonth() : d.getMonth())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCDate(p) : d.setDate(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCDate() : d.getDate())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCHours(p) : d.setHours(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCHours() : d.getHours())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCMinutes(p) : d.setMinutes(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCMinutes() : d.getMinutes())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCSeconds(p) : d.setSeconds(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCSeconds() : d.getSeconds())(utcCalendar));
        /* set */((d, p) => d["UTC"] ? d.setUTCMilliseconds(p) : d.setMilliseconds(p))(convertedCalendar, /* get */(d => d["UTC"] ? d.getUTCMilliseconds() : d.getMilliseconds())(utcCalendar));
        return /* getTimeInMillis */convertedCalendar.getTime();
    }

    /**
     * Returns the lens of this camera.
     * @return {Camera.Lens}
     */
    public getLens(): Camera.Lens {
        return this.lens;
    }

    /**
     * Sets the lens of this camera and notifies listeners of this change.
     * @param {Camera.Lens} lens
     */
    public setLens(lens: Camera.Lens) {
        if (lens !== this.lens) {
            const oldLens: Camera.Lens = this.lens;
            this.lens = lens;
            this.lensName = /* Enum.name */Camera.Lens[this.lens];
            this.firePropertyChange(/* name */"LENS", oldLens, lens);
        }
    }

    /**
     * Sets the rendering engine used to create photos.
     * @param {string} renderer
     */
    public setRenderer(renderer: string) {
        if (renderer !== this.renderer && (renderer == null || !(renderer === this.renderer))) {
            const oldRenderer: string = this.renderer;
            this.renderer = renderer;
            this.firePropertyChange(/* name */"RENDERER", oldRenderer, renderer);
        }
    }

    /**
     * Returns the rendering engine used to create photos.
     * @return {string}
     */
    public getRenderer(): string {
        return this.renderer;
    }

    /**
     * Sets the location and angles of this camera from the <code>camera</code> in parameter.
     * @param {Camera} camera
     */
    public setCamera(camera: Camera) {
        this.setX(camera.getX());
        this.setY(camera.getY());
        this.setZ(camera.getZ());
        this.setYaw(camera.getYaw());
        this.setPitch(camera.getPitch());
        this.setFieldOfView(camera.getFieldOfView());
    }

    /**
     * Returns a clone of this camera.
     * @return {Camera}
     */
    public clone(): Camera {
        return <Camera>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }
}
Camera["__class"] = "com.eteks.sweethome3d.model.Camera";


export namespace Camera {

    /**
     * The kind of lens that can be used with a camera.
     * @author Emmanuel Puybaret
     * @enum
     * @property {Camera.Lens} PINHOLE
     * @property {Camera.Lens} NORMAL
     * @property {Camera.Lens} FISHEYE
     * @property {Camera.Lens} SPHERICAL
     * @class
     */
    export enum Lens {
        PINHOLE, NORMAL, FISHEYE, SPHERICAL
    }
}
Camera['__transients'] = ['lens', 'propertyChangeSupport'];

/**
 * Creates a room from its name and the given coordinates.
 * @param {string} id
 * @param {float[][]} points
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Room extends HomeObject implements Selectable, Elevatable {
    static TWICE_PI: number; public static TWICE_PI_$LI$(): number { if (Room.TWICE_PI == null) { Room.TWICE_PI = 2 * Math.PI; } return Room.TWICE_PI; }

    /*private*/ name: string;

    /*private*/ nameXOffset: number;

    /*private*/ nameYOffset: number;

    /*private*/ nameStyle: TextStyle;

    /*private*/ nameAngle: number;

    /*private*/ points: number[][];

    /*private*/ areaVisible: boolean;

    /*private*/ areaXOffset: number;

    /*private*/ areaYOffset: number;

    /*private*/ areaStyle: TextStyle;

    /*private*/ areaAngle: number;

    /*private*/ floorVisible: boolean;

    /*private*/ floorColor: number;

    /*private*/ floorTexture: HomeTexture;

    /*private*/ floorShininess: number;

    /*private*/ ceilingVisible: boolean;

    /*private*/ ceilingColor: number;

    /*private*/ ceilingTexture: HomeTexture;

    /*private*/ ceilingShininess: number;

    /*private*/ ceilingFlat: boolean;

    /*private*/ level: Level;

    /*private*/ shapeCache: java.awt.Shape;

    /*private*/ boundsCache: java.awt.geom.Rectangle2D;

    /*private*/ areaCache: number;

    public constructor(id?: any, points?: any) {
        if (((typeof id === 'string') || id === null) && ((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null || points[0] instanceof Array)) || points === null)) {
            let __args = arguments;
            super(id);
            if (this.name === undefined) { this.name = null; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.points === undefined) { this.points = null; }
            if (this.areaVisible === undefined) { this.areaVisible = false; }
            if (this.areaXOffset === undefined) { this.areaXOffset = 0; }
            if (this.areaYOffset === undefined) { this.areaYOffset = 0; }
            if (this.areaStyle === undefined) { this.areaStyle = null; }
            if (this.areaAngle === undefined) { this.areaAngle = 0; }
            if (this.floorVisible === undefined) { this.floorVisible = false; }
            if (this.floorColor === undefined) { this.floorColor = null; }
            if (this.floorTexture === undefined) { this.floorTexture = null; }
            if (this.floorShininess === undefined) { this.floorShininess = 0; }
            if (this.ceilingVisible === undefined) { this.ceilingVisible = false; }
            if (this.ceilingColor === undefined) { this.ceilingColor = null; }
            if (this.ceilingTexture === undefined) { this.ceilingTexture = null; }
            if (this.ceilingShininess === undefined) { this.ceilingShininess = 0; }
            if (this.ceilingFlat === undefined) { this.ceilingFlat = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.boundsCache === undefined) { this.boundsCache = null; }
            if (this.areaCache === undefined) { this.areaCache = null; }
            if (points.length <= 1) {
                throw new IllegalStateException("Room points must containt at least two points");
            }
            this.points = this.deepCopy(points);
            this.areaVisible = true;
            this.nameYOffset = -40.0;
            this.floorVisible = true;
            this.ceilingVisible = true;
            this.ceilingFlat = true;
        } else if (((id != null && id instanceof <any>Array && (id.length == 0 || id[0] == null || id[0] instanceof Array)) || id === null) && points === undefined) {
            let __args = arguments;
            let points: any = __args[0];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("room");
                super(id);
                if (this.name === undefined) { this.name = null; }
                if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
                if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
                if (this.nameStyle === undefined) { this.nameStyle = null; }
                if (this.nameAngle === undefined) { this.nameAngle = 0; }
                if (this.points === undefined) { this.points = null; }
                if (this.areaVisible === undefined) { this.areaVisible = false; }
                if (this.areaXOffset === undefined) { this.areaXOffset = 0; }
                if (this.areaYOffset === undefined) { this.areaYOffset = 0; }
                if (this.areaStyle === undefined) { this.areaStyle = null; }
                if (this.areaAngle === undefined) { this.areaAngle = 0; }
                if (this.floorVisible === undefined) { this.floorVisible = false; }
                if (this.floorColor === undefined) { this.floorColor = null; }
                if (this.floorTexture === undefined) { this.floorTexture = null; }
                if (this.floorShininess === undefined) { this.floorShininess = 0; }
                if (this.ceilingVisible === undefined) { this.ceilingVisible = false; }
                if (this.ceilingColor === undefined) { this.ceilingColor = null; }
                if (this.ceilingTexture === undefined) { this.ceilingTexture = null; }
                if (this.ceilingShininess === undefined) { this.ceilingShininess = 0; }
                if (this.ceilingFlat === undefined) { this.ceilingFlat = false; }
                if (this.level === undefined) { this.level = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.boundsCache === undefined) { this.boundsCache = null; }
                if (this.areaCache === undefined) { this.areaCache = null; }
                if (points.length <= 1) {
                    throw new IllegalStateException("Room points must containt at least two points");
                }
                this.points = this.deepCopy(points);
                this.areaVisible = true;
                this.nameYOffset = -40.0;
                this.floorVisible = true;
                this.ceilingVisible = true;
                this.ceilingFlat = true;
            }
            if (this.name === undefined) { this.name = null; }
            if (this.nameXOffset === undefined) { this.nameXOffset = 0; }
            if (this.nameYOffset === undefined) { this.nameYOffset = 0; }
            if (this.nameStyle === undefined) { this.nameStyle = null; }
            if (this.nameAngle === undefined) { this.nameAngle = 0; }
            if (this.points === undefined) { this.points = null; }
            if (this.areaVisible === undefined) { this.areaVisible = false; }
            if (this.areaXOffset === undefined) { this.areaXOffset = 0; }
            if (this.areaYOffset === undefined) { this.areaYOffset = 0; }
            if (this.areaStyle === undefined) { this.areaStyle = null; }
            if (this.areaAngle === undefined) { this.areaAngle = 0; }
            if (this.floorVisible === undefined) { this.floorVisible = false; }
            if (this.floorColor === undefined) { this.floorColor = null; }
            if (this.floorTexture === undefined) { this.floorTexture = null; }
            if (this.floorShininess === undefined) { this.floorShininess = 0; }
            if (this.ceilingVisible === undefined) { this.ceilingVisible = false; }
            if (this.ceilingColor === undefined) { this.ceilingColor = null; }
            if (this.ceilingTexture === undefined) { this.ceilingTexture = null; }
            if (this.ceilingShininess === undefined) { this.ceilingShininess = 0; }
            if (this.ceilingFlat === undefined) { this.ceilingFlat = false; }
            if (this.level === undefined) { this.level = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.boundsCache === undefined) { this.boundsCache = null; }
            if (this.areaCache === undefined) { this.areaCache = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the name of this room.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name && (name == null || !(name === this.name))) {
            const oldName: string = this.name;
            this.name = name;
            this.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns the distance along x axis applied to room center abscissa
     * to display room name.
     * @return {number}
     */
    public getNameXOffset(): number {
        return this.nameXOffset;
    }

    /**
     * Sets the distance along x axis applied to room center abscissa to display room name.
     * Once this room  is updated, listeners added to this room will receive a change notification.
     * @param {number} nameXOffset
     */
    public setNameXOffset(nameXOffset: number) {
        if (nameXOffset !== this.nameXOffset) {
            const oldNameXOffset: number = this.nameXOffset;
            this.nameXOffset = nameXOffset;
            this.firePropertyChange(/* name */"NAME_X_OFFSET", oldNameXOffset, nameXOffset);
        }
    }

    /**
     * Returns the distance along y axis applied to room center ordinate
     * to display room name.
     * @return {number}
     */
    public getNameYOffset(): number {
        return this.nameYOffset;
    }

    /**
     * Sets the distance along y axis applied to room center ordinate to display room name.
     * Once this room is updated, listeners added to this room will receive a change notification.
     * @param {number} nameYOffset
     */
    public setNameYOffset(nameYOffset: number) {
        if (nameYOffset !== this.nameYOffset) {
            const oldNameYOffset: number = this.nameYOffset;
            this.nameYOffset = nameYOffset;
            this.firePropertyChange(/* name */"NAME_Y_OFFSET", oldNameYOffset, nameYOffset);
        }
    }

    /**
     * Returns the text style used to display room name.
     * @return {TextStyle}
     */
    public getNameStyle(): TextStyle {
        return this.nameStyle;
    }

    /**
     * Sets the text style used to display room name.
     * Once this room is updated, listeners added to this room will receive a change notification.
     * @param {TextStyle} nameStyle
     */
    public setNameStyle(nameStyle: TextStyle) {
        if (nameStyle !== this.nameStyle) {
            const oldNameStyle: TextStyle = this.nameStyle;
            this.nameStyle = nameStyle;
            this.firePropertyChange(/* name */"NAME_STYLE", oldNameStyle, nameStyle);
        }
    }

    /**
     * Returns the angle in radians used to display the room name.
     * @return {number}
     */
    public getNameAngle(): number {
        return this.nameAngle;
    }

    /**
     * Sets the angle in radians used to display the room name. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} nameAngle
     */
    public setNameAngle(nameAngle: number) {
        nameAngle = <number>((nameAngle % Room.TWICE_PI_$LI$() + Room.TWICE_PI_$LI$()) % Room.TWICE_PI_$LI$());
        if (nameAngle !== this.nameAngle) {
            const oldNameAngle: number = this.nameAngle;
            this.nameAngle = nameAngle;
            this.firePropertyChange(/* name */"NAME_ANGLE", oldNameAngle, nameAngle);
        }
    }

    /**
     * Returns the points of the polygon matching this room.
     * @return {float[][]} an array of the (x,y) coordinates of the room points.
     */
    public getPoints(): number[][] {
        return this.deepCopy(this.points);
    }

    /**
     * Returns the number of points of the polygon matching this room.
     * @return {number}
     */
    public getPointCount(): number {
        return this.points.length;
    }

    deepCopy(points: number[][]): number[][] {
        const pointsCopy: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(points.length);
        for (let i: number = 0; i < points.length; i++) {
            {
                pointsCopy[i] = /* clone */points[i].slice(0);
            };
        }
        return pointsCopy;
    }

    /**
     * Sets the points of the polygon matching this room. Once this room
     * is updated, listeners added to this room will receive a change notification.
     * @param {float[][]} points
     */
    public setPoints(points: number[][]) {
        if (!/* deepEquals */(JSON.stringify(this.points) === JSON.stringify(points))) {
            this.updatePoints(points);
        }
    }

    /**
     * Update the points of the polygon matching this room.
     * @param {float[][]} points
     * @private
     */
    updatePoints(points: number[][]) {
        const oldPoints: number[][] = this.points;
        this.points = this.deepCopy(points);
        this.shapeCache = null;
        this.boundsCache = null;
        this.areaCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, points);
    }

    public addPoint$float$float(x: number, y: number) {
        this.addPoint$float$float$int(x, y, this.points.length);
    }

    public addPoint$float$float$int(x: number, y: number, index: number) {
        if (index < 0 || index > this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        }
        const newPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(this.points.length + 1);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, 0, newPoints, 0, index);
        newPoints[index] = [x, y];
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, index, newPoints, index + 1, this.points.length - index);
        const oldPoints: number[][] = this.points;
        this.points = newPoints;
        this.shapeCache = null;
        this.boundsCache = null;
        this.areaCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
    }

    /**
     * Adds a point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or > <code>getPointCount()</code>
     * @param {number} x
     * @param {number} y
     * @param {number} index
     */
    public addPoint(x?: any, y?: any, index?: any) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof index === 'number') || index === null)) {
            return <any>this.addPoint$float$float$int(x, y, index);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && index === undefined) {
            return <any>this.addPoint$float$float(x, y);
        } else throw new Error('invalid overload');
    }

    /**
     * Sets the point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or >= <code>getPointCount()</code>
     * @param {number} x
     * @param {number} y
     * @param {number} index
     */
    public setPoint(x: number, y: number, index: number) {
        if (index < 0 || index >= this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        }
        if (this.points[index][0] !== x || this.points[index][1] !== y) {
            const oldPoints: number[][] = this.points;
            this.points = this.deepCopy(this.points);
            this.points[index][0] = x;
            this.points[index][1] = y;
            this.shapeCache = null;
            this.boundsCache = null;
            this.areaCache = null;
            this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
        }
    }

    /**
     * Removes the point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or >= <code>getPointCount()</code>
     * @param {number} index
     */
    public removePoint(index: number) {
        if (index < 0 || index >= this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        } else if (this.points.length <= 1) {
            throw new IllegalStateException("Room points must containt at least one point");
        }
        const newPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(this.points.length - 1);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, 0, newPoints, 0, index);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, index + 1, newPoints, index, this.points.length - index - 1);
        const oldPoints: number[][] = this.points;
        this.points = newPoints;
        this.shapeCache = null;
        this.boundsCache = null;
        this.areaCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
    }

    /**
     * Returns the minimum coordinates of the rectangle bounding this room.
     * @return {float[]}
     */
    public getBoundsMinimumCoordinates(): number[] {
        if (this.boundsCache == null) {
            this.boundsCache = this.getShape().getBounds2D();
        }
        return [<number>this.boundsCache.getMinX(), <number>this.boundsCache.getMinY()];
    }

    /**
     * Returns the maximum coordinates of the rectangle bounding this room.
     * @return {float[]}
     */
    public getBoundsMaximumCoordinates(): number[] {
        if (this.boundsCache == null) {
            this.boundsCache = this.getShape().getBounds2D();
        }
        return [<number>this.boundsCache.getMaxX(), <number>this.boundsCache.getMaxY()];
    }

    /**
     * Returns whether the area of this room is visible or not.
     * @return {boolean}
     */
    public isAreaVisible(): boolean {
        return this.areaVisible;
    }

    /**
     * Sets whether the area of this room is visible or not. Once this room
     * is updated, listeners added to this room will receive a change notification.
     * @param {boolean} areaVisible
     */
    public setAreaVisible(areaVisible: boolean) {
        if (areaVisible !== this.areaVisible) {
            this.areaVisible = areaVisible;
            this.firePropertyChange(/* name */"AREA_VISIBLE", !areaVisible, areaVisible);
        }
    }

    /**
     * Returns the distance along x axis applied to room center abscissa
     * to display room area.
     * @return {number}
     */
    public getAreaXOffset(): number {
        return this.areaXOffset;
    }

    /**
     * Sets the distance along x axis applied to room center abscissa to display room area.
     * Once this room  is updated, listeners added to this room will receive a change notification.
     * @param {number} areaXOffset
     */
    public setAreaXOffset(areaXOffset: number) {
        if (areaXOffset !== this.areaXOffset) {
            const oldAreaXOffset: number = this.areaXOffset;
            this.areaXOffset = areaXOffset;
            this.firePropertyChange(/* name */"AREA_X_OFFSET", oldAreaXOffset, areaXOffset);
        }
    }

    /**
     * Returns the distance along y axis applied to room center ordinate
     * to display room area.
     * @return {number}
     */
    public getAreaYOffset(): number {
        return this.areaYOffset;
    }

    /**
     * Sets the distance along y axis applied to room center ordinate to display room area.
     * Once this room is updated, listeners added to this room will receive a change notification.
     * @param {number} areaYOffset
     */
    public setAreaYOffset(areaYOffset: number) {
        if (areaYOffset !== this.areaYOffset) {
            const oldAreaYOffset: number = this.areaYOffset;
            this.areaYOffset = areaYOffset;
            this.firePropertyChange(/* name */"AREA_Y_OFFSET", oldAreaYOffset, areaYOffset);
        }
    }

    /**
     * Returns the text style used to display room area.
     * @return {TextStyle}
     */
    public getAreaStyle(): TextStyle {
        return this.areaStyle;
    }

    /**
     * Sets the text style used to display room area.
     * Once this room is updated, listeners added to this room will receive a change notification.
     * @param {TextStyle} areaStyle
     */
    public setAreaStyle(areaStyle: TextStyle) {
        if (areaStyle !== this.areaStyle) {
            const oldAreaStyle: TextStyle = this.areaStyle;
            this.areaStyle = areaStyle;
            this.firePropertyChange(/* name */"AREA_STYLE", oldAreaStyle, areaStyle);
        }
    }

    /**
     * Returns the angle in radians used to display the room area.
     * @return {number}
     */
    public getAreaAngle(): number {
        return this.areaAngle;
    }

    /**
     * Sets the angle in radians used to display the room area. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {number} areaAngle
     */
    public setAreaAngle(areaAngle: number) {
        areaAngle = <number>((areaAngle % Room.TWICE_PI_$LI$() + Room.TWICE_PI_$LI$()) % Room.TWICE_PI_$LI$());
        if (areaAngle !== this.areaAngle) {
            const oldAreaAngle: number = this.areaAngle;
            this.areaAngle = areaAngle;
            this.firePropertyChange(/* name */"AREA_ANGLE", oldAreaAngle, areaAngle);
        }
    }

    /**
     * Returns the abscissa of the center point of this room.
     * @return {number}
     */
    public getXCenter(): number {
        let xMin: number = this.points[0][0];
        let xMax: number = this.points[0][0];
        for (let i: number = 1; i < this.points.length; i++) {
            {
                xMin = Math.min(xMin, this.points[i][0]);
                xMax = Math.max(xMax, this.points[i][0]);
            };
        }
        return (xMin + xMax) / 2;
    }

    /**
     * Returns the ordinate of the center point of this room.
     * @return {number}
     */
    public getYCenter(): number {
        let yMin: number = this.points[0][1];
        let yMax: number = this.points[0][1];
        for (let i: number = 1; i < this.points.length; i++) {
            {
                yMin = Math.min(yMin, this.points[i][1]);
                yMax = Math.max(yMax, this.points[i][1]);
            };
        }
        return (yMin + yMax) / 2;
    }

    /**
     * Returns the floor color of this room.
     * @return {number}
     */
    public getFloorColor(): number {
        return this.floorColor;
    }

    /**
     * Sets the floor color of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {number} floorColor
     */
    public setFloorColor(floorColor: number) {
        if (floorColor !== this.floorColor && (floorColor == null || !(floorColor === this.floorColor))) {
            const oldFloorColor: number = this.floorColor;
            this.floorColor = floorColor;
            this.firePropertyChange(/* name */"FLOOR_COLOR", oldFloorColor, floorColor);
        }
    }

    /**
     * Returns the floor texture of this room.
     * @return {HomeTexture}
     */
    public getFloorTexture(): HomeTexture {
        return this.floorTexture;
    }

    /**
     * Sets the floor texture of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {HomeTexture} floorTexture
     */
    public setFloorTexture(floorTexture: HomeTexture) {
        if (floorTexture !== this.floorTexture && (floorTexture == null || !floorTexture.equals(this.floorTexture))) {
            const oldFloorTexture: HomeTexture = this.floorTexture;
            this.floorTexture = floorTexture;
            this.firePropertyChange(/* name */"FLOOR_TEXTURE", oldFloorTexture, floorTexture);
        }
    }

    /**
     * Returns whether the floor of this room is visible or not.
     * @return {boolean}
     */
    public isFloorVisible(): boolean {
        return this.floorVisible;
    }

    /**
     * Sets whether the floor of this room is visible or not. Once this room
     * is updated, listeners added to this room will receive a change notification.
     * @param {boolean} floorVisible
     */
    public setFloorVisible(floorVisible: boolean) {
        if (floorVisible !== this.floorVisible) {
            this.floorVisible = floorVisible;
            this.firePropertyChange(/* name */"FLOOR_VISIBLE", !floorVisible, floorVisible);
        }
    }

    /**
     * Returns the floor shininess of this room.
     * @return {number} a value between 0 (matt) and 1 (very shiny)
     */
    public getFloorShininess(): number {
        return this.floorShininess;
    }

    /**
     * Sets the floor shininess of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {number} floorShininess
     */
    public setFloorShininess(floorShininess: number) {
        if (floorShininess !== this.floorShininess) {
            const oldFloorShininess: number = this.floorShininess;
            this.floorShininess = floorShininess;
            this.firePropertyChange(/* name */"FLOOR_SHININESS", oldFloorShininess, floorShininess);
        }
    }

    /**
     * Returns the ceiling color color of this room.
     * @return {number}
     */
    public getCeilingColor(): number {
        return this.ceilingColor;
    }

    /**
     * Sets the ceiling color of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {number} ceilingColor
     */
    public setCeilingColor(ceilingColor: number) {
        if (ceilingColor !== this.ceilingColor && (ceilingColor == null || !(ceilingColor === this.ceilingColor))) {
            const oldCeilingColor: number = this.ceilingColor;
            this.ceilingColor = ceilingColor;
            this.firePropertyChange(/* name */"CEILING_COLOR", oldCeilingColor, ceilingColor);
        }
    }

    /**
     * Returns the ceiling texture of this room.
     * @return {HomeTexture}
     */
    public getCeilingTexture(): HomeTexture {
        return this.ceilingTexture;
    }

    /**
     * Sets the ceiling texture of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {HomeTexture} ceilingTexture
     */
    public setCeilingTexture(ceilingTexture: HomeTexture) {
        if (ceilingTexture !== this.ceilingTexture && (ceilingTexture == null || !ceilingTexture.equals(this.ceilingTexture))) {
            const oldCeilingTexture: HomeTexture = this.ceilingTexture;
            this.ceilingTexture = ceilingTexture;
            this.firePropertyChange(/* name */"CEILING_TEXTURE", oldCeilingTexture, ceilingTexture);
        }
    }

    /**
     * Returns whether the ceiling of this room is visible or not.
     * @return {boolean}
     */
    public isCeilingVisible(): boolean {
        return this.ceilingVisible;
    }

    /**
     * Sets whether the ceiling of this room is visible or not. Once this room
     * is updated, listeners added to this room will receive a change notification.
     * @param {boolean} ceilingVisible
     */
    public setCeilingVisible(ceilingVisible: boolean) {
        if (ceilingVisible !== this.ceilingVisible) {
            this.ceilingVisible = ceilingVisible;
            this.firePropertyChange(/* name */"CEILING_VISIBLE", !ceilingVisible, ceilingVisible);
        }
    }

    /**
     * Returns the ceiling shininess of this room.
     * @return {number} a value between 0 (matt) and 1 (very shiny)
     */
    public getCeilingShininess(): number {
        return this.ceilingShininess;
    }

    /**
     * Sets the ceiling shininess of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {number} ceilingShininess
     */
    public setCeilingShininess(ceilingShininess: number) {
        if (ceilingShininess !== this.ceilingShininess) {
            const oldCeilingShininess: number = this.ceilingShininess;
            this.ceilingShininess = ceilingShininess;
            this.firePropertyChange(/* name */"CEILING_SHININESS", oldCeilingShininess, ceilingShininess);
        }
    }

    /**
     * Returns <code>true</code> if the ceiling should remain flat whatever its environment.
     * @return {boolean}
     */
    public isCeilingFlat(): boolean {
        return this.ceilingFlat;
    }

    /**
     * Sets whether the floor texture should remain flat. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {boolean} ceilingFlat
     */
    public setCeilingFlat(ceilingFlat: boolean) {
        if (ceilingFlat !== this.ceilingFlat) {
            this.ceilingFlat = ceilingFlat;
            this.firePropertyChange(/* name */"CEILING_FLAT", !ceilingFlat, ceilingFlat);
        }
    }

    /**
     * Returns the level which this room belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this room. Once this room is updated,
     * listeners added to this room will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this room is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        return this.level === level || this.level != null && level != null && this.level.getElevation() === level.getElevation() && this.level.getElevationIndex() < level.getElevationIndex();
    }

    /**
     * Returns the area of this room.
     * @return {number}
     */
    public getArea(): number {
        if (this.areaCache == null) {
            const roomArea: java.awt.geom.Area = new java.awt.geom.Area(this.getShape());
            if (roomArea.isSingular()) {
                this.areaCache = Math.abs(this.getSignedArea(this.getPoints()));
            } else {
                let area: number = 0;
                const currentPathPoints: Array<number[]> = <any>([]);
                for (const it: java.awt.geom.PathIterator = roomArea.getPathIterator(null); !it.isDone();) {
                    {
                        const roomPoint: number[] = [0, 0];
                        switch ((it.currentSegment(roomPoint))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                        /* add */(currentPathPoints.push(roomPoint) > 0);
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                        /* add */(currentPathPoints.push(roomPoint) > 0);
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                const pathPoints: number[][] = /* toArray */currentPathPoints.slice(0);
                                area += this.getSignedArea(pathPoints);
                        /* clear */(currentPathPoints.length = 0);
                                break;
                        }
                        it.next();
                    };
                }
                this.areaCache = area;
            }
        }
        return this.areaCache;
    }

    getSignedArea(areaPoints: number[][]): number {
        let area: number = 0;
        for (let i: number = 1; i < areaPoints.length; i++) {
            {
                area += <number>areaPoints[i][0] * areaPoints[i - 1][1];
                area -= <number>areaPoints[i][1] * areaPoints[i - 1][0];
            };
        }
        area += <number>areaPoints[0][0] * areaPoints[areaPoints.length - 1][1];
        area -= <number>areaPoints[0][1] * areaPoints[areaPoints.length - 1][0];
        return <number>area / 2;
    }

    /**
     * Returns <code>true</code> if the points of this room are in clockwise order.
     * @return {boolean}
     */
    public isClockwise(): boolean {
        return this.getSignedArea(this.getPoints()) < 0;
    }

    /**
     * Returns <code>true</code> if this room is comprised of only one polygon.
     * @return {boolean}
     */
    public isSingular(): boolean {
        return new java.awt.geom.Area(this.getShape()).isSingular();
    }

    /**
     * Returns <code>true</code> if this room intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape().intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if this room contains
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        return this.containsShapeAtWithMargin(this.getShape(), x, y, margin);
    }

    /**
     * Returns the index of the point of this room equal to
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @return {number} the index of the first found point or -1.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     */
    public getPointIndexAt(x: number, y: number, margin: number): number {
        for (let i: number = 0; i < this.points.length; i++) {
            {
                if (Math.abs(x - this.points[i][0]) <= margin && Math.abs(y - this.points[i][1]) <= margin) {
                    return i;
                }
            };
        }
        return -1;
    }

    /**
     * Returns <code>true</code> if the center point at which is displayed the name
     * of this room is equal to the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isNameCenterPointAt(x: number, y: number, margin: number): boolean {
        return Math.abs(x - this.getXCenter() - this.getNameXOffset()) <= margin && Math.abs(y - this.getYCenter() - this.getNameYOffset()) <= margin;
    }

    /**
     * Returns <code>true</code> if the center point at which is displayed the area
     * of this room is equal to the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public isAreaCenterPointAt(x: number, y: number, margin: number): boolean {
        return Math.abs(x - this.getXCenter() - this.getAreaXOffset()) <= margin && Math.abs(y - this.getYCenter() - this.getAreaYOffset()) <= margin;
    }

    /**
     * Returns <code>true</code> if <code>shape</code> contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {Object} shape
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     * @private
     */
    containsShapeAtWithMargin(shape: java.awt.Shape, x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return shape.contains(x, y);
        } else {
            return shape.intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns the shape matching this room.
     * @return {Object}
     * @private
     */
    getShape(): java.awt.Shape {
        if (this.shapeCache == null) {
            const roomShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            roomShape.moveTo(this.points[0][0], this.points[0][1]);
            for (let i: number = 1; i < this.points.length; i++) {
                {
                    roomShape.lineTo(this.points[i][0], this.points[i][1]);
                };
            }
            roomShape.closePath();
            this.shapeCache = roomShape;
        }
        return this.shapeCache;
    }

    /**
     * Moves this room of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        if (dx !== 0 || dy !== 0) {
            const points: number[][] = this.getPoints();
            for (let i: number = 0; i < points.length; i++) {
                {
                    points[i][0] += dx;
                    points[i][1] += dy;
                };
            }
            this.updatePoints(points);
        }
    }

    /**
     * Returns a clone of this room.
     * @return {Room}
     */
    public clone(): Room {
        const clone: Room = <Room>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.level = null;
        return clone;
    }
}
Room["__class"] = "com.eteks.sweethome3d.model.Room";
Room["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.Elevatable"];

Room['__transients'] = ['shapeCache', 'boundsCache', 'areaCache', 'propertyChangeSupport'];

/**
 * Creates a polyline from the given coordinates.
 * @param {string} id
 * @param {float[][]} points
 * @param {number} thickness
 * @param {Polyline.CapStyle} capStyle
 * @param {Polyline.JoinStyle} joinStyle
 * @param {Polyline.DashStyle} dashStyle
 * @param {number} dashOffset
 * @param {Polyline.ArrowStyle} startArrowStyle
 * @param {Polyline.ArrowStyle} endArrowStyle
 * @param {boolean} closedPath
 * @param {number} color
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Polyline extends HomeObject implements Selectable, Elevatable {
    /*private*/ points: number[][];

    /*private*/ thickness: number;

    /*private*/ capStyle: Polyline.CapStyle;

    /*private*/ capStyleName: string;

    /*private*/ joinStyle: Polyline.JoinStyle;

    /*private*/ joinStyleName: string;

    /*private*/ dashStyle: Polyline.DashStyle;

    /*private*/ dashStyleName: string;

    /*private*/ dashPattern: number[];

    /*private*/ dashOffset: number;

    /*private*/ startArrowStyle: Polyline.ArrowStyle;

    /*private*/ startArrowStyleName: string;

    /*private*/ endArrowStyle: Polyline.ArrowStyle;

    /*private*/ endArrowStyleName: string;

    /*private*/ closedPath: boolean;

    /*private*/ color: number;

    /*private*/ elevation: number;

    /*private*/ level: Level;

    /*private*/ polylinePathCache: java.awt.Shape;

    /*private*/ shapeCache: java.awt.Shape;

    public constructor(id?: any, points?: any, thickness?: any, capStyle?: any, joinStyle?: any, dashStyle?: any, dashOffset?: any, startArrowStyle?: any, endArrowStyle?: any, closedPath?: any, color?: any) {
        if (((typeof id === 'string') || id === null) && ((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null || points[0] instanceof Array)) || points === null) && ((typeof thickness === 'number') || thickness === null) && ((typeof capStyle === 'number') || capStyle === null) && ((typeof joinStyle === 'number') || joinStyle === null) && ((typeof dashStyle === 'number') || dashStyle === null) && ((typeof dashOffset === 'number') || dashOffset === null) && ((typeof startArrowStyle === 'number') || startArrowStyle === null) && ((typeof endArrowStyle === 'number') || endArrowStyle === null) && ((typeof closedPath === 'boolean') || closedPath === null) && ((typeof color === 'number') || color === null)) {
            let __args = arguments;
            super(id);
            if (this.points === undefined) { this.points = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.capStyleName === undefined) { this.capStyleName = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.joinStyleName === undefined) { this.joinStyleName = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashStyleName === undefined) { this.dashStyleName = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = 0; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
            if (this.closedPath === undefined) { this.closedPath = false; }
            if (this.color === undefined) { this.color = 0; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            this.points = this.deepCopy(points);
            this.thickness = thickness;
            this.capStyle = capStyle;
            this.joinStyle = joinStyle;
            this.dashStyle = dashStyle;
            this.dashOffset = dashOffset;
            this.startArrowStyle = startArrowStyle;
            this.endArrowStyle = endArrowStyle;
            this.closedPath = closedPath;
            this.color = color;
        } else if (((id != null && id instanceof <any>Array && (id.length == 0 || id[0] == null || id[0] instanceof Array)) || id === null) && ((typeof points === 'number') || points === null) && ((typeof thickness === 'number') || thickness === null) && ((typeof capStyle === 'number') || capStyle === null) && ((typeof joinStyle === 'number') || joinStyle === null) && ((typeof dashStyle === 'number') || dashStyle === null) && ((typeof dashOffset === 'number') || dashOffset === null) && ((typeof startArrowStyle === 'number') || startArrowStyle === null) && ((typeof endArrowStyle === 'boolean') || endArrowStyle === null) && ((typeof closedPath === 'number') || closedPath === null) && color === undefined) {
            let __args = arguments;
            let points: any = __args[0];
            let thickness: any = __args[1];
            let capStyle: any = __args[2];
            let joinStyle: any = __args[3];
            let dashStyle: any = __args[4];
            let dashOffset: any = __args[5];
            let startArrowStyle: any = __args[6];
            let endArrowStyle: any = __args[7];
            let closedPath: any = __args[8];
            let color: any = __args[9];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("polyline");
                super(id);
                if (this.points === undefined) { this.points = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.capStyle === undefined) { this.capStyle = null; }
                if (this.capStyleName === undefined) { this.capStyleName = null; }
                if (this.joinStyle === undefined) { this.joinStyle = null; }
                if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                if (this.dashStyle === undefined) { this.dashStyle = null; }
                if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                if (this.dashPattern === undefined) { this.dashPattern = null; }
                if (this.dashOffset === undefined) { this.dashOffset = 0; }
                if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                if (this.closedPath === undefined) { this.closedPath = false; }
                if (this.color === undefined) { this.color = 0; }
                if (this.elevation === undefined) { this.elevation = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.points = this.deepCopy(points);
                this.thickness = thickness;
                this.capStyle = capStyle;
                this.joinStyle = joinStyle;
                this.dashStyle = dashStyle;
                this.dashOffset = dashOffset;
                this.startArrowStyle = startArrowStyle;
                this.endArrowStyle = endArrowStyle;
                this.closedPath = closedPath;
                this.color = color;
            }
            if (this.points === undefined) { this.points = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.capStyleName === undefined) { this.capStyleName = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.joinStyleName === undefined) { this.joinStyleName = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashStyleName === undefined) { this.dashStyleName = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = 0; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
            if (this.closedPath === undefined) { this.closedPath = false; }
            if (this.color === undefined) { this.color = 0; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((id != null && id instanceof <any>Array && (id.length == 0 || id[0] == null || id[0] instanceof Array)) || id === null) && ((typeof points === 'number') || points === null) && ((typeof thickness === 'number') || thickness === null) && ((typeof capStyle === 'number') || capStyle === null) && ((typeof joinStyle === 'number') || joinStyle === null) && ((typeof dashStyle === 'number') || dashStyle === null) && ((typeof dashOffset === 'number') || dashOffset === null) && ((typeof startArrowStyle === 'boolean') || startArrowStyle === null) && ((typeof endArrowStyle === 'number') || endArrowStyle === null) && closedPath === undefined && color === undefined) {
            let __args = arguments;
            let points: any = __args[0];
            let thickness: any = __args[1];
            let capStyle: any = __args[2];
            let joinStyle: any = __args[3];
            let dashStyle: any = __args[4];
            let startArrowStyle: any = __args[5];
            let endArrowStyle: any = __args[6];
            let closedPath: any = __args[7];
            let color: any = __args[8];
            {
                let __args = arguments;
                let dashOffset: any = 0.0;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("polyline");
                    super(id);
                    if (this.points === undefined) { this.points = null; }
                    if (this.thickness === undefined) { this.thickness = 0; }
                    if (this.capStyle === undefined) { this.capStyle = null; }
                    if (this.capStyleName === undefined) { this.capStyleName = null; }
                    if (this.joinStyle === undefined) { this.joinStyle = null; }
                    if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                    if (this.dashStyle === undefined) { this.dashStyle = null; }
                    if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                    if (this.dashPattern === undefined) { this.dashPattern = null; }
                    if (this.dashOffset === undefined) { this.dashOffset = 0; }
                    if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                    if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                    if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                    if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                    if (this.closedPath === undefined) { this.closedPath = false; }
                    if (this.color === undefined) { this.color = 0; }
                    if (this.elevation === undefined) { this.elevation = null; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                    this.points = this.deepCopy(points);
                    this.thickness = thickness;
                    this.capStyle = capStyle;
                    this.joinStyle = joinStyle;
                    this.dashStyle = dashStyle;
                    this.dashOffset = dashOffset;
                    this.startArrowStyle = startArrowStyle;
                    this.endArrowStyle = endArrowStyle;
                    this.closedPath = closedPath;
                    this.color = color;
                }
                if (this.points === undefined) { this.points = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.capStyle === undefined) { this.capStyle = null; }
                if (this.capStyleName === undefined) { this.capStyleName = null; }
                if (this.joinStyle === undefined) { this.joinStyle = null; }
                if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                if (this.dashStyle === undefined) { this.dashStyle = null; }
                if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                if (this.dashPattern === undefined) { this.dashPattern = null; }
                if (this.dashOffset === undefined) { this.dashOffset = 0; }
                if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                if (this.closedPath === undefined) { this.closedPath = false; }
                if (this.color === undefined) { this.color = 0; }
                if (this.elevation === undefined) { this.elevation = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
            }
            if (this.points === undefined) { this.points = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.capStyleName === undefined) { this.capStyleName = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.joinStyleName === undefined) { this.joinStyleName = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashStyleName === undefined) { this.dashStyleName = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = 0; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
            if (this.closedPath === undefined) { this.closedPath = false; }
            if (this.color === undefined) { this.color = 0; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((typeof id === 'string') || id === null) && ((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null || points[0] instanceof Array)) || points === null) && thickness === undefined && capStyle === undefined && joinStyle === undefined && dashStyle === undefined && dashOffset === undefined && startArrowStyle === undefined && endArrowStyle === undefined && closedPath === undefined && color === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let thickness: any = 1;
                let capStyle: any = Polyline.CapStyle.BUTT;
                let joinStyle: any = Polyline.JoinStyle.MITER;
                let dashStyle: any = Polyline.DashStyle.SOLID;
                let dashOffset: any = 0.0;
                let startArrowStyle: any = Polyline.ArrowStyle.NONE;
                let endArrowStyle: any = Polyline.ArrowStyle.NONE;
                let closedPath: any = false;
                let color: any = -16777216;
                super(id);
                if (this.points === undefined) { this.points = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.capStyle === undefined) { this.capStyle = null; }
                if (this.capStyleName === undefined) { this.capStyleName = null; }
                if (this.joinStyle === undefined) { this.joinStyle = null; }
                if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                if (this.dashStyle === undefined) { this.dashStyle = null; }
                if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                if (this.dashPattern === undefined) { this.dashPattern = null; }
                if (this.dashOffset === undefined) { this.dashOffset = 0; }
                if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                if (this.closedPath === undefined) { this.closedPath = false; }
                if (this.color === undefined) { this.color = 0; }
                if (this.elevation === undefined) { this.elevation = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                this.points = this.deepCopy(points);
                this.thickness = thickness;
                this.capStyle = capStyle;
                this.joinStyle = joinStyle;
                this.dashStyle = dashStyle;
                this.dashOffset = dashOffset;
                this.startArrowStyle = startArrowStyle;
                this.endArrowStyle = endArrowStyle;
                this.closedPath = closedPath;
                this.color = color;
            }
            if (this.points === undefined) { this.points = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.capStyleName === undefined) { this.capStyleName = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.joinStyleName === undefined) { this.joinStyleName = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashStyleName === undefined) { this.dashStyleName = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = 0; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
            if (this.closedPath === undefined) { this.closedPath = false; }
            if (this.color === undefined) { this.color = 0; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else if (((id != null && id instanceof <any>Array && (id.length == 0 || id[0] == null || id[0] instanceof Array)) || id === null) && points === undefined && thickness === undefined && capStyle === undefined && joinStyle === undefined && dashStyle === undefined && dashOffset === undefined && startArrowStyle === undefined && endArrowStyle === undefined && closedPath === undefined && color === undefined) {
            let __args = arguments;
            let points: any = __args[0];
            {
                let __args = arguments;
                let thickness: any = 1;
                let capStyle: any = Polyline.CapStyle.BUTT;
                let joinStyle: any = Polyline.JoinStyle.MITER;
                let dashStyle: any = Polyline.DashStyle.SOLID;
                let startArrowStyle: any = Polyline.ArrowStyle.NONE;
                let endArrowStyle: any = Polyline.ArrowStyle.NONE;
                let closedPath: any = false;
                let color: any = -16777216;
                {
                    let __args = arguments;
                    let dashOffset: any = 0.0;
                    {
                        let __args = arguments;
                        let id: any = HomeObject.createId("polyline");
                        super(id);
                        if (this.points === undefined) { this.points = null; }
                        if (this.thickness === undefined) { this.thickness = 0; }
                        if (this.capStyle === undefined) { this.capStyle = null; }
                        if (this.capStyleName === undefined) { this.capStyleName = null; }
                        if (this.joinStyle === undefined) { this.joinStyle = null; }
                        if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                        if (this.dashStyle === undefined) { this.dashStyle = null; }
                        if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                        if (this.dashPattern === undefined) { this.dashPattern = null; }
                        if (this.dashOffset === undefined) { this.dashOffset = 0; }
                        if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                        if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                        if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                        if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                        if (this.closedPath === undefined) { this.closedPath = false; }
                        if (this.color === undefined) { this.color = 0; }
                        if (this.elevation === undefined) { this.elevation = null; }
                        if (this.level === undefined) { this.level = null; }
                        if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                        if (this.shapeCache === undefined) { this.shapeCache = null; }
                        this.points = this.deepCopy(points);
                        this.thickness = thickness;
                        this.capStyle = capStyle;
                        this.joinStyle = joinStyle;
                        this.dashStyle = dashStyle;
                        this.dashOffset = dashOffset;
                        this.startArrowStyle = startArrowStyle;
                        this.endArrowStyle = endArrowStyle;
                        this.closedPath = closedPath;
                        this.color = color;
                    }
                    if (this.points === undefined) { this.points = null; }
                    if (this.thickness === undefined) { this.thickness = 0; }
                    if (this.capStyle === undefined) { this.capStyle = null; }
                    if (this.capStyleName === undefined) { this.capStyleName = null; }
                    if (this.joinStyle === undefined) { this.joinStyle = null; }
                    if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                    if (this.dashStyle === undefined) { this.dashStyle = null; }
                    if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                    if (this.dashPattern === undefined) { this.dashPattern = null; }
                    if (this.dashOffset === undefined) { this.dashOffset = 0; }
                    if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                    if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                    if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                    if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                    if (this.closedPath === undefined) { this.closedPath = false; }
                    if (this.color === undefined) { this.color = 0; }
                    if (this.elevation === undefined) { this.elevation = null; }
                    if (this.level === undefined) { this.level = null; }
                    if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                    if (this.shapeCache === undefined) { this.shapeCache = null; }
                }
                if (this.points === undefined) { this.points = null; }
                if (this.thickness === undefined) { this.thickness = 0; }
                if (this.capStyle === undefined) { this.capStyle = null; }
                if (this.capStyleName === undefined) { this.capStyleName = null; }
                if (this.joinStyle === undefined) { this.joinStyle = null; }
                if (this.joinStyleName === undefined) { this.joinStyleName = null; }
                if (this.dashStyle === undefined) { this.dashStyle = null; }
                if (this.dashStyleName === undefined) { this.dashStyleName = null; }
                if (this.dashPattern === undefined) { this.dashPattern = null; }
                if (this.dashOffset === undefined) { this.dashOffset = 0; }
                if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
                if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
                if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
                if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
                if (this.closedPath === undefined) { this.closedPath = false; }
                if (this.color === undefined) { this.color = 0; }
                if (this.elevation === undefined) { this.elevation = null; }
                if (this.level === undefined) { this.level = null; }
                if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
            }
            if (this.points === undefined) { this.points = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.capStyleName === undefined) { this.capStyleName = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.joinStyleName === undefined) { this.joinStyleName = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashStyleName === undefined) { this.dashStyleName = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = 0; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.startArrowStyleName === undefined) { this.startArrowStyleName = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.endArrowStyleName === undefined) { this.endArrowStyleName = null; }
            if (this.closedPath === undefined) { this.closedPath = false; }
            if (this.color === undefined) { this.color = 0; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.polylinePathCache === undefined) { this.polylinePathCache = null; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the points of the polygon matching this polyline.
     * @return {float[][]} an array of the (x,y) coordinates of the polyline points.
     */
    public getPoints(): number[][] {
        return this.deepCopy(this.points);
    }

    /**
     * Returns the number of points of the polygon matching this polyline.
     * @return {number}
     */
    public getPointCount(): number {
        return this.points.length;
    }

    deepCopy(points: number[][]): number[][] {
        const pointsCopy: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(points.length);
        for (let i: number = 0; i < points.length; i++) {
            {
                pointsCopy[i] = /* clone */points[i].slice(0);
            };
        }
        return pointsCopy;
    }

    /**
     * Sets the points of the polygon matching this polyline. Once this polyline
     * is updated, listeners added to this polyline will receive a change notification.
     * @param {float[][]} points
     */
    public setPoints(points: number[][]) {
        if (!/* deepEquals */(JSON.stringify(this.points) === JSON.stringify(points))) {
            this.updatePoints(points);
        }
    }

    /**
     * Update the points of the polygon matching this polyline.
     * @param {float[][]} points
     * @private
     */
    updatePoints(points: number[][]) {
        const oldPoints: number[][] = this.points;
        this.points = this.deepCopy(points);
        this.polylinePathCache = null;
        this.shapeCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, points);
    }

    public addPoint$float$float(x: number, y: number) {
        this.addPoint$float$float$int(x, y, this.points.length);
    }

    public addPoint$float$float$int(x: number, y: number, index: number) {
        if (index < 0 || index > this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        }
        const newPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(this.points.length + 1);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, 0, newPoints, 0, index);
        newPoints[index] = [x, y];
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, index, newPoints, index + 1, this.points.length - index);
        const oldPoints: number[][] = this.points;
        this.points = newPoints;
        this.polylinePathCache = null;
        this.shapeCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
    }

    /**
     * Adds a point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or > <code>getPointCount()</code>
     * @param {number} x
     * @param {number} y
     * @param {number} index
     */
    public addPoint(x?: any, y?: any, index?: any) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof index === 'number') || index === null)) {
            return <any>this.addPoint$float$float$int(x, y, index);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && index === undefined) {
            return <any>this.addPoint$float$float(x, y);
        } else throw new Error('invalid overload');
    }

    /**
     * Sets the point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or >= <code>getPointCount()</code>
     * @param {number} x
     * @param {number} y
     * @param {number} index
     */
    public setPoint(x: number, y: number, index: number) {
        if (index < 0 || index >= this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        }
        if (this.points[index][0] !== x || this.points[index][1] !== y) {
            const oldPoints: number[][] = this.points;
            this.points = this.deepCopy(this.points);
            this.points[index][0] = x;
            this.points[index][1] = y;
            this.polylinePathCache = null;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
        }
    }

    /**
     * Removes the point at the given <code>index</code>.
     * @throws IndexOutOfBoundsException if <code>index</code> is negative or >= <code>getPointCount()</code>
     * @param {number} index
     */
    public removePoint(index: number) {
        if (index < 0 || index >= this.points.length) {
            throw Object.defineProperty(new Error("Invalid index " + index), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
        }
        const newPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(this.points.length - 1);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, 0, newPoints, 0, index);
        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(this.points, index + 1, newPoints, index, this.points.length - index - 1);
        const oldPoints: number[][] = this.points;
        this.points = newPoints;
        this.polylinePathCache = null;
        this.shapeCache = null;
        this.firePropertyChange(/* name */"POINTS", oldPoints, this.deepCopy(this.points));
    }

    /**
     * Returns the thickness of this polyline.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Sets the thickness of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {number} thickness
     */
    public setThickness(thickness: number) {
        if (thickness !== this.thickness) {
            const oldThickness: number = this.thickness;
            this.thickness = thickness;
            this.firePropertyChange(/* name */"THICKNESS", oldThickness, thickness);
        }
    }

    /**
     * Returns the cap style of this polyline.
     * @return {Polyline.CapStyle}
     */
    public getCapStyle(): Polyline.CapStyle {
        return this.capStyle;
    }

    /**
     * Sets the cap style of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {Polyline.CapStyle} capStyle
     */
    public setCapStyle(capStyle: Polyline.CapStyle) {
        if (capStyle !== this.capStyle) {
            const oldStyle: Polyline.CapStyle = this.capStyle;
            this.capStyle = capStyle;
            this.capStyleName = /* Enum.name */Polyline.CapStyle[this.capStyle];
            this.firePropertyChange(/* name */"CAP_STYLE", oldStyle, capStyle);
        }
    }

    /**
     * Returns the join style of this polyline.
     * @return {Polyline.JoinStyle}
     */
    public getJoinStyle(): Polyline.JoinStyle {
        return this.joinStyle;
    }

    /**
     * Sets the join style of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {Polyline.JoinStyle} joinStyle
     */
    public setJoinStyle(joinStyle: Polyline.JoinStyle) {
        if (joinStyle !== this.joinStyle) {
            const oldJoinStyle: Polyline.JoinStyle = this.joinStyle;
            this.joinStyle = joinStyle;
            this.joinStyleName = /* Enum.name */Polyline.JoinStyle[this.joinStyle];
            this.polylinePathCache = null;
            this.shapeCache = null;
            this.firePropertyChange(/* name */"JOIN_STYLE", oldJoinStyle, joinStyle);
        }
    }

    /**
     * Returns the dash style of this polyline. If <code>DashStyle.CUSTOMIZED</code> is returned,
     * the actual dash pattern will be returned by {@link #getDashPattern()}.
     * @return {Polyline.DashStyle}
     */
    public getDashStyle(): Polyline.DashStyle {
        return this.dashStyle;
    }

    /**
     * Sets the dash style of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {Polyline.DashStyle} dashStyle
     */
    public setDashStyle(dashStyle: Polyline.DashStyle) {
        if (dashStyle !== this.dashStyle) {
            const oldDashPattern: number[] = this.getDashPattern();
            const oldDashStyle: Polyline.DashStyle = this.dashStyle;
            this.dashStyle = dashStyle;
            this.dashStyleName = /* Enum.name */Polyline.DashStyle[this.dashStyle];
            if (dashStyle !== Polyline.DashStyle.CUSTOMIZED) {
                this.dashPattern = null;
            }
            this.firePropertyChange(/* name */"DASH_PATTERN", oldDashPattern, this.getDashPattern());
            this.firePropertyChange(/* name */"DASH_STYLE", oldDashStyle, dashStyle);
        }
    }

    /**
     * Returns the dash pattern of this polyline in percentage of its thickness.
     * @return {float[]}
     */
    public getDashPattern(): number[] {
        let dashPattern: number[] = null;
        if (this.dashStyle !== Polyline.DashStyle.CUSTOMIZED) {
            return Polyline.DashStyle["_$wrappers"][this.dashStyle].getDashPattern();
        } else if (this.dashPattern != null) {
            dashPattern = /* clone */this.dashPattern.slice(0);
        }
        return dashPattern;
    }

    /**
     * Sets the dash pattern of this polyline in percentage of its thickness.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {float[]} dashPattern
     */
    public setDashPattern(dashPattern: number[]) {
        {
            let array = /* Enum.values */function () { let result: Polyline.DashStyle[] = []; for (let val in Polyline.DashStyle) { if (!isNaN(<any>val)) { result.push(parseInt(val, 10)); } } return result; }();
            for (let index = 0; index < array.length; index++) {
                let dashStyle = array[index];
                {
                    if (this.dashStyle !== Polyline.DashStyle.CUSTOMIZED) {
                        if (/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(dashPattern, Polyline.DashStyle["_$wrappers"][dashStyle].getDashPattern())) {
                            this.setDashStyle(dashStyle);
                            return;
                        }
                    }
                }
            }
        }
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(dashPattern, this.dashPattern)) {
            const oldDashPattern: number[] = this.getDashPattern();
            this.dashPattern = /* clone */dashPattern.slice(0);
            this.firePropertyChange(/* name */"DASH_PATTERN", oldDashPattern, dashPattern);
            const oldDashStyle: Polyline.DashStyle = this.dashStyle;
            this.dashStyle = Polyline.DashStyle.CUSTOMIZED;
            this.dashStyleName = /* Enum.name */Polyline.DashStyle[this.dashStyle];
            this.firePropertyChange(/* name */"DASH_STYLE", oldDashStyle, Polyline.DashStyle.CUSTOMIZED);
        }
    }

    /**
     * Returns the offset from which the dash of this polyline should start.
     * @return {number} the offset in percentage of the dash pattern
     */
    public getDashOffset(): number {
        return this.dashOffset;
    }

    /**
     * Sets the offset from which the dash of this polyline should start.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {number} dashOffset the offset in percentage of the dash pattern
     */
    public setDashOffset(dashOffset: number) {
        if (dashOffset !== this.dashOffset) {
            const oldDashOffset: number = this.dashOffset;
            this.dashOffset = dashOffset;
            this.firePropertyChange(/* name */"DASH_OFFSET", oldDashOffset, dashOffset);
        }
    }

    /**
     * Returns the arrow style at the start of this polyline.
     * @return {Polyline.ArrowStyle}
     */
    public getStartArrowStyle(): Polyline.ArrowStyle {
        return this.startArrowStyle;
    }

    /**
     * Sets the arrow style at the start of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {Polyline.ArrowStyle} startArrowStyle
     */
    public setStartArrowStyle(startArrowStyle: Polyline.ArrowStyle) {
        if (startArrowStyle !== this.startArrowStyle) {
            const oldStartArrowStyle: Polyline.ArrowStyle = this.startArrowStyle;
            this.startArrowStyle = startArrowStyle;
            this.startArrowStyleName = /* Enum.name */Polyline.ArrowStyle[this.startArrowStyle];
            this.firePropertyChange(/* name */"START_ARROW_STYLE", oldStartArrowStyle, startArrowStyle);
        }
    }

    /**
     * Returns the arrow style at the end of this polyline.
     * @return {Polyline.ArrowStyle}
     */
    public getEndArrowStyle(): Polyline.ArrowStyle {
        return this.endArrowStyle;
    }

    /**
     * Sets the arrow style at the end of this polyline.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {Polyline.ArrowStyle} endArrowStyle
     */
    public setEndArrowStyle(endArrowStyle: Polyline.ArrowStyle) {
        if (endArrowStyle !== this.endArrowStyle) {
            const oldEndArrowStyle: Polyline.ArrowStyle = this.endArrowStyle;
            this.endArrowStyle = endArrowStyle;
            this.endArrowStyleName = /* Enum.name */Polyline.ArrowStyle[this.endArrowStyle];
            this.firePropertyChange(/* name */"END_ARROW_STYLE", oldEndArrowStyle, endArrowStyle);
        }
    }

    /**
     * Returns <code>true</code> if the first and last points of this polyline should be joined to form a polygon.
     * @return {boolean}
     */
    public isClosedPath(): boolean {
        return this.closedPath;
    }

    /**
     * Sets whether the first and last points of this polyline should be joined.
     * Once this polyline is updated, listeners added to this polyline will receive a change notification.
     * @param {boolean} closedPath
     */
    public setClosedPath(closedPath: boolean) {
        if (closedPath !== this.closedPath) {
            this.closedPath = closedPath;
            this.firePropertyChange(/* name */"CLOSED_PATH", !closedPath, closedPath);
        }
    }

    /**
     * Returns the color of this polyline.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the color of this polyline. Once this polyline is updated,
     * listeners added to this polyline will receive a change notification.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the elevation of this polyline
     * from the ground according to the elevation of its level.
     * @return {number}
     */
    public getGroundElevation(): number {
        const elevation: number = this.getElevation();
        if (this.level != null) {
            return elevation + this.level.getElevation();
        } else {
            return elevation;
        }
    }

    /**
     * Returns the elevation of this polyline in 3D.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation != null ? this.elevation : 0;
    }

    /**
     * Sets the elevation of this polyline in 3D. Once this polyline is updated,
     * listeners added to this polyline will receive a change notification.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (this.elevation != null && elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns <code>true</code> if this polyline should be displayed in 3D.
     * @return {boolean}
     */
    public isVisibleIn3D(): boolean {
        return this.elevation != null;
    }

    /**
     * Sets whether this polyline should be displayed in 3D and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} visibleIn3D
     */
    public setVisibleIn3D(visibleIn3D: boolean) {
        if ((visibleIn3D) !== ((this.elevation != null))) {
            this.elevation = visibleIn3D ? 0 : null;
            this.firePropertyChange(/* name */"VISIBLE_IN_3D", !visibleIn3D, visibleIn3D);
        }
    }

    /**
     * Returns the level which this polyline belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this polyline. Once this polyline is updated,
     * listeners added to this polyline will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this polyline is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        return this.level === level || this.level != null && level != null && this.level.getElevation() === level.getElevation() && this.level.getElevationIndex() < level.getElevationIndex();
    }

    /**
     * Returns an approximate length of this polyline.
     * @return {number}
     */
    public getLength(): number {
        const firstPoint: number[] = [0, 0];
        const previousPoint: number[] = [0, 0];
        const point: number[] = [0, 0];
        let length: number = 0;
        for (const it: java.awt.geom.PathIterator = this.getPolylinePath().getPathIterator(null, 0.1); !it.isDone(); it.next()) {
            {
                switch ((it.currentSegment(point))) {
                    case java.awt.geom.PathIterator.SEG_CLOSE:
                        length += java.awt.geom.Point2D.distance(firstPoint[0], firstPoint[1], previousPoint[0], previousPoint[1]);
                        break;
                    case java.awt.geom.PathIterator.SEG_MOVETO:
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(point, 0, firstPoint, 0, 2);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(point, 0, previousPoint, 0, 2);
                        break;
                    case java.awt.geom.PathIterator.SEG_LINETO:
                        length += java.awt.geom.Point2D.distance(previousPoint[0], previousPoint[1], point[0], point[1]);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(point, 0, previousPoint, 0, 2);
                        break;
                }
            };
        }
        return length;
    }

    /**
     * Returns <code>true</code> if this polyline intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape().intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if this polyline contains
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        return this.containsShapeAtWithMargin(this.getShape(), x, y, margin);
    }

    /**
     * Returns the index of the point of this polyline equal to
     * the point at (<code>x</code>, <code>y</code>) with a given <code>margin</code>.
     * @return {number} the index of the first found point or -1.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     */
    public getPointIndexAt(x: number, y: number, margin: number): number {
        for (let i: number = 0; i < this.points.length; i++) {
            {
                if (Math.abs(x - this.points[i][0]) <= margin && Math.abs(y - this.points[i][1]) <= margin) {
                    return i;
                }
            };
        }
        return -1;
    }

    /**
     * Returns <code>true</code> if <code>shape</code> contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {Object} shape
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     * @private
     */
    containsShapeAtWithMargin(shape: java.awt.Shape, x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return shape.contains(x, y);
        } else {
            return shape.intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns the path matching this polyline.
     * @return {Object}
     * @private
     */
    getPolylinePath(): java.awt.Shape {
        if (this.polylinePathCache == null) {
            const polylinePath: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            if (this.joinStyle === Polyline.JoinStyle.CURVED) {
                for (let i: number = 0, n: number = this.closedPath ? this.points.length : this.points.length - 1; i < n; i++) {
                    {
                        const curve2D: java.awt.geom.CubicCurve2D.Float = new java.awt.geom.CubicCurve2D.Float();
                        const previousPoint: number[] = this.points[i === 0 ? this.points.length - 1 : i - 1];
                        const point: number[] = this.points[i];
                        const nextPoint: number[] = this.points[i === this.points.length - 1 ? 0 : i + 1];
                        const vectorToBisectorPoint: number[] = [nextPoint[0] - previousPoint[0], nextPoint[1] - previousPoint[1]];
                        const nextNextPoint: number[] = this.points[(i + 2) % this.points.length];
                        const vectorToBisectorNextPoint: number[] = [point[0] - nextNextPoint[0], point[1] - nextNextPoint[1]];
                        curve2D.setCurve(point[0], point[1], point[0] + (i !== 0 || this.closedPath ? vectorToBisectorPoint[0] / 3.625 : 0), point[1] + (i !== 0 || this.closedPath ? vectorToBisectorPoint[1] / 3.625 : 0), nextPoint[0] + (i !== this.points.length - 2 || this.closedPath ? vectorToBisectorNextPoint[0] / 3.625 : 0), nextPoint[1] + (i !== this.points.length - 2 || this.closedPath ? vectorToBisectorNextPoint[1] / 3.625 : 0), nextPoint[0], nextPoint[1]);
                        polylinePath.append(curve2D, true);
                    };
                }
            } else {
                polylinePath.moveTo(this.points[0][0], this.points[0][1]);
                for (let i: number = 1; i < this.points.length; i++) {
                    {
                        polylinePath.lineTo(this.points[i][0], this.points[i][1]);
                    };
                }
                if (this.closedPath) {
                    polylinePath.closePath();
                }
            }
            this.polylinePathCache = polylinePath;
        }
        return this.polylinePathCache;
    }

    /**
     * Returns the shape matching this polyline.
     * @return {Object}
     * @private
     */
    getShape(): java.awt.Shape {
        if (this.shapeCache == null) {
            this.shapeCache = new java['awt']['BasicStroke'](this.thickness).createStrokedShape(this.getPolylinePath());
        }
        return this.shapeCache;
    }

    /**
     * Moves this polyline of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        if (dx !== 0 || dy !== 0) {
            const points: number[][] = this.getPoints();
            for (let i: number = 0; i < points.length; i++) {
                {
                    points[i][0] += dx;
                    points[i][1] += dy;
                };
            }
            this.updatePoints(points);
        }
    }

    /**
     * Returns a clone of this polyline.
     * @return {Polyline}
     */
    public clone(): Polyline {
        const clone: Polyline = <Polyline>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.level = null;
        return clone;
    }
}
Polyline["__class"] = "com.eteks.sweethome3d.model.Polyline";
Polyline["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.Elevatable"];



export namespace Polyline {

    export enum CapStyle {
        BUTT, SQUARE, ROUND
    }

    export enum JoinStyle {
        BEVEL, MITER, ROUND, CURVED
    }

    export enum ArrowStyle {
        NONE, DELTA, OPEN, DISC
    }

    export enum DashStyle {
        SOLID, DOT, DASH, DASH_DOT, DASH_DOT_DOT, CUSTOMIZED
    }

    /** @ignore */
    export class DashStyle_$WRAPPER {
        constructor(protected _$ordinal: number, protected _$name: string) {
        }

        /**
         * Returns an array describing the length of dashes and spaces between them
         * for a 1 cm thick polyline.
         * @return {float[]}
         */
        public getDashPattern(): number[] {
            switch ((this._$ordinal)) {
                case Polyline.DashStyle.SOLID:
                    return [1.0, 0.0];
                case Polyline.DashStyle.DOT:
                    return [1.0, 1.0];
                case Polyline.DashStyle.DASH:
                    return [4.0, 2.0];
                case Polyline.DashStyle.DASH_DOT:
                    return [8.0, 2.0, 2.0, 2.0];
                case Polyline.DashStyle.DASH_DOT_DOT:
                    return [8.0, 2.0, 2.0, 2.0, 2.0, 2.0];
                default:
                    return null;
            }
        }
        public name(): string { return this._$name; }
        public ordinal(): number { return this._$ordinal; }
        public compareTo(other: any): number { return this._$ordinal - (isNaN(other) ? other._$ordinal : other); }
    }
    DashStyle["__class"] = "com.eteks.sweethome3d.model.Polyline.DashStyle";
    DashStyle["_$wrappers"] = { 0: new DashStyle_$WRAPPER(0, "SOLID"), 1: new DashStyle_$WRAPPER(1, "DOT"), 2: new DashStyle_$WRAPPER(2, "DASH"), 3: new DashStyle_$WRAPPER(3, "DASH_DOT"), 4: new DashStyle_$WRAPPER(4, "DASH_DOT_DOT"), 5: new DashStyle_$WRAPPER(5, "CUSTOMIZED") };

}
Polyline['__transients'] = ['capStyle', 'joinStyle', 'dashStyle', 'startArrowStyle', 'endArrowStyle', 'polylinePathCache', 'shapeCache', 'propertyChangeSupport'];

/**
 * Creates a label with the given <code>text</code>.
 * @param {string} id
 * @param {string} text
 * @param {number} x
 * @param {number} y
 * @class
 * @extends HomeObject
 * @author Emmanuel Puybaret
 */
export class Label extends HomeObject implements Selectable, Elevatable {
    static TWICE_PI: number; public static TWICE_PI_$LI$(): number { if (Label.TWICE_PI == null) { Label.TWICE_PI = 2 * Math.PI; } return Label.TWICE_PI; }

    /*private*/ text: string;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ style: TextStyle;

    /*private*/ color: number;

    /*private*/ outlineColor: number;

    /*private*/ angle: number;

    /*private*/ pitch: number;

    /*private*/ elevation: number;

    /*private*/ level: Level;

    public constructor(id?: any, text?: any, x?: any, y?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof text === 'string') || text === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            let __args = arguments;
            super(id);
            if (this.text === undefined) { this.text = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.style === undefined) { this.style = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.outlineColor === undefined) { this.outlineColor = null; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.level === undefined) { this.level = null; }
            this.text = text;
            this.x = x;
            this.y = y;
        } else if (((typeof id === 'string') || id === null) && ((typeof text === 'number') || text === null) && ((typeof x === 'number') || x === null) && y === undefined) {
            let __args = arguments;
            let text: any = __args[0];
            let x: any = __args[1];
            let y: any = __args[2];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("label");
                super(id);
                if (this.text === undefined) { this.text = null; }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.style === undefined) { this.style = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.outlineColor === undefined) { this.outlineColor = null; }
                if (this.angle === undefined) { this.angle = 0; }
                if (this.pitch === undefined) { this.pitch = null; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.level === undefined) { this.level = null; }
                this.text = text;
                this.x = x;
                this.y = y;
            }
            if (this.text === undefined) { this.text = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.style === undefined) { this.style = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.outlineColor === undefined) { this.outlineColor = null; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.level === undefined) { this.level = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the text of this label.
     * @return {string}
     */
    public getText(): string {
        return this.text;
    }

    /**
     * Sets the text of this label. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {string} text
     */
    public setText(text: string) {
        if (text !== this.text && (text == null || !(text === this.text))) {
            const oldText: string = this.text;
            this.text = text;
            this.firePropertyChange(/* name */"TEXT", oldText, text);
        }
    }

    /**
     * Returns the abscissa of the text of this label.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the abscissa of the text of this label. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the ordinate of the text of this label.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the ordinate of the text of this label. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the elevation of this label
     * from the ground according to the elevation of its level.
     * @return {number}
     */
    public getGroundElevation(): number {
        if (this.level != null) {
            return this.elevation + this.level.getElevation();
        } else {
            return this.elevation;
        }
    }

    /**
     * Returns the elevation of this label on its level.
     * @see #getPitch()
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Sets the elevation of this label on its level. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns the style used to display the text of this label.
     * @return {TextStyle}
     */
    public getStyle(): TextStyle {
        return this.style;
    }

    /**
     * Sets the style used to display the text of this label.
     * Once this label is updated, listeners added to this label will receive a change notification.
     * @param {TextStyle} style
     */
    public setStyle(style: TextStyle) {
        if (style !== this.style) {
            const oldStyle: TextStyle = this.style;
            this.style = style;
            this.firePropertyChange(/* name */"STYLE", oldStyle, style);
        }
    }

    /**
     * Returns the color used to display the text of this label.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the color used to display the text of this label.
     * Once this label is updated, listeners added to this label will receive a change notification.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the color used to outline the text of this label.
     * @return {number}
     */
    public getOutlineColor(): number {
        return this.outlineColor;
    }

    /**
     * Sets the color used to outline the text of this label.
     * Once this label is updated, listeners added to this label will receive a change notification.
     * @param {number} outlineColor
     */
    public setOutlineColor(outlineColor: number) {
        if (outlineColor !== this.outlineColor) {
            const oldOutlineColor: number = this.outlineColor;
            this.outlineColor = outlineColor;
            this.firePropertyChange(/* name */"OUTLINE_COLOR", oldOutlineColor, outlineColor);
        }
    }

    /**
     * Returns the angle in radians around vertical axis used to display this label.
     * @return {number}
     */
    public getAngle(): number {
        return this.angle;
    }

    /**
     * Sets the angle in radians around vertical axis used to display this label. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {number} angle
     */
    public setAngle(angle: number) {
        angle = <number>((angle % Label.TWICE_PI_$LI$() + Label.TWICE_PI_$LI$()) % Label.TWICE_PI_$LI$());
        if (angle !== this.angle) {
            const oldAngle: number = this.angle;
            this.angle = angle;
            this.firePropertyChange(/* name */"ANGLE", oldAngle, angle);
        }
    }

    /**
     * Returns the pitch angle in radians used to rotate this label around horizontal axis in 3D.
     * @return {number} an angle in radians or <code>null</code> if the label shouldn't be displayed in 3D.
     * A pitch angle equal to 0 should make this label fully visible when seen from top.
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Sets the angle in radians used to rotate this label around horizontal axis in 3D. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * Pitch axis is horizontal transverse axis.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch != null) {
            pitch = <number>((pitch % Label.TWICE_PI_$LI$() + Label.TWICE_PI_$LI$()) % Label.TWICE_PI_$LI$());
        }
        if (pitch !== this.pitch && (pitch == null || !(pitch === this.pitch))) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
    }

    /**
     * Returns the level which this label belongs to.
     * @return {Level}
     */
    public getLevel(): Level {
        return this.level;
    }

    /**
     * Sets the level of this label. Once this label is updated,
     * listeners added to this label will receive a change notification.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        if (level !== this.level) {
            const oldLevel: Level = this.level;
            this.level = level;
            this.firePropertyChange(/* name */"LEVEL", oldLevel, level);
        }
    }

    /**
     * Returns <code>true</code> if this label is at the given <code>level</code>
     * or at a level with the same elevation and a smaller elevation index
     * or if the elevation of this label is higher than <code>level</code> elevation.
     * @param {Level} level
     * @return {boolean}
     */
    public isAtLevel(level: Level): boolean {
        if (this.level === level) {
            return true;
        } else if (this.level != null && level != null) {
            const labelLevelElevation: number = this.level.getElevation();
            const levelElevation: number = level.getElevation();
            return labelLevelElevation === levelElevation && this.level.getElevationIndex() < level.getElevationIndex() || labelLevelElevation < levelElevation && labelLevelElevation + this.elevation > levelElevation;
        } else {
            return false;
        }
    }

    /**
     * Returns the point of this label.
     * @return {float[][]} an array of the (x,y) coordinates of this label.
     */
    public getPoints(): number[][] {
        return [[this.x, this.y]];
    }

    /**
     * Returns <code>true</code> if the point of this label is contained
     * in the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return rectangle.contains(this.x, this.y);
    }

    /**
     * Returns <code>true</code> if this text is at the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        return Math.abs(x - this.x) <= margin && Math.abs(y - this.y) <= margin;
    }

    /**
     * Moves this label of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setX(this.getX() + dx);
        this.setY(this.getY() + dy);
    }

    /**
     * Returns a clone of this label.
     * @return {Label}
     */
    public clone(): Label {
        const clone: Label = <Label>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.level = null;
        return clone;
    }
}
Label["__class"] = "com.eteks.sweethome3d.model.Label";
Label["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.Elevatable"];

Label['__transients'] = ['propertyChangeSupport'];

/**
 * Creates the controller of polyline view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class PolylineController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ polylineView: DialogView;

    /*private*/ thickness: number;

    /*private*/ capStyleEditable: boolean;

    /*private*/ capStyle: Polyline.CapStyle;

    /*private*/ joinStyle: Polyline.JoinStyle;

    /*private*/ joinStyleEditable: boolean;

    /*private*/ dashStyle: Polyline.DashStyle;

    /*private*/ dashPattern: number[];

    /*private*/ dashOffset: number;

    /*private*/ arrowsStyleEditable: boolean;

    /*private*/ startArrowStyle: Polyline.ArrowStyle;

    /*private*/ endArrowStyle: Polyline.ArrowStyle;

    /*private*/ color: number;

    /*private*/ elevation: number;

    /*private*/ elevationEnabled: boolean;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.polylineView === undefined) { this.polylineView = null; }
        if (this.thickness === undefined) { this.thickness = null; }
        if (this.capStyleEditable === undefined) { this.capStyleEditable = false; }
        if (this.capStyle === undefined) { this.capStyle = null; }
        if (this.joinStyle === undefined) { this.joinStyle = null; }
        if (this.joinStyleEditable === undefined) { this.joinStyleEditable = false; }
        if (this.dashStyle === undefined) { this.dashStyle = null; }
        if (this.dashPattern === undefined) { this.dashPattern = null; }
        if (this.dashOffset === undefined) { this.dashOffset = null; }
        if (this.arrowsStyleEditable === undefined) { this.arrowsStyleEditable = false; }
        if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
        if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
        if (this.color === undefined) { this.color = null; }
        if (this.elevation === undefined) { this.elevation = null; }
        if (this.elevationEnabled === undefined) { this.elevationEnabled = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.polylineView == null) {
            this.polylineView = this.viewFactory.createPolylineView(this.preferences, this);
        }
        return this.polylineView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from selected polylines in the home edited by this controller.
     */
    updateProperties() {
        const selectedPolylines: Array<Polyline> = Home.getPolylinesSubList(this.home.getSelectedItems());
        if (/* isEmpty */(selectedPolylines.length == 0)) {
            this.setThickness(null);
            this.capStyleEditable = false;
            this.setCapStyle(null);
            this.joinStyleEditable = false;
            this.setJoinStyle(null);
            this.setDashStyle(null);
            this.dashPattern = null;
            this.setDashOffset(null);
            this.arrowsStyleEditable = false;
            this.setStartArrowStyle(null);
            this.setEndArrowStyle(null);
            this.setColor(null);
            this.elevationEnabled = false;
        } else {
            const firstPolyline: Polyline = /* get */selectedPolylines[0];
            let thickness: number = firstPolyline.getThickness();
            for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (thickness !== /* get */selectedPolylines[i].getThickness()) {
                        thickness = null;
                        break;
                    }
                };
            }
            this.setThickness(thickness);
            this.capStyleEditable = false;
            for (let i: number = 0; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (!/* get */selectedPolylines[i].isClosedPath()) {
                        this.capStyleEditable = true;
                        break;
                    }
                };
            }
            if (this.capStyleEditable) {
                let capStyle: Polyline.CapStyle = firstPolyline.getCapStyle();
                if (capStyle != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                        {
                            if (capStyle !== /* get */selectedPolylines[i].getCapStyle()) {
                                capStyle = null;
                                break;
                            }
                        };
                    }
                }
                this.setCapStyle(capStyle);
            } else {
                this.setCapStyle(null);
            }
            this.joinStyleEditable = false;
            for (let i: number = 0; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (/* get */selectedPolylines[i].getPointCount() > 2) {
                        this.joinStyleEditable = true;
                        break;
                    }
                };
            }
            if (this.joinStyleEditable) {
                let joinStyle: Polyline.JoinStyle = firstPolyline.getJoinStyle();
                if (joinStyle != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                        {
                            if (joinStyle !== /* get */selectedPolylines[i].getJoinStyle()) {
                                joinStyle = null;
                                break;
                            }
                        };
                    }
                }
                this.setJoinStyle(joinStyle);
            } else {
                this.setJoinStyle(null);
            }
            let dashPattern: number[] = firstPolyline.getDashPattern();
            if (dashPattern != null) {
                for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                    {
                        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(dashPattern, /* get */selectedPolylines[i].getDashPattern())) {
                            dashPattern = null;
                            break;
                        }
                    };
                }
            }
            this.setDashPattern(dashPattern);
            if (dashPattern != null) {
                let dashStyle: Polyline.DashStyle = firstPolyline.getDashStyle();
                if (dashStyle != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                        {
                            if (dashStyle !== /* get */selectedPolylines[i].getDashStyle()) {
                                dashStyle = null;
                                break;
                            }
                        };
                    }
                }
                if (dashStyle === Polyline.DashStyle.CUSTOMIZED) {
                }
                this.setDashStyle(dashStyle);
            } else {
                this.setDashStyle(null);
            }
            let dashOffset: number = firstPolyline.getDashOffset();
            for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (dashOffset !== /* get */selectedPolylines[i].getDashOffset()) {
                        dashOffset = null;
                        break;
                    }
                };
            }
            this.setDashOffset(dashOffset);
            this.arrowsStyleEditable = this.capStyleEditable;
            if (this.arrowsStyleEditable) {
                let startArrowStyle: Polyline.ArrowStyle = firstPolyline.getStartArrowStyle();
                if (startArrowStyle != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                        {
                            if (startArrowStyle !== /* get */selectedPolylines[i].getStartArrowStyle()) {
                                startArrowStyle = null;
                                break;
                            }
                        };
                    }
                }
                this.setStartArrowStyle(startArrowStyle);
                let endArrowStyle: Polyline.ArrowStyle = firstPolyline.getEndArrowStyle();
                if (endArrowStyle != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                        {
                            if (endArrowStyle !== /* get */selectedPolylines[i].getEndArrowStyle()) {
                                endArrowStyle = null;
                                break;
                            }
                        };
                    }
                }
                this.setEndArrowStyle(endArrowStyle);
            } else {
                this.setStartArrowStyle(null);
                this.setEndArrowStyle(null);
            }
            let color: number = firstPolyline.getColor();
            if (color != null) {
                for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                    {
                        if (color !== /* get */selectedPolylines[i].getColor()) {
                            color = null;
                            break;
                        }
                    };
                }
            }
            this.setColor(color);
            let elevation: number = firstPolyline.getElevation();
            for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (elevation !== /* get */selectedPolylines[i].getElevation()) {
                        elevation = null;
                        break;
                    }
                };
            }
            this.setElevation(elevation);
            let elevationEnabled: boolean = firstPolyline.isVisibleIn3D();
            for (let i: number = 1; i < /* size */(<number>selectedPolylines.length); i++) {
                {
                    if (!(elevationEnabled === /* get */selectedPolylines[i].isVisibleIn3D())) {
                        elevationEnabled = null;
                        break;
                    }
                };
            }
            this.elevationEnabled = elevationEnabled;
        }
    }

    /**
     * Sets the edited thickness.
     * @param {number} thickness
     */
    public setThickness(thickness: number) {
        if (thickness !== this.thickness) {
            const oldThickness: number = this.thickness;
            this.thickness = thickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"THICKNESS", oldThickness, thickness);
        }
    }

    /**
     * Returns the edited thickness.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Sets the edited capStyle.
     * @param {Polyline.CapStyle} capStyle
     */
    public setCapStyle(capStyle: Polyline.CapStyle) {
        if (capStyle !== this.capStyle) {
            const oldCapStyle: Polyline.CapStyle = this.capStyle;
            this.capStyle = capStyle;
            this.propertyChangeSupport.firePropertyChange(/* name */"CAP_STYLE", oldCapStyle, capStyle);
        }
    }

    /**
     * Returns the edited capStyle.
     * @return {Polyline.CapStyle}
     */
    public getCapStyle(): Polyline.CapStyle {
        return this.capStyle;
    }

    /**
     * Returns <code>true</code> if cap style is editable.
     * @return {boolean}
     */
    public isCapStyleEditable(): boolean {
        return this.capStyleEditable;
    }

    /**
     * Sets the edited joinStyle.
     * @param {Polyline.JoinStyle} joinStyle
     */
    public setJoinStyle(joinStyle: Polyline.JoinStyle) {
        if (joinStyle !== this.joinStyle) {
            const oldJoinStyle: Polyline.JoinStyle = this.joinStyle;
            this.joinStyle = joinStyle;
            this.propertyChangeSupport.firePropertyChange(/* name */"JOIN_STYLE", oldJoinStyle, joinStyle);
        }
    }

    /**
     * Returns the edited joinStyle.
     * @return {Polyline.JoinStyle}
     */
    public getJoinStyle(): Polyline.JoinStyle {
        return this.joinStyle;
    }

    /**
     * Returns <code>true</code> if join style is editable.
     * @return {boolean}
     */
    public isJoinStyleEditable(): boolean {
        return this.joinStyleEditable;
    }

    /**
     * Sets the edited dash style.
     * @param {Polyline.DashStyle} dashStyle
     */
    public setDashStyle(dashStyle: Polyline.DashStyle) {
        if (dashStyle !== this.dashStyle) {
            const oldDashStyle: Polyline.DashStyle = this.dashStyle;
            this.dashStyle = dashStyle;
            this.propertyChangeSupport.firePropertyChange(/* name */"DASH_STYLE", oldDashStyle, dashStyle);
        }
    }

    /**
     * Returns the edited dash style.
     * @return {Polyline.DashStyle}
     */
    public getDashStyle(): Polyline.DashStyle {
        return this.dashStyle;
    }

    /**
     * Sets the edited dash pattern.
     * @param {float[]} dashPattern
     */
    public setDashPattern(dashPattern: number[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(dashPattern, this.dashPattern)) {
            const oldDashPattern: number[] = this.dashPattern;
            this.dashPattern = dashPattern;
            this.propertyChangeSupport.firePropertyChange(/* name */"DASH_PATTERN", oldDashPattern, dashPattern);
        }
    }

    /**
     * Returns the edited dash pattern.
     * @return {float[]}
     */
    public getDashPattern(): number[] {
        return this.dashPattern;
    }

    /**
     * Sets the edited dash offset.
     * @param {number} dashOffset
     */
    public setDashOffset(dashOffset: number) {
        if (dashOffset !== this.dashOffset) {
            const oldDashOffset: number = this.dashOffset;
            this.dashOffset = dashOffset;
            this.propertyChangeSupport.firePropertyChange(/* name */"DASH_OFFSET", oldDashOffset, dashOffset);
        }
    }

    /**
     * Returns the edited dash offset.
     * @return {number}
     */
    public getDashOffset(): number {
        return this.dashOffset;
    }

    /**
     * Sets the edited start arrow style.
     * @param {Polyline.ArrowStyle} startArrowStyle
     */
    public setStartArrowStyle(startArrowStyle: Polyline.ArrowStyle) {
        if (startArrowStyle !== this.startArrowStyle) {
            const oldStartArrowStyle: Polyline.ArrowStyle = this.startArrowStyle;
            this.startArrowStyle = startArrowStyle;
            this.propertyChangeSupport.firePropertyChange(/* name */"START_ARROW_STYLE", oldStartArrowStyle, startArrowStyle);
        }
    }

    /**
     * Returns the edited start arrow style.
     * @return {Polyline.ArrowStyle}
     */
    public getStartArrowStyle(): Polyline.ArrowStyle {
        return this.startArrowStyle;
    }

    /**
     * Sets the edited end arrow style.
     * @param {Polyline.ArrowStyle} endArrowStyle
     */
    public setEndArrowStyle(endArrowStyle: Polyline.ArrowStyle) {
        if (endArrowStyle !== this.endArrowStyle) {
            const oldEndArrowStyle: Polyline.ArrowStyle = this.endArrowStyle;
            this.endArrowStyle = endArrowStyle;
            this.propertyChangeSupport.firePropertyChange(/* name */"END_ARROW_STYLE", oldEndArrowStyle, endArrowStyle);
        }
    }

    /**
     * Returns the edited end arrow style.
     * @return {Polyline.ArrowStyle}
     */
    public getEndArrowStyle(): Polyline.ArrowStyle {
        return this.endArrowStyle;
    }

    /**
     * Returns <code>true</code> if arrows style is editable.
     * @return {boolean}
     */
    public isArrowsStyleEditable(): boolean {
        return this.arrowsStyleEditable;
    }

    /**
     * Sets the edited color.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the edited color.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the edited elevation.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
        this.elevationEnabled = elevation != null;
    }

    /**
     * Returns the edited elevation.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Returns <code>Boolean.TRUE</code> if all edited polylines are viewed in 3D,
     * or <code>Boolean.FALSE</code> if no polyline is viewed in 3D.
     * @return {boolean}
     */
    public isElevationEnabled(): boolean {
        return this.elevationEnabled;
    }

    /**
     * Controls the modification of selected polylines in edited home.
     */
    public modifyPolylines() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedPolylines: Array<Polyline> = Home.getPolylinesSubList(oldSelection);
        if (!/* isEmpty */(selectedPolylines.length == 0)) {
            const thickness: number = this.getThickness();
            const capStyle: Polyline.CapStyle = this.getCapStyle();
            const joinStyle: Polyline.JoinStyle = this.getJoinStyle();
            const dashStyle: Polyline.DashStyle = this.getDashStyle();
            const dashPattern: number[] = this.getDashPattern();
            const dashOffset: number = this.getDashOffset();
            const startArrowStyle: Polyline.ArrowStyle = this.getStartArrowStyle();
            const endArrowStyle: Polyline.ArrowStyle = this.getEndArrowStyle();
            const color: number = this.getColor();
            const elevation: number = this.getElevation();
            const elevationEnabled: boolean = this.isElevationEnabled();
            const modifiedPolylines: PolylineController.ModifiedPolyline[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedPolylines.length));
            for (let i: number = 0; i < modifiedPolylines.length; i++) {
                {
                    modifiedPolylines[i] = new PolylineController.ModifiedPolyline(/* get */selectedPolylines[i]);
                };
            }
            PolylineController.doModifyPolylines(modifiedPolylines, thickness, capStyle, joinStyle, dashStyle, dashPattern, dashOffset, startArrowStyle, endArrowStyle, color, elevation, elevationEnabled);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new PolylineController.PolylinesModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), modifiedPolylines, thickness, capStyle, joinStyle, dashStyle, dashPattern, dashOffset, startArrowStyle, endArrowStyle, color, elevation, elevationEnabled);
                this.undoSupport.postEdit(undoableEdit);
            }
        }
    }

    /**
     * Modifies polylines properties with the values in parameter.
     * @param {com.eteks.sweethome3d.viewcontroller.PolylineController.ModifiedPolyline[]} modifiedPolylines
     * @param {number} thickness
     * @param {Polyline.CapStyle} capStyle
     * @param {Polyline.JoinStyle} joinStyle
     * @param {Polyline.DashStyle} dashStyle
     * @param {float[]} dashPattern
     * @param {number} dashOffset
     * @param {Polyline.ArrowStyle} startArrowStyle
     * @param {Polyline.ArrowStyle} endArrowStyle
     * @param {number} color
     * @param {number} elevation
     * @param {boolean} elevationEnabled
     * @private
     */
    static doModifyPolylines(modifiedPolylines: PolylineController.ModifiedPolyline[], thickness: number, capStyle: Polyline.CapStyle, joinStyle: Polyline.JoinStyle, dashStyle: Polyline.DashStyle, dashPattern: number[], dashOffset: number, startArrowStyle: Polyline.ArrowStyle, endArrowStyle: Polyline.ArrowStyle, color: number, elevation: number, elevationEnabled: boolean) {
        for (let index = 0; index < modifiedPolylines.length; index++) {
            let modifiedPolyline = modifiedPolylines[index];
            {
                const polyline: Polyline = modifiedPolyline.getPolyline();
                if (thickness != null) {
                    polyline.setThickness(thickness);
                }
                if (capStyle != null) {
                    polyline.setCapStyle(capStyle);
                }
                if (joinStyle != null) {
                    polyline.setJoinStyle(joinStyle);
                }
                if (dashStyle != null) {
                    polyline.setDashStyle(dashStyle);
                }
                if (dashStyle === Polyline.DashStyle.CUSTOMIZED && dashPattern != null) {
                    polyline.setDashPattern(dashPattern);
                }
                if (dashOffset != null) {
                    polyline.setDashOffset(polyline.getDashStyle() !== Polyline.DashStyle.SOLID ? dashOffset : 0);
                }
                if (startArrowStyle != null) {
                    polyline.setStartArrowStyle(startArrowStyle);
                }
                if (endArrowStyle != null) {
                    polyline.setEndArrowStyle(endArrowStyle);
                }
                if (color != null) {
                    polyline.setColor(color);
                }
                if (elevationEnabled != null) {
                    if (false === elevationEnabled) {
                        polyline.setVisibleIn3D(false);
                    } else if (elevation != null) {
                        polyline.setVisibleIn3D(true);
                        polyline.setElevation(elevation);
                    }
                }
            }
        }
    }

    /**
     * Restores polyline properties from the values stored in <code>modifiedPolylines</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.PolylineController.ModifiedPolyline[]} modifiedPolylines
     * @private
     */
    static undoModifyPolylines(modifiedPolylines: PolylineController.ModifiedPolyline[]) {
        for (let index = 0; index < modifiedPolylines.length; index++) {
            let modifiedPolyline = modifiedPolylines[index];
            {
                modifiedPolyline.reset();
            }
        }
    }
}
PolylineController["__class"] = "com.eteks.sweethome3d.viewcontroller.PolylineController";
PolylineController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace PolylineController {

    /**
     * Undoable edit for polylines modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class PolylinesModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        modifiedPolylines: PolylineController.ModifiedPolyline[];

        thickness: number;

        capStyle: Polyline.CapStyle;

        joinStyle: Polyline.JoinStyle;

        dashStyle: Polyline.DashStyle;

        dashPattern: number[];

        dashOffset: number;

        startArrowStyle: Polyline.ArrowStyle;

        endArrowStyle: Polyline.ArrowStyle;

        color: number;

        elevation: number;

        elevationEnabled: boolean;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], modifiedPolylines: PolylineController.ModifiedPolyline[], thickness: number, capStyle: Polyline.CapStyle, joinStyle: Polyline.JoinStyle, dashStyle: Polyline.DashStyle, dashPattern: number[], dashOffset: number, startArrowStyle: Polyline.ArrowStyle, endArrowStyle: Polyline.ArrowStyle, color: number, elevation: number, elevationEnabled: boolean) {
            super(preferences, PolylineController, "undoModifyPolylinesName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.modifiedPolylines === undefined) { this.modifiedPolylines = null; }
            if (this.thickness === undefined) { this.thickness = null; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.dashStyle === undefined) { this.dashStyle = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = null; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.elevationEnabled === undefined) { this.elevationEnabled = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.modifiedPolylines = modifiedPolylines;
            this.thickness = thickness;
            this.capStyle = capStyle;
            this.joinStyle = joinStyle;
            this.dashStyle = dashStyle;
            this.dashPattern = dashPattern;
            this.dashOffset = dashOffset;
            this.startArrowStyle = startArrowStyle;
            this.endArrowStyle = endArrowStyle;
            this.color = color;
            this.elevation = elevation;
            this.elevationEnabled = elevationEnabled;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            PolylineController.undoModifyPolylines(this.modifiedPolylines);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            PolylineController.doModifyPolylines(this.modifiedPolylines, this.thickness, this.capStyle, this.joinStyle, this.dashStyle, this.dashPattern, this.dashOffset, this.startArrowStyle, this.endArrowStyle, this.color, this.elevation, this.elevationEnabled);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }
    }
    PolylinesModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PolylineController.PolylinesModificationUndoableEdit";
    PolylinesModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified polyline.
     * @param {Polyline} polyline
     * @class
     */
    export class ModifiedPolyline {
        polyline: Polyline;

        thickness: number;

        capStyle: Polyline.CapStyle;

        joinStyle: Polyline.JoinStyle;

        dashPattern: number[];

        dashOffset: number;

        startArrowStyle: Polyline.ArrowStyle;

        endArrowStyle: Polyline.ArrowStyle;

        color: number;

        visibleIn3D: boolean;

        elevation: number;

        public constructor(polyline: Polyline) {
            if (this.polyline === undefined) { this.polyline = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.capStyle === undefined) { this.capStyle = null; }
            if (this.joinStyle === undefined) { this.joinStyle = null; }
            if (this.dashPattern === undefined) { this.dashPattern = null; }
            if (this.dashOffset === undefined) { this.dashOffset = null; }
            if (this.startArrowStyle === undefined) { this.startArrowStyle = null; }
            if (this.endArrowStyle === undefined) { this.endArrowStyle = null; }
            if (this.color === undefined) { this.color = 0; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            this.polyline = polyline;
            this.thickness = polyline.getThickness();
            this.capStyle = polyline.getCapStyle();
            this.joinStyle = polyline.getJoinStyle();
            this.dashPattern = polyline.getDashPattern();
            this.dashOffset = polyline.getDashOffset();
            this.startArrowStyle = polyline.getStartArrowStyle();
            this.endArrowStyle = polyline.getEndArrowStyle();
            this.color = polyline.getColor();
            this.visibleIn3D = polyline.isVisibleIn3D();
            this.elevation = polyline.getElevation();
        }

        public getPolyline(): Polyline {
            return this.polyline;
        }

        public reset() {
            this.polyline.setThickness(this.thickness);
            this.polyline.setCapStyle(this.capStyle);
            this.polyline.setJoinStyle(this.joinStyle);
            this.polyline.setDashPattern(this.dashPattern);
            this.polyline.setDashOffset(this.dashOffset);
            this.polyline.setStartArrowStyle(this.startArrowStyle);
            this.polyline.setEndArrowStyle(this.endArrowStyle);
            this.polyline.setColor(this.color);
            this.polyline.setVisibleIn3D(this.visibleIn3D);
            this.polyline.setElevation(this.elevation);
        }
    }
    ModifiedPolyline["__class"] = "com.eteks.sweethome3d.viewcontroller.PolylineController.ModifiedPolyline";

}


/**
 * Creates the controller of dimension line view with undo support.
 * @param {Home} home
 * @param {number} x
 * @param {number} y
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class DimensionLineController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ dimensionLineView: DialogView;

    /*private*/ dimensionLineModification: boolean;

    /*private*/ editableDistance: boolean;

    /*private*/ xStart: number;

    /*private*/ yStart: number;

    /*private*/ elevationStart: number;

    /*private*/ xEnd: number;

    /*private*/ yEnd: number;

    /*private*/ elevationEnd: number;

    /*private*/ distanceToEndPoint: number;

    /*private*/ orientation: DimensionLineController.DimensionLineOrientation;

    /*private*/ offset: number;

    /*private*/ lengthFontSize: number;

    /*private*/ color: number;

    /*private*/ visibleIn3D: boolean;

    /*private*/ pitch: number;

    public constructor(home?: any, x?: any, y?: any, preferences?: any, viewFactory?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.dimensionLineView === undefined) { this.dimensionLineView = null; }
            if (this.dimensionLineModification === undefined) { this.dimensionLineModification = false; }
            if (this.editableDistance === undefined) { this.editableDistance = false; }
            if (this.xStart === undefined) { this.xStart = null; }
            if (this.yStart === undefined) { this.yStart = null; }
            if (this.elevationStart === undefined) { this.elevationStart = null; }
            if (this.xEnd === undefined) { this.xEnd = null; }
            if (this.yEnd === undefined) { this.yEnd = null; }
            if (this.elevationEnd === undefined) { this.elevationEnd = null; }
            if (this.distanceToEndPoint === undefined) { this.distanceToEndPoint = null; }
            if (this.orientation === undefined) { this.orientation = null; }
            if (this.offset === undefined) { this.offset = null; }
            if (this.lengthFontSize === undefined) { this.lengthFontSize = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.dimensionLineModification = false;
            this.xStart = this.xEnd = x;
            this.yStart = this.yEnd = y;
            this.editableDistance = true;
            this.elevationStart = 0.0;
            this.elevationEnd = this.distanceToEndPoint = home.getWallHeight();
            this.offset = 20.0;
            this.orientation = DimensionLineController.DimensionLineOrientation.ELEVATION;
            this.lengthFontSize = preferences.getDefaultTextStyle(DimensionLine).getFontSize();
            this.visibleIn3D = true;
            this.pitch = <number>(-Math.PI / 2);
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((x != null && x instanceof <any>UserPreferences) || x === null) && ((y != null && (y.constructor != null && y.constructor["__interfaces"] != null && y.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || y === null) && ((preferences != null && preferences instanceof <any>javax.swing.undo.UndoableEditSupport) || preferences === null) && viewFactory === undefined && undoSupport === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let undoSupport: any = __args[3];
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.dimensionLineView === undefined) { this.dimensionLineView = null; }
            if (this.dimensionLineModification === undefined) { this.dimensionLineModification = false; }
            if (this.editableDistance === undefined) { this.editableDistance = false; }
            if (this.xStart === undefined) { this.xStart = null; }
            if (this.yStart === undefined) { this.yStart = null; }
            if (this.elevationStart === undefined) { this.elevationStart = null; }
            if (this.xEnd === undefined) { this.xEnd = null; }
            if (this.yEnd === undefined) { this.yEnd = null; }
            if (this.elevationEnd === undefined) { this.elevationEnd = null; }
            if (this.distanceToEndPoint === undefined) { this.distanceToEndPoint = null; }
            if (this.orientation === undefined) { this.orientation = null; }
            if (this.offset === undefined) { this.offset = null; }
            if (this.lengthFontSize === undefined) { this.lengthFontSize = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.dimensionLineModification = true;
            this.updateProperties();
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.dimensionLineView == null) {
            this.dimensionLineView = this.viewFactory.createDimensionLineView(this.dimensionLineModification, this.preferences, this);
        }
        return this.dimensionLineView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from selected dimension lines in the home edited by this controller.
     */
    updateProperties() {
        const selectedDimensionLines: Array<DimensionLine> = Home.getDimensionLinesSubList(this.home.getSelectedItems());
        if (/* isEmpty */(selectedDimensionLines.length == 0)) {
            this.setXStart(null);
            this.setYStart(null);
            this.setElevationStart(null);
            this.setXEnd(null);
            this.setYEnd(null);
            this.setElevationEnd(null);
            this.setEditableDistance(false);
            this.setOrientation(null);
            this.setOffset(null);
            this.setLengthFontSize(null);
            this.setColor(null);
            this.setVisibleIn3D(null);
            this.setPitch(null);
        } else {
            const firstDimensionLine: DimensionLine = /* get */selectedDimensionLines[0];
            let xStart: number = firstDimensionLine.getXStart();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(xStart === /* get */selectedDimensionLines[i].getXStart())) {
                        xStart = null;
                        break;
                    }
                };
            }
            this.setXStart(xStart);
            let yStart: number = firstDimensionLine.getYStart();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(yStart === /* get */selectedDimensionLines[i].getYStart())) {
                        yStart = null;
                        break;
                    }
                };
            }
            this.setYStart(yStart);
            let elevationStart: number = firstDimensionLine.getElevationStart();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(elevationStart === /* get */selectedDimensionLines[i].getElevationStart())) {
                        elevationStart = null;
                        break;
                    }
                };
            }
            this.setElevationStart(elevationStart);
            let xEnd: number = firstDimensionLine.getXEnd();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(xEnd === /* get */selectedDimensionLines[i].getXEnd())) {
                        xEnd = null;
                        break;
                    }
                };
            }
            this.setXEnd(xEnd);
            let yEnd: number = firstDimensionLine.getYEnd();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(yEnd === /* get */selectedDimensionLines[i].getYEnd())) {
                        yEnd = null;
                        break;
                    }
                };
            }
            this.setYEnd(yEnd);
            let elevationEnd: number = firstDimensionLine.getElevationEnd();
            const elevationDimensionLine: boolean = firstDimensionLine.isElevationDimensionLine();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(elevationEnd === /* get */selectedDimensionLines[i].getElevationEnd()) || elevationDimensionLine !== /* get */selectedDimensionLines[i].isElevationDimensionLine()) {
                        elevationEnd = null;
                        break;
                    }
                };
            }
            this.setElevationEnd(elevationEnd);
            this.setEditableDistance(this.getXStart() != null && this.getYStart() != null && this.getElevationStart() != null && this.getXEnd() != null && this.getYEnd() != null && this.getElevationEnd() != null);
            let orientation: DimensionLineController.DimensionLineOrientation = null;
            if (firstDimensionLine.isElevationDimensionLine()) {
                orientation = DimensionLineController.DimensionLineOrientation.ELEVATION;
            } else if (firstDimensionLine.getElevationStart() === firstDimensionLine.getElevationEnd()) {
                orientation = DimensionLineController.DimensionLineOrientation.PLAN;
            }
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    const dimensionLine: DimensionLine = /* get */selectedDimensionLines[i];
                    if (dimensionLine.isElevationDimensionLine() && orientation !== DimensionLineController.DimensionLineOrientation.ELEVATION || dimensionLine.getElevationStart() === dimensionLine.getElevationEnd() && orientation !== DimensionLineController.DimensionLineOrientation.PLAN) {
                        orientation = null;
                        break;
                    }
                };
            }
            this.setOrientation(orientation, false);
            let offset: number = firstDimensionLine.getOffset();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(offset === /* get */selectedDimensionLines[i].getOffset())) {
                        offset = null;
                        break;
                    }
                };
            }
            this.setOffset(offset);
            const defaultFontSize: number = this.preferences.getDefaultTextStyle(DimensionLine).getFontSize();
            let fontSize: number = firstDimensionLine.getLengthStyle() != null ? firstDimensionLine.getLengthStyle().getFontSize() : defaultFontSize;
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    const dimensionLine: DimensionLine = /* get */selectedDimensionLines[i];
                    if (!(fontSize === (dimensionLine.getLengthStyle() != null ? dimensionLine.getLengthStyle().getFontSize() : defaultFontSize))) {
                        fontSize = null;
                        break;
                    }
                };
            }
            this.setLengthFontSize(fontSize);
            let color: number = firstDimensionLine.getColor();
            if (color != null) {
                for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                    {
                        if (!(color === /* get */selectedDimensionLines[i].getColor())) {
                            color = null;
                            break;
                        }
                    };
                }
            }
            this.setColor(color);
            let visibleIn3D: boolean = firstDimensionLine.isVisibleIn3D();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(visibleIn3D === /* get */selectedDimensionLines[i].isVisibleIn3D())) {
                        visibleIn3D = null;
                        break;
                    }
                };
            }
            this.setVisibleIn3D(visibleIn3D);
            let pitch: number = firstDimensionLine.getPitch();
            for (let i: number = 1; i < /* size */(<number>selectedDimensionLines.length); i++) {
                {
                    if (!(pitch === /* get */selectedDimensionLines[i].getPitch())) {
                        pitch = null;
                        break;
                    }
                };
            }
            this.setPitch(pitch);
        }
    }

    public setXStart(xStart: number, updateXEnd: boolean = true) {
        if (xStart !== this.xStart) {
            const oldXStart: number = this.xStart;
            this.xStart = xStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"X_START", oldXStart, xStart);
            if (updateXEnd && this.orientation === DimensionLineController.DimensionLineOrientation.ELEVATION) {
                this.setXEnd(xStart, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited abscissa of the start point.
     * @return {number}
     */
    public getXStart(): number {
        return this.xStart;
    }

    public setYStart(yStart: number, updateYEnd: boolean = true) {
        if (yStart !== this.yStart) {
            const oldYStart: number = this.yStart;
            this.yStart = yStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y_START", oldYStart, yStart);
            if (updateYEnd && this.orientation === DimensionLineController.DimensionLineOrientation.ELEVATION) {
                this.setYEnd(yStart, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited ordinate of the start point.
     * @return {number}
     */
    public getYStart(): number {
        return this.yStart;
    }

    public setElevationStart(elevationStart: number, updateElevationEnd: boolean = true) {
        if (elevationStart !== this.elevationStart) {
            const oldElevationStart: number = this.elevationStart;
            this.elevationStart = elevationStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION_START", oldElevationStart, elevationStart);
            if (updateElevationEnd && this.orientation === DimensionLineController.DimensionLineOrientation.PLAN) {
                this.setElevationEnd(elevationStart, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited elevation of the start point.
     * @return {number}
     */
    public getElevationStart(): number {
        return this.elevationStart;
    }

    public setXEnd(xEnd: number, updateXStart: boolean = true) {
        if (xEnd !== this.xEnd) {
            const oldXEnd: number = this.xEnd;
            this.xEnd = xEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"X_END", oldXEnd, xEnd);
            if (updateXStart && this.orientation === DimensionLineController.DimensionLineOrientation.ELEVATION) {
                this.setXStart(xEnd, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited abscissa of the end point.
     * @return {number}
     */
    public getXEnd(): number {
        return this.xEnd;
    }

    public setYEnd(yEnd: number, updateYStart: boolean = true) {
        if (yEnd !== this.yEnd) {
            const oldYEnd: number = this.yEnd;
            this.yEnd = yEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y_END", oldYEnd, yEnd);
            if (updateYStart && this.orientation === DimensionLineController.DimensionLineOrientation.ELEVATION) {
                this.setYStart(yEnd, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited ordinate of the end point.
     * @return {number}
     */
    public getYEnd(): number {
        return this.yEnd;
    }

    public setElevationEnd(elevationEnd: number, updateElevationStart: boolean = true) {
        if (elevationEnd !== this.elevationEnd) {
            const oldElevationEnd: number = this.elevationEnd;
            this.elevationEnd = elevationEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION_END", oldElevationEnd, elevationEnd);
            if (updateElevationStart && this.orientation === DimensionLineController.DimensionLineOrientation.PLAN) {
                this.setElevationStart(elevationEnd, false);
            } else {
                this.updateDistanceToEndPoint();
            }
        }
    }

    /**
     * Returns the edited elevation of the end point.
     * @return {number}
     */
    public getElevationEnd(): number {
        return this.elevationEnd;
    }

    /**
     * Updates the edited distance to end point after its coordinates change.
     * @private
     */
    updateDistanceToEndPoint() {
        const xStart: number = this.getXStart();
        const yStart: number = this.getYStart();
        const elevationStart: number = this.getElevationStart();
        const xEnd: number = this.getXEnd();
        const yEnd: number = this.getYEnd();
        const elevationEnd: number = this.getElevationEnd();
        if (xStart != null && yStart != null && elevationStart != null && xEnd != null && yEnd != null && elevationEnd != null) {
            const dimensionLine: DimensionLine = new DimensionLine(xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, 0);
            this.setDistanceToEndPoint(dimensionLine.getLength(), false);
        } else {
            this.setDistanceToEndPoint(null, false);
        }
    }

    public setDistanceToEndPoint(distanceToEndPoint: number, updateEndPoint: boolean = true) {
        if (distanceToEndPoint !== this.distanceToEndPoint) {
            const oldDistance: number = this.distanceToEndPoint;
            this.distanceToEndPoint = distanceToEndPoint;
            this.propertyChangeSupport.firePropertyChange(/* name */"DISTANCE_TO_END_POINT", oldDistance, distanceToEndPoint);
            if (updateEndPoint) {
                const xStart: number = this.getXStart();
                const yStart: number = this.getYStart();
                const elevationStart: number = this.getElevationStart();
                const xEnd: number = this.getXEnd();
                const yEnd: number = this.getYEnd();
                const elevationEnd: number = this.getElevationEnd();
                if (xStart != null && yStart != null && elevationStart != null && xEnd != null && yEnd != null && elevationEnd != null && distanceToEndPoint != null) {
                    const dimensionLinePlanAngle: number = Math.atan2(yStart - yEnd, xEnd - xStart);
                    const dimensionLineVerticalAngle: number = Math.atan2(elevationEnd - elevationStart, xEnd - xStart);
                    this.setXEnd(<number>(xStart + distanceToEndPoint * Math.cos(dimensionLinePlanAngle) * Math.cos(dimensionLineVerticalAngle)));
                    this.setYEnd(<number>(yStart - distanceToEndPoint * Math.sin(dimensionLinePlanAngle) * Math.cos(dimensionLineVerticalAngle)));
                    this.setElevationEnd(<number>(elevationStart + distanceToEndPoint * Math.sin(dimensionLineVerticalAngle)));
                } else {
                    this.setXEnd(null);
                    this.setYEnd(null);
                    this.setElevationEnd(null);
                }
            }
        }
    }

    /**
     * Returns the edited distance to end point.
     * @return {number}
     */
    public getDistanceToEndPoint(): number {
        return this.distanceToEndPoint;
    }

    public setOrientation(orientation: DimensionLineController.DimensionLineOrientation, updateEndPointAndPitch: boolean = true) {
        if (orientation !== this.orientation) {
            const oldOrientation: DimensionLineController.DimensionLineOrientation = this.orientation;
            this.orientation = orientation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ORIENTATION", oldOrientation, orientation);
            if (updateEndPointAndPitch) {
                if (orientation === DimensionLineController.DimensionLineOrientation.PLAN && this.pitch !== 0 && this.pitch !== <number>(Math.PI / 2)) {
                    this.setPitch(0.0);
                }
                if (this.distanceToEndPoint != null) {
                    const distanceToEndPoint: number = this.distanceToEndPoint;
                    const xStart: number = this.getXStart();
                    const yStart: number = this.getYStart();
                    const elevationStart: number = this.getElevationStart();
                    if (orientation === DimensionLineController.DimensionLineOrientation.PLAN) {
                        this.setElevationEnd(elevationStart, false);
                        this.setYEnd(yStart, false);
                        this.setXEnd(xStart + distanceToEndPoint, false);
                    } else if (orientation === DimensionLineController.DimensionLineOrientation.ELEVATION) {
                        this.setXEnd(xStart, false);
                        this.setYEnd(yStart, false);
                        this.setElevationEnd(elevationStart + distanceToEndPoint, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the edited orientation.
     * @return {DimensionLineController.DimensionLineOrientation}
     */
    public getOrientation(): DimensionLineController.DimensionLineOrientation {
        return this.orientation;
    }

    /**
     * Sets whether the distance can be be edited or not.
     * @param {boolean} editableDistance
     */
    public setEditableDistance(editableDistance: boolean) {
        if (editableDistance !== this.editableDistance) {
            this.editableDistance = editableDistance;
            this.propertyChangeSupport.firePropertyChange(/* name */"EDITABLE_DISTANCE", !editableDistance, editableDistance);
        }
    }

    /**
     * Returns whether the distance can be be edited or not.
     * @return {boolean}
     */
    public isEditableDistance(): boolean {
        return this.editableDistance;
    }

    /**
     * Sets the edited offset.
     * @param {number} offset
     */
    public setOffset(offset: number) {
        if (offset !== this.offset) {
            const oldOffset: number = this.offset;
            this.offset = offset;
            this.propertyChangeSupport.firePropertyChange(/* name */"OFFSET", oldOffset, offset);
        }
    }

    /**
     * Returns the edited offset.
     * @return {number}
     */
    public getOffset(): number {
        return this.offset;
    }

    /**
     * Sets the edited font size.
     * @param {number} lengthFontSize
     */
    public setLengthFontSize(lengthFontSize: number) {
        if (lengthFontSize !== this.lengthFontSize) {
            const oldLengthFontSize: number = this.lengthFontSize;
            this.lengthFontSize = lengthFontSize;
            this.propertyChangeSupport.firePropertyChange(/* name */"LENGTH_FONT_SIZE", oldLengthFontSize, lengthFontSize);
        }
    }

    /**
     * Returns the edited font size.
     * @return {number}
     */
    public getLengthFontSize(): number {
        return this.lengthFontSize;
    }

    /**
     * Sets the edited color.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the edited color.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets whether all edited dimension lines are viewed in 3D.
     * @param {boolean} visibleIn3D
     */
    public setVisibleIn3D(visibleIn3D: boolean) {
        if (visibleIn3D !== this.visibleIn3D) {
            const oldVisibleIn3D: boolean = this.visibleIn3D;
            this.visibleIn3D = visibleIn3D;
            this.propertyChangeSupport.firePropertyChange(/* name */"VISIBLE_IN_3D", oldVisibleIn3D, visibleIn3D);
        }
    }

    /**
     * Returns <code>Boolean.TRUE</code> if all edited dimension lines are viewed in 3D,
     * or <code>Boolean.FALSE</code> if no dimension line is viewed in 3D.
     * @return {boolean}
     */
    public isVisibleIn3D(): boolean {
        return this.visibleIn3D;
    }

    /**
     * Sets the edited pitch angle.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.propertyChangeSupport.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
    }

    /**
     * Returns the edited pitch.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    public createDimensionLine$float$float$float$float$float$float$float(xStart: number, yStart: number, elevationStart: number, xEnd: number, yEnd: number, elevationEnd: number, offset: number): DimensionLine {
        const dimensionLine: DimensionLine = new DimensionLine(this.getXStart(), this.getYStart(), this.getElevationStart(), this.getXEnd(), this.getYEnd(), this.getElevationEnd(), this.getOffset());
        this.home.addDimensionLine(dimensionLine);
        return dimensionLine;
    }

    /**
     * Returns a new dimension line instance added to home.
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} elevationStart
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {number} elevationEnd
     * @param {number} offset
     * @return {DimensionLine}
     */
    public createDimensionLine(xStart?: any, yStart?: any, elevationStart?: any, xEnd?: any, yEnd?: any, elevationEnd?: any, offset?: any): any {
        if (((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof elevationStart === 'number') || elevationStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof elevationEnd === 'number') || elevationEnd === null) && ((typeof offset === 'number') || offset === null)) {
            return <any>this.createDimensionLine$float$float$float$float$float$float$float(xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, offset);
        } else if (xStart === undefined && yStart === undefined && elevationStart === undefined && xEnd === undefined && yEnd === undefined && elevationEnd === undefined && offset === undefined) {
            return <any>this.createDimensionLine$();
        } else throw new Error('invalid overload');
    }

    public createDimensionLine$() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const basePlanLocked: boolean = this.home.isBasePlanLocked();
        const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
        const dimensionLine: DimensionLine = this.createDimensionLine$float$float$float$float$float$float$float(this.getXStart(), this.getYStart(), this.getElevationStart(), this.getXEnd(), this.getYEnd(), this.getElevationEnd(), this.getOffset());
        const fontSize: number = this.getLengthFontSize();
        if (fontSize != null) {
            const style: TextStyle = this.preferences.getDefaultTextStyle(DimensionLine).deriveStyle$float(fontSize);
            dimensionLine.setLengthStyle(style);
        }
        dimensionLine.setColor(this.getColor());
        dimensionLine.setVisibleIn3D(this.isVisibleIn3D());
        dimensionLine.setPitch(this.getPitch());
        DimensionLineController.doAddAndSelectDimensionLine(this.home, dimensionLine, false);
        if (this.undoSupport != null) {
            const undoableEdit: javax.swing.undo.UndoableEdit = new DimensionLineController.DimensionLineCreationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), basePlanLocked, allLevelsSelection, dimensionLine);
            this.undoSupport.postEdit(undoableEdit);
        }
    }

    /**
     * Adds dimension line to home and selects it.
     * @param {Home} home
     * @param {DimensionLine} dimensionLine
     * @param {boolean} addToHome
     * @private
     */
    static doAddAndSelectDimensionLine(home: Home, dimensionLine: DimensionLine, addToHome: boolean) {
        if (addToHome) {
            home.addDimensionLine(dimensionLine);
        }
        home.setBasePlanLocked(false);
        home.setSelectedItems(/* asList */[dimensionLine].slice(0));
        home.setAllLevelsSelection(false);
    }

    /**
     * Deletes dimensionLine from home.
     * @param {Home} home
     * @param {DimensionLine} dimensionLine
     * @param {boolean} basePlanLocked
     * @private
     */
    static doDeleteDimensionLine(home: Home, dimensionLine: DimensionLine, basePlanLocked: boolean) {
        home.deleteDimensionLine(dimensionLine);
        home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Controls the modification of selected dimension lines in edited home.
     */
    public modifyDimensionLines() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedDimensionLines: Array<DimensionLine> = Home.getDimensionLinesSubList(oldSelection);
        if (!/* isEmpty */(selectedDimensionLines.length == 0)) {
            const xStart: number = this.getXStart();
            const yStart: number = this.getYStart();
            const elevationStart: number = this.getElevationStart();
            const xEnd: number = this.getXEnd();
            const yEnd: number = this.getYEnd();
            const elevationEnd: number = this.getElevationEnd();
            const offset: number = this.getOffset();
            const lengthFontSize: number = this.getLengthFontSize();
            const color: number = this.getColor();
            const visibleIn3D: boolean = this.isVisibleIn3D();
            const pitch: number = this.getPitch();
            const modifiedDimensionLines: DimensionLineController.ModifiedDimensionLine[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedDimensionLines.length));
            for (let i: number = 0; i < modifiedDimensionLines.length; i++) {
                {
                    modifiedDimensionLines[i] = new DimensionLineController.ModifiedDimensionLine(/* get */selectedDimensionLines[i]);
                };
            }
            const defaultStyle: TextStyle = this.preferences.getDefaultTextStyle(DimensionLine);
            DimensionLineController.doModifyDimensionLines(modifiedDimensionLines, xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, offset, lengthFontSize, defaultStyle, color, visibleIn3D, pitch);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new DimensionLineController.DimensionLinesModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), modifiedDimensionLines, xStart, yStart, elevationStart, xEnd, yEnd, elevationEnd, offset, lengthFontSize, defaultStyle, color, visibleIn3D, pitch);
                this.undoSupport.postEdit(undoableEdit);
            }
        }
    }

    /**
     * Modifies dimension lines properties with the values in parameter.
     * @param {com.eteks.sweethome3d.viewcontroller.DimensionLineController.ModifiedDimensionLine[]} modifiedDimensionLines
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} elevationStart
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {number} elevationEnd
     * @param {number} offset
     * @param {number} lengthFontSize
     * @param {TextStyle} defaultStyle
     * @param {number} color
     * @param {boolean} visibleIn3D
     * @param {number} pitch
     * @private
     */
    static doModifyDimensionLines(modifiedDimensionLines: DimensionLineController.ModifiedDimensionLine[], xStart: number, yStart: number, elevationStart: number, xEnd: number, yEnd: number, elevationEnd: number, offset: number, lengthFontSize: number, defaultStyle: TextStyle, color: number, visibleIn3D: boolean, pitch: number) {
        for (let index = 0; index < modifiedDimensionLines.length; index++) {
            let modifiedDimensionLine = modifiedDimensionLines[index];
            {
                const dimensionLine: DimensionLine = modifiedDimensionLine.getDimensionLine();
                if (xStart != null) {
                    dimensionLine.setXStart(xStart);
                }
                if (yStart != null) {
                    dimensionLine.setYStart(yStart);
                }
                if (elevationStart != null) {
                    if (elevationEnd == null) {
                        if (dimensionLine.isElevationDimensionLine()) {
                            dimensionLine.setElevationEnd(elevationStart + dimensionLine.getElevationEnd() - dimensionLine.getElevationStart());
                        } else {
                            dimensionLine.setElevationEnd(elevationStart);
                        }
                    }
                    dimensionLine.setElevationStart(elevationStart);
                }
                if (xEnd != null) {
                    dimensionLine.setXEnd(xEnd);
                }
                if (yEnd != null) {
                    dimensionLine.setYEnd(yEnd);
                }
                if (elevationEnd != null) {
                    dimensionLine.setElevationEnd(elevationEnd);
                }
                if (offset != null) {
                    dimensionLine.setOffset(offset);
                }
                if (lengthFontSize != null) {
                    dimensionLine.setLengthStyle(dimensionLine.getLengthStyle() != null ? dimensionLine.getLengthStyle().deriveStyle$float(lengthFontSize) : defaultStyle.deriveStyle$float(lengthFontSize));
                }
                if (color != null) {
                    dimensionLine.setColor(color);
                }
                if (visibleIn3D != null) {
                    dimensionLine.setVisibleIn3D(visibleIn3D);
                }
                if (pitch != null) {
                    dimensionLine.setPitch(pitch);
                }
            }
        }
    }

    /**
     * Restores dimension line properties from the values stored in <code>modifiedDimensionLines</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.DimensionLineController.ModifiedDimensionLine[]} modifiedDimensionLines
     * @private
     */
    static undoModifyDimensionLines(modifiedDimensionLines: DimensionLineController.ModifiedDimensionLine[]) {
        for (let index = 0; index < modifiedDimensionLines.length; index++) {
            let modifiedDimensionLine = modifiedDimensionLines[index];
            {
                modifiedDimensionLine.reset();
            }
        }
    }
}
DimensionLineController["__class"] = "com.eteks.sweethome3d.viewcontroller.DimensionLineController";
DimensionLineController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace DimensionLineController {

    /**
     * The possible values for {@linkplain #getOrientation() dimension line type}.
     * @enum
     * @property {DimensionLineController.DimensionLineOrientation} PLAN
     * @property {DimensionLineController.DimensionLineOrientation} ELEVATION
     * @property {DimensionLineController.DimensionLineOrientation} DIAGONAL
     * @class
     */
    export enum DimensionLineOrientation {
        PLAN, ELEVATION, DIAGONAL
    }

    /**
     * Undoable edit for dimension line creation. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class DimensionLineCreationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        dimensionLine: DimensionLine;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, dimensionLine: DimensionLine) {
            super(preferences, DimensionLineController, "undoCreateDimensionLineName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.dimensionLine = dimensionLine;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            DimensionLineController.doDeleteDimensionLine(this.home, this.dimensionLine, this.oldBasePlanLocked);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
            this.home.setAllLevelsSelection(this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            DimensionLineController.doAddAndSelectDimensionLine(this.home, this.dimensionLine, true);
        }
    }
    DimensionLineCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.DimensionLineController.DimensionLineCreationUndoableEdit";
    DimensionLineCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension lines modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class DimensionLinesModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        modifiedDimensionLines: DimensionLineController.ModifiedDimensionLine[];

        xStart: number;

        yStart: number;

        elevationStart: number;

        xEnd: number;

        yEnd: number;

        elevationEnd: number;

        offset: number;

        lengthFontSize: number;

        defaultStyle: TextStyle;

        color: number;

        visibleIn3D: boolean;

        pitch: number;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], modifiedDimensionLines: DimensionLineController.ModifiedDimensionLine[], xStart: number, yStart: number, elevationStart: number, xEnd: number, yEnd: number, elevationEnd: number, offset: number, lengthFontSize: number, defaultStyle: TextStyle, color: number, visibleIn3D: boolean, pitch: number) {
            super(preferences, DimensionLineController, "undoModifyDimensionLinesName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.modifiedDimensionLines === undefined) { this.modifiedDimensionLines = null; }
            if (this.xStart === undefined) { this.xStart = null; }
            if (this.yStart === undefined) { this.yStart = null; }
            if (this.elevationStart === undefined) { this.elevationStart = null; }
            if (this.xEnd === undefined) { this.xEnd = null; }
            if (this.yEnd === undefined) { this.yEnd = null; }
            if (this.elevationEnd === undefined) { this.elevationEnd = null; }
            if (this.offset === undefined) { this.offset = null; }
            if (this.lengthFontSize === undefined) { this.lengthFontSize = null; }
            if (this.defaultStyle === undefined) { this.defaultStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.modifiedDimensionLines = modifiedDimensionLines;
            this.xStart = xStart;
            this.yStart = yStart;
            this.elevationStart = elevationStart;
            this.xEnd = xEnd;
            this.yEnd = yEnd;
            this.elevationEnd = elevationEnd;
            this.offset = offset;
            this.lengthFontSize = lengthFontSize;
            this.defaultStyle = defaultStyle;
            this.color = color;
            this.visibleIn3D = visibleIn3D;
            this.pitch = pitch;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            DimensionLineController.undoModifyDimensionLines(this.modifiedDimensionLines);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            DimensionLineController.doModifyDimensionLines(this.modifiedDimensionLines, this.xStart, this.yStart, this.elevationStart, this.xEnd, this.yEnd, this.elevationEnd, this.offset, this.lengthFontSize, this.defaultStyle, this.color, this.visibleIn3D, this.pitch);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }
    }
    DimensionLinesModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.DimensionLineController.DimensionLinesModificationUndoableEdit";
    DimensionLinesModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified dimension line.
     * @param {DimensionLine} dimensionLine
     * @class
     */
    export class ModifiedDimensionLine {
        dimensionLine: DimensionLine;

        xStart: number;

        yStart: number;

        elevationStart: number;

        xEnd: number;

        yEnd: number;

        elevationEnd: number;

        offset: number;

        lengthStyle: TextStyle;

        color: number;

        visibleIn3D: boolean;

        pitch: number;

        public constructor(dimensionLine: DimensionLine) {
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.elevationStart === undefined) { this.elevationStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.elevationEnd === undefined) { this.elevationEnd = 0; }
            if (this.offset === undefined) { this.offset = 0; }
            if (this.lengthStyle === undefined) { this.lengthStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.visibleIn3D === undefined) { this.visibleIn3D = false; }
            if (this.pitch === undefined) { this.pitch = 0; }
            this.dimensionLine = dimensionLine;
            this.xStart = dimensionLine.getXStart();
            this.yStart = dimensionLine.getYStart();
            this.elevationStart = dimensionLine.getElevationStart();
            this.xEnd = dimensionLine.getXEnd();
            this.yEnd = dimensionLine.getYEnd();
            this.elevationEnd = dimensionLine.getElevationEnd();
            this.offset = dimensionLine.getOffset();
            this.lengthStyle = dimensionLine.getLengthStyle();
            this.color = dimensionLine.getColor();
            this.visibleIn3D = dimensionLine.isVisibleIn3D();
            this.pitch = dimensionLine.getPitch();
        }

        public getDimensionLine(): DimensionLine {
            return this.dimensionLine;
        }

        public reset() {
            this.dimensionLine.setXStart(this.xStart);
            this.dimensionLine.setYStart(this.yStart);
            this.dimensionLine.setElevationStart(this.elevationStart);
            this.dimensionLine.setXEnd(this.xEnd);
            this.dimensionLine.setYEnd(this.yEnd);
            this.dimensionLine.setElevationEnd(this.elevationEnd);
            this.dimensionLine.setOffset(this.offset);
            this.dimensionLine.setLengthStyle(this.lengthStyle);
            this.dimensionLine.setColor(this.color);
            this.dimensionLine.setVisibleIn3D(this.visibleIn3D);
            this.dimensionLine.setPitch(this.pitch);
        }
    }
    ModifiedDimensionLine["__class"] = "com.eteks.sweethome3d.viewcontroller.DimensionLineController.ModifiedDimensionLine";

}


/**
 * Creates the controller of home view.
 * @param {Home} home the home edited by this controller and its view.
 * @param {HomeApplication} application the instance of current application.
 * @param {Object} viewFactory a factory able to create views.
 * @param {Object} contentManager the content manager of the application.
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ application: HomeApplication;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ undoManager: javax.swing.undo.UndoManager;

    /*private*/ homeView: HomeView;

    /*private*/ childControllers: Array<Controller>;

    /*private*/ furnitureCatalogController: FurnitureCatalogController;

    /*private*/ furnitureController: FurnitureController;

    /*private*/ planController: PlanController;

    /*private*/ homeController3D: HomeController3D;

    static helpController: any = null;

    /*private*/ saveUndoLevel: number;

    /*private*/ notUndoableModifications: boolean;

    /*private*/ focusedView: View;

    public constructor(home?: any, application?: any, preferences?: any, viewFactory?: any, contentManager?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((application != null && application instanceof <any>HomeApplication) || application === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null)) {
            let __args = arguments;
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.application === undefined) { this.application = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.undoManager === undefined) { this.undoManager = null; }
            if (this.homeView === undefined) { this.homeView = null; }
            if (this.childControllers === undefined) { this.childControllers = null; }
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.homeController3D === undefined) { this.homeController3D = null; }
            if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
            if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
            if (this.focusedView === undefined) { this.focusedView = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.contentManager = contentManager;
            this.application = application;
            this.undoSupport = new HomeController.HomeController$0(this);
            this.undoManager = new javax.swing.undo.UndoManager();
            this.undoSupport.addUndoableEditListener(this.undoManager);
            this.notUndoableModifications = home.isModified();
            if (home.getName() != null) {
                const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
                /* remove */(a => { let index = a.indexOf(home.getName()); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(recentHomes);
                /* add */recentHomes.splice(0, 0, home.getName());
                this.updateUserPreferencesRecentHomes(recentHomes);
            }
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((application != null && application instanceof <any>HomeApplication) || application === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && contentManager === undefined) {
            let __args = arguments;
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let preferences: any = __args[1].getUserPreferences();
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.application === undefined) { this.application = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.undoManager === undefined) { this.undoManager = null; }
                if (this.homeView === undefined) { this.homeView = null; }
                if (this.childControllers === undefined) { this.childControllers = null; }
                if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.planController === undefined) { this.planController = null; }
                if (this.homeController3D === undefined) { this.homeController3D = null; }
                if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
                if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
                if (this.focusedView === undefined) { this.focusedView = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.application = application;
                this.undoSupport = new HomeController.HomeController$0(this);
                this.undoManager = new javax.swing.undo.UndoManager();
                this.undoSupport.addUndoableEditListener(this.undoManager);
                this.notUndoableModifications = home.isModified();
                if (home.getName() != null) {
                    const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
                    /* remove */(a => { let index = a.indexOf(home.getName()); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(recentHomes);
                    /* add */recentHomes.splice(0, 0, home.getName());
                    this.updateUserPreferencesRecentHomes(recentHomes);
                }
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.application === undefined) { this.application = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.undoManager === undefined) { this.undoManager = null; }
            if (this.homeView === undefined) { this.homeView = null; }
            if (this.childControllers === undefined) { this.childControllers = null; }
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.homeController3D === undefined) { this.homeController3D = null; }
            if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
            if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
            if (this.focusedView === undefined) { this.focusedView = null; }
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((application != null && application instanceof <any>UserPreferences) || application === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && contentManager === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let application: any = null;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.application === undefined) { this.application = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.undoManager === undefined) { this.undoManager = null; }
                if (this.homeView === undefined) { this.homeView = null; }
                if (this.childControllers === undefined) { this.childControllers = null; }
                if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.planController === undefined) { this.planController = null; }
                if (this.homeController3D === undefined) { this.homeController3D = null; }
                if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
                if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
                if (this.focusedView === undefined) { this.focusedView = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.application = application;
                this.undoSupport = new HomeController.HomeController$0(this);
                this.undoManager = new javax.swing.undo.UndoManager();
                this.undoSupport.addUndoableEditListener(this.undoManager);
                this.notUndoableModifications = home.isModified();
                if (home.getName() != null) {
                    const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
                    /* remove */(a => { let index = a.indexOf(home.getName()); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(recentHomes);
                    /* add */recentHomes.splice(0, 0, home.getName());
                    this.updateUserPreferencesRecentHomes(recentHomes);
                }
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.application === undefined) { this.application = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.undoManager === undefined) { this.undoManager = null; }
            if (this.homeView === undefined) { this.homeView = null; }
            if (this.childControllers === undefined) { this.childControllers = null; }
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.homeController3D === undefined) { this.homeController3D = null; }
            if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
            if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
            if (this.focusedView === undefined) { this.focusedView = null; }
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((application != null && application instanceof <any>HomeApplication) || application === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && viewFactory === undefined && contentManager === undefined) {
            let __args = arguments;
            let viewFactory: any = __args[2];
            {
                let __args = arguments;
                let preferences: any = __args[1].getUserPreferences();
                let contentManager: any = null;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.application === undefined) { this.application = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.undoManager === undefined) { this.undoManager = null; }
                if (this.homeView === undefined) { this.homeView = null; }
                if (this.childControllers === undefined) { this.childControllers = null; }
                if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.planController === undefined) { this.planController = null; }
                if (this.homeController3D === undefined) { this.homeController3D = null; }
                if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
                if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
                if (this.focusedView === undefined) { this.focusedView = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.application = application;
                this.undoSupport = new HomeController.HomeController$0(this);
                this.undoManager = new javax.swing.undo.UndoManager();
                this.undoSupport.addUndoableEditListener(this.undoManager);
                this.notUndoableModifications = home.isModified();
                if (home.getName() != null) {
                    const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
                    /* remove */(a => { let index = a.indexOf(home.getName()); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(recentHomes);
                    /* add */recentHomes.splice(0, 0, home.getName());
                    this.updateUserPreferencesRecentHomes(recentHomes);
                }
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.application === undefined) { this.application = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.undoManager === undefined) { this.undoManager = null; }
            if (this.homeView === undefined) { this.homeView = null; }
            if (this.childControllers === undefined) { this.childControllers = null; }
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.homeController3D === undefined) { this.homeController3D = null; }
            if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
            if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
            if (this.focusedView === undefined) { this.focusedView = null; }
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((application != null && application instanceof <any>UserPreferences) || application === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && viewFactory === undefined && contentManager === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            {
                let __args = arguments;
                let application: any = null;
                let contentManager: any = null;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.application === undefined) { this.application = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.undoManager === undefined) { this.undoManager = null; }
                if (this.homeView === undefined) { this.homeView = null; }
                if (this.childControllers === undefined) { this.childControllers = null; }
                if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.planController === undefined) { this.planController = null; }
                if (this.homeController3D === undefined) { this.homeController3D = null; }
                if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
                if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
                if (this.focusedView === undefined) { this.focusedView = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.application = application;
                this.undoSupport = new HomeController.HomeController$0(this);
                this.undoManager = new javax.swing.undo.UndoManager();
                this.undoSupport.addUndoableEditListener(this.undoManager);
                this.notUndoableModifications = home.isModified();
                if (home.getName() != null) {
                    const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
                    /* remove */(a => { let index = a.indexOf(home.getName()); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(recentHomes);
                    /* add */recentHomes.splice(0, 0, home.getName());
                    this.updateUserPreferencesRecentHomes(recentHomes);
                }
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.application === undefined) { this.application = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.undoManager === undefined) { this.undoManager = null; }
            if (this.homeView === undefined) { this.homeView = null; }
            if (this.childControllers === undefined) { this.childControllers = null; }
            if (this.furnitureCatalogController === undefined) { this.furnitureCatalogController = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.planController === undefined) { this.planController = null; }
            if (this.homeController3D === undefined) { this.homeController3D = null; }
            if (this.saveUndoLevel === undefined) { this.saveUndoLevel = 0; }
            if (this.notUndoableModifications === undefined) { this.notUndoableModifications = false; }
            if (this.focusedView === undefined) { this.focusedView = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Enables actions at controller instantiation.
     * @param {Object} homeView
     * @private
     */
    enableDefaultActions(homeView: HomeView) {
        const applicationExists: boolean = this.application != null;
        homeView.setEnabled(HomeView.ActionType.NEW_HOME, applicationExists);
        homeView.setEnabled(HomeView.ActionType.NEW_HOME_FROM_EXAMPLE, applicationExists);
        homeView.setEnabled(HomeView.ActionType.OPEN, applicationExists);
        homeView.setEnabled(HomeView.ActionType.DELETE_RECENT_HOMES, applicationExists && !/* isEmpty */(this.preferences.getRecentHomes().length == 0));
        homeView.setEnabled(HomeView.ActionType.CLOSE, applicationExists);
        homeView.setEnabled(HomeView.ActionType.SAVE, applicationExists);
        homeView.setEnabled(HomeView.ActionType.SAVE_AS, applicationExists);
        homeView.setEnabled(HomeView.ActionType.SAVE_AND_COMPRESS, applicationExists);
        homeView.setEnabled(HomeView.ActionType.PAGE_SETUP, true);
        homeView.setEnabled(HomeView.ActionType.PRINT_PREVIEW, true);
        homeView.setEnabled(HomeView.ActionType.PRINT, true);
        homeView.setEnabled(HomeView.ActionType.PRINT_TO_PDF, true);
        homeView.setEnabled(HomeView.ActionType.PREFERENCES, true);
        homeView.setEnabled(HomeView.ActionType.EXIT, applicationExists);
        homeView.setEnabled(HomeView.ActionType.IMPORT_FURNITURE, true);
        homeView.setEnabled(HomeView.ActionType.IMPORT_FURNITURE_LIBRARY, true);
        homeView.setEnabled(HomeView.ActionType.IMPORT_TEXTURE, true);
        homeView.setEnabled(HomeView.ActionType.IMPORT_TEXTURES_LIBRARY, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_NAME, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_DESCRIPTION, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_CREATOR, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_LICENSE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_WIDTH, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_DEPTH, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_X, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_Y, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_ANGLE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_LEVEL, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_MODEL_SIZE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_COLOR, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_TYPE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_PRICE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, true);
        homeView.setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, this.home.getFurnitureSortedPropertyName() != null);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_NAME, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_DESCRIPTION, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_CREATOR, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_LICENSE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_WIDTH, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_DEPTH, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_X, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_Y, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_ANGLE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_LEVEL, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_MODEL_SIZE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_COLOR, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_PRICE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, true);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, true);
        {
            let array = this.home.getFurnitureAdditionalProperties();
            for (let index = 0; index < array.length; index++) {
                let property = array[index];
                {
                    homeView.setActionEnabled(HomeView.SORT_HOME_FURNITURE_ADDITIONAL_PROPERTY_ACTION_PREFIX + property.getName(), true);
                    homeView.setActionEnabled(HomeView.DISPLAY_HOME_FURNITURE_ADDITIONAL_PROPERTY_ACTION_PREFIX + property.getName(), true);
                }
            }
        }
        homeView.setEnabled(HomeView.ActionType.EXPORT_TO_CSV, true);
        homeView.setEnabled(HomeView.ActionType.SELECT, true);
        homeView.setEnabled(HomeView.ActionType.PAN, true);
        homeView.setEnabled(HomeView.ActionType.LOCK_BASE_PLAN, true);
        homeView.setEnabled(HomeView.ActionType.UNLOCK_BASE_PLAN, true);
        homeView.setEnabled(HomeView.ActionType.ENABLE_MAGNETISM, true);
        homeView.setEnabled(HomeView.ActionType.DISABLE_MAGNETISM, true);
        homeView.setEnabled(HomeView.ActionType.MODIFY_COMPASS, true);
        const selectedLevel: Level = this.home.getSelectedLevel();
        this.enableBackgroungImageActions(homeView, selectedLevel != null ? selectedLevel.getBackgroundImage() : this.home.getBackgroundImage());
        this.enableLevelActions(homeView);
        homeView.setEnabled(HomeView.ActionType.ZOOM_IN, true);
        homeView.setEnabled(HomeView.ActionType.ZOOM_OUT, true);
        homeView.setEnabled(HomeView.ActionType.EXPORT_TO_SVG, true);
        homeView.setEnabled(HomeView.ActionType.VIEW_FROM_TOP, true);
        homeView.setEnabled(HomeView.ActionType.VIEW_FROM_OBSERVER, true);
        homeView.setEnabled(HomeView.ActionType.MODIFY_OBSERVER, this.home.getCamera() === this.home.getObserverCamera());
        homeView.setEnabled(HomeView.ActionType.STORE_POINT_OF_VIEW, true);
        const emptyStoredCameras: boolean = /* isEmpty */(this.home.getStoredCameras().length == 0);
        homeView.setEnabled(HomeView.ActionType.DELETE_POINTS_OF_VIEW, !emptyStoredCameras);
        homeView.setEnabled(HomeView.ActionType.CREATE_PHOTOS_AT_POINTS_OF_VIEW, !emptyStoredCameras);
        homeView.setEnabled(HomeView.ActionType.DETACH_3D_VIEW, true);
        homeView.setEnabled(HomeView.ActionType.ATTACH_3D_VIEW, true);
        homeView.setEnabled(HomeView.ActionType.VIEW_FROM_OBSERVER, true);
        homeView.setEnabled(HomeView.ActionType.MODIFY_3D_ATTRIBUTES, true);
        homeView.setEnabled(HomeView.ActionType.CREATE_PHOTO, true);
        homeView.setEnabled(HomeView.ActionType.CREATE_VIDEO, true);
        homeView.setEnabled(HomeView.ActionType.EXPORT_TO_OBJ, true);
        homeView.setEnabled(HomeView.ActionType.HELP, true);
        homeView.setEnabled(HomeView.ActionType.ABOUT, true);
        this.enableCreationToolsActions(homeView);
        homeView.setTransferEnabled(true);
    }

    /**
     * Enables actions handling levels.
     * @param {Object} homeView
     * @private
     */
    enableLevelActions(homeView: HomeView) {
        const modificationState: boolean = this.getPlanController().isModificationState();
        homeView.setEnabled(HomeView.ActionType.ADD_LEVEL, !modificationState);
        homeView.setEnabled(HomeView.ActionType.ADD_LEVEL_AT_SAME_ELEVATION, !modificationState);
        const levels: Array<Level> = this.home.getLevels();
        const selectedLevel: Level = this.home.getSelectedLevel();
        const homeContainsOneSelectedLevel: boolean = /* size */(<number>levels.length) > 1 && selectedLevel != null;
        homeView.setEnabled(HomeView.ActionType.SELECT_ALL_AT_ALL_LEVELS, !modificationState && /* size */(<number>levels.length) > 1);
        homeView.setEnabled(HomeView.ActionType.MAKE_LEVEL_VIEWABLE, !modificationState && homeContainsOneSelectedLevel);
        homeView.setEnabled(HomeView.ActionType.MAKE_LEVEL_UNVIEWABLE, !modificationState && homeContainsOneSelectedLevel);
        homeView.setEnabled(HomeView.ActionType.MAKE_LEVEL_ONLY_VIEWABLE_ONE, homeContainsOneSelectedLevel);
        homeView.setEnabled(HomeView.ActionType.MAKE_ALL_LEVELS_VIEWABLE, /* size */(<number>levels.length) > 1);
        homeView.setEnabled(HomeView.ActionType.MODIFY_LEVEL, homeContainsOneSelectedLevel);
        homeView.setEnabled(HomeView.ActionType.DELETE_LEVEL, !modificationState && homeContainsOneSelectedLevel);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_ALL_LEVELS, /* size */(<number>levels.length) > 1);
        homeView.setEnabled(HomeView.ActionType.DISPLAY_SELECTED_LEVEL, /* size */(<number>levels.length) > 1);
    }

    /**
     * Enables plan actions depending on the selected level is viewable or not.
     * @param {Object} homeView
     * @private
     */
    enableCreationToolsActions(homeView: HomeView) {
        const selectedLevel: Level = this.home.getSelectedLevel();
        const viewableLevel: boolean = selectedLevel == null || selectedLevel.isViewable();
        homeView.setEnabled(HomeView.ActionType.CREATE_WALLS, viewableLevel);
        homeView.setEnabled(HomeView.ActionType.CREATE_ROOMS, viewableLevel);
        homeView.setEnabled(HomeView.ActionType.CREATE_POLYLINES, viewableLevel);
        homeView.setEnabled(HomeView.ActionType.CREATE_DIMENSION_LINES, viewableLevel);
        homeView.setEnabled(HomeView.ActionType.CREATE_LABELS, viewableLevel);
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): HomeView {
        if (this.homeView == null) {
            this.homeView = this.viewFactory.createHomeView(this.home, this.preferences, this);
            this.enableDefaultActions(this.homeView);
            this.addListeners();
            if (this.home.getName() != null && this.home.getVersion() > Home.CURRENT_VERSION) {
                this.homeView.invokeLater(() => {
                    const message: string = this.preferences.getLocalizedString(HomeController, "moreRecentVersionHome", this.home.getName());
                    this.getView().showMessage(message);
                });
            }
        }
        return this.homeView;
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Returns the furniture catalog controller managed by this controller.
     * @return {FurnitureCatalogController}
     */
    public getFurnitureCatalogController(): FurnitureCatalogController {
        if (this.furnitureCatalogController == null) {
            this.furnitureCatalogController = new FurnitureCatalogController(this.preferences.getFurnitureCatalog(), this.preferences, this.viewFactory, this.contentManager);
        }
        return this.furnitureCatalogController;
    }

    /**
     * Returns the furniture controller managed by this controller.
     * @return {FurnitureController}
     */
    public getFurnitureController(): FurnitureController {
        if (this.furnitureController == null) {
            this.furnitureController = new FurnitureController(this.home, this.preferences, this.viewFactory, this.contentManager, this.getUndoableEditSupport());
        }
        return this.furnitureController;
    }

    /**
     * Returns the controller of home plan.
     * @return {PlanController}
     */
    public getPlanController(): PlanController {
        if (this.planController == null) {
            this.planController = new PlanController(this.home, this.preferences, this.viewFactory, this.contentManager, this.getUndoableEditSupport());
        }
        return this.planController;
    }

    /**
     * Returns the controller of home 3D view.
     * @return {HomeController3D}
     */
    public getHomeController3D(): HomeController3D {
        if (this.homeController3D == null) {
            this.homeController3D = new HomeController3D(this.home, this.getPlanController(), this.preferences, this.viewFactory, this.contentManager, this.getUndoableEditSupport());
        }
        return this.homeController3D;
    }

    /**
     * Returns the undoable edit support managed by this controller.
     * @return {javax.swing.undo.UndoableEditSupport}
     */
    getUndoableEditSupport(): javax.swing.undo.UndoableEditSupport {
        return this.undoSupport;
    }

    /**
     * Adds listeners that updates the enabled / disabled state of actions.
     * @private
     */
    addListeners() {
        this.preferences.getFurnitureCatalog().addFurnitureListener(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(new HomeController.FurnitureCatalogChangeListener(this)));
        this.preferences.getTexturesCatalog().addTexturesListener(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(new HomeController.TexturesCatalogChangeListener(this)));
        this.preferences.addPropertyChangeListener(new HomeController.UserPreferencesPropertiesChangeListener(this));
        this.addCatalogSelectionListener();
        this.addHomeBackgroundImageListener();
        this.addNotUndoableModificationListeners();
        this.addHomeSelectionListener();
        this.addFurnitureSortListener();
        this.addUndoSupportListener();
        this.addHomeItemsListener();
        this.addLevelListeners();
        this.addStoredCamerasListener();
        this.addPlanControllerListeners();
        this.addLanguageListener();
    }

    /**
     * Adds a selection listener to catalog that enables / disables Add Furniture action.
     * @private
     */
    addCatalogSelectionListener() {
        this.getFurnitureCatalogController().addSelectionListener(new HomeController.HomeController$1(this));
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * undo and redo presentation names when preferred language changes.
     * @private
     */
    addLanguageListener() {
        this.preferences.addPropertyChangeListener("LANGUAGE", new HomeController.LanguageChangeListener(this));
    }

    /**
     * Adds a selection listener to home that enables / disables actions on selection.
     * @private
     */
    addHomeSelectionListener() {
        if (this.home != null) {
            this.home.addSelectionListener(new HomeController.HomeController$2(this));
        }
    }

    /**
     * Adds a property change listener to home that enables / disables sort order action.
     * @private
     */
    addFurnitureSortListener() {
        if (this.home != null) {
            this.home.addPropertyChangeListener("FURNITURE_SORTED_PROPERTY", new HomeController.HomeController$3(this));
        }
    }

    /**
     * Adds a property change listener to home that enables / disables background image actions.
     * @private
     */
    addHomeBackgroundImageListener() {
        if (this.home != null) {
            this.home.addPropertyChangeListener("BACKGROUND_IMAGE", new HomeController.HomeController$4(this));
        }
    }

    /**
     * Enables background image actions.
     * @param {Object} homeView
     * @param {BackgroundImage} backgroundImage
     * @private
     */
    enableBackgroungImageActions(homeView: HomeView, backgroundImage: BackgroundImage) {
        const selectedLevel: Level = this.home.getSelectedLevel();
        const homeHasBackgroundImage: boolean = backgroundImage != null && (selectedLevel == null || selectedLevel.isViewable());
        this.getView().setEnabled(HomeView.ActionType.IMPORT_BACKGROUND_IMAGE, !homeHasBackgroundImage);
        this.getView().setEnabled(HomeView.ActionType.MODIFY_BACKGROUND_IMAGE, homeHasBackgroundImage);
        this.getView().setEnabled(HomeView.ActionType.HIDE_BACKGROUND_IMAGE, homeHasBackgroundImage && backgroundImage.isVisible());
        this.getView().setEnabled(HomeView.ActionType.SHOW_BACKGROUND_IMAGE, homeHasBackgroundImage && !backgroundImage.isVisible());
        this.getView().setEnabled(HomeView.ActionType.DELETE_BACKGROUND_IMAGE, homeHasBackgroundImage);
    }

    /**
     * Adds listeners to track property changes that are not undoable.
     * @private
     */
    addNotUndoableModificationListeners() {
        if (this.home != null) {
            const notUndoableModificationListener: PropertyChangeListener = new HomeController.HomeController$5(this);
            this.home.addPropertyChangeListener("STORED_CAMERAS", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("OBSERVER_CAMERA_ELEVATION_ADJUSTED", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("VIDEO_WIDTH", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("VIDEO_ASPECT_RATIO", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("VIDEO_FRAME_RATE", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("VIDEO_QUALITY", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("VIDEO_CAMERA_PATH", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("CEILING_LIGHT_COLOR", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("PHOTO_QUALITY", notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("PHOTO_ASPECT_RATIO", notUndoableModificationListener);
            const photoSizeModificationListener: PropertyChangeListener = new HomeController.HomeController$6(this, notUndoableModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("PHOTO_WIDTH", photoSizeModificationListener);
            this.home.getEnvironment().addPropertyChangeListener("PHOTO_HEIGHT", photoSizeModificationListener);
            const timeOrLensModificationListener: PropertyChangeListener = new HomeController.HomeController$7(this, notUndoableModificationListener);
            this.home.getObserverCamera().addPropertyChangeListener(timeOrLensModificationListener);
            this.home.getTopCamera().addPropertyChangeListener(timeOrLensModificationListener);
        }
    }

    /**
     * Enables or disables action bound to selection.
     * This method will be called when selection in plan or in catalog changes and when
     * focused component or modification state in plan changes.
     */
    enableActionsBoundToSelection() {
        const modificationState: boolean = this.getPlanController().isModificationState();
        const catalogSelectedItems: Array<CatalogPieceOfFurniture> = this.getFurnitureCatalogController().getSelectedFurniture();
        const catalogSelectionContainsFurniture: boolean = !/* isEmpty */(catalogSelectedItems.length == 0);
        const catalogSelectionContainsOneModifiablePiece: boolean = /* size */(<number>catalogSelectedItems.length) === 1 && /* get */catalogSelectedItems[0].isModifiable();
        const selectedItems: Array<Selectable> = this.home.getSelectedItems();
        let homeSelectionContainsDeletableItems: boolean = false;
        let homeSelectionContainsFurniture: boolean = false;
        let homeSelectionContainsDeletableFurniture: boolean = false;
        let homeSelectionContainsOneCopiableItemOrMore: boolean = false;
        let homeSelectionContainsOneMovablePieceOfFurnitureOrMore: boolean = false;
        let homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore: boolean = false;
        let homeSelectionContainsTwoMovableGroupablePiecesOfFurnitureOrMore: boolean = false;
        let homeSelectionContainsThreeMovablePiecesOfFurnitureOrMore: boolean = false;
        const homeSelectionContainsOnlyOneGroup: boolean = /* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>HomeFurnitureGroup);
        let homeSelectionContainsFurnitureGroup: boolean = false;
        let homeSelectionContainsWalls: boolean = false;
        let homeSelectionContainsOneWall: boolean = false;
        let homeSelectionContainsOneOrTwoWallsWithOneFreeEnd: boolean = false;
        let homeSelectionContainsRooms: boolean = false;
        let homeSelectionContainsOnlyOneRoom: boolean = false;
        let homeSelectionContainsOnlyOneRoomWithFourPointsOrMore: boolean = false;
        let homeSelectionContainsPolylines: boolean = false;
        let homeSelectionContainsDimensionLines: boolean = false;
        let homeSelectionContainsLabels: boolean = false;
        let homeSelectionContainsItemsWithText: boolean = false;
        let homeSelectionContainsCompass: boolean = false;
        const furnitureController: FurnitureController = this.getFurnitureController();
        if (!modificationState) {
            for (let index = 0; index < selectedItems.length; index++) {
                let item = selectedItems[index];
                {
                    if (this.getPlanController().isItemDeletable(item)) {
                        homeSelectionContainsDeletableItems = true;
                        break;
                    }
                }
            }
            const selectedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(selectedItems);
            homeSelectionContainsFurniture = !/* isEmpty */(selectedFurniture.length == 0);
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    if (furnitureController.isPieceOfFurnitureDeletable(piece)) {
                        homeSelectionContainsDeletableFurniture = true;
                        break;
                    }
                }
            }
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        homeSelectionContainsFurnitureGroup = true;
                        break;
                    }
                }
            }
            let movablePiecesOfFurnitureCount: number = 0;
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    if (furnitureController.isPieceOfFurnitureMovable(piece)) {
                        homeSelectionContainsOneMovablePieceOfFurnitureOrMore = true;
                        movablePiecesOfFurnitureCount++;
                        if (movablePiecesOfFurnitureCount >= 2) {
                            homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore = true;
                        }
                        if (movablePiecesOfFurnitureCount >= 3) {
                            homeSelectionContainsThreeMovablePiecesOfFurnitureOrMore = true;
                            break;
                        }
                    }
                }
            }
            if (homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore) {
                homeSelectionContainsTwoMovableGroupablePiecesOfFurnitureOrMore = true;
                const furniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
                for (let index = 0; index < selectedFurniture.length; index++) {
                    let piece = selectedFurniture[index];
                    {
                        if (!furnitureController.isPieceOfFurnitureMovable(piece) || !/* contains */(furniture.indexOf(<any>(piece)) >= 0)) {
                            homeSelectionContainsTwoMovableGroupablePiecesOfFurnitureOrMore = false;
                            break;
                        }
                    }
                }
            }
            const selectedWalls: Array<Wall> = Home.getWallsSubList(selectedItems);
            homeSelectionContainsWalls = !/* isEmpty */(selectedWalls.length == 0);
            homeSelectionContainsOneWall = /* size */(<number>selectedWalls.length) === 1;
            if (/* size */(<number>selectedWalls.length) >= 2) {
                const wallsWithFreeEnd: Wall[] = [null, null, null];
                for (let index = 0; index < selectedWalls.length; index++) {
                    let wall = selectedWalls[index];
                    {
                        if ((wall.getArcExtent() == null || wall.getArcExtent() === 0.0) && (wall.getWallAtStart() == null || wall.getWallAtEnd() == null)) {
                            for (let i: number = 0; i < wallsWithFreeEnd.length; i++) {
                                {
                                    if (wallsWithFreeEnd[i] == null) {
                                        wallsWithFreeEnd[i] = wall;
                                        break;
                                    }
                                };
                            }
                            if (wallsWithFreeEnd[2] != null) {
                                break;
                            }
                        }
                    }
                }
                homeSelectionContainsOneOrTwoWallsWithOneFreeEnd = wallsWithFreeEnd[2] == null && wallsWithFreeEnd[0] != null && (wallsWithFreeEnd[1] == null && !/* contains */(selectedWalls.indexOf(<any>(wallsWithFreeEnd[0].getWallAtStart())) >= 0) && !/* contains */(selectedWalls.indexOf(<any>(wallsWithFreeEnd[0].getWallAtEnd())) >= 0) || wallsWithFreeEnd[0].getWallAtEnd() !== wallsWithFreeEnd[1] && wallsWithFreeEnd[0].getWallAtStart() !== wallsWithFreeEnd[1]);
            }
            const selectedRooms: Array<Room> = Home.getRoomsSubList(selectedItems);
            homeSelectionContainsRooms = !/* isEmpty */(selectedRooms.length == 0);
            homeSelectionContainsOnlyOneRoom = /* size */(<number>selectedItems.length) === 1 && /* size */(<number>selectedRooms.length) === 1;
            homeSelectionContainsOnlyOneRoomWithFourPointsOrMore = homeSelectionContainsOnlyOneRoom && /* get */selectedRooms[0].getPointCount() >= 4;
            homeSelectionContainsDimensionLines = !/* isEmpty */(Home.getDimensionLinesSubList(selectedItems).length == 0);
            homeSelectionContainsPolylines = !/* isEmpty */(Home.getPolylinesSubList(selectedItems).length == 0);
            homeSelectionContainsLabels = !/* isEmpty */(Home.getLabelsSubList(selectedItems).length == 0);
            homeSelectionContainsCompass = /* contains */(selectedItems.indexOf(<any>(this.home.getCompass())) >= 0);
            homeSelectionContainsOneCopiableItemOrMore = homeSelectionContainsFurniture || homeSelectionContainsWalls || homeSelectionContainsRooms || homeSelectionContainsDimensionLines || homeSelectionContainsPolylines || homeSelectionContainsLabels || homeSelectionContainsCompass;
            homeSelectionContainsItemsWithText = homeSelectionContainsFurniture || homeSelectionContainsRooms || homeSelectionContainsDimensionLines || homeSelectionContainsLabels;
        }
        const view: HomeView = this.getView();
        if (this.focusedView === this.getFurnitureCatalogController().getView()) {
            view.setEnabled(HomeView.ActionType.COPY, !modificationState && catalogSelectionContainsFurniture);
            view.setEnabled(HomeView.ActionType.CUT, false);
            view.setEnabled(HomeView.ActionType.DELETE, false);
            for (let index = 0; index < catalogSelectedItems.length; index++) {
                let piece = catalogSelectedItems[index];
                {
                    if (piece.isModifiable()) {
                        view.setEnabled(HomeView.ActionType.DELETE, true);
                        break;
                    }
                }
            }
        } else if (this.focusedView === furnitureController.getView()) {
            view.setEnabled(HomeView.ActionType.COPY, homeSelectionContainsFurniture);
            view.setEnabled(HomeView.ActionType.CUT, homeSelectionContainsDeletableFurniture);
            view.setEnabled(HomeView.ActionType.DELETE, homeSelectionContainsDeletableFurniture);
        } else if (this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView() && this.preferences.isEditingIn3DViewEnabled()) {
            view.setEnabled(HomeView.ActionType.COPY, homeSelectionContainsOneCopiableItemOrMore);
            view.setEnabled(HomeView.ActionType.CUT, homeSelectionContainsDeletableItems);
            view.setEnabled(HomeView.ActionType.DELETE, homeSelectionContainsDeletableItems);
        } else {
            view.setEnabled(HomeView.ActionType.COPY, false);
            view.setEnabled(HomeView.ActionType.CUT, false);
            view.setEnabled(HomeView.ActionType.DELETE, false);
        }
        this.enablePasteToGroupAction();
        this.enablePasteStyleAction();
        const selectedLevel: Level = this.home.getSelectedLevel();
        const viewableLevel: boolean = selectedLevel == null || selectedLevel.isViewable();
        view.setEnabled(HomeView.ActionType.ADD_HOME_FURNITURE, catalogSelectionContainsFurniture && viewableLevel);
        view.setEnabled(HomeView.ActionType.ADD_FURNITURE_TO_GROUP, catalogSelectionContainsFurniture && viewableLevel && homeSelectionContainsOnlyOneGroup);
        view.setEnabled(HomeView.ActionType.DELETE_HOME_FURNITURE, homeSelectionContainsDeletableFurniture);
        view.setEnabled(HomeView.ActionType.DELETE_SELECTION, (catalogSelectionContainsFurniture && this.focusedView === this.getFurnitureCatalogController().getView()) || (homeSelectionContainsDeletableItems && (this.focusedView === furnitureController.getView() || this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView())));
        view.setEnabled(HomeView.ActionType.MODIFY_FURNITURE, (catalogSelectionContainsOneModifiablePiece && this.focusedView === this.getFurnitureCatalogController().getView()) || (homeSelectionContainsFurniture && (this.focusedView === furnitureController.getView() || this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView())));
        view.setEnabled(HomeView.ActionType.MODIFY_WALL, homeSelectionContainsWalls);
        view.setEnabled(HomeView.ActionType.FLIP_HORIZONTALLY, homeSelectionContainsOneCopiableItemOrMore);
        view.setEnabled(HomeView.ActionType.FLIP_VERTICALLY, homeSelectionContainsOneCopiableItemOrMore);
        view.setEnabled(HomeView.ActionType.JOIN_WALLS, homeSelectionContainsOneOrTwoWallsWithOneFreeEnd);
        view.setEnabled(HomeView.ActionType.REVERSE_WALL_DIRECTION, homeSelectionContainsWalls);
        view.setEnabled(HomeView.ActionType.SPLIT_WALL, homeSelectionContainsOneWall);
        view.setEnabled(HomeView.ActionType.MODIFY_ROOM, homeSelectionContainsRooms);
        view.setEnabled(HomeView.ActionType.MODIFY_POLYLINE, homeSelectionContainsPolylines);
        view.setEnabled(HomeView.ActionType.MODIFY_DIMENSION_LINE, homeSelectionContainsDimensionLines);
        view.setEnabled(HomeView.ActionType.MODIFY_LABEL, homeSelectionContainsLabels);
        view.setEnabled(HomeView.ActionType.TOGGLE_BOLD_STYLE, homeSelectionContainsItemsWithText);
        view.setEnabled(HomeView.ActionType.TOGGLE_ITALIC_STYLE, homeSelectionContainsItemsWithText);
        view.setEnabled(HomeView.ActionType.INCREASE_TEXT_SIZE, homeSelectionContainsItemsWithText);
        view.setEnabled(HomeView.ActionType.DECREASE_TEXT_SIZE, homeSelectionContainsItemsWithText);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_TOP, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_BOTTOM, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_LEFT, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_RIGHT, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, homeSelectionContainsTwoMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, homeSelectionContainsThreeMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, homeSelectionContainsThreeMovablePiecesOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.RESET_FURNITURE_ELEVATION, homeSelectionContainsOneMovablePieceOfFurnitureOrMore);
        view.setEnabled(HomeView.ActionType.GROUP_FURNITURE, homeSelectionContainsTwoMovableGroupablePiecesOfFurnitureOrMore && viewableLevel);
        view.setEnabled(HomeView.ActionType.UNGROUP_FURNITURE, homeSelectionContainsFurnitureGroup);
        const selectionMode: boolean = this.getPlanController() != null && this.getPlanController().getMode() === PlanController.Mode.SELECTION_$LI$();
        view.setEnabled(HomeView.ActionType.ADD_ROOM_POINT, homeSelectionContainsOnlyOneRoom && selectionMode);
        view.setEnabled(HomeView.ActionType.DELETE_ROOM_POINT, homeSelectionContainsOnlyOneRoomWithFourPointsOrMore && selectionMode);
        view.setEnabled(HomeView.ActionType.RECOMPUTE_ROOM_POINTS, homeSelectionContainsOnlyOneRoomWithFourPointsOrMore && selectionMode);
    }

    /**
     * Enables clipboard paste action if clipboard isn't empty.
     */
    public enablePasteAction() {
        const view: HomeView = this.getView();
        let pasteEnabled: boolean = false;
        if (this.focusedView === this.getFurnitureController().getView() || this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView() && this.preferences.isEditingIn3DViewEnabled()) {
            const selectedLevel: Level = this.home.getSelectedLevel();
            pasteEnabled = (selectedLevel == null || selectedLevel.isViewable()) && !this.getPlanController().isModificationState() && !view.isClipboardEmpty();
        }
        view.setEnabled(HomeView.ActionType.PASTE, pasteEnabled);
        this.enablePasteToGroupAction();
        this.enablePasteStyleAction();
    }

    /**
     * Enables paste to group action if clipboard contains furniture and
     * home selected item is a furniture group.
     * @private
     */
    enablePasteToGroupAction() {
        const view: HomeView = this.getView();
        let pasteToGroupEnabled: boolean = false;
        if (this.focusedView === this.getFurnitureController().getView() || this.focusedView === this.getPlanController().getView()) {
            const selectedLevel: Level = this.home.getSelectedLevel();
            if ((selectedLevel == null || selectedLevel.isViewable()) && !this.getPlanController().isModificationState()) {
                const selectedItems: Array<Selectable> = this.home.getSelectedItems();
                if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>HomeFurnitureGroup)) {
                    const clipboardItems: Array<Selectable> = view.getClipboardItems();
                    if (clipboardItems != null) {
                        pasteToGroupEnabled = true;
                        for (let index = 0; index < clipboardItems.length; index++) {
                            let item = clipboardItems[index];
                            {
                                if (!(item != null && item instanceof <any>HomePieceOfFurniture)) {
                                    pasteToGroupEnabled = false;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        view.setEnabled(HomeView.ActionType.PASTE_TO_GROUP, pasteToGroupEnabled);
    }

    /**
     * Enables clipboard paste style action if selection contains some items of a class
     * compatible with the clipboard item.
     * @private
     */
    enablePasteStyleAction() {
        const view: HomeView = this.getView();
        let pasteStyleEnabled: boolean = false;
        if ((this.focusedView === this.getFurnitureController().getView() || this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView() && this.preferences.isEditingIn3DViewEnabled()) && !this.getPlanController().isModificationState()) {
            const clipboardItems: Array<Selectable> = view.getClipboardItems();
            if (clipboardItems != null && /* size */(<number>clipboardItems.length) === 1) {
                const clipboardItem: Selectable = /* get */clipboardItems[0];
                {
                    let array = this.home.getSelectedItems();
                    for (let index = 0; index < array.length; index++) {
                        let item = array[index];
                        {
                            if ((item != null && item instanceof <any>HomePieceOfFurniture) && (clipboardItem != null && clipboardItem instanceof <any>HomePieceOfFurniture) || (item != null && item instanceof <any>Wall) && (clipboardItem != null && clipboardItem instanceof <any>Wall) || (item != null && item instanceof <any>Room) && (clipboardItem != null && clipboardItem instanceof <any>Room) || (item != null && item instanceof <any>Polyline) && (clipboardItem != null && clipboardItem instanceof <any>Polyline) || (item != null && item instanceof <any>Label) && (clipboardItem != null && clipboardItem instanceof <any>Label)) {
                                pasteStyleEnabled = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        view.setEnabled(HomeView.ActionType.PASTE_STYLE, pasteStyleEnabled);
    }

    /**
     * Enables select all action if home isn't empty.
     */
    enableSelectAllAction() {
        const view: HomeView = this.getView();
        const modificationState: boolean = this.getPlanController().isModificationState();
        if (this.focusedView === this.getFurnitureController().getView()) {
            view.setEnabled(HomeView.ActionType.SELECT_ALL, !modificationState && /* size */(<number>this.home.getFurniture().length) > 0);
        } else if (this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView()) {
            const homeContainsOneSelectableItemOrMore: boolean = !this.home.isEmpty() || this.home.getCompass().isVisible();
            view.setEnabled(HomeView.ActionType.SELECT_ALL, !modificationState && homeContainsOneSelectableItemOrMore);
        } else {
            view.setEnabled(HomeView.ActionType.SELECT_ALL, false);
        }
    }

    /**
     * Enables zoom actions depending on current scale.
     * @private
     */
    enableZoomActions() {
        const planController: PlanController = this.getPlanController();
        const scale: number = planController.getScale();
        const view: HomeView = this.getView();
        view.setEnabled(HomeView.ActionType.ZOOM_IN, scale < planController.getMaximumScale());
        view.setEnabled(HomeView.ActionType.ZOOM_OUT, scale > planController.getMinimumScale());
    }

    /**
     * Adds undoable edit listener to undo support that enables Undo action.
     * @private
     */
    addUndoSupportListener() {
        this.getUndoableEditSupport().addUndoableEditListener(new HomeController.HomeController$8(this));
        this.home.addPropertyChangeListener("MODIFIED", new HomeController.HomeController$9(this));
    }

    /**
     * Adds a furniture listener to home that enables / disables actions on furniture list change.
     * @private
     */
    addHomeItemsListener() {
        const homeItemsListener: CollectionListener<any> = (ev: CollectionEvent<any>) => {
            if (ev.getType() === CollectionEvent.Type.ADD || ev.getType() === CollectionEvent.Type.DELETE) {
                this.enableSelectAllAction();
            }
        };
        this.home.addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.addWallsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.addRoomsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.addPolylinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.addDimensionLinesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.addLabelsListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(homeItemsListener)))));
        this.home.getCompass().addPropertyChangeListener(new HomeController.HomeController$10(this));
        this.home.addPropertyChangeListener("CAMERA", new HomeController.HomeController$11(this));
    }

    /**
     * Adds a property change listener to home to
     * enable/disable authorized actions according to selected level.
     * @private
     */
    addLevelListeners() {
        const selectedLevelListener: PropertyChangeListener = new HomeController.HomeController$12(this);
        this.home.addPropertyChangeListener("SELECTED_LEVEL", selectedLevelListener);
        const backgroundImageChangeListener: PropertyChangeListener = new HomeController.HomeController$13(this);
        {
            let array = this.home.getLevels();
            for (let index = 0; index < array.length; index++) {
                let level = array[index];
                {
                    level.addPropertyChangeListener(backgroundImageChangeListener);
                }
            }
        }
        this.home.addLevelsListener((ev: CollectionEvent<Level>) => {
            switch ((ev.getType())) {
                case CollectionEvent.Type.ADD:
                    this.home.setSelectedLevel(ev.getItem());
                    ev.getItem().addPropertyChangeListener(backgroundImageChangeListener);
                    break;
                case CollectionEvent.Type.DELETE:
                    selectedLevelListener.propertyChange(null);
                    ev.getItem().removePropertyChangeListener(backgroundImageChangeListener);
                    break;
            }
        });
    }

    /**
     * Adds a property change listener to home to
     * enable/disable authorized actions according to stored cameras change.
     * @private
     */
    addStoredCamerasListener() {
        this.home.addPropertyChangeListener("STORED_CAMERAS", new HomeController.HomeController$14(this));
    }

    /**
     * Adds a property change listener to plan controller to
     * enable/disable authorized actions according to its modification state and the plan scale.
     * @private
     */
    addPlanControllerListeners() {
        this.getPlanController().addPropertyChangeListener("MODIFICATION_STATE", new HomeController.HomeController$15(this));
        this.getPlanController().addPropertyChangeListener("MODE", new HomeController.HomeController$16(this));
        this.getPlanController().addPropertyChangeListener("SCALE", new HomeController.HomeController$17(this));
    }

    /**
     * Adds the selected furniture in catalog to home and selects it.
     */
    public addHomeFurniture() {
        this.addFurniture(null);
    }

    /**
     * Adds the selected furniture in catalog to the selected group and selects it.
     */
    public addFurnitureToGroup() {
        this.addFurniture(<HomeFurnitureGroup><any>/* get */this.home.getSelectedItems()[0]);
    }

    addFurniture(group: HomeFurnitureGroup) {
        this.getPlanController().setMode(PlanController.Mode.SELECTION_$LI$());
        const selectedFurniture: Array<CatalogPieceOfFurniture> = this.getFurnitureCatalogController().getSelectedFurniture();
        if (!/* isEmpty */(selectedFurniture.length == 0)) {
            const addedFurniture: Array<HomePieceOfFurniture> = <any>([]);
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    /* add */(addedFurniture.push(this.getFurnitureController().createHomePieceOfFurniture(piece)) > 0);
                }
            }
            if (group != null) {
                this.getFurnitureController().addFurnitureToGroup(addedFurniture, group);
            } else {
                this.getFurnitureController().addFurniture$java_util_List(addedFurniture);
            }
            this.adjustFurnitureSizeAndElevation(addedFurniture, false);
        }
    }

    /**
     * Modifies the selected furniture of the focused view.
     */
    public modifySelectedFurniture() {
        if (this.focusedView === this.getFurnitureCatalogController().getView()) {
            this.getFurnitureCatalogController().modifySelectedFurniture();
        } else if (this.focusedView === this.getFurnitureController().getView() || this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView()) {
            this.getFurnitureController().modifySelectedFurniture();
        }
    }

    public importLanguageLibrary$() {
        this.getView().invokeLater(() => {
            const languageLibraryName: string = this.getView().showImportLanguageLibraryDialog();
            if (languageLibraryName != null) {
                this.importLanguageLibrary$java_lang_String(languageLibraryName);
            }
        });
    }

    public importLanguageLibrary$java_lang_String(languageLibraryName: string) {
        try {
            if (!this.preferences.languageLibraryExists(languageLibraryName) || this.getView().confirmReplaceLanguageLibrary(languageLibraryName)) {
                this.preferences.addLanguageLibrary(languageLibraryName);
            }
        } catch (ex) {
            const message: string = this.preferences.getLocalizedString(HomeController, "importLanguageLibraryError", languageLibraryName);
            this.getView().showError(message);
        }
    }

    /**
     * Imports a given language library.
     * @param {string} languageLibraryName
     */
    public importLanguageLibrary(languageLibraryName?: any) {
        if (((typeof languageLibraryName === 'string') || languageLibraryName === null)) {
            return <any>this.importLanguageLibrary$java_lang_String(languageLibraryName);
        } else if (languageLibraryName === undefined) {
            return <any>this.importLanguageLibrary$();
        } else throw new Error('invalid overload');
    }

    /**
     * Imports furniture to the catalog or home depending on the focused view.
     */
    public importFurniture() {
        this.getPlanController().setMode(PlanController.Mode.SELECTION_$LI$());
        if (this.focusedView === this.getFurnitureCatalogController().getView()) {
            this.getFurnitureCatalogController().importFurniture$();
        } else {
            this.getFurnitureController().importFurniture$();
        }
    }

    public importFurnitureLibrary$() {
        this.getView().invokeLater(() => {
            const furnitureLibraryName: string = this.getView().showImportFurnitureLibraryDialog();
            if (furnitureLibraryName != null) {
                this.importFurnitureLibrary$java_lang_String(furnitureLibraryName);
            }
        });
    }

    public importFurnitureLibrary$java_lang_String(furnitureLibraryName: string) {
        try {
            if (!this.preferences.furnitureLibraryExists(furnitureLibraryName) || this.getView().confirmReplaceFurnitureLibrary(furnitureLibraryName)) {
                this.preferences.addFurnitureLibrary(furnitureLibraryName);
                this.getView().showMessage(this.preferences.getLocalizedString(HomeController, "importedFurnitureLibraryMessage", this.contentManager != null ? this.contentManager.getPresentationName(furnitureLibraryName, ContentManager.ContentType.FURNITURE_LIBRARY) : furnitureLibraryName));
            }
        } catch (ex) {
            const message: string = this.preferences.getLocalizedString(HomeController, "importFurnitureLibraryError", furnitureLibraryName);
            this.getView().showError(message);
        }
    }

    /**
     * Imports a given furniture library.
     * @param {string} furnitureLibraryName
     */
    public importFurnitureLibrary(furnitureLibraryName?: any) {
        if (((typeof furnitureLibraryName === 'string') || furnitureLibraryName === null)) {
            return <any>this.importFurnitureLibrary$java_lang_String(furnitureLibraryName);
        } else if (furnitureLibraryName === undefined) {
            return <any>this.importFurnitureLibrary$();
        } else throw new Error('invalid overload');
    }

    /**
     * Imports a texture to the texture catalog.
     */
    public importTexture() {
        new ImportedTextureWizardController(this.preferences, this.viewFactory, this.contentManager).displayView(this.getView());
    }

    public importTexturesLibrary$() {
        this.getView().invokeLater(() => {
            const texturesLibraryName: string = this.getView().showImportTexturesLibraryDialog();
            if (texturesLibraryName != null) {
                this.importTexturesLibrary$java_lang_String(texturesLibraryName);
            }
        });
    }

    public importTexturesLibrary$java_lang_String(texturesLibraryName: string) {
        try {
            if (!this.preferences.texturesLibraryExists(texturesLibraryName) || this.getView().confirmReplaceTexturesLibrary(texturesLibraryName)) {
                this.preferences.addTexturesLibrary(texturesLibraryName);
                this.getView().showMessage(this.preferences.getLocalizedString(HomeController, "importedTexturesLibraryMessage", this.contentManager != null ? this.contentManager.getPresentationName(texturesLibraryName, ContentManager.ContentType.TEXTURES_LIBRARY) : texturesLibraryName));
            }
        } catch (ex) {
            const message: string = this.preferences.getLocalizedString(HomeController, "importTexturesLibraryError", texturesLibraryName);
            this.getView().showError(message);
        }
    }

    /**
     * Imports a given textures library.
     * @param {string} texturesLibraryName
     */
    public importTexturesLibrary(texturesLibraryName?: any) {
        if (((typeof texturesLibraryName === 'string') || texturesLibraryName === null)) {
            return <any>this.importTexturesLibrary$java_lang_String(texturesLibraryName);
        } else if (texturesLibraryName === undefined) {
            return <any>this.importTexturesLibrary$();
        } else throw new Error('invalid overload');
    }

    /**
     * Undoes last operation.
     */
    public undo() {
        this.undoManager.undo();
        const view: HomeView = this.getView();
        const moreUndo: boolean = this.undoManager.canUndo();
        view.setEnabled(HomeView.ActionType.UNDO, moreUndo);
        view.setEnabled(HomeView.ActionType.REDO, true);
        if (moreUndo) {
            view.setUndoRedoName(this.undoManager.getUndoPresentationName(), this.undoManager.getRedoPresentationName());
        } else {
            view.setUndoRedoName(null, this.undoManager.getRedoPresentationName());
        }
        this.saveUndoLevel--;
        this.home.setModified(this.saveUndoLevel !== 0 || this.notUndoableModifications);
    }

    /**
     * Redoes last undone operation.
     */
    public redo() {
        this.undoManager.redo();
        const view: HomeView = this.getView();
        const moreRedo: boolean = this.undoManager.canRedo();
        view.setEnabled(HomeView.ActionType.UNDO, true);
        view.setEnabled(HomeView.ActionType.REDO, moreRedo);
        if (moreRedo) {
            view.setUndoRedoName(this.undoManager.getUndoPresentationName(), this.undoManager.getRedoPresentationName());
        } else {
            view.setUndoRedoName(this.undoManager.getUndoPresentationName(), null);
        }
        this.saveUndoLevel++;
        this.home.setModified(this.saveUndoLevel !== 0 || this.notUndoableModifications);
    }

    /**
     * Deletes items and post a cut operation to undo support.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     */
    public cut(items: Array<any>) {
        const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
        undoSupport.beginUpdate();
        this.getPlanController().deleteItems(items);
        undoSupport.postEdit(new LocalizedUndoableEdit(this.preferences, HomeController, "undoCutName"));
        undoSupport.endUpdate();
    }

    /**
     * Adds items to home and posts a paste operation to undo support.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     */
    public paste(items: Array<any>) {
        const selectedItems: Array<Selectable> = this.home.getSelectedItems();
        let pastedItemsDelta: number = 0;
        if (/* size */(<number>items.length) === /* size */(<number>selectedItems.length)) {
            pastedItemsDelta = 20;
            for (let index = 0; index < items.length; index++) {
                let pastedItem = items[index];
                {
                    const pastedItemPoints: number[][] = pastedItem.getPoints();
                    let pastedItemOverlapSelectedItem: boolean = false;
                    for (let index1 = 0; index1 < selectedItems.length; index1++) {
                        let selectedItem = selectedItems[index1];
                        {
                            if (/* deepEquals */(JSON.stringify(pastedItemPoints) === JSON.stringify(selectedItem.getPoints()))) {
                                pastedItemOverlapSelectedItem = true;
                                break;
                            }
                        }
                    }
                    if (!pastedItemOverlapSelectedItem) {
                        pastedItemsDelta = 0;
                        break;
                    }
                }
            }
        }
        this.addPastedItems(items, null, pastedItemsDelta, pastedItemsDelta, null, "undoPasteName");
    }

    public drop$java_util_List$float$float(items: Array<any>, dx: number, dy: number) {
        this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$float$float(items, null, dx, dy);
    }

    public drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$float$float(items: Array<any>, destinationView: View, dx: number, dy: number) {
        this.addPastedItems(items, destinationView, dx, dy, null, "undoDropName");
    }

    public drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$com_eteks_sweethome3d_model_Level$float$float$java_lang_Float(items: Array<any>, destinationView: View, level: Level, dx: number, dy: number, dz: number) {
        const oldSelectedLevel: Level = this.home.getSelectedLevel();
        if (level !== oldSelectedLevel || dz != null && /* size */(<number>items.length) === 1 && (/* get */items[0] != null && /* get */items[0] instanceof <any>HomePieceOfFurniture) && this.application.getUserPreferences().isMagnetismEnabled()) {
            const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
            undoSupport.beginUpdate();
            const piece: HomePieceOfFurniture = <any>/* get */items[0];
            piece.setElevation(<number>Math.max(0, dz));
            if (level !== oldSelectedLevel) {
                const selection: Array<Selectable> = this.home.getSelectedItems();
                const selectedItems: Selectable[] = /* toArray */selection.slice(0);
                const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
                this.home.setSelectedLevel(level);
                undoSupport.postEdit(new HomeController.LevelModificationUndoableEdit(this.home, this.preferences, oldSelectedLevel, level, selectedItems, allLevelsSelection));
            }
            this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$float$float(items, destinationView, dx, dy);
            undoSupport.postEdit(new LocalizedUndoableEdit(this.preferences, HomeController, "undoDropName"));
            undoSupport.endUpdate();
        } else {
            this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$float$float(items, destinationView, dx, dy);
        }
    }

    /**
     * Adds items to home, moves them of (dx, dy, dz) delta vector
     * and posts a drop operation to undo support.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @param {Object} destinationView
     * @param {Level} level
     * @param {number} dx
     * @param {number} dy
     * @param {number} dz
     */
    public drop(items?: any, destinationView?: any, level?: any, dx?: any, dy?: any, dz?: any) {
        if (((items != null && (items instanceof Array)) || items === null) && ((destinationView != null && (destinationView.constructor != null && destinationView.constructor["__interfaces"] != null && destinationView.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.View") >= 0)) || destinationView === null) && ((level != null && level instanceof <any>Level) || level === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null) && ((typeof dz === 'number') || dz === null)) {
            return <any>this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$com_eteks_sweethome3d_model_Level$float$float$java_lang_Float(items, destinationView, level, dx, dy, dz);
        } else if (((items != null && (items instanceof Array)) || items === null) && ((destinationView != null && (destinationView.constructor != null && destinationView.constructor["__interfaces"] != null && destinationView.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.View") >= 0)) || destinationView === null) && ((typeof level === 'number') || level === null) && ((typeof dx === 'number') || dx === null) && dy === undefined && dz === undefined) {
            return <any>this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$float$float(items, destinationView, level, dx);
        } else if (((items != null && (items instanceof Array)) || items === null) && ((destinationView != null && (destinationView.constructor != null && destinationView.constructor["__interfaces"] != null && destinationView.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.View") >= 0)) || destinationView === null) && ((level != null && (level.constructor != null && level.constructor["__interfaces"] != null && level.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Selectable") >= 0)) || level === null) && dx === undefined && dy === undefined && dz === undefined) {
            return <any>this.drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$com_eteks_sweethome3d_model_Selectable(items, destinationView, level);
        } else if (((items != null && (items instanceof Array)) || items === null) && ((typeof destinationView === 'number') || destinationView === null) && ((typeof level === 'number') || level === null) && dx === undefined && dy === undefined && dz === undefined) {
            return <any>this.drop$java_util_List$float$float(items, destinationView, level);
        } else throw new Error('invalid overload');
    }

    public drop$java_util_List$com_eteks_sweethome3d_viewcontroller_View$com_eteks_sweethome3d_model_Selectable(items: Array<any>, destinationView: View, beforeItem: Selectable) {
        this.addPastedItems(items, destinationView, 0, 0, beforeItem, "undoDropName");
    }

    /**
     * Adds items to home.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @param {Object} destinationView
     * @param {number} dx
     * @param {number} dy
     * @param {Object} beforeItem
     * @param {string} presentationNameKey
     * @private
     */
    addPastedItems(items: Array<any>, destinationView: View, dx: number, dy: number, beforeItem: Selectable, presentationNameKey: string) {
        if (/* size */(<number>items.length) > 1 || (/* size */(<number>items.length) === 1 && !(/* get */items[0] != null && /* get */items[0] instanceof <any>Compass))) {
            const compassList: Array<Compass> = Home.getSubList<any>(items, Compass);
            if (/* size */(<number>compassList.length) !== 0) {
                items = <any>(items.slice(0));
                /* removeAll */((a, r) => { let b = false; for (let i = 0; i < r.length; i++) { let ndx = a.indexOf(r[i]); if (ndx >= 0) { a.splice(ndx, 1); b = true; } } return b; })(items, compassList);
            }
            this.getPlanController().setMode(PlanController.Mode.SELECTION_$LI$());
            const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
            undoSupport.beginUpdate();
            if (destinationView != null && destinationView === this.getFurnitureController().getView()) {
                this.getFurnitureController().addFurniture$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(Home.getFurnitureSubList(items), <HomePieceOfFurniture><any>beforeItem);
            } else {
                this.getPlanController().addItems(items);
            }
            const addedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(items);
            this.adjustFurnitureSizeAndElevation(addedFurniture, dx === 0 && dy === 0 && destinationView == null);
            this.getPlanController().moveItems(items, dx, dy);
            if (destinationView === this.getPlanController().getView() || destinationView === this.getHomeController3D().getView()) {
                if (this.preferences.isMagnetismEnabled() && /* size */(<number>items.length) === 1 && /* size */(<number>addedFurniture.length) === 1) {
                    this.getPlanController().adjustMagnetizedPieceOfFurniture(<any>/* get */items[0], dx, dy);
                }
            }
            undoSupport.postEdit(new LocalizedUndoableEdit(this.preferences, HomeController, presentationNameKey));
            undoSupport.endUpdate();
        }
    }

    /**
     * Adjusts furniture size and elevation if magnetism is enabled.
     * This method should be called after the given furniture is added to the plan,
     * to ensure its size in plan is adjusted too.
     * @param {HomePieceOfFurniture[]} furniture
     * @param {boolean} keepDoorAndWindowDepth
     * @private
     */
    adjustFurnitureSizeAndElevation(furniture: Array<HomePieceOfFurniture>, keepDoorAndWindowDepth: boolean) {
        if (this.preferences.isMagnetismEnabled()) {
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    if (!(piece != null && piece instanceof <any>HomeFurnitureGroup) && piece.isResizable()) {
                        piece.setWidth(this.preferences.getLengthUnit().getMagnetizedLength(piece.getWidth(), 0.1));
                        if (!(piece != null && piece instanceof <any>HomeDoorOrWindow) || !keepDoorAndWindowDepth) {
                            piece.setDepth(this.preferences.getLengthUnit().getMagnetizedLength(piece.getDepth(), 0.1));
                        }
                        piece.setHeight(this.preferences.getLengthUnit().getMagnetizedLength(piece.getHeight(), 0.1));
                    }
                    piece.setElevation(this.preferences.getLengthUnit().getMagnetizedLength(piece.getElevation(), 0.1));
                }
            }
        }
    }

    /**
     * Adds imported models to home, moves them of (dx, dy)
     * and post a drop operation to undo support.
     * @param {string[]} importableModels
     * @param {number} dx
     * @param {number} dy
     */
    public dropFiles(importableModels: Array<string>, dx: number, dy: number) {
        this.getPlanController().setMode(PlanController.Mode.SELECTION_$LI$());
        const importedFurniture: Array<HomePieceOfFurniture> = <any>([]);
        const addedFurnitureListener: CollectionListener<HomePieceOfFurniture> = (ev: CollectionEvent<HomePieceOfFurniture>) => {
            /* add */(importedFurniture.push(ev.getItem()) > 0);
        };
        this.home.addFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
        const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
        undoSupport.beginUpdate();
        for (let index = 0; index < importableModels.length; index++) {
            let model = importableModels[index];
            {
                this.getFurnitureController().importFurniture$java_lang_String(model);
            }
        }
        this.home.removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(addedFurnitureListener)));
        if (/* size */(<number>importedFurniture.length) > 0) {
            this.getPlanController().moveItems(importedFurniture, dx, dy);
            this.home.setSelectedItems(importedFurniture);
            undoSupport.postEdit(new HomeController.DroppingEndUndoableEdit(this.home, this.preferences, /* toArray */importedFurniture.slice(0)));
        }
        undoSupport.endUpdate();
    }

    /**
     * Paste the furniture in clipboard to the selected group in home.
     */
    public pasteToGroup() {
        const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
        undoSupport.beginUpdate();
        const addedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(this.getView().getClipboardItems());
        this.getFurnitureController().addFurnitureToGroup(addedFurniture, <HomeFurnitureGroup><any>/* get */this.home.getSelectedItems()[0]);
        this.adjustFurnitureSizeAndElevation(addedFurniture, true);
        undoSupport.postEdit(new LocalizedUndoableEdit(this.preferences, HomeController, "undoPasteToGroupName"));
        undoSupport.endUpdate();
    }

    /**
     * Paste the style of the item in clipboard on selected items compatible with it.
     */
    public pasteStyle() {
        const undoSupport: javax.swing.undo.UndoableEditSupport = this.getUndoableEditSupport();
        undoSupport.beginUpdate();
        const clipboardItem: Selectable = /* get */this.getView().getClipboardItems()[0];
        const selectedItems: Array<Selectable> = this.home.getSelectedItems();
        if (clipboardItem != null && clipboardItem instanceof <any>HomePieceOfFurniture) {
            const clipboardPiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>clipboardItem;
            const furnitureController: HomeFurnitureController = new HomeFurnitureController(this.home, this.preferences, this.viewFactory, this.contentManager, undoSupport);
            const materials: HomeMaterial[] = clipboardPiece.getModelMaterials();
            if (materials != null) {
                furnitureController.getModelMaterialsController().setMaterials(clipboardPiece.getModelMaterials());
                furnitureController.setPaint(HomeFurnitureController.FurniturePaint.MODEL_MATERIALS);
            } else if (clipboardPiece.getTexture() != null) {
                furnitureController.getTextureController().setTexture(clipboardPiece.getTexture());
                furnitureController.setPaint(HomeFurnitureController.FurniturePaint.TEXTURED);
            } else if (clipboardPiece.getColor() != null) {
                furnitureController.setColor(clipboardPiece.getColor());
                furnitureController.setPaint(HomeFurnitureController.FurniturePaint.COLORED);
            } else {
                furnitureController.setPaint(HomeFurnitureController.FurniturePaint.DEFAULT);
            }
            const shininess: number = clipboardPiece.getShininess();
            furnitureController.setShininess(shininess == null ? HomeFurnitureController.FurnitureShininess.DEFAULT : (/* floatValue */shininess === 0 ? HomeFurnitureController.FurnitureShininess.MATT : HomeFurnitureController.FurnitureShininess.SHINY));
            furnitureController.modifyFurniture();
        } else if (clipboardItem != null && clipboardItem instanceof <any>Wall) {
            const clipboardWall: Wall = <Wall><any>clipboardItem;
            const wallController: WallController = new WallController(this.home, this.preferences, this.viewFactory, this.contentManager, undoSupport);
            if (clipboardWall.getLeftSideColor() != null) {
                wallController.setLeftSideColor(clipboardWall.getLeftSideColor());
                wallController.setLeftSidePaint(WallController.WallPaint.COLORED);
            } else if (clipboardWall.getLeftSideTexture() != null) {
                wallController.getLeftSideTextureController().setTexture(clipboardWall.getLeftSideTexture());
                wallController.setLeftSidePaint(WallController.WallPaint.TEXTURED);
            } else {
                wallController.setLeftSidePaint(WallController.WallPaint.DEFAULT);
            }
            wallController.setLeftSideShininess(clipboardWall.getLeftSideShininess());
            wallController.getLeftSideBaseboardController().setBaseboard(clipboardWall.getLeftSideBaseboard());
            if (clipboardWall.getRightSideColor() != null) {
                wallController.setRightSideColor(clipboardWall.getRightSideColor());
                wallController.setRightSidePaint(WallController.WallPaint.COLORED);
            } else if (clipboardWall.getRightSideTexture() != null) {
                wallController.getRightSideTextureController().setTexture(clipboardWall.getRightSideTexture());
                wallController.setRightSidePaint(WallController.WallPaint.TEXTURED);
            } else {
                wallController.setRightSidePaint(WallController.WallPaint.DEFAULT);
            }
            wallController.setRightSideShininess(clipboardWall.getRightSideShininess());
            wallController.getRightSideBaseboardController().setBaseboard(clipboardWall.getRightSideBaseboard());
            wallController.setPattern(clipboardWall.getPattern());
            wallController.setTopColor(clipboardWall.getTopColor());
            wallController.setTopPaint(clipboardWall.getTopColor() != null ? WallController.WallPaint.COLORED : WallController.WallPaint.DEFAULT);
            wallController.modifyWalls();
        } else if (clipboardItem != null && clipboardItem instanceof <any>Room) {
            const clipboardRoom: Room = <Room><any>clipboardItem;
            const roomController: RoomController = new RoomController(this.home, this.preferences, this.viewFactory, this.contentManager, undoSupport);
            if (clipboardRoom.getFloorColor() != null) {
                roomController.setFloorColor(clipboardRoom.getFloorColor());
                roomController.setFloorPaint(RoomController.RoomPaint.COLORED);
            } else if (clipboardRoom.getFloorTexture() != null) {
                roomController.getFloorTextureController().setTexture(clipboardRoom.getFloorTexture());
                roomController.setFloorPaint(RoomController.RoomPaint.TEXTURED);
            } else {
                roomController.setFloorPaint(RoomController.RoomPaint.DEFAULT);
            }
            roomController.setFloorShininess(clipboardRoom.getFloorShininess());
            if (clipboardRoom.getCeilingColor() != null) {
                roomController.setCeilingColor(clipboardRoom.getCeilingColor());
                roomController.setCeilingPaint(RoomController.RoomPaint.COLORED);
            } else if (clipboardRoom.getCeilingTexture() != null) {
                roomController.getCeilingTextureController().setTexture(clipboardRoom.getCeilingTexture());
                roomController.setCeilingPaint(RoomController.RoomPaint.TEXTURED);
            } else {
                roomController.setCeilingPaint(RoomController.RoomPaint.DEFAULT);
            }
            roomController.setCeilingShininess(clipboardRoom.getCeilingShininess());
            roomController.modifyRooms();
        } else if (clipboardItem != null && clipboardItem instanceof <any>Polyline) {
            const clipboardPolyline: Polyline = <Polyline><any>clipboardItem;
            const polylineController: PolylineController = new PolylineController(this.home, this.preferences, this.viewFactory, this.contentManager, undoSupport);
            polylineController.setThickness(clipboardPolyline.getThickness());
            polylineController.setJoinStyle(clipboardPolyline.getJoinStyle());
            polylineController.setCapStyle(clipboardPolyline.getCapStyle());
            polylineController.setStartArrowStyle(clipboardPolyline.getStartArrowStyle());
            polylineController.setEndArrowStyle(clipboardPolyline.getEndArrowStyle());
            polylineController.setDashStyle(clipboardPolyline.getDashStyle());
            polylineController.setDashPattern(clipboardPolyline.getDashPattern());
            polylineController.setDashOffset(clipboardPolyline.getDashOffset());
            polylineController.setColor(clipboardPolyline.getColor());
            polylineController.modifyPolylines();
        } else if (clipboardItem != null && clipboardItem instanceof <any>Label) {
            const clipboardLabel: Label = <Label><any>clipboardItem;
            const labelController: LabelController = new LabelController(this.home, this.preferences, this.viewFactory, undoSupport);
            labelController.setColor(clipboardLabel.getColor());
            const labelStyle: TextStyle = clipboardLabel.getStyle();
            if (labelStyle != null) {
                labelController.setAlignment(labelStyle.getAlignment());
                labelController.setFontName(labelStyle.getFontName());
                labelController.setFontSize(labelStyle.getFontSize());
            } else {
                labelController.setAlignment(null);
                labelController.setFontName(null);
                labelController.setFontSize(this.preferences.getDefaultTextStyle(Label).getFontSize());
            }
            labelController.modifyLabels();
        }
        undoSupport.postEdit(new HomeController.PastingStyleEndUndoableEdit(this.home, this.preferences, /* toArray */selectedItems.slice(0)));
        undoSupport.endUpdate();
    }

    /**
     * Returns the transfer data matching the requested types.
     * @param {Object} observer
     * @param {com.eteks.sweethome3d.viewcontroller.TransferableView.DataType[]} dataTypes
     */
    public createTransferData(observer: TransferableView.TransferObserver, ...dataTypes: TransferableView.DataType[]) {
        const data: Array<any> = <any>([]);
        for (let i: number = 0; i < dataTypes.length; i++) {
            {
                if (this.childControllers == null) {
                    this.childControllers = <any>([]);
                /* add */(this.childControllers.push(this.getFurnitureCatalogController()) > 0);
                /* add */(this.childControllers.push(this.getFurnitureController()) > 0);
                /* add */(this.childControllers.push(this.getPlanController()) > 0);
                /* add */(this.childControllers.push(this.getHomeController3D()) > 0);
                }
                for (let index = 0; index < this.childControllers.length; index++) {
                    let childController = this.childControllers[index];
                    {
                        if (childController.getView() != null && (childController.getView().constructor != null && childController.getView().constructor["__interfaces"] != null && childController.getView().constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.TransferableView") >= 0)) {
                        /* add */(data.push((<TransferableView><any>childController.getView()).createTransferData(dataTypes[i])) > 0);
                        }
                    }
                }
            };
        }
        observer.dataReady(/* toArray */data.slice(0));
    }

    /**
     * Deletes the selection in the focused component.
     */
    public delete() {
        if (this.focusedView === this.getFurnitureCatalogController().getView()) {
            if (this.getView().confirmDeleteCatalogSelection()) {
                this.getFurnitureCatalogController().deleteSelection();
            }
        } else if (this.focusedView === this.getFurnitureController().getView()) {
            this.getFurnitureController().deleteSelection();
        } else if (this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView() && this.preferences.isEditingIn3DViewEnabled()) {
            this.getPlanController().deleteSelection();
        }
    }

    /**
     * Updates actions when focused view changed.
     * @param {Object} focusedView
     */
    public focusedViewChanged(focusedView: View) {
        this.focusedView = focusedView;
        this.enableActionsBoundToSelection();
        this.enablePasteAction();
        this.enablePasteToGroupAction();
        this.enablePasteStyleAction();
        this.enableSelectAllAction();
    }

    /**
     * Selects everything in the focused component.
     */
    public selectAll() {
        if (this.focusedView === this.getFurnitureController().getView()) {
            this.getFurnitureController().selectAll();
        } else if (this.focusedView === this.getPlanController().getView() || this.focusedView === this.getHomeController3D().getView()) {
            this.getPlanController().selectAll();
        }
    }

    /**
     * Creates a new home and adds it to application home list.
     */
    public newHome() {
        let home: Home;
        if (this.application != null) {
            home = this.application.createHome();
        } else {
            home = new Home(this.preferences.getNewWallHeight());
        }
        this.application.addHome(home);
    }

    public newHomeFromExample() {
    }


    /**
     * Returns a map with entries containing furniture name associated to their id.
     * @param {FurnitureCatalog} catalog
     * @return {Object}
     * @private
     */
    getCatalogFurnitureNames(catalog: FurnitureCatalog): any {
        const furnitureNames: any = <any>({});
        {
            let array = catalog.getCategories();
            for (let index = 0; index < array.length; index++) {
                let category = array[index];
                {
                    {
                        let array1 = category.getFurniture();
                        for (let index1 = 0; index1 < array1.length; index1++) {
                            let piece = array1[index1];
                            {
                                if (piece.getId() != null) {
                                    /* put */(furnitureNames[piece.getId()] = piece.getName());
                                }
                            }
                        }
                    }
                }
            }
        }
        return furnitureNames;
    }

    /**
     * Renames the given <code>piece</code> from the piece name with the same id in <code>furnitureNames</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {Object} furnitureNames
     * @param {string} groupName
     * @private
     */
    renameToCatalogName(piece: HomePieceOfFurniture, furnitureNames: any, groupName: string) {
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            piece.setName(groupName);
            {
                let array = (<HomeFurnitureGroup>piece).getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let groupPiece = array[index];
                    {
                        this.renameToCatalogName(groupPiece, furnitureNames, groupName);
                    }
                }
            }
        } else {
            const id: string = piece.getCatalogId();
            if (id != null) {
                piece.setName(/* get */((m, k) => m[k] === undefined ? null : m[k])(furnitureNames, id));
            }
        }
    }

    public open() {
    }


    /**
     * Adds the given home to application.
     * @param {Home} home
     * @private
     */
    addHomeToApplication(home: Home) {
        this.getView().invokeLater(() => {
            this.application.addHome(home);
        });
    }

    /**
     * Updates user preferences <code>recentHomes</code> and write preferences.
     * @param {string[]} recentHomes
     * @private
     */
    updateUserPreferencesRecentHomes(recentHomes: Array<string>) {
        if (this.application != null) {
            for (let i: number = /* size */(<number>recentHomes.length) - 1; i >= 0; i--) {
                {
                    try {
                        if (!null /*erased method exists(java.lang.String)*/) {
                        /* remove */recentHomes.splice(i, 1)[0];
                        }
                    } catch (ex) {
                    }
                };
            }
            this.preferences.setRecentHomes(recentHomes);
        }
    }

    /**
     * Returns a list of displayable recent homes.
     * @return {string[]}
     */
    public getRecentHomes(): Array<string> {
        if (this.application != null) {
            const recentHomes: Array<string> = <any>([]);
            {
                let array = this.preferences.getRecentHomes();
                for (let index = 0; index < array.length; index++) {
                    let homeName = array[index];
                    {
                        try {
                            if (null /*erased method exists(java.lang.String)*/) {
                                /* add */(recentHomes.push(homeName) > 0);
                                if (/* size */(<number>recentHomes.length) === this.preferences.getRecentHomesMaxCount()) {
                                    break;
                                }
                            }
                        } catch (ex) {
                        }
                    }
                }
            }
            this.getView().setEnabled(HomeView.ActionType.DELETE_RECENT_HOMES, !/* isEmpty */(recentHomes.length == 0));
            return /* unmodifiableList */recentHomes.slice(0);
        } else {
            return <any>([]);
        }
    }

    /**
     * Returns the version of the application for display purpose.
     * @return {string}
     */
    public getVersion(): string {
        if (this.application != null) {
            let applicationVersion: string = this.application.getVersion();
            try {
                const deploymentInformation: string = 'JS';
                if (deploymentInformation != null) {
                    applicationVersion += " " + deploymentInformation;
                }
            } catch (ex) {
            }
            return applicationVersion;
        } else {
            return "";
        }
    }

    /**
     * Deletes the list of recent homes in user preferences.
     */
    public deleteRecentHomes() {
        this.updateUserPreferencesRecentHomes(<any>([]));
        this.getView().setEnabled(HomeView.ActionType.DELETE_RECENT_HOMES, false);
    }

    public close() {
    }


    public save() {
    }


    public saveAs() {
    }


    public saveAndCompress() {
    }


    public saveAsAndCompress() {
    }


    /**
     * Updates the saved home and executes <code>postSaveTask</code>
     * if it's not <code>null</code>.
     * @param {string} homeName
     * @param {number} savedVersion
     * @param {() => void} postSaveTask
     * @private
     */
    updateSavedHome(homeName: string, savedVersion: number, postSaveTask: () => void) {
        this.getView().invokeLater(() => {
            this.home.setName(homeName);
            this.home.setModified(false);
            this.home.setRecovered(false);
            this.home.setRepaired(false);
            this.home.setVersion(savedVersion);
            const recentHomes: Array<string> = <any>(this.preferences.getRecentHomes().slice(0));
            const homeNameIndex: number = recentHomes.indexOf(homeName);
            if (homeNameIndex >= 0) {
                /* remove */recentHomes.splice(homeNameIndex, 1)[0];
            }
            /* add */recentHomes.splice(0, 0, homeName);
            this.updateUserPreferencesRecentHomes(recentHomes);
            if (postSaveTask != null) {
                (target => (typeof target === 'function') ? target() : (<any>target).run())(postSaveTask);
            }
        });
    }

    public exportToCSV() {
    }


    public exportToSVG() {
    }


    public exportToOBJ() {
    }


    public createPhotos() {
    }


    public createPhoto() {
    }


    public createVideo() {
    }


    public setupPage() {
    }


    public previewPrint() {
    }


    public print() {
    }


    public printToPDF() {
    }


    /**
     * Controls application exit. If any home in application homes list is modified,
     * the user will be {@link HomeView#confirmExit() prompted} in view whether he wants
     * to discard his modifications or not.
     */
    public exit() {
        {
            let array = this.application.getHomes();
            for (let index = 0; index < array.length; index++) {
                let home = array[index];
                {
                    if (home.isModified() || home.isRecovered() || home.isRepaired()) {
                        if (this.getView().confirmExit()) {
                            break;
                        } else {
                            return;
                        }
                    }
                }
            }
        }
        {
            let array = this.application.getHomes();
            for (let index = 0; index < array.length; index++) {
                let home = array[index];
                {
                    home.setRecovered(false);
                    this.application.deleteHome(home);
                }
            }
        }
    }

    /**
     * Edits preferences and changes them if user agrees.
     */
    public editPreferences() {
        new UserPreferencesController(this.preferences, this.viewFactory, this.contentManager, this).displayView(this.getView());
    }

    /**
     * Enables magnetism in preferences.
     */
    public enableMagnetism() {
        this.preferences.setMagnetismEnabled(true);
    }

    /**
     * Disables magnetism in preferences.
     */
    public disableMagnetism() {
        this.preferences.setMagnetismEnabled(false);
    }

    /**
     * Displays a tip message dialog depending on the given mode and
     * sets the active mode of the plan controller.
     * @param {PlanController.Mode} mode
     */
    public setMode(mode: PlanController.Mode) {
        if (this.getPlanController().getMode() !== mode) {
            let actionKey: string;
            if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                actionKey = /* Enum.name */HomeView.ActionType[HomeView.ActionType.CREATE_WALLS];
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                actionKey = /* Enum.name */HomeView.ActionType[HomeView.ActionType.CREATE_ROOMS];
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                actionKey = /* Enum.name */HomeView.ActionType[HomeView.ActionType.CREATE_POLYLINES];
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                actionKey = /* Enum.name */HomeView.ActionType[HomeView.ActionType.CREATE_DIMENSION_LINES];
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                actionKey = /* Enum.name */HomeView.ActionType[HomeView.ActionType.CREATE_LABELS];
            } else {
                actionKey = null;
            }
            if (actionKey != null && !this.preferences.isActionTipIgnored(actionKey)) {
                this.getView().invokeLater(() => {
                    if (this.getView().showActionTipMessage(actionKey)) {
                        this.preferences.setActionTipIgnored(actionKey);
                    }
                });
            }
            this.getPlanController().setMode(mode);
        }
    }

    /**
     * Displays the wizard that helps to import home background image.
     */
    public importBackgroundImage() {
        new BackgroundImageWizardController(this.home, this.preferences, this.viewFactory, this.contentManager, this.getUndoableEditSupport()).displayView(this.getView());
    }

    /**
     * Displays the wizard that helps to change home background image.
     */
    public modifyBackgroundImage() {
        this.importBackgroundImage();
    }

    /**
     * Hides the home background image.
     */
    public hideBackgroundImage() {
        this.toggleBackgroundImageVisibility("undoHideBackgroundImageName");
    }

    /**
     * Shows the home background image.
     */
    public showBackgroundImage() {
        this.toggleBackgroundImageVisibility("undoShowBackgroundImageName");
    }

    /**
     * Toggles visibility of the background image and posts an undoable operation.
     * @param {string} presentationName
     * @private
     */
    toggleBackgroundImageVisibility(presentationName: string) {
        const selectedLevel: Level = this.home.getSelectedLevel();
        HomeController.doToggleBackgroundImageVisibility(this.home);
        this.getUndoableEditSupport().postEdit(new HomeController.BackgroundImageVisibilityTogglingUndoableEdit(this.home, this.preferences, presentationName, selectedLevel));
    }

    /**
     * Toggles visibility of the background image.
     * @param {Home} home
     * @private
     */
    static doToggleBackgroundImageVisibility(home: Home) {
        let backgroundImage: BackgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        backgroundImage = new BackgroundImage(backgroundImage.getImage(), backgroundImage.getScaleDistance(), backgroundImage.getScaleDistanceXStart(), backgroundImage.getScaleDistanceYStart(), backgroundImage.getScaleDistanceXEnd(), backgroundImage.getScaleDistanceYEnd(), backgroundImage.getXOrigin(), backgroundImage.getYOrigin(), !backgroundImage.isVisible());
        if (home.getSelectedLevel() != null) {
            home.getSelectedLevel().setBackgroundImage(backgroundImage);
        } else {
            home.setBackgroundImage(backgroundImage);
        }
    }

    /**
     * Deletes home background image and posts and posts an undoable operation.
     */
    public deleteBackgroundImage() {
        const selectedLevel: Level = this.home.getSelectedLevel();
        let oldImage: BackgroundImage;
        if (selectedLevel != null) {
            oldImage = selectedLevel.getBackgroundImage();
            selectedLevel.setBackgroundImage(null);
        } else {
            oldImage = this.home.getBackgroundImage();
            this.home.setBackgroundImage(null);
        }
        this.getUndoableEditSupport().postEdit(new HomeController.BackgroundImageDeletionUndoableEdit(this.home, this.preferences, selectedLevel, oldImage));
    }

    /**
     * Zooms out in plan.
     */
    public zoomOut() {
        const planController: PlanController = this.getPlanController();
        const newScale: number = planController.getScale() / 1.5;
        planController.setScale(newScale);
        planController.getView().makeSelectionVisible();
    }

    /**
     * Zooms in in plan.
     */
    public zoomIn() {
        const planController: PlanController = this.getPlanController();
        const newScale: number = planController.getScale() * 1.5;
        planController.setScale(newScale);
        planController.getView().makeSelectionVisible();
    }

    /**
     * Prompts a name for the current camera and stores it in home.
     */
    public storeCamera() {
        const now: string = new Date().toLocaleDateString(this.preferences.getLanguage().replace('_', '-'));
        const name: string = this.getView().showStoreCameraDialog(now);
        if (name != null) {
            this.getHomeController3D().storeCamera(name);
        }
    }

    /**
     * Prompts stored cameras in home to be deleted and deletes the ones selected by the user.
     */
    public deleteCameras() {
        const deletedCameras: Array<Camera> = this.getView().showDeletedCamerasDialog();
        if (deletedCameras != null) {
            this.getHomeController3D().deleteCameras(deletedCameras);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     * @param {Object} view
     */
    public detachView(view: View) {
        if (view != null) {
            this.getView().detachView(view);
            this.notUndoableModifications = true;
            this.home.setModified(true);
        }
    }

    /**
     * Attaches the given <code>view</code> to home view.
     * @param {Object} view
     */
    public attachView(view: View) {
        if (view != null) {
            this.getView().attachView(view);
            this.notUndoableModifications = true;
            this.home.setModified(true);
        }
    }

    public help() {
    }


    /**
     * Displays about dialog.
     */
    public about() {
        this.getView().showAboutDialog();
    }

    /**
     * Controls the change of value of a visual property in home.
     * @deprecated {@link #setVisualProperty(String, Object) setVisualProperty} should be replaced by a call to
     * {@link #setHomeProperty(String, String)} to ensure the property can be easily saved and read.
     * @param {string} propertyName
     * @param {Object} propertyValue
     */
    public setVisualProperty(propertyName: string, propertyValue: any) {
        this.home.setVisualProperty(propertyName, propertyValue);
    }

    /**
     * Controls the change of value of a property in home.
     * @param {string} propertyName
     * @param {string} propertyValue
     */
    public setHomeProperty(propertyName: string, propertyValue: string) {
        this.home.setProperty(propertyName, propertyValue);
    }
}
HomeController["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController";
HomeController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace HomeController {

    /**
     * Super class of catalog listeners that writes preferences each time a piece of furniture or a texture
     * is deleted or added in furniture or textures catalog.
     * @class
     */
    export abstract class UserPreferencesChangeListener {
        static writingPreferences: Array<any>; public static writingPreferences_$LI$(): Array<any> { if (UserPreferencesChangeListener.writingPreferences == null) { UserPreferencesChangeListener.writingPreferences = <any>([]); } return UserPreferencesChangeListener.writingPreferences; }

        public writePreferences(controller: HomeController) {
            if (!/* contains */(UserPreferencesChangeListener.writingPreferences_$LI$().indexOf(<any>(controller.preferences)) >= 0)) {
                /* add */((s, e) => { if (s.indexOf(e) == -1) { s.push(e); return true; } else { return false; } })(UserPreferencesChangeListener.writingPreferences_$LI$(), controller.preferences);
                controller.getView().invokeLater(() => {
                    try {
                        controller.preferences.write();
                        /* remove */(a => { let index = a.indexOf(controller.preferences); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(UserPreferencesChangeListener.writingPreferences_$LI$());
                    } catch (ex) {
                        controller.getView().showError(controller.preferences.getLocalizedString(HomeController, "savePreferencesError"));
                    }
                });
            }
        }

        constructor() {
        }
    }
    UserPreferencesChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.UserPreferencesChangeListener";


    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     * @param {HomeController} homeController
     * @class
     */
    export class LanguageChangeListener {
        homeController: HomeController;

        public constructor(homeController: HomeController) {
            if (this.homeController === undefined) { this.homeController = null; }
            this.homeController = <any>(homeController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const homeController: HomeController = /* get */this.homeController;
            if (homeController == null) {
                (ev.getSource()).removePropertyChangeListener("LANGUAGE", this);
            } else {
                homeController.getView().setUndoRedoName(homeController.undoManager.canUndo() ? homeController.undoManager.getUndoPresentationName() : null, homeController.undoManager.canRedo() ? homeController.undoManager.getRedoPresentationName() : null);
            }
        }
    }
    LanguageChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.LanguageChangeListener";


    /**
     * Undoable edit for level modification.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class LevelModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelectedLevel: Level;

        selectedLevel: Level;

        selectedItems: Selectable[];

        allLevelsSelection: boolean;

        constructor(home: Home, preferences: any, oldSelectedLevel: Level, selectedLevel: Level, selectedItems: Selectable[], allLevelsSelection: boolean) {
            super(preferences, HomeController, "undoDropName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelectedLevel === undefined) { this.oldSelectedLevel = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            this.home = home;
            this.oldSelectedLevel = oldSelectedLevel;
            this.selectedLevel = selectedLevel;
            this.selectedItems = selectedItems;
            this.allLevelsSelection = allLevelsSelection;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            if (this.allLevelsSelection) {
                this.home.setAllLevelsSelection(this.allLevelsSelection);
            } else {
                this.home.setSelectedLevel(this.oldSelectedLevel);
            }
            this.home.setSelectedItems(/* asList */this.selectedItems.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedLevel(this.selectedLevel);
        }
    }
    LevelModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.LevelModificationUndoableEdit";
    LevelModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dropping end.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} importedFurniture
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DroppingEndUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        importedFurniture: HomePieceOfFurniture[];

        public constructor(home: Home, preferences: any, importedFurniture: HomePieceOfFurniture[]) {
            super(preferences, HomeController, "undoDropName");
            if (this.home === undefined) { this.home = null; }
            if (this.importedFurniture === undefined) { this.importedFurniture = null; }
            this.home = home;
            this.importedFurniture = importedFurniture;
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.importedFurniture.slice(0));
        }
    }
    DroppingEndUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.DroppingEndUndoableEdit";
    DroppingEndUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for pasting style end.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} selectedItems
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PastingStyleEndUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        selectedItems: Selectable[];

        public constructor(home: Home, preferences: any, selectedItems: Selectable[]) {
            super(preferences, HomeController, "undoPasteStyleName");
            if (this.home === undefined) { this.home = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            this.home = home;
            this.selectedItems = selectedItems;
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.selectedItems.slice(0));
        }
    }
    PastingStyleEndUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.PastingStyleEndUndoableEdit";
    PastingStyleEndUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for toggling background image visibility.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class BackgroundImageVisibilityTogglingUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        selectedLevel: Level;

        constructor(home: Home, preferences: any, presentationName: string, selectedLevel: Level) {
            super(preferences, HomeController, presentationName);
            if (this.home === undefined) { this.home = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            this.home = home;
            this.selectedLevel = selectedLevel;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setSelectedLevel(this.selectedLevel);
            HomeController.doToggleBackgroundImageVisibility(this.home);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedLevel(this.selectedLevel);
            HomeController.doToggleBackgroundImageVisibility(this.home);
        }
    }
    BackgroundImageVisibilityTogglingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.BackgroundImageVisibilityTogglingUndoableEdit";
    BackgroundImageVisibilityTogglingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for background image deletion.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class BackgroundImageDeletionUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        selectedLevel: Level;

        oldImage: BackgroundImage;

        constructor(home: Home, preferences: any, selectedLevel: Level, oldImage: BackgroundImage) {
            super(preferences, HomeController, "undoDeleteBackgroundImageName");
            if (this.home === undefined) { this.home = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.oldImage === undefined) { this.oldImage = null; }
            this.home = home;
            this.oldImage = oldImage;
            this.selectedLevel = selectedLevel;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setSelectedLevel(this.selectedLevel);
            if (this.selectedLevel != null) {
                this.selectedLevel.setBackgroundImage(this.oldImage);
            } else {
                this.home.setBackgroundImage(this.oldImage);
            }
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedLevel(this.selectedLevel);
            if (this.selectedLevel != null) {
                this.selectedLevel.setBackgroundImage(null);
            } else {
                this.home.setBackgroundImage(null);
            }
        }
    }
    BackgroundImageDeletionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.BackgroundImageDeletionUndoableEdit";
    BackgroundImageDeletionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Furniture catalog listener that writes preferences each time a piece of furniture
     * is deleted or added in furniture catalog. This listener is bound to this controller
     * with a weak reference to avoid strong link between catalog and this controller.
     * @param {HomeController} homeController
     * @class
     * @extends HomeController.UserPreferencesChangeListener
     */
    export class FurnitureCatalogChangeListener extends HomeController.UserPreferencesChangeListener {
        homeController: HomeController;

        public constructor(homeController: HomeController) {
            super();
            if (this.homeController === undefined) { this.homeController = null; }
            this.homeController = <any>(homeController);
        }

        public collectionChanged(ev: CollectionEvent<CatalogPieceOfFurniture>) {
            const controller: HomeController = /* get */this.homeController;
            if (controller == null) {
                (<FurnitureCatalog>ev.getSource()).removeFurnitureListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this)));
            } else {
                this.writePreferences(controller);
            }
        }
    }
    FurnitureCatalogChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.FurnitureCatalogChangeListener";
    FurnitureCatalogChangeListener["__interfaces"] = ["com.eteks.sweethome3d.model.CollectionListener"];



    /**
     * Textures catalog listener that writes preferences each time a texture
     * is deleted or added in textures catalog. This listener is bound to this controller
     * with a weak reference to avoid strong link between catalog and this controller.
     * @param {HomeController} homeController
     * @class
     * @extends HomeController.UserPreferencesChangeListener
     */
    export class TexturesCatalogChangeListener extends HomeController.UserPreferencesChangeListener {
        homeController: HomeController;

        public constructor(homeController: HomeController) {
            super();
            if (this.homeController === undefined) { this.homeController = null; }
            this.homeController = <any>(homeController);
        }

        public collectionChanged(ev: CollectionEvent<CatalogTexture>) {
            const controller: HomeController = /* get */this.homeController;
            if (controller == null) {
                (<TexturesCatalog>ev.getSource()).removeTexturesListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(this)));
            } else {
                this.writePreferences(controller);
            }
        }
    }
    TexturesCatalogChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.TexturesCatalogChangeListener";
    TexturesCatalogChangeListener["__interfaces"] = ["com.eteks.sweethome3d.model.CollectionListener"];



    /**
     * Properties listener that writes preferences each time the value of one of its properties changes.
     * This listener is bound to this controller with a weak reference to avoid strong link
     * between catalog and this controller.
     * @param {HomeController} homeController
     * @class
     * @extends HomeController.UserPreferencesChangeListener
     */
    export class UserPreferencesPropertiesChangeListener extends HomeController.UserPreferencesChangeListener {
        homeController: HomeController;

        public constructor(homeController: HomeController) {
            super();
            if (this.homeController === undefined) { this.homeController = null; }
            this.homeController = <any>(homeController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: HomeController = /* get */this.homeController;
            if (controller == null) {
                (ev.getSource()).removePropertyChangeListener(/* valueOf */ev.getPropertyName(), this);
            } else {
                this.writePreferences(controller);
            }
        }
    }
    UserPreferencesPropertiesChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeController.UserPreferencesPropertiesChangeListener";


    export class HomeController$0 extends javax.swing.undo.UndoableEditSupport {
        public __parent: any;
        /**
         * 
         * @param {Object} edit
         */
        _postEdit(edit: javax.swing.undo.UndoableEdit) {
            if (!(edit != null && edit instanceof <any>javax.swing.undo.CompoundEdit) || edit.isSignificant()) {
                super._postEdit(edit);
            }
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }


    export class HomeController$1 implements SelectionListener {
        public __parent: any;
        public selectionChanged(ev: SelectionEvent) {
            this.__parent.enableActionsBoundToSelection();
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }
    HomeController$1["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];



    export class HomeController$2 implements SelectionListener {
        public __parent: any;
        public selectionChanged(ev: SelectionEvent) {
            this.__parent.enableActionsBoundToSelection();
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }
    HomeController$2["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];



    export class HomeController$3 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.getView().setEnabled(HomeView.ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, ev.getNewValue() != null);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$4 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.enableBackgroungImageActions(this.__parent.getView(), <BackgroundImage>ev.getNewValue());
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$5 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.notUndoableModifications = true;
            this.__parent.home.setModified(true);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$6 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (this.__parent.home.getEnvironment().getPhotoAspectRatio() !== AspectRatio.VIEW_3D_RATIO) {
                this.notUndoableModificationListener.propertyChange(ev);
            }
        }

        constructor(__parent: any, private notUndoableModificationListener: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$7 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if ((ev.getPropertyName() === /* name */"TIME") || (ev.getPropertyName() === /* name */"LENS")) {
                this.notUndoableModificationListener.propertyChange(ev);
            }
        }

        constructor(__parent: any, private notUndoableModificationListener: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$8 implements javax.swing.event.UndoableEditListener {
        public __parent: any;
        public undoableEditHappened(ev: javax.swing.event.UndoableEditEvent) {
            const view: HomeView = this.__parent.getView();
            view.setEnabled(HomeView.ActionType.UNDO, !this.__parent.getPlanController().isModificationState());
            view.setEnabled(HomeView.ActionType.REDO, false);
            view.setUndoRedoName(ev.getEdit().getUndoPresentationName(), null);
            this.__parent.saveUndoLevel++;
            this.__parent.home.setModified(true);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }
    HomeController$8["__interfaces"] = ["javax.swing.event.UndoableEditListener"];



    export class HomeController$9 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (!this.__parent.home.isModified()) {
                this.__parent.saveUndoLevel = 0;
                this.__parent.notUndoableModifications = false;
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$10 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (/* name */"VISIBLE" === ev.getPropertyName()) {
                this.__parent.enableSelectAllAction();
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$11 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.getView().setEnabled(HomeView.ActionType.MODIFY_OBSERVER, this.__parent.home.getCamera() === this.__parent.home.getObserverCamera());
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$12 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const selectedLevel: Level = this.__parent.home.getSelectedLevel();
            if (!this.__parent.home.isAllLevelsSelection()) {
                const selectedItemsAtLevel: Array<Selectable> = <any>([]);
                {
                    let array = this.__parent.home.getSelectedItems();
                    for (let index = 0; index < array.length; index++) {
                        let item = array[index];
                        {
                            if (!(item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) || (<Elevatable><any>item).isAtLevel(selectedLevel)) {
                                /* add */(selectedItemsAtLevel.push(item) > 0);
                            }
                        }
                    }
                }
                this.__parent.home.setSelectedItems(selectedItemsAtLevel);
            }
            const view: HomeView = this.__parent.getView();
            this.__parent.enableCreationToolsActions(view);
            this.__parent.enableBackgroungImageActions(view, selectedLevel == null ? this.__parent.home.getBackgroundImage() : selectedLevel.getBackgroundImage());
            this.__parent.enableLevelActions(view);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$13 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (/* name */"BACKGROUND_IMAGE" === ev.getPropertyName()) {
                this.__parent.enableBackgroungImageActions(this.__parent.getView(), <BackgroundImage>ev.getNewValue());
            } else if (/* name */"VIEWABLE" === ev.getPropertyName()) {
                this.__parent.enableCreationToolsActions(this.__parent.getView());
                this.__parent.enableActionsBoundToSelection();
                if (!<boolean>ev.getNewValue()) {
                    const mode: PlanController.Mode = this.__parent.getPlanController().getMode();
                    if (mode !== PlanController.Mode.SELECTION_$LI$() && mode !== PlanController.Mode.PANNING_$LI$()) {
                        this.__parent.getPlanController().setMode(PlanController.Mode.SELECTION_$LI$());
                    }
                }
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$14 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const emptyStoredCameras: boolean = /* isEmpty */(this.__parent.home.getStoredCameras().length == 0);
            this.__parent.getView().setEnabled(HomeView.ActionType.DELETE_POINTS_OF_VIEW, !emptyStoredCameras);
            this.__parent.getView().setEnabled(HomeView.ActionType.CREATE_PHOTOS_AT_POINTS_OF_VIEW, !emptyStoredCameras);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$15 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.enableActionsBoundToSelection();
            this.__parent.enableSelectAllAction();
            const view: HomeView = this.__parent.getView();
            this.__parent.enableLevelActions(view);
            const modificationState: boolean = this.__parent.getPlanController().isModificationState();
            if (modificationState) {
                view.setEnabled(HomeView.ActionType.PASTE, false);
                view.setEnabled(HomeView.ActionType.UNDO, false);
                view.setEnabled(HomeView.ActionType.REDO, false);
            } else {
                this.__parent.enablePasteAction();
                view.setEnabled(HomeView.ActionType.UNDO, this.__parent.undoManager.canUndo());
                view.setEnabled(HomeView.ActionType.REDO, this.__parent.undoManager.canRedo());
            }
            view.setEnabled(HomeView.ActionType.LOCK_BASE_PLAN, !modificationState);
            view.setEnabled(HomeView.ActionType.UNLOCK_BASE_PLAN, !modificationState);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$16 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.enableActionsBoundToSelection();
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeController$17 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.enableZoomActions();
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * Creates the controller of room view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class RoomController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ floorTextureController: TextureChoiceController;

    /*private*/ ceilingTextureController: TextureChoiceController;

    /*private*/ wallSidesTextureController: TextureChoiceController;

    /*private*/ wallSidesBaseboardController: BaseboardChoiceController;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ roomView: DialogView;

    /*private*/ name: string;

    /*private*/ areaVisible: boolean;

    /*private*/ floorVisible: boolean;

    /*private*/ floorColor: number;

    /*private*/ floorPaint: RoomController.RoomPaint;

    /*private*/ floorShininess: number;

    /*private*/ ceilingVisible: boolean;

    /*private*/ ceilingColor: number;

    /*private*/ ceilingPaint: RoomController.RoomPaint;

    /*private*/ ceilingShininess: number;

    /*private*/ ceilingFlat: boolean;

    /*private*/ wallSidesEditable: boolean;

    /*private*/ splitSurroundingWalls: boolean;

    /*private*/ splitSurroundingWallsNeeded: boolean;

    /*private*/ wallSidesColor: number;

    /*private*/ wallSidesPaint: RoomController.RoomPaint;

    /*private*/ wallSidesShininess: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.floorTextureController === undefined) { this.floorTextureController = null; }
        if (this.ceilingTextureController === undefined) { this.ceilingTextureController = null; }
        if (this.wallSidesTextureController === undefined) { this.wallSidesTextureController = null; }
        if (this.wallSidesBaseboardController === undefined) { this.wallSidesBaseboardController = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.roomView === undefined) { this.roomView = null; }
        if (this.name === undefined) { this.name = null; }
        if (this.areaVisible === undefined) { this.areaVisible = null; }
        if (this.floorVisible === undefined) { this.floorVisible = null; }
        if (this.floorColor === undefined) { this.floorColor = null; }
        if (this.floorPaint === undefined) { this.floorPaint = null; }
        if (this.floorShininess === undefined) { this.floorShininess = null; }
        if (this.ceilingVisible === undefined) { this.ceilingVisible = null; }
        if (this.ceilingColor === undefined) { this.ceilingColor = null; }
        if (this.ceilingPaint === undefined) { this.ceilingPaint = null; }
        if (this.ceilingShininess === undefined) { this.ceilingShininess = null; }
        if (this.ceilingFlat === undefined) { this.ceilingFlat = null; }
        if (this.wallSidesEditable === undefined) { this.wallSidesEditable = false; }
        if (this.splitSurroundingWalls === undefined) { this.splitSurroundingWalls = false; }
        if (this.splitSurroundingWallsNeeded === undefined) { this.splitSurroundingWallsNeeded = false; }
        if (this.wallSidesColor === undefined) { this.wallSidesColor = null; }
        if (this.wallSidesPaint === undefined) { this.wallSidesPaint = null; }
        if (this.wallSidesShininess === undefined) { this.wallSidesShininess = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the texture controller of the room floor.
     * @return {TextureChoiceController}
     */
    public getFloorTextureController(): TextureChoiceController {
        if (this.floorTextureController == null) {
            this.floorTextureController = new TextureChoiceController(this.preferences.getLocalizedString(RoomController, "floorTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.floorTextureController.addPropertyChangeListener("TEXTURE", new RoomController.RoomController$0(this));
        }
        return this.floorTextureController;
    }

    /**
     * Returns the texture controller of the room ceiling.
     * @return {TextureChoiceController}
     */
    public getCeilingTextureController(): TextureChoiceController {
        if (this.ceilingTextureController == null) {
            this.ceilingTextureController = new TextureChoiceController(this.preferences.getLocalizedString(RoomController, "ceilingTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.ceilingTextureController.addPropertyChangeListener("TEXTURE", new RoomController.RoomController$1(this));
        }
        return this.ceilingTextureController;
    }

    /**
     * Returns the texture controller of the room wall sides.
     * @return {TextureChoiceController}
     */
    public getWallSidesTextureController(): TextureChoiceController {
        if (this.wallSidesTextureController == null) {
            this.wallSidesTextureController = new TextureChoiceController(this.preferences.getLocalizedString(RoomController, "wallSidesTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.wallSidesTextureController.addPropertyChangeListener("TEXTURE", new RoomController.RoomController$2(this));
        }
        return this.wallSidesTextureController;
    }

    /**
     * Returns the controller of the wall sides baseboard.
     * @return {BaseboardChoiceController}
     */
    public getWallSidesBaseboardController(): BaseboardChoiceController {
        if (this.wallSidesBaseboardController == null) {
            this.wallSidesBaseboardController = new BaseboardChoiceController(this.preferences, this.viewFactory, this.contentManager);
        }
        return this.wallSidesBaseboardController;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.roomView == null) {
            this.roomView = this.viewFactory.createRoomView(this.preferences, this);
        }
        return this.roomView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * The implementation of this method always returns <code>true</code> except for <code>WALL</code> properties.
     * @param {string} property
     * @return {boolean}
     */
    public isPropertyEditable(property: any): boolean {
        switch ((property)) {
            case "SPLIT_SURROUNDING_WALLS":
            case "WALL_SIDES_COLOR":
            case "WALL_SIDES_PAINT":
            case "WALL_SIDES_SHININESS":
            case "WALL_SIDES_BASEBOARD":
                return this.wallSidesEditable;
            default:
                return true;
        }
    }

    /**
     * Updates edited properties from selected rooms in the home edited by this controller.
     */
    updateProperties() {
        const selectedRooms: Array<Room> = Home.getRoomsSubList(this.home.getSelectedItems());
        if (/* isEmpty */(selectedRooms.length == 0)) {
            this.setAreaVisible(null);
            this.setFloorColor(null);
            this.getFloorTextureController().setTexture(null);
            this.setFloorPaint(null);
            this.setFloorShininess(null);
            this.setCeilingColor(null);
            this.getCeilingTextureController().setTexture(null);
            this.setCeilingPaint(null);
            this.setCeilingShininess(null);
            this.setCeilingFlat(null);
        } else {
            const firstRoom: Room = /* get */selectedRooms[0];
            let name: string = firstRoom.getName();
            if (name != null) {
                for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                    {
                        if (!(name === /* get */selectedRooms[i].getName())) {
                            name = null;
                            break;
                        }
                    };
                }
            }
            this.setName(name);
            let areaVisible: boolean = firstRoom.isAreaVisible();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (areaVisible !== /* get */selectedRooms[i].isAreaVisible()) {
                        areaVisible = null;
                        break;
                    }
                };
            }
            this.setAreaVisible(areaVisible);
            let floorVisible: boolean = firstRoom.isFloorVisible();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (floorVisible !== /* get */selectedRooms[i].isFloorVisible()) {
                        floorVisible = null;
                        break;
                    }
                };
            }
            this.setFloorVisible(floorVisible);
            let floorColor: number = firstRoom.getFloorColor();
            if (floorColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                    {
                        if (!(floorColor === /* get */selectedRooms[i].getFloorColor())) {
                            floorColor = null;
                            break;
                        }
                    };
                }
            }
            this.setFloorColor(floorColor);
            let floorTexture: HomeTexture = firstRoom.getFloorTexture();
            if (floorTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                    {
                        if (!floorTexture.equals(/* get */selectedRooms[i].getFloorTexture())) {
                            floorTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getFloorTextureController().setTexture(floorTexture);
            let defaultColorsAndTextures: boolean = true;
            for (let i: number = 0; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    const room: Room = /* get */selectedRooms[i];
                    if (room.getFloorColor() != null || room.getFloorTexture() != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (floorColor != null) {
                this.setFloorPaint(RoomController.RoomPaint.COLORED);
            } else if (floorTexture != null) {
                this.setFloorPaint(RoomController.RoomPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.setFloorPaint(RoomController.RoomPaint.DEFAULT);
            } else {
                this.setFloorPaint(null);
            }
            let floorShininess: number = firstRoom.getFloorShininess();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (!(floorShininess === /* get */selectedRooms[i].getFloorShininess())) {
                        floorShininess = null;
                        break;
                    }
                };
            }
            this.setFloorShininess(floorShininess);
            let ceilingVisible: boolean = firstRoom.isCeilingVisible();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (ceilingVisible !== /* get */selectedRooms[i].isCeilingVisible()) {
                        ceilingVisible = null;
                        break;
                    }
                };
            }
            this.setCeilingVisible(ceilingVisible);
            let ceilingColor: number = firstRoom.getCeilingColor();
            if (ceilingColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                    {
                        if (!(ceilingColor === /* get */selectedRooms[i].getCeilingColor())) {
                            ceilingColor = null;
                            break;
                        }
                    };
                }
            }
            this.setCeilingColor(ceilingColor);
            let ceilingTexture: HomeTexture = firstRoom.getCeilingTexture();
            if (ceilingTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                    {
                        if (!ceilingTexture.equals(/* get */selectedRooms[i].getCeilingTexture())) {
                            ceilingTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getCeilingTextureController().setTexture(ceilingTexture);
            defaultColorsAndTextures = true;
            for (let i: number = 0; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    const room: Room = /* get */selectedRooms[i];
                    if (room.getCeilingColor() != null || room.getCeilingTexture() != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (ceilingColor != null) {
                this.setCeilingPaint(RoomController.RoomPaint.COLORED);
            } else if (ceilingTexture != null) {
                this.setCeilingPaint(RoomController.RoomPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.setCeilingPaint(RoomController.RoomPaint.DEFAULT);
            } else {
                this.setCeilingPaint(null);
            }
            let ceilingShininess: number = firstRoom.getCeilingShininess();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (!(ceilingShininess === /* get */selectedRooms[i].getCeilingShininess())) {
                        ceilingShininess = null;
                        break;
                    }
                };
            }
            this.setCeilingShininess(ceilingShininess);
            let ceilingFlat: boolean = firstRoom.isCeilingFlat();
            for (let i: number = 1; i < /* size */(<number>selectedRooms.length); i++) {
                {
                    if (ceilingFlat !== /* get */selectedRooms[i].isCeilingFlat()) {
                        ceilingFlat = null;
                        break;
                    }
                };
            }
            this.setCeilingFlat(ceilingFlat);
        }
        const wallSides: Array<RoomController.WallSide> = this.getRoomsWallSides(selectedRooms, null);
        if (/* isEmpty */(wallSides.length == 0)) {
            this.wallSidesEditable = this.splitSurroundingWallsNeeded = this.splitSurroundingWalls = false;
            this.setWallSidesColor(null);
            this.setWallSidesPaint(null);
            this.setWallSidesShininess(null);
            this.getWallSidesBaseboardController().setVisible(null);
            this.getWallSidesBaseboardController().setThickness(null);
            this.getWallSidesBaseboardController().setHeight(null);
            this.getWallSidesBaseboardController().setColor(null);
            this.getWallSidesBaseboardController().getTextureController().setTexture(null);
            this.getWallSidesBaseboardController().setPaint(null);
        } else {
            this.wallSidesEditable = true;
            this.splitSurroundingWallsNeeded = this.splitWalls(wallSides, null, null, null);
            this.splitSurroundingWalls = false;
            const firstWallSide: RoomController.WallSide = /* get */wallSides[0];
            let wallSidesColor: number = firstWallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? firstWallSide.getWall().getLeftSideColor() : firstWallSide.getWall().getRightSideColor();
            if (wallSidesColor != null) {
                for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        if (!(wallSidesColor === (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideColor() : wallSide.getWall().getRightSideColor()))) {
                            wallSidesColor = null;
                            break;
                        }
                    };
                }
            }
            this.setWallSidesColor(wallSidesColor);
            let wallSidesTexture: HomeTexture = firstWallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? firstWallSide.getWall().getLeftSideTexture() : firstWallSide.getWall().getRightSideTexture();
            if (wallSidesTexture != null) {
                for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        if (!wallSidesTexture.equals(wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideTexture() : wallSide.getWall().getRightSideTexture())) {
                            wallSidesTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getWallSidesTextureController().setTexture(wallSidesTexture);
            let defaultColorsAndTextures: boolean = true;
            for (let i: number = 0; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wallSide: RoomController.WallSide = /* get */wallSides[i];
                    if ((wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideColor() : wallSide.getWall().getRightSideColor()) != null || (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideTexture() : wallSide.getWall().getRightSideTexture()) != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (wallSidesColor != null) {
                this.setWallSidesPaint(RoomController.RoomPaint.COLORED);
            } else if (wallSidesTexture != null) {
                this.setWallSidesPaint(RoomController.RoomPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.setWallSidesPaint(RoomController.RoomPaint.DEFAULT);
            } else {
                this.setWallSidesPaint(null);
            }
            let wallSidesShininess: number = firstWallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? firstWallSide.getWall().getLeftSideShininess() : firstWallSide.getWall().getRightSideShininess();
            if (wallSidesShininess != null) {
                for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        if (!(wallSidesShininess === (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideShininess() : wallSide.getWall().getRightSideShininess()))) {
                            wallSidesShininess = null;
                            break;
                        }
                    };
                }
            }
            this.setWallSidesShininess(wallSidesShininess);
            const firstWallSideBaseboard: Baseboard = firstWallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? firstWallSide.getWall().getLeftSideBaseboard() : firstWallSide.getWall().getRightSideBaseboard();
            let wallSidesBaseboardVisible: boolean = firstWallSideBaseboard != null;
            for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wallSide: RoomController.WallSide = /* get */wallSides[i];
                    if (wallSidesBaseboardVisible !== (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() != null : wallSide.getWall().getRightSideBaseboard() != null)) {
                        wallSidesBaseboardVisible = null;
                        break;
                    }
                };
            }
            this.getWallSidesBaseboardController().setVisible(wallSidesBaseboardVisible);
            let wallSidesBaseboardThickness: number = firstWallSideBaseboard != null ? firstWallSideBaseboard.getThickness() : this.preferences.getNewWallBaseboardThickness();
            for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wallSide: RoomController.WallSide = /* get */wallSides[i];
                    const baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() : wallSide.getWall().getRightSideBaseboard();
                    if (!(wallSidesBaseboardThickness === (baseboard != null ? baseboard.getThickness() : this.preferences.getNewWallBaseboardThickness()))) {
                        wallSidesBaseboardThickness = null;
                        break;
                    }
                };
            }
            this.getWallSidesBaseboardController().setThickness(wallSidesBaseboardThickness);
            let wallSidesBaseboardHeight: number = firstWallSideBaseboard != null ? firstWallSideBaseboard.getHeight() : this.preferences.getNewWallBaseboardHeight();
            for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wallSide: RoomController.WallSide = /* get */wallSides[i];
                    const baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() : wallSide.getWall().getRightSideBaseboard();
                    if (!(wallSidesBaseboardHeight === (baseboard != null ? baseboard.getHeight() : this.preferences.getNewWallBaseboardHeight()))) {
                        wallSidesBaseboardHeight = null;
                        break;
                    }
                };
            }
            this.getWallSidesBaseboardController().setHeight(wallSidesBaseboardHeight);
            let maxBaseboardHeight: number = firstWallSide.getWall().isTrapezoidal() ? Math.max(firstWallSide.getWall().getHeight(), firstWallSide.getWall().getHeightAtEnd()) : firstWallSide.getWall().getHeight();
            for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wall: Wall = /* get */wallSides[i].getWall();
                    maxBaseboardHeight = Math.max(maxBaseboardHeight, wall.isTrapezoidal() ? Math.max(wall.getHeight(), wall.getHeightAtEnd()) : wall.getHeight());
                };
            }
            this.getWallSidesBaseboardController().setMaxHeight(maxBaseboardHeight);
            let wallSidesBaseboardColor: number = firstWallSideBaseboard != null ? firstWallSideBaseboard.getColor() : null;
            if (wallSidesBaseboardColor != null) {
                for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        const baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() : wallSide.getWall().getRightSideBaseboard();
                        if (baseboard == null || !(wallSidesBaseboardColor === baseboard.getColor())) {
                            wallSidesBaseboardColor = null;
                            break;
                        }
                    };
                }
            }
            this.getWallSidesBaseboardController().setColor(wallSidesBaseboardColor);
            let wallSidesBaseboardTexture: HomeTexture = firstWallSideBaseboard != null ? firstWallSideBaseboard.getTexture() : null;
            if (wallSidesBaseboardTexture != null) {
                for (let i: number = 1; i < /* size */(<number>wallSides.length); i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        const baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() : wallSide.getWall().getRightSideBaseboard();
                        if (baseboard == null || !wallSidesBaseboardTexture.equals(baseboard.getTexture())) {
                            wallSidesBaseboardTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getWallSidesBaseboardController().getTextureController().setTexture(wallSidesBaseboardTexture);
            defaultColorsAndTextures = true;
            for (let i: number = 0; i < /* size */(<number>wallSides.length); i++) {
                {
                    const wallSide: RoomController.WallSide = /* get */wallSides[i];
                    const baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wallSide.getWall().getLeftSideBaseboard() : wallSide.getWall().getRightSideBaseboard();
                    if (baseboard != null && (baseboard.getColor() != null || baseboard.getTexture() != null)) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (wallSidesBaseboardColor != null) {
                this.getWallSidesBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.COLORED);
            } else if (wallSidesBaseboardTexture != null) {
                this.getWallSidesBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.getWallSidesBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.DEFAULT);
            } else {
                this.getWallSidesBaseboardController().setPaint(null);
            }
        }
    }

    /**
     * Returns the wall sides close to each room of <code>rooms</code>.
     * @param {Room[]} rooms
     * @param {RoomController.WallSide[]} defaultWallSides
     * @return {RoomController.WallSide[]}
     * @private
     */
    getRoomsWallSides(rooms: Array<Room>, defaultWallSides: Array<RoomController.WallSide>): Array<RoomController.WallSide> {
        const wallSides: Array<RoomController.WallSide> = <any>([]);
        for (let index = 0; index < rooms.length; index++) {
            let room = rooms[index];
            {
                const roomArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath(room.getPoints(), true));
                if (defaultWallSides != null) {
                    for (let index1 = 0; index1 < defaultWallSides.length; index1++) {
                        let wallSide = defaultWallSides[index1];
                        {
                            if (this.isRoomItersectingWallSide(wallSide.getWall().getPoints$(), wallSide.getSide(), roomArea)) {
                                /* add */(wallSides.push(wallSide) > 0);
                            }
                        }
                    }
                } else {
                    {
                        let array = this.home.getWalls();
                        for (let index1 = 0; index1 < array.length; index1++) {
                            let wall = array[index1];
                            {
                                if ((wall.getLevel() == null || wall.getLevel().isViewable()) && wall.isAtLevel(this.home.getSelectedLevel())) {
                                    const wallPoints: number[][] = wall.getPoints$();
                                    if (this.isRoomItersectingWallSide(wallPoints, RoomController.WallSide.LEFT_SIDE, roomArea)) {
                                        /* add */(wallSides.push(new RoomController.WallSide(wall, RoomController.WallSide.LEFT_SIDE)) > 0);
                                    }
                                    if (this.isRoomItersectingWallSide(wallPoints, RoomController.WallSide.RIGHT_SIDE, roomArea)) {
                                        /* add */(wallSides.push(new RoomController.WallSide(wall, RoomController.WallSide.RIGHT_SIDE)) > 0);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return wallSides;
    }

    /**
     * Returns <code>true</code> if the wall points on the given <code>wallSide</code>
     * intersects room area.
     * @param {float[][]} wallPoints
     * @param {number} wallSide
     * @param {java.awt.geom.Area} roomArea
     * @return {boolean}
     * @private
     */
    isRoomItersectingWallSide(wallPoints: number[][], wallSide: number, roomArea: java.awt.geom.Area): boolean {
        const wallSideTestArea: java.awt.geom.Area = this.getWallSideArea(wallPoints, wallSide);
        const wallSideTestAreaSurface: number = this.getSurface(wallSideTestArea);
        wallSideTestArea.intersect(roomArea);
        if (!wallSideTestArea.isEmpty()) {
            const wallSideIntersectionSurface: number = this.getSurface(wallSideTestArea);
            if (wallSideIntersectionSurface > wallSideTestAreaSurface * 0.02) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the area of the side of the given <code>wall</code>.
     * @param {float[][]} wallPoints
     * @param {number} wallSide
     * @return {java.awt.geom.Area}
     * @private
     */
    getWallSideArea(wallPoints: number[][], wallSide: number): java.awt.geom.Area {
        const thickness: number = 2.0;
        if (wallPoints.length === 4) {
            if (wallSide === RoomController.WallSide.LEFT_SIDE) {
                return new java.awt.geom.Area(this.getPath(new Wall(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], thickness, 0).getPoints$(), true));
            } else {
                return new java.awt.geom.Area(this.getPath(new Wall(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], thickness, 0).getPoints$(), true));
            }
        } else {
            let wallSidePoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })((wallPoints.length / 2 | 0));
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++]; } else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; } })(wallPoints, wallSide === RoomController.WallSide.LEFT_SIDE ? 0 : wallSidePoints.length, wallSidePoints, 0, wallSidePoints.length);
            const wallSideWalls: Wall[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(wallSidePoints.length - 1);
            for (let i: number = 0; i < wallSideWalls.length; i++) {
                {
                    wallSideWalls[i] = new Wall(wallSidePoints[i][0], wallSidePoints[i][1], wallSidePoints[i + 1][0], wallSidePoints[i + 1][1], thickness, 0);
                    if (i > 0) {
                        wallSideWalls[i].setWallAtStart(wallSideWalls[i - 1]);
                        wallSideWalls[i - 1].setWallAtEnd(wallSideWalls[i]);
                    }
                };
            }
            wallSidePoints = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(wallPoints.length);
            let wallSideWallPoints: number[][] = null;
            for (let i: number = 0; i < wallSideWalls.length; i++) {
                {
                    wallSideWallPoints = wallSideWalls[i].getPoints$();
                    wallSidePoints[i] = wallSideWallPoints[0];
                    wallSidePoints[wallSidePoints.length - i - 1] = wallSideWallPoints[3];
                };
            }
            wallSidePoints[(wallSidePoints.length / 2 | 0) - 1] = wallSideWallPoints[1];
            wallSidePoints[(wallSidePoints.length / 2 | 0)] = wallSideWallPoints[2];
            return new java.awt.geom.Area(this.getPath(wallSidePoints, true));
        }
    }

    /**
     * Returns the shape matching the coordinates in <code>points</code> array.
     * @param {float[][]} points
     * @param {boolean} closedPath
     * @return {java.awt.geom.GeneralPath}
     * @private
     */
    getPath(points: number[][], closedPath: boolean): java.awt.geom.GeneralPath {
        const path: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
        path.moveTo(points[0][0], points[0][1]);
        for (let i: number = 1; i < points.length; i++) {
            {
                path.lineTo(points[i][0], points[i][1]);
            };
        }
        if (closedPath) {
            path.closePath();
        }
        return path;
    }

    /**
     * Returns the surface of the given <code>area</code>.
     * @param {java.awt.geom.Area} area
     * @return {number}
     * @private
     */
    getSurface(area: java.awt.geom.Area): number {
        let surface: number = 0;
        const currentPathPoints: Array<number[]> = <any>([]);
        for (const it: java.awt.geom.PathIterator = area.getPathIterator(null); !it.isDone();) {
            {
                const roomPoint: number[] = [0, 0];
                switch ((it.currentSegment(roomPoint))) {
                    case java.awt.geom.PathIterator.SEG_MOVETO:
                /* add */(currentPathPoints.push(roomPoint) > 0);
                        break;
                    case java.awt.geom.PathIterator.SEG_LINETO:
                /* add */(currentPathPoints.push(roomPoint) > 0);
                        break;
                    case java.awt.geom.PathIterator.SEG_CLOSE:
                        const pathPoints: number[][] = /* toArray */currentPathPoints.slice(0);
                        surface += Math.abs(this.getSignedSurface(pathPoints));
                /* clear */(currentPathPoints.length = 0);
                        break;
                }
                it.next();
            };
        }
        return surface;
    }

    getSignedSurface(areaPoints: number[][]): number {
        let area: number = 0;
        for (let i: number = 1; i < areaPoints.length; i++) {
            {
                area += areaPoints[i][0] * areaPoints[i - 1][1];
                area -= areaPoints[i][1] * areaPoints[i - 1][0];
            };
        }
        area += areaPoints[0][0] * areaPoints[areaPoints.length - 1][1];
        area -= areaPoints[0][1] * areaPoints[areaPoints.length - 1][0];
        return area / 2;
    }

    /**
     * Sets the edited name.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name) {
            const oldName: string = this.name;
            this.name = name;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns the edited name.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets whether room area is visible or not.
     * @param {boolean} areaVisible
     */
    public setAreaVisible(areaVisible: boolean) {
        if (areaVisible !== this.areaVisible) {
            const oldAreaVisible: boolean = this.areaVisible;
            this.areaVisible = areaVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"AREA_VISIBLE", oldAreaVisible, areaVisible);
        }
    }

    /**
     * Returns whether room area is visible or not.
     * @return {boolean}
     */
    public getAreaVisible(): boolean {
        return this.areaVisible;
    }

    /**
     * Sets whether room floor is visible or not.
     * @param {boolean} floorVisible
     */
    public setFloorVisible(floorVisible: boolean) {
        if (floorVisible !== this.floorVisible) {
            const oldFloorVisible: boolean = this.floorVisible;
            this.floorVisible = floorVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"FLOOR_VISIBLE", oldFloorVisible, floorVisible);
        }
    }

    /**
     * Returns whether room floor is visible or not.
     * @return {boolean}
     */
    public getFloorVisible(): boolean {
        return this.floorVisible;
    }

    /**
     * Sets the edited color of the floor.
     * @param {number} floorColor
     */
    public setFloorColor(floorColor: number) {
        if (floorColor !== this.floorColor) {
            const oldFloorColor: number = this.floorColor;
            this.floorColor = floorColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"FLOOR_COLOR", oldFloorColor, floorColor);
            this.setFloorPaint(RoomController.RoomPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the floor.
     * @return {number}
     */
    public getFloorColor(): number {
        return this.floorColor;
    }

    /**
     * Sets whether the floor is colored, textured or unknown painted.
     * @param {RoomController.RoomPaint} floorPaint
     */
    public setFloorPaint(floorPaint: RoomController.RoomPaint) {
        if (floorPaint !== this.floorPaint) {
            const oldFloorPaint: RoomController.RoomPaint = this.floorPaint;
            this.floorPaint = floorPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"FLOOR_PAINT", oldFloorPaint, floorPaint);
        }
    }

    /**
     * Returns whether the floor is colored, textured or unknown painted.
     * @return {RoomController.RoomPaint}
     */
    public getFloorPaint(): RoomController.RoomPaint {
        return this.floorPaint;
    }

    /**
     * Sets the edited shininess of the floor.
     * @param {number} floorShininess
     */
    public setFloorShininess(floorShininess: number) {
        if (floorShininess !== this.floorShininess) {
            const oldFloorShininess: number = this.floorShininess;
            this.floorShininess = floorShininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"FLOOR_SHININESS", oldFloorShininess, floorShininess);
        }
    }

    /**
     * Returns the edited shininess of the floor.
     * @return {number}
     */
    public getFloorShininess(): number {
        return this.floorShininess;
    }

    /**
     * Sets whether room ceiling is visible or not.
     * @param {boolean} ceilingCeilingVisible
     */
    public setCeilingVisible(ceilingCeilingVisible: boolean) {
        if (ceilingCeilingVisible !== this.ceilingVisible) {
            const oldCeilingVisible: boolean = this.ceilingVisible;
            this.ceilingVisible = ceilingCeilingVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_VISIBLE", oldCeilingVisible, ceilingCeilingVisible);
        }
    }

    /**
     * Returns whether room ceiling is visible or not.
     * @return {boolean}
     */
    public getCeilingVisible(): boolean {
        return this.ceilingVisible;
    }

    /**
     * Sets the edited color of the ceiling.
     * @param {number} ceilingColor
     */
    public setCeilingColor(ceilingColor: number) {
        if (ceilingColor !== this.ceilingColor) {
            const oldCeilingColor: number = this.ceilingColor;
            this.ceilingColor = ceilingColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_COLOR", oldCeilingColor, ceilingColor);
            this.setCeilingPaint(RoomController.RoomPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the ceiling.
     * @return {number}
     */
    public getCeilingColor(): number {
        return this.ceilingColor;
    }

    /**
     * Sets whether the ceiling is colored, textured or unknown painted.
     * @param {RoomController.RoomPaint} ceilingPaint
     */
    public setCeilingPaint(ceilingPaint: RoomController.RoomPaint) {
        if (ceilingPaint !== this.ceilingPaint) {
            const oldCeilingPaint: RoomController.RoomPaint = this.ceilingPaint;
            this.ceilingPaint = ceilingPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_PAINT", oldCeilingPaint, ceilingPaint);
        }
    }

    /**
     * Returns whether the ceiling is colored, textured or unknown painted.
     * @return {RoomController.RoomPaint}
     */
    public getCeilingPaint(): RoomController.RoomPaint {
        return this.ceilingPaint;
    }

    /**
     * Sets the edited shininess of the ceiling.
     * @param {number} ceilingShininess
     */
    public setCeilingShininess(ceilingShininess: number) {
        if (ceilingShininess !== this.ceilingShininess) {
            const oldCeilingShininess: number = this.ceilingShininess;
            this.ceilingShininess = ceilingShininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_SHININESS", oldCeilingShininess, ceilingShininess);
        }
    }

    /**
     * Returns the edited shininess of the ceiling.
     * @return {number}
     */
    public getCeilingShininess(): number {
        return this.ceilingShininess;
    }

    /**
     * Sets whether room ceiling should remain flat whatever its environment or not.
     * @param {boolean} ceilingCeilingFlat
     */
    public setCeilingFlat(ceilingCeilingFlat: boolean) {
        if (ceilingCeilingFlat !== this.ceilingFlat) {
            const oldCeilingFlat: boolean = this.ceilingFlat;
            this.ceilingFlat = ceilingCeilingFlat;
            this.propertyChangeSupport.firePropertyChange(/* name */"CEILING_FLAT", oldCeilingFlat, ceilingCeilingFlat);
        }
    }

    /**
     * Returns whether room ceiling should remain flat whatever its environment or not.
     * @return {boolean}
     */
    public getCeilingFlat(): boolean {
        return this.ceilingFlat;
    }

    /**
     * Returns <code>true</code> if walls around the edited rooms should be split.
     * @return {boolean}
     */
    public isSplitSurroundingWalls(): boolean {
        return this.splitSurroundingWalls;
    }

    /**
     * Sets whether walls around the edited rooms should be split or not.
     * @param {boolean} splitSurroundingWalls
     */
    public setSplitSurroundingWalls(splitSurroundingWalls: boolean) {
        if (splitSurroundingWalls !== this.splitSurroundingWalls) {
            this.splitSurroundingWalls = splitSurroundingWalls;
            this.propertyChangeSupport.firePropertyChange(/* name */"SPLIT_SURROUNDING_WALLS", !splitSurroundingWalls, splitSurroundingWalls);
        }
    }

    /**
     * Returns <code>true</code> if walls around the edited rooms need to be split
     * to avoid changing the color of wall sides that belong to neighborhood rooms.
     * @return {boolean}
     */
    public isSplitSurroundingWallsNeeded(): boolean {
        return this.splitSurroundingWallsNeeded;
    }

    /**
     * Sets the edited color of the wall sides.
     * @param {number} wallSidesColor
     */
    public setWallSidesColor(wallSidesColor: number) {
        if (wallSidesColor !== this.wallSidesColor) {
            const oldWallSidesColor: number = this.wallSidesColor;
            this.wallSidesColor = wallSidesColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"WALL_SIDES_COLOR", oldWallSidesColor, wallSidesColor);
            this.setWallSidesPaint(RoomController.RoomPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the wall sides.
     * @return {number}
     */
    public getWallSidesColor(): number {
        return this.wallSidesColor;
    }

    /**
     * Sets whether the wall sides are colored, textured or unknown painted.
     * @param {RoomController.RoomPaint} wallSidesPaint
     */
    public setWallSidesPaint(wallSidesPaint: RoomController.RoomPaint) {
        if (wallSidesPaint !== this.wallSidesPaint) {
            const oldWallSidesPaint: RoomController.RoomPaint = this.wallSidesPaint;
            this.wallSidesPaint = wallSidesPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"WALL_SIDES_PAINT", oldWallSidesPaint, wallSidesPaint);
        }
    }

    /**
     * Returns whether the wall sides are colored, textured or unknown painted.
     * @return {RoomController.RoomPaint}
     */
    public getWallSidesPaint(): RoomController.RoomPaint {
        return this.wallSidesPaint;
    }

    /**
     * Sets the edited shininess of the wall sides.
     * @param {number} wallSidesShininess
     */
    public setWallSidesShininess(wallSidesShininess: number) {
        if (wallSidesShininess !== this.wallSidesShininess) {
            const oldWallSidesShininess: number = this.wallSidesShininess;
            this.wallSidesShininess = wallSidesShininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"WALL_SIDES_SHININESS", oldWallSidesShininess, wallSidesShininess);
        }
    }

    /**
     * Returns the edited shininess of the wall sides.
     * @return {number}
     */
    public getWallSidesShininess(): number {
        return this.wallSidesShininess;
    }

    /**
     * Controls the modification of selected rooms in edited home.
     */
    public modifyRooms() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedRooms: Array<Room> = Home.getRoomsSubList(oldSelection);
        if (!/* isEmpty */(selectedRooms.length == 0)) {
            const name: string = this.getName();
            const areaVisible: boolean = this.getAreaVisible();
            const floorVisible: boolean = this.getFloorVisible();
            const floorPaint: RoomController.RoomPaint = this.getFloorPaint();
            const floorColor: number = floorPaint === RoomController.RoomPaint.COLORED ? this.getFloorColor() : null;
            const floorTexture: HomeTexture = floorPaint === RoomController.RoomPaint.TEXTURED ? this.getFloorTextureController().getTexture() : null;
            const floorShininess: number = this.getFloorShininess();
            const ceilingVisible: boolean = this.getCeilingVisible();
            const ceilingPaint: RoomController.RoomPaint = this.getCeilingPaint();
            const ceilingColor: number = ceilingPaint === RoomController.RoomPaint.COLORED ? this.getCeilingColor() : null;
            const ceilingTexture: HomeTexture = ceilingPaint === RoomController.RoomPaint.TEXTURED ? this.getCeilingTextureController().getTexture() : null;
            const ceilingShininess: number = this.getCeilingShininess();
            const ceilingFlat: boolean = this.getCeilingFlat();
            const wallSidesPaint: RoomController.RoomPaint = this.getWallSidesPaint();
            const wallSidesColor: number = wallSidesPaint === RoomController.RoomPaint.COLORED ? this.getWallSidesColor() : null;
            const wallSidesTexture: HomeTexture = wallSidesPaint === RoomController.RoomPaint.TEXTURED ? this.getWallSidesTextureController().getTexture() : null;
            const wallSidesShininess: number = this.getWallSidesShininess();
            const wallSidesBaseboardVisible: boolean = this.getWallSidesBaseboardController().getVisible();
            const wallSidesBaseboardThickness: number = this.getWallSidesBaseboardController().getThickness();
            const wallSidesBaseboardHeight: number = this.getWallSidesBaseboardController().getHeight();
            const wallSidesBaseboardPaint: BaseboardChoiceController.BaseboardPaint = this.getWallSidesBaseboardController().getPaint();
            const wallSidesBaseboardColor: number = wallSidesBaseboardPaint === BaseboardChoiceController.BaseboardPaint.COLORED ? this.getWallSidesBaseboardController().getColor() : null;
            const wallSidesBaseboardTexture: HomeTexture = wallSidesBaseboardPaint === BaseboardChoiceController.BaseboardPaint.TEXTURED ? this.getWallSidesBaseboardController().getTextureController().getTexture() : null;
            let selectedRoomsWallSides: Array<RoomController.WallSide> = this.getRoomsWallSides(selectedRooms, null);
            const modifiedRooms: RoomController.ModifiedRoom[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedRooms.length));
            for (let i: number = 0; i < modifiedRooms.length; i++) {
                {
                    modifiedRooms[i] = new RoomController.ModifiedRoom(/* get */selectedRooms[i]);
                };
            }
            const deletedWalls: Array<RoomController.ModifiedWall> = <any>([]);
            const addedWalls: Array<RoomController.ModifiedWall> = <any>([]);
            const newSelection: Array<Selectable> = <any>(oldSelection.slice(0));
            if (this.splitSurroundingWalls) {
                if (this.splitWalls(selectedRoomsWallSides, deletedWalls, addedWalls, newSelection)) {
                    this.home.setSelectedItems(newSelection);
                    selectedRoomsWallSides = this.getRoomsWallSides(selectedRooms, selectedRoomsWallSides);
                }
            }
            const modifiedWallSides: RoomController.ModifiedWallSide[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedRoomsWallSides.length));
            for (let i: number = 0; i < modifiedWallSides.length; i++) {
                {
                    modifiedWallSides[i] = new RoomController.ModifiedWallSide(/* get */selectedRoomsWallSides[i]);
                };
            }
            RoomController.doModifyRoomsAndWallSides(this.home, modifiedRooms, name, areaVisible, floorVisible, floorPaint, floorColor, floorTexture, floorShininess, ceilingVisible, ceilingPaint, ceilingColor, ceilingTexture, ceilingShininess, ceilingFlat, modifiedWallSides, this.preferences.getNewWallBaseboardThickness(), this.preferences.getNewWallBaseboardHeight(), wallSidesPaint, wallSidesColor, wallSidesTexture, wallSidesShininess, wallSidesBaseboardVisible, wallSidesBaseboardThickness, wallSidesBaseboardHeight, wallSidesBaseboardPaint, wallSidesBaseboardColor, wallSidesBaseboardTexture, null, null);
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(new RoomController.RoomsAndWallSidesModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), /* toArray */newSelection.slice(0), modifiedRooms, name, areaVisible, floorVisible, floorPaint, floorColor, floorTexture, floorShininess, ceilingVisible, ceilingPaint, ceilingColor, ceilingTexture, ceilingShininess, ceilingFlat, modifiedWallSides, this.preferences.getNewWallBaseboardThickness(), this.preferences.getNewWallBaseboardHeight(), wallSidesPaint, wallSidesColor, wallSidesTexture, wallSidesShininess, wallSidesBaseboardVisible, wallSidesBaseboardThickness, wallSidesBaseboardHeight, wallSidesBaseboardPaint, wallSidesBaseboardColor, wallSidesBaseboardTexture, /* toArray */deletedWalls.slice(0), /* toArray */addedWalls.slice(0)));
            }
            if (name != null) {
                this.preferences.addAutoCompletionString("RoomName", name);
            }
        }
    }

    /**
     * Splits walls that overfill on other rooms if needed and returns <code>false</code> if the operation wasn't needed.
     * @param {RoomController.WallSide[]} wallSides
     * @param {RoomController.ModifiedWall[]} deletedWalls
     * @param {RoomController.ModifiedWall[]} addedWalls
     * @param {*[]} selectedItems
     * @return {boolean}
     * @private
     */
    splitWalls(wallSides: Array<RoomController.WallSide>, deletedWalls: Array<RoomController.ModifiedWall>, addedWalls: Array<RoomController.ModifiedWall>, selectedItems: Array<Selectable>): boolean {
        let existingWalls: any = null;
        const newWalls: Array<Wall> = <any>([]);
        let splitWallSide: RoomController.WallSide;
        do {
            {
                splitWallSide = null;
                let firstWall: Wall = null;
                let secondWall: Wall = null;
                let deletedWall: RoomController.ModifiedWall = null;
                for (let i: number = 0; i < /* size */(<number>wallSides.length) && splitWallSide == null; i++) {
                    {
                        const wallSide: RoomController.WallSide = /* get */wallSides[i];
                        const wall: Wall = wallSide.getWall();
                        const arcExtent: number = wall.getArcExtent();
                        if (arcExtent == null || /* floatValue */arcExtent === 0) {
                            const wallArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath(wall.getPoints$(), true));
                            for (let index = 0; index < wallSides.length; index++) {
                                let intersectedWallSide = wallSides[index];
                                {
                                    const intersectedWall: Wall = intersectedWallSide.getWall();
                                    if (wall !== intersectedWall) {
                                        const intersectedWallArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath(intersectedWall.getPoints$(), true));
                                        intersectedWallArea.intersect(wallArea);
                                        if (!intersectedWallArea.isEmpty() && intersectedWallArea.isSingular()) {
                                            const intersection: number[] = this.computeIntersection(wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd(), intersectedWall.getXStart(), intersectedWall.getYStart(), intersectedWall.getXEnd(), intersectedWall.getYEnd());
                                            if (intersection != null) {
                                                firstWall = <Wall>wall.duplicate();
                                                secondWall = <Wall>wall.duplicate();
                                                firstWall.setLevel(wall.getLevel());
                                                secondWall.setLevel(wall.getLevel());
                                                firstWall.setXEnd(intersection[0]);
                                                firstWall.setYEnd(intersection[1]);
                                                secondWall.setXStart(intersection[0]);
                                                secondWall.setYStart(intersection[1]);
                                                if (firstWall.getLength() > intersectedWall.getThickness() / 2 && secondWall.getLength() > intersectedWall.getThickness() / 2) {
                                                    if (deletedWalls == null) {
                                                        return true;
                                                    }
                                                    if (existingWalls == null) {
                                                        existingWalls = <any>({});
                                                        for (let index1 = 0; index1 < wallSides.length; index1++) {
                                                            let side = wallSides[index1];
                                                            {
                                                                if (!/* containsKey */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return true; } return false; })(<any>existingWalls, side.getWall())) {
                                                            /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>existingWalls, side.getWall(), new RoomController.ModifiedWall(side.getWall()));
                                                                }
                                                            }
                                                        }
                                                    }
                                                    deletedWall = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>existingWalls, wall);
                                                    const wallAtStart: Wall = wall.getWallAtStart();
                                                    if (wallAtStart != null) {
                                                        firstWall.setWallAtStart(wallAtStart);
                                                        if (wallAtStart.getWallAtEnd() === wall) {
                                                            wallAtStart.setWallAtEnd(firstWall);
                                                        } else {
                                                            wallAtStart.setWallAtStart(firstWall);
                                                        }
                                                    }
                                                    const wallAtEnd: Wall = wall.getWallAtEnd();
                                                    if (wallAtEnd != null) {
                                                        secondWall.setWallAtEnd(wallAtEnd);
                                                        if (wallAtEnd.getWallAtEnd() === wall) {
                                                            wallAtEnd.setWallAtEnd(secondWall);
                                                        } else {
                                                            wallAtEnd.setWallAtStart(secondWall);
                                                        }
                                                    }
                                                    firstWall.setWallAtEnd(secondWall);
                                                    secondWall.setWallAtStart(firstWall);
                                                    if (wall.getHeightAtEnd() != null) {
                                                        const heightAtIntersecion: number = wall.getHeight() + (wall.getHeightAtEnd() - wall.getHeight()) * <number>java.awt.geom.Point2D.distance(wall.getXStart(), wall.getYStart(), intersection[0], intersection[1]) / wall.getLength();
                                                        firstWall.setHeightAtEnd(heightAtIntersecion);
                                                        secondWall.setHeight(heightAtIntersecion);
                                                    }
                                                    splitWallSide = wallSide;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                if (splitWallSide != null) {
                /* add */(newWalls.push(firstWall) > 0);
                /* add */(newWalls.push(secondWall) > 0);
                    const splitWall: Wall = splitWallSide.getWall();
                    if (/* contains */(this.home.getWalls().indexOf(<any>(splitWall)) >= 0)) {
                    /* add */(deletedWalls.push(deletedWall) > 0);
                    } else {
                        for (let i: number = /* size */(<number>newWalls.length) - 1; i >= 0; i--) {
                            {
                                if (/* get */newWalls[i] === splitWall) {
                            /* remove */newWalls.splice(i, 1)[0];
                                    break;
                                }
                            };
                        }
                    }
                    if (/* remove */(a => { let index = a.indexOf(splitWall); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems)) {
                    /* add */(selectedItems.push(firstWall) > 0);
                    /* add */(selectedItems.push(secondWall) > 0);
                    }
                /* remove */(a => { let index = a.indexOf(splitWallSide); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(wallSides);
                /* add */(wallSides.push(new RoomController.WallSide(firstWall, splitWallSide.getSide())) > 0);
                /* add */(wallSides.push(new RoomController.WallSide(secondWall, splitWallSide.getSide())) > 0);
                    const sameWallSides: Array<RoomController.WallSide> = <any>([]);
                    for (let i: number = /* size */(<number>wallSides.length) - 1; i >= 0; i--) {
                        {
                            const wallSide: RoomController.WallSide = /* get */wallSides[i];
                            if (wallSide.getWall() === splitWall) {
                        /* remove */wallSides.splice(i, 1)[0];
                        /* add */(sameWallSides.push(new RoomController.WallSide(firstWall, wallSide.getSide())) > 0);
                        /* add */(sameWallSides.push(new RoomController.WallSide(secondWall, wallSide.getSide())) > 0);
                            }
                        };
                    }
                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(wallSides, sameWallSides);
                }
            }
        } while ((splitWallSide != null));
        if (deletedWalls == null) {
            return false;
        } else {
            for (let index = 0; index < newWalls.length; index++) {
                let newWall = newWalls[index];
                {
                    const addedWall: RoomController.ModifiedWall = new RoomController.ModifiedWall(newWall);
                    /* add */(addedWalls.push(addedWall) > 0);
                    this.home.addWall(newWall);
                    newWall.setLevel(addedWall.getLevel());
                }
            }
            for (let index = 0; index < deletedWalls.length; index++) {
                let deletedWall = deletedWalls[index];
                {
                    this.home.deleteWall(deletedWall.getWall());
                }
            }
            return !/* isEmpty */(deletedWalls.length == 0);
        }
    }

    /**
     * Returns the intersection between a line segment and a second line.
     * @param {number} xPoint1
     * @param {number} yPoint1
     * @param {number} xPoint2
     * @param {number} yPoint2
     * @param {number} xPoint3
     * @param {number} yPoint3
     * @param {number} xPoint4
     * @param {number} yPoint4
     * @return {float[]}
     * @private
     */
    computeIntersection(xPoint1: number, yPoint1: number, xPoint2: number, yPoint2: number, xPoint3: number, yPoint3: number, xPoint4: number, yPoint4: number): number[] {
        const point: number[] = PlanController.computeIntersection$float$float$float$float$float$float$float$float(xPoint1, yPoint1, xPoint2, yPoint2, xPoint3, yPoint3, xPoint4, yPoint4);
        if (java.awt.geom.Line2D.ptSegDistSq(xPoint1, yPoint1, xPoint2, yPoint2, point[0], point[1]) < 1.0E-7 && (Math.abs(xPoint1 - point[0]) > 1.0E-4 || Math.abs(yPoint1 - point[1]) > 1.0E-4) && (Math.abs(xPoint2 - point[0]) > 1.0E-4 || Math.abs(yPoint2 - point[1]) > 1.0E-4)) {
            return point;
        } else {
            return null;
        }
    }

    /**
     * Modifies rooms and walls properties with the values in parameter.
     * @param {Home} home
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedRoom[]} modifiedRooms
     * @param {string} name
     * @param {boolean} areaVisible
     * @param {boolean} floorVisible
     * @param {RoomController.RoomPaint} floorPaint
     * @param {number} floorColor
     * @param {HomeTexture} floorTexture
     * @param {number} floorShininess
     * @param {boolean} ceilingVisible
     * @param {RoomController.RoomPaint} ceilingPaint
     * @param {number} ceilingColor
     * @param {HomeTexture} ceilingTexture
     * @param {number} ceilingShininess
     * @param {boolean} ceilingFlat
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWallSide[]} modifiedWallSides
     * @param {number} newWallBaseboardThickness
     * @param {number} newWallBaseboardHeight
     * @param {RoomController.RoomPaint} wallSidesPaint
     * @param {number} wallSidesColor
     * @param {HomeTexture} wallSidesTexture
     * @param {number} wallSidesShininess
     * @param {boolean} wallSidesBaseboardVisible
     * @param {number} wallSidesBaseboardThickness
     * @param {number} wallSidesBaseboardHeight
     * @param {BaseboardChoiceController.BaseboardPaint} wallSidesBaseboardPaint
     * @param {number} wallSidesBaseboardColor
     * @param {HomeTexture} wallSidesBaseboardTexture
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWall[]} deletedWalls
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWall[]} addedWalls
     * @private
     */
    static doModifyRoomsAndWallSides(home: Home, modifiedRooms: RoomController.ModifiedRoom[], name: string, areaVisible: boolean, floorVisible: boolean, floorPaint: RoomController.RoomPaint, floorColor: number, floorTexture: HomeTexture, floorShininess: number, ceilingVisible: boolean, ceilingPaint: RoomController.RoomPaint, ceilingColor: number, ceilingTexture: HomeTexture, ceilingShininess: number, ceilingFlat: boolean, modifiedWallSides: RoomController.ModifiedWallSide[], newWallBaseboardThickness: number, newWallBaseboardHeight: number, wallSidesPaint: RoomController.RoomPaint, wallSidesColor: number, wallSidesTexture: HomeTexture, wallSidesShininess: number, wallSidesBaseboardVisible: boolean, wallSidesBaseboardThickness: number, wallSidesBaseboardHeight: number, wallSidesBaseboardPaint: BaseboardChoiceController.BaseboardPaint, wallSidesBaseboardColor: number, wallSidesBaseboardTexture: HomeTexture, deletedWalls: RoomController.ModifiedWall[], addedWalls: RoomController.ModifiedWall[]) {
        if (deletedWalls != null) {
            for (let index = 0; index < addedWalls.length; index++) {
                let newWall = addedWalls[index];
                {
                    newWall.resetJoinedWalls();
                    home.addWall(newWall.getWall());
                    newWall.getWall().setLevel(newWall.getLevel());
                }
            }
            for (let index = 0; index < deletedWalls.length; index++) {
                let deletedWall = deletedWalls[index];
                {
                    home.deleteWall(deletedWall.getWall());
                }
            }
        }
        for (let index = 0; index < modifiedRooms.length; index++) {
            let modifiedRoom = modifiedRooms[index];
            {
                const room: Room = modifiedRoom.getRoom();
                if (name != null) {
                    room.setName(name);
                }
                if (areaVisible != null) {
                    room.setAreaVisible(areaVisible);
                }
                if (floorVisible != null) {
                    room.setFloorVisible(floorVisible);
                }
                if (floorPaint != null) {
                    switch ((floorPaint)) {
                        case RoomController.RoomPaint.DEFAULT:
                            room.setFloorColor(null);
                            room.setFloorTexture(null);
                            break;
                        case RoomController.RoomPaint.COLORED:
                            room.setFloorColor(floorColor);
                            room.setFloorTexture(null);
                            break;
                        case RoomController.RoomPaint.TEXTURED:
                            room.setFloorColor(null);
                            room.setFloorTexture(floorTexture);
                            break;
                    }
                }
                if (floorShininess != null) {
                    room.setFloorShininess(floorShininess);
                }
                if (ceilingVisible != null) {
                    room.setCeilingVisible(ceilingVisible);
                }
                if (ceilingPaint != null) {
                    switch ((ceilingPaint)) {
                        case RoomController.RoomPaint.DEFAULT:
                            room.setCeilingColor(null);
                            room.setCeilingTexture(null);
                            break;
                        case RoomController.RoomPaint.COLORED:
                            room.setCeilingColor(ceilingColor);
                            room.setCeilingTexture(null);
                            break;
                        case RoomController.RoomPaint.TEXTURED:
                            room.setCeilingColor(null);
                            room.setCeilingTexture(ceilingTexture);
                            break;
                    }
                }
                if (ceilingShininess != null) {
                    room.setCeilingShininess(ceilingShininess);
                }
                if (ceilingFlat != null) {
                    room.setCeilingFlat(ceilingFlat);
                }
            }
        }
        for (let index = 0; index < modifiedWallSides.length; index++) {
            let modifiedWallSide = modifiedWallSides[index];
            {
                const wallSide: RoomController.WallSide = modifiedWallSide.getWallSide();
                const wall: Wall = wallSide.getWall();
                if (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE) {
                    if (wallSidesPaint != null) {
                        switch ((wallSidesPaint)) {
                            case RoomController.RoomPaint.DEFAULT:
                                wall.setLeftSideColor(null);
                                wall.setLeftSideTexture(null);
                                break;
                            case RoomController.RoomPaint.COLORED:
                                wall.setLeftSideColor(wallSidesColor);
                                wall.setLeftSideTexture(null);
                                break;
                            case RoomController.RoomPaint.TEXTURED:
                                wall.setLeftSideColor(null);
                                wall.setLeftSideTexture(wallSidesTexture);
                                break;
                        }
                    }
                    if (wallSidesShininess != null) {
                        wall.setLeftSideShininess(wallSidesShininess);
                    }
                } else {
                    if (wallSidesPaint != null) {
                        switch ((wallSidesPaint)) {
                            case RoomController.RoomPaint.DEFAULT:
                                wall.setRightSideColor(null);
                                wall.setRightSideTexture(null);
                                break;
                            case RoomController.RoomPaint.COLORED:
                                wall.setRightSideColor(wallSidesColor);
                                wall.setRightSideTexture(null);
                                break;
                            case RoomController.RoomPaint.TEXTURED:
                                wall.setRightSideColor(null);
                                wall.setRightSideTexture(wallSidesTexture);
                                break;
                        }
                    }
                    if (wallSidesShininess != null) {
                        wall.setRightSideShininess(wallSidesShininess);
                    }
                }
                if (wallSidesBaseboardVisible === false) {
                    if (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE) {
                        wall.setLeftSideBaseboard(null);
                    } else {
                        wall.setRightSideBaseboard(null);
                    }
                } else {
                    let baseboard: Baseboard = wallSide.getSide() === RoomController.WallSide.LEFT_SIDE ? wall.getLeftSideBaseboard() : wall.getRightSideBaseboard();
                    if (wallSidesBaseboardVisible === true || baseboard != null) {
                        const baseboardThickness: number = baseboard != null ? baseboard.getThickness() : newWallBaseboardThickness;
                        const baseboardHeight: number = baseboard != null ? baseboard.getHeight() : newWallBaseboardHeight;
                        let baseboardColor: number = baseboard != null ? baseboard.getColor() : null;
                        let baseboardTexture: HomeTexture = baseboard != null ? baseboard.getTexture() : null;
                        if (wallSidesBaseboardPaint != null) {
                            switch ((wallSidesBaseboardPaint)) {
                                case BaseboardChoiceController.BaseboardPaint.DEFAULT:
                                    baseboardColor = null;
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.COLORED:
                                    if (wallSidesBaseboardColor != null) {
                                        baseboardColor = wallSidesBaseboardColor;
                                    }
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.TEXTURED:
                                    baseboardColor = null;
                                    if (wallSidesBaseboardTexture != null) {
                                        baseboardTexture = wallSidesBaseboardTexture;
                                    }
                                    break;
                            }
                        }
                        baseboard = Baseboard.getInstance(wallSidesBaseboardThickness != null ? wallSidesBaseboardThickness : baseboardThickness, wallSidesBaseboardHeight != null ? wallSidesBaseboardHeight : baseboardHeight, baseboardColor, baseboardTexture);
                        if (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE) {
                            wall.setLeftSideBaseboard(baseboard);
                        } else {
                            wall.setRightSideBaseboard(baseboard);
                        }
                    }
                }
            }
        }
    }

    /**
     * Restores room properties from the values stored in <code>modifiedRooms</code> and <code>modifiedWallSides</code>.
     * @param {Home} home
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedRoom[]} modifiedRooms
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWallSide[]} modifiedWallSides
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWall[]} deletedWalls
     * @param {com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWall[]} addedWalls
     * @private
     */
    static undoModifyRoomsAndWallSides(home: Home, modifiedRooms: RoomController.ModifiedRoom[], modifiedWallSides: RoomController.ModifiedWallSide[], deletedWalls: RoomController.ModifiedWall[], addedWalls: RoomController.ModifiedWall[]) {
        for (let index = 0; index < modifiedRooms.length; index++) {
            let modifiedRoom = modifiedRooms[index];
            {
                modifiedRoom.reset();
            }
        }
        for (let index = 0; index < modifiedWallSides.length; index++) {
            let modifiedWallSide = modifiedWallSides[index];
            {
                modifiedWallSide.reset();
            }
        }
        for (let index = 0; index < addedWalls.length; index++) {
            let newWall = addedWalls[index];
            {
                home.deleteWall(newWall.getWall());
            }
        }
        for (let index = 0; index < deletedWalls.length; index++) {
            let deletedWall = deletedWalls[index];
            {
                deletedWall.resetJoinedWalls();
                home.addWall(deletedWall.getWall());
                deletedWall.getWall().setLevel(deletedWall.getLevel());
            }
        }
    }
}
RoomController["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController";
RoomController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace RoomController {

    /**
     * The possible values for {@linkplain #getFloorPaint() room paint type}.
     * @enum
     * @property {RoomController.RoomPaint} DEFAULT
     * @property {RoomController.RoomPaint} COLORED
     * @property {RoomController.RoomPaint} TEXTURED
     * @class
     */
    export enum RoomPaint {
        DEFAULT, COLORED, TEXTURED
    }

    /**
     * Undoable edit for rooms modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class RoomsAndWallSidesModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        newSelection: Selectable[];

        modifiedRooms: RoomController.ModifiedRoom[];

        name: string;

        areaVisible: boolean;

        floorVisible: boolean;

        floorPaint: RoomController.RoomPaint;

        floorColor: number;

        floorTexture: HomeTexture;

        floorShininess: number;

        ceilingVisible: boolean;

        ceilingPaint: RoomController.RoomPaint;

        ceilingColor: number;

        ceilingTexture: HomeTexture;

        ceilingShininess: number;

        ceilingFlat: boolean;

        modifiedWallSides: RoomController.ModifiedWallSide[];

        newWallBaseboardHeight: number;

        newWallBaseboardThickness: number;

        wallSidesPaint: RoomController.RoomPaint;

        wallSidesColor: number;

        wallSidesTexture: HomeTexture;

        wallSidesShininess: number;

        wallSidesBaseboardVisible: boolean;

        wallSidesBaseboardThickness: number;

        wallSidesBaseboardHeight: number;

        wallSidesBaseboardPaint: BaseboardChoiceController.BaseboardPaint;

        wallSidesBaseboardColor: number;

        wallSidesBaseboardTexture: HomeTexture;

        deletedWalls: RoomController.ModifiedWall[];

        addedWalls: RoomController.ModifiedWall[];

        constructor(home: Home, preferences: any, oldSelection: Selectable[], newSelection: Selectable[], modifiedRooms: RoomController.ModifiedRoom[], name: string, areaVisible: boolean, floorVisible: boolean, floorPaint: RoomController.RoomPaint, floorColor: number, floorTexture: HomeTexture, floorShininess: number, ceilingVisible: boolean, ceilingPaint: RoomController.RoomPaint, ceilingColor: number, ceilingTexture: HomeTexture, ceilingShininess: number, ceilingFlat: boolean, modifiedWallSides: RoomController.ModifiedWallSide[], newWallBaseboardThickness: number, newWallBaseboardHeight: number, wallSidesPaint: RoomController.RoomPaint, wallSidesColor: number, wallSidesTexture: HomeTexture, wallSidesShininess: number, wallSidesBaseboardVisible: boolean, wallSidesBaseboardThickness: number, wallSidesBaseboardHeight: number, wallSidesBaseboardPaint: BaseboardChoiceController.BaseboardPaint, wallSidesBaseboardColor: number, wallSidesBaseboardTexture: HomeTexture, deletedWalls: RoomController.ModifiedWall[], addedWalls: RoomController.ModifiedWall[]) {
            super(preferences, RoomController, "undoModifyRoomsName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.newSelection === undefined) { this.newSelection = null; }
            if (this.modifiedRooms === undefined) { this.modifiedRooms = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.areaVisible === undefined) { this.areaVisible = null; }
            if (this.floorVisible === undefined) { this.floorVisible = null; }
            if (this.floorPaint === undefined) { this.floorPaint = null; }
            if (this.floorColor === undefined) { this.floorColor = null; }
            if (this.floorTexture === undefined) { this.floorTexture = null; }
            if (this.floorShininess === undefined) { this.floorShininess = null; }
            if (this.ceilingVisible === undefined) { this.ceilingVisible = null; }
            if (this.ceilingPaint === undefined) { this.ceilingPaint = null; }
            if (this.ceilingColor === undefined) { this.ceilingColor = null; }
            if (this.ceilingTexture === undefined) { this.ceilingTexture = null; }
            if (this.ceilingShininess === undefined) { this.ceilingShininess = null; }
            if (this.ceilingFlat === undefined) { this.ceilingFlat = null; }
            if (this.modifiedWallSides === undefined) { this.modifiedWallSides = null; }
            if (this.newWallBaseboardHeight === undefined) { this.newWallBaseboardHeight = 0; }
            if (this.newWallBaseboardThickness === undefined) { this.newWallBaseboardThickness = 0; }
            if (this.wallSidesPaint === undefined) { this.wallSidesPaint = null; }
            if (this.wallSidesColor === undefined) { this.wallSidesColor = null; }
            if (this.wallSidesTexture === undefined) { this.wallSidesTexture = null; }
            if (this.wallSidesShininess === undefined) { this.wallSidesShininess = null; }
            if (this.wallSidesBaseboardVisible === undefined) { this.wallSidesBaseboardVisible = null; }
            if (this.wallSidesBaseboardThickness === undefined) { this.wallSidesBaseboardThickness = null; }
            if (this.wallSidesBaseboardHeight === undefined) { this.wallSidesBaseboardHeight = null; }
            if (this.wallSidesBaseboardPaint === undefined) { this.wallSidesBaseboardPaint = null; }
            if (this.wallSidesBaseboardColor === undefined) { this.wallSidesBaseboardColor = null; }
            if (this.wallSidesBaseboardTexture === undefined) { this.wallSidesBaseboardTexture = null; }
            if (this.deletedWalls === undefined) { this.deletedWalls = null; }
            if (this.addedWalls === undefined) { this.addedWalls = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.newSelection = newSelection;
            this.modifiedRooms = modifiedRooms;
            this.name = name;
            this.areaVisible = areaVisible;
            this.floorVisible = floorVisible;
            this.floorPaint = floorPaint;
            this.floorColor = floorColor;
            this.floorTexture = floorTexture;
            this.floorShininess = floorShininess;
            this.ceilingVisible = ceilingVisible;
            this.ceilingPaint = ceilingPaint;
            this.ceilingColor = ceilingColor;
            this.ceilingTexture = ceilingTexture;
            this.ceilingShininess = ceilingShininess;
            this.ceilingFlat = ceilingFlat;
            this.modifiedWallSides = modifiedWallSides;
            this.newWallBaseboardThickness = newWallBaseboardThickness;
            this.newWallBaseboardHeight = newWallBaseboardHeight;
            this.wallSidesPaint = wallSidesPaint;
            this.wallSidesColor = wallSidesColor;
            this.wallSidesTexture = wallSidesTexture;
            this.wallSidesShininess = wallSidesShininess;
            this.wallSidesBaseboardVisible = wallSidesBaseboardVisible;
            this.wallSidesBaseboardThickness = wallSidesBaseboardThickness;
            this.wallSidesBaseboardHeight = wallSidesBaseboardHeight;
            this.wallSidesBaseboardPaint = wallSidesBaseboardPaint;
            this.wallSidesBaseboardColor = wallSidesBaseboardColor;
            this.wallSidesBaseboardTexture = wallSidesBaseboardTexture;
            this.deletedWalls = deletedWalls;
            this.addedWalls = addedWalls;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            RoomController.undoModifyRoomsAndWallSides(this.home, this.modifiedRooms, this.modifiedWallSides, this.deletedWalls, this.addedWalls);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            RoomController.doModifyRoomsAndWallSides(this.home, this.modifiedRooms, this.name, this.areaVisible, this.floorVisible, this.floorPaint, this.floorColor, this.floorTexture, this.floorShininess, this.ceilingVisible, this.ceilingPaint, this.ceilingColor, this.ceilingTexture, this.ceilingShininess, this.ceilingFlat, this.modifiedWallSides, this.newWallBaseboardThickness, this.newWallBaseboardHeight, this.wallSidesPaint, this.wallSidesColor, this.wallSidesTexture, this.wallSidesShininess, this.wallSidesBaseboardVisible, this.wallSidesBaseboardThickness, this.wallSidesBaseboardHeight, this.wallSidesBaseboardPaint, this.wallSidesBaseboardColor, this.wallSidesBaseboardTexture, this.deletedWalls, this.addedWalls);
            this.home.setSelectedItems(/* asList */this.newSelection.slice(0));
        }
    }
    RoomsAndWallSidesModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController.RoomsAndWallSidesModificationUndoableEdit";
    RoomsAndWallSidesModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified room.
     * @param {Room} room
     * @class
     */
    export class ModifiedRoom {
        room: Room;

        name: string;

        areaVisible: boolean;

        floorVisible: boolean;

        floorColor: number;

        floorTexture: HomeTexture;

        floorShininess: number;

        ceilingVisible: boolean;

        ceilingColor: number;

        ceilingTexture: HomeTexture;

        ceilingShininess: number;

        ceilingFlat: boolean;

        public constructor(room: Room) {
            if (this.room === undefined) { this.room = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.areaVisible === undefined) { this.areaVisible = false; }
            if (this.floorVisible === undefined) { this.floorVisible = false; }
            if (this.floorColor === undefined) { this.floorColor = null; }
            if (this.floorTexture === undefined) { this.floorTexture = null; }
            if (this.floorShininess === undefined) { this.floorShininess = 0; }
            if (this.ceilingVisible === undefined) { this.ceilingVisible = false; }
            if (this.ceilingColor === undefined) { this.ceilingColor = null; }
            if (this.ceilingTexture === undefined) { this.ceilingTexture = null; }
            if (this.ceilingShininess === undefined) { this.ceilingShininess = 0; }
            if (this.ceilingFlat === undefined) { this.ceilingFlat = false; }
            this.room = room;
            this.name = room.getName();
            this.areaVisible = room.isAreaVisible();
            this.floorVisible = room.isFloorVisible();
            this.floorColor = room.getFloorColor();
            this.floorTexture = room.getFloorTexture();
            this.floorShininess = room.getFloorShininess();
            this.ceilingVisible = room.isCeilingVisible();
            this.ceilingColor = room.getCeilingColor();
            this.ceilingTexture = room.getCeilingTexture();
            this.ceilingShininess = room.getCeilingShininess();
            this.ceilingFlat = room.isCeilingFlat();
        }

        public getRoom(): Room {
            return this.room;
        }

        public reset() {
            this.room.setName(this.name);
            this.room.setAreaVisible(this.areaVisible);
            this.room.setFloorVisible(this.floorVisible);
            this.room.setFloorColor(this.floorColor);
            this.room.setFloorTexture(this.floorTexture);
            this.room.setFloorShininess(this.floorShininess);
            this.room.setCeilingVisible(this.ceilingVisible);
            this.room.setCeilingColor(this.ceilingColor);
            this.room.setCeilingTexture(this.ceilingTexture);
            this.room.setCeilingShininess(this.ceilingShininess);
            this.room.setCeilingFlat(this.ceilingFlat);
        }
    }
    ModifiedRoom["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedRoom";


    /**
     * A wall side.
     * @param {Wall} wall
     * @param {number} side
     * @class
     */
    export class WallSide {
        public static LEFT_SIDE: number = 0;

        public static RIGHT_SIDE: number = 1;

        wall: Wall;

        side: number;

        wallAtStart: Wall;

        wallAtEnd: Wall;

        joinedAtEndOfWallAtStart: boolean;

        joinedAtStartOfWallAtEnd: boolean;

        public constructor(wall: Wall, side: number) {
            if (this.wall === undefined) { this.wall = null; }
            if (this.side === undefined) { this.side = 0; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.joinedAtEndOfWallAtStart === undefined) { this.joinedAtEndOfWallAtStart = false; }
            if (this.joinedAtStartOfWallAtEnd === undefined) { this.joinedAtStartOfWallAtEnd = false; }
            this.wall = wall;
            this.side = side;
            this.wallAtStart = wall.getWallAtStart();
            this.joinedAtEndOfWallAtStart = this.wallAtStart != null && this.wallAtStart.getWallAtEnd() === wall;
            this.wallAtEnd = wall.getWallAtEnd();
            this.joinedAtStartOfWallAtEnd = this.wallAtEnd != null && this.wallAtEnd.getWallAtStart() === wall;
        }

        public getWall(): Wall {
            return this.wall;
        }

        public getSide(): number {
            return this.side;
        }

        public getWallAtStart(): Wall {
            return this.wallAtStart;
        }

        public getWallAtEnd(): Wall {
            return this.wallAtEnd;
        }

        public isJoinedAtEndOfWallAtStart(): boolean {
            return this.joinedAtEndOfWallAtStart;
        }

        public isJoinedAtStartOfWallAtEnd(): boolean {
            return this.joinedAtStartOfWallAtEnd;
        }
    }
    WallSide["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController.WallSide";


    /**
     * A modified wall.
     * @param {Wall} wall
     * @class
     */
    export class ModifiedWall {
        wall: Wall;

        level: Level;

        wallAtStart: Wall;

        wallAtEnd: Wall;

        joinedAtEndOfWallAtStart: boolean;

        joinedAtStartOfWallAtEnd: boolean;

        public constructor(wall: Wall) {
            if (this.wall === undefined) { this.wall = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.joinedAtEndOfWallAtStart === undefined) { this.joinedAtEndOfWallAtStart = false; }
            if (this.joinedAtStartOfWallAtEnd === undefined) { this.joinedAtStartOfWallAtEnd = false; }
            this.wall = wall;
            this.level = wall.getLevel();
            this.wallAtStart = wall.getWallAtStart();
            this.joinedAtEndOfWallAtStart = this.wallAtStart != null && this.wallAtStart.getWallAtEnd() === wall;
            this.wallAtEnd = wall.getWallAtEnd();
            this.joinedAtStartOfWallAtEnd = this.wallAtEnd != null && this.wallAtEnd.getWallAtStart() === wall;
        }

        public getWall(): Wall {
            return this.wall;
        }

        public getLevel(): Level {
            return this.level;
        }

        public resetJoinedWalls() {
            if (this.wallAtStart != null) {
                this.wall.setWallAtStart(this.wallAtStart);
                if (this.joinedAtEndOfWallAtStart) {
                    this.wallAtStart.setWallAtEnd(this.wall);
                } else {
                    this.wallAtStart.setWallAtStart(this.wall);
                }
            }
            if (this.wallAtEnd != null) {
                this.wall.setWallAtEnd(this.wallAtEnd);
                if (this.joinedAtStartOfWallAtEnd) {
                    this.wallAtEnd.setWallAtStart(this.wall);
                } else {
                    this.wallAtEnd.setWallAtEnd(this.wall);
                }
            }
        }
    }
    ModifiedWall["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWall";


    /**
     * Stores the current properties values of a modified wall side.
     * @param {RoomController.WallSide} wallSide
     * @class
     */
    export class ModifiedWallSide {
        wallSide: RoomController.WallSide;

        wallColor: number;

        wallTexture: HomeTexture;

        wallShininess: number;

        wallBaseboard: Baseboard;

        public constructor(wallSide: RoomController.WallSide) {
            if (this.wallSide === undefined) { this.wallSide = null; }
            if (this.wallColor === undefined) { this.wallColor = null; }
            if (this.wallTexture === undefined) { this.wallTexture = null; }
            if (this.wallShininess === undefined) { this.wallShininess = null; }
            if (this.wallBaseboard === undefined) { this.wallBaseboard = null; }
            this.wallSide = wallSide;
            const wall: Wall = wallSide.getWall();
            if (wallSide.getSide() === RoomController.WallSide.LEFT_SIDE) {
                this.wallColor = wall.getLeftSideColor();
                this.wallTexture = wall.getLeftSideTexture();
                this.wallShininess = wall.getLeftSideShininess();
                this.wallBaseboard = wall.getLeftSideBaseboard();
            } else {
                this.wallColor = wall.getRightSideColor();
                this.wallTexture = wall.getRightSideTexture();
                this.wallShininess = wall.getRightSideShininess();
                this.wallBaseboard = wall.getRightSideBaseboard();
            }
        }

        public getWallSide(): RoomController.WallSide {
            return this.wallSide;
        }

        public reset() {
            const wall: Wall = this.wallSide.getWall();
            if (this.wallSide.getSide() === RoomController.WallSide.LEFT_SIDE) {
                wall.setLeftSideColor(this.wallColor);
                wall.setLeftSideTexture(this.wallTexture);
                wall.setLeftSideShininess(this.wallShininess);
                wall.setLeftSideBaseboard(this.wallBaseboard);
            } else {
                wall.setRightSideColor(this.wallColor);
                wall.setRightSideTexture(this.wallTexture);
                wall.setRightSideShininess(this.wallShininess);
                wall.setRightSideBaseboard(this.wallBaseboard);
            }
            const wallAtStart: Wall = this.wallSide.getWallAtStart();
            if (wallAtStart != null) {
                wall.setWallAtStart(wallAtStart);
                if (this.wallSide.isJoinedAtEndOfWallAtStart()) {
                    wallAtStart.setWallAtEnd(wall);
                } else {
                    wallAtStart.setWallAtStart(wall);
                }
            }
            const wallAtEnd: Wall = this.wallSide.getWallAtEnd();
            if (wallAtEnd != null) {
                wall.setWallAtEnd(wallAtEnd);
                if (this.wallSide.isJoinedAtStartOfWallAtEnd()) {
                    wallAtEnd.setWallAtStart(wall);
                } else {
                    wallAtEnd.setWallAtEnd(wall);
                }
            }
        }
    }
    ModifiedWallSide["__class"] = "com.eteks.sweethome3d.viewcontroller.RoomController.ModifiedWallSide";


    export class RoomController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setFloorPaint(RoomController.RoomPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class RoomController$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setCeilingPaint(RoomController.RoomPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class RoomController$2 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setWallSidesPaint(RoomController.RoomPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * Creates the controller of home levels view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class LevelController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ homeLevelView: DialogView;

    /*private*/ name: string;

    /*private*/ viewable: boolean;

    /*private*/ elevation: number;

    /*private*/ elevationIndex: number;

    /*private*/ floorThickness: number;

    /*private*/ height: number;

    /*private*/ levels: Level[];

    /*private*/ selectedLevelIndex: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.homeLevelView === undefined) { this.homeLevelView = null; }
        if (this.name === undefined) { this.name = null; }
        if (this.viewable === undefined) { this.viewable = null; }
        if (this.elevation === undefined) { this.elevation = null; }
        if (this.elevationIndex === undefined) { this.elevationIndex = null; }
        if (this.floorThickness === undefined) { this.floorThickness = null; }
        if (this.height === undefined) { this.height = null; }
        if (this.levels === undefined) { this.levels = null; }
        if (this.selectedLevelIndex === undefined) { this.selectedLevelIndex = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.homeLevelView == null) {
            this.homeLevelView = this.viewFactory.createLevelView(this.preferences, this);
        }
        return this.homeLevelView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from selected level in the home edited by this controller.
     */
    updateProperties() {
        const selectedLevel: Level = this.home.getSelectedLevel();
        this.setLevels(this.clone(/* toArray */((a1, a2) => { if (a1.length >= a2.length) { a1.length = 0; a1.push.apply(a1, a2); return a1; } else { return a2.slice(0); } })([], this.home.getLevels())));
        if (selectedLevel == null) {
            this.setSelectedLevelIndex(null);
            this.setName(null);
            this.setViewable(true);
            this.setElevation(null, false);
            this.setFloorThickness(null);
            this.setHeight(null);
            this.setElevationIndex(null, false);
        } else {
            this.setSelectedLevelIndex(this.home.getLevels().indexOf(selectedLevel));
            this.setName(selectedLevel.getName());
            this.setViewable(selectedLevel.isViewable());
            this.setElevation(selectedLevel.getElevation(), false);
            this.setFloorThickness(selectedLevel.getFloorThickness());
            this.setHeight(selectedLevel.getHeight());
            this.setElevationIndex(selectedLevel.getElevationIndex(), false);
        }
    }

    clone(levels: Level[]): Level[] {
        for (let i: number = 0; i < levels.length; i++) {
            {
                levels[i] = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(levels[i]);
            };
        }
        return levels;
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * The implementation of this method always returns <code>true</code>.
     * @param {string} property
     * @return {boolean}
     */
    public isPropertyEditable(property: any): boolean {
        return true;
    }

    /**
     * Sets the edited name.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name) {
            const oldName: string = this.name;
            this.name = name;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
            if (this.selectedLevelIndex != null) {
                this.levels[this.selectedLevelIndex].setName(name);
                this.propertyChangeSupport.firePropertyChange(/* name */"LEVELS", null, this.levels);
            }
        }
    }

    /**
     * Returns the edited name.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the edited viewable attribute.
     * @param {boolean} viewable
     */
    public setViewable(viewable: boolean) {
        if (viewable !== this.viewable) {
            const oldViewable: boolean = viewable;
            this.viewable = viewable;
            this.propertyChangeSupport.firePropertyChange(/* name */"VIEWABLE", oldViewable, viewable);
            if (viewable != null && this.selectedLevelIndex != null) {
                this.levels[this.selectedLevelIndex].setViewable(viewable);
                this.propertyChangeSupport.firePropertyChange(/* name */"LEVELS", null, this.levels);
            }
        }
    }

    /**
     * Returns the edited viewable attribute.
     * @return {boolean}
     */
    public getViewable(): boolean {
        return this.viewable;
    }

    public setElevation(elevation: number, updateLevels: boolean = true) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
            if (updateLevels && elevation != null && this.selectedLevelIndex != null) {
                const elevationIndex: number = LevelController.updateLevelElevation(this.levels[this.selectedLevelIndex], elevation, /* asList */this.levels.slice(0));
                this.setElevationIndex(elevationIndex, false);
                this.updateLevels();
            }
        }
    }

    /**
     * Updates the elevation of the given <code>level</code> and modifies the
     * elevation index of other levels if necessary.
     * @param {Level} level
     * @param {number} elevation
     * @param {Level[]} levels
     * @return {number}
     * @private
     */
    static updateLevelElevation(level: Level, elevation: number, levels: Array<Level>): number {
        let levelIndex: number = /* size */(<number>levels.length);
        let elevationIndex: number = 0;
        for (let i: number = 0; i < /* size */(<number>levels.length); i++) {
            {
                const homeLevel: Level = /* get */levels[i];
                if (homeLevel === level) {
                    levelIndex = i;
                } else {
                    if (homeLevel.getElevation() === elevation) {
                        elevationIndex = homeLevel.getElevationIndex() + 1;
                    } else if (i > levelIndex && homeLevel.getElevation() === level.getElevation()) {
                        homeLevel.setElevationIndex(homeLevel.getElevationIndex() - 1);
                    }
                }
            };
        }
        level.setElevation(elevation);
        level.setElevationIndex(elevationIndex);
        return elevationIndex;
    }

    /**
     * Returns the edited elevation.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    public setElevationIndex(elevationIndex: number, updateLevels: boolean = true) {
        if (elevationIndex !== this.elevationIndex) {
            const oldElevationIndex: number = this.elevationIndex;
            this.elevationIndex = elevationIndex;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION_INDEX", oldElevationIndex, elevationIndex);
            if (updateLevels && elevationIndex != null && this.selectedLevelIndex != null) {
                LevelController.updateLevelElevationIndex(this.levels[this.selectedLevelIndex], elevationIndex, /* asList */this.levels.slice(0));
                this.updateLevels();
            }
        }
    }

    /**
     * Updates the elevation index of the given <code>level</code> and modifies the
     * elevation index of other levels at same elevation if necessary.
     * @param {Level} level
     * @param {number} elevationIndex
     * @param {Level[]} levels
     * @private
     */
    static updateLevelElevationIndex(level: Level, elevationIndex: number, levels: Array<Level>) {
        const elevationIndexSignum: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(elevationIndex - level.getElevationIndex());
        for (let index = 0; index < levels.length; index++) {
            let homeLevel = levels[index];
            {
                if (homeLevel !== level && homeLevel.getElevation() === level.getElevation() && /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(homeLevel.getElevationIndex() - level.getElevationIndex()) === elevationIndexSignum && /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(homeLevel.getElevationIndex() - elevationIndex) !== elevationIndexSignum) {
                    homeLevel.setElevationIndex(homeLevel.getElevationIndex() - (<number>elevationIndexSignum | 0));
                } else if (homeLevel.getElevation() > level.getElevation()) {
                    break;
                }
            }
        }
        level.setElevationIndex(elevationIndex);
    }

    updateLevels() {
        const tempHome: Home = new Home();
        const selectedLevel: Level = this.levels[this.selectedLevelIndex];
        for (let index = 0; index < this.levels.length; index++) {
            let homeLevel = this.levels[index];
            {
                tempHome.addLevel(homeLevel);
            }
        }
        const updatedLevels: Array<Level> = tempHome.getLevels();
        this.setLevels(/* toArray */updatedLevels.slice(0));
        this.setSelectedLevelIndex(updatedLevels.indexOf(selectedLevel));
    }

    /**
     * Returns the edited elevation index.
     * @return {number}
     */
    public getElevationIndex(): number {
        return this.elevationIndex;
    }

    /**
     * Sets the edited floor thickness.
     * @param {number} floorThickness
     */
    public setFloorThickness(floorThickness: number) {
        if (floorThickness !== this.floorThickness) {
            const oldFloorThickness: number = this.floorThickness;
            this.floorThickness = floorThickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"FLOOR_THICKNESS", oldFloorThickness, floorThickness);
            if (floorThickness != null && this.selectedLevelIndex != null) {
                this.levels[this.selectedLevelIndex].setFloorThickness(floorThickness);
                this.propertyChangeSupport.firePropertyChange(/* name */"LEVELS", null, this.levels);
            }
        }
    }

    /**
     * Returns the edited floor thickness.
     * @return {number}
     */
    public getFloorThickness(): number {
        return this.floorThickness;
    }

    /**
     * Sets the edited height.
     * @param {number} height
     */
    public setHeight(height: number) {
        if (height !== this.height) {
            const oldHeight: number = this.height;
            this.height = height;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
            if (height != null && this.selectedLevelIndex != null) {
                this.levels[this.selectedLevelIndex].setHeight(height);
                this.propertyChangeSupport.firePropertyChange(/* name */"LEVELS", null, this.levels);
            }
        }
    }

    /**
     * Returns the edited height.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets home levels.
     * @param {com.eteks.sweethome3d.model.Level[]} levels
     * @private
     */
    setLevels(levels: Level[]) {
        if (levels !== this.levels) {
            const oldLevels: Level[] = this.levels;
            this.levels = levels;
            this.propertyChangeSupport.firePropertyChange(/* name */"LEVELS", oldLevels, levels);
        }
    }

    /**
     * Returns a copy of home levels.
     * @return {com.eteks.sweethome3d.model.Level[]}
     */
    public getLevels(): Level[] {
        return /* clone */this.levels.slice(0);
    }

    /**
     * Sets the selected level index.
     * @param {number} selectedLevelIndex
     * @private
     */
    setSelectedLevelIndex(selectedLevelIndex: number) {
        if (selectedLevelIndex !== this.selectedLevelIndex) {
            const oldSelectedLevelIndex: number = this.selectedLevelIndex;
            this.selectedLevelIndex = selectedLevelIndex;
            this.propertyChangeSupport.firePropertyChange(/* name */"SELECT_LEVEL_INDEX", oldSelectedLevelIndex, selectedLevelIndex);
        }
    }

    /**
     * Returns the selected level index.
     * @return {number}
     */
    public getSelectedLevelIndex(): number {
        return this.selectedLevelIndex;
    }

    /**
     * Controls the modification of selected level in the edited home.
     */
    public modifyLevels() {
        const selectedLevel: Level = this.home.getSelectedLevel();
        if (selectedLevel != null) {
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const name: string = this.getName();
            const viewable: boolean = this.getViewable();
            const elevation: number = this.getElevation();
            const floorThickness: number = this.getFloorThickness();
            const height: number = this.getHeight();
            const elevationIndex: number = this.getElevationIndex();
            const modifiedLevel: LevelController.ModifiedLevel = new LevelController.ModifiedLevel(selectedLevel);
            LevelController.doModifyLevel(this.home, modifiedLevel, name, viewable, elevation, floorThickness, height, elevationIndex);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new LevelController.LevelModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), modifiedLevel, name, viewable, elevation, floorThickness, height, elevationIndex);
                this.undoSupport.postEdit(undoableEdit);
            }
            if (name != null) {
                this.preferences.addAutoCompletionString("LevelName", name);
            }
        }
    }

    /**
     * Modifies level properties with the values in parameter.
     * @param {Home} home
     * @param {LevelController.ModifiedLevel} modifiedLevel
     * @param {string} name
     * @param {boolean} viewable
     * @param {number} elevation
     * @param {number} floorThickness
     * @param {number} height
     * @param {number} elevationIndex
     * @private
     */
    static doModifyLevel(home: Home, modifiedLevel: LevelController.ModifiedLevel, name: string, viewable: boolean, elevation: number, floorThickness: number, height: number, elevationIndex: number) {
        const level: Level = modifiedLevel.getLevel();
        if (name != null) {
            level.setName(name);
        }
        if (viewable != null) {
            const selectedItems: Array<Selectable> = home.getSelectedItems();
            level.setViewable(viewable);
            home.setSelectedItems(LevelController.getViewableSublist(selectedItems));
        }
        if (elevation != null && elevation !== level.getElevation()) {
            LevelController.updateLevelElevation(level, elevation, home.getLevels());
        }
        if (elevationIndex != null) {
            LevelController.updateLevelElevationIndex(level, elevationIndex, home.getLevels());
        }
        if (!home.getEnvironment().isAllLevelsVisible()) {
            const selectedLevel: Level = home.getSelectedLevel();
            let visible: boolean = true;
            {
                let array = home.getLevels();
                for (let index = 0; index < array.length; index++) {
                    let homeLevel = array[index];
                    {
                        homeLevel.setVisible(visible);
                        if (homeLevel === selectedLevel) {
                            visible = false;
                        }
                    }
                }
            }
        }
        if (floorThickness != null) {
            level.setFloorThickness(floorThickness);
        }
        if (height != null) {
            level.setHeight(height);
        }
    }

    /**
     * Returns a sub list of <code>items</code> that are at a viewable level.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @return {*[]}
     * @private
     */
    static getViewableSublist(items: Array<any>): Array<Selectable> {
        const viewableItems: Array<Selectable> = <any>([]);
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (!(item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) || (<Elevatable><any>item).getLevel().isViewable()) {
                    /* add */(viewableItems.push(item) > 0);
                }
            }
        }
        return viewableItems;
    }

    /**
     * Restores level properties from the values stored in <code>modifiedLevel</code>.
     * @param {Home} home
     * @param {LevelController.ModifiedLevel} modifiedLevel
     * @private
     */
    static undoModifyLevel(home: Home, modifiedLevel: LevelController.ModifiedLevel) {
        modifiedLevel.reset();
        const level: Level = modifiedLevel.getLevel();
        if (modifiedLevel.getElevation() !== level.getElevation()) {
            LevelController.updateLevelElevation(level, modifiedLevel.getElevation(), home.getLevels());
        }
        if (modifiedLevel.getElevationIndex() !== level.getElevationIndex()) {
            LevelController.updateLevelElevationIndex(level, modifiedLevel.getElevationIndex(), home.getLevels());
        }
    }
}
LevelController["__class"] = "com.eteks.sweethome3d.viewcontroller.LevelController";
LevelController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace LevelController {

    /**
     * Undoable edit for level modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class LevelModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        modifiedLevel: LevelController.ModifiedLevel;

        name: string;

        viewable: boolean;

        elevation: number;

        floorThickness: number;

        height: number;

        elevationIndex: number;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], modifiedLevel: LevelController.ModifiedLevel, name: string, viewable: boolean, elevation: number, floorThickness: number, height: number, elevationIndex: number) {
            super(preferences, LevelController, "undoModifyLevelName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.modifiedLevel === undefined) { this.modifiedLevel = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.viewable === undefined) { this.viewable = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.floorThickness === undefined) { this.floorThickness = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.elevationIndex === undefined) { this.elevationIndex = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.modifiedLevel = modifiedLevel;
            this.name = name;
            this.viewable = viewable;
            this.elevation = elevation;
            this.floorThickness = floorThickness;
            this.height = height;
            this.elevationIndex = elevationIndex;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            LevelController.undoModifyLevel(this.home, this.modifiedLevel);
            this.home.setSelectedLevel(this.modifiedLevel.getLevel());
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedLevel(this.modifiedLevel.getLevel());
            LevelController.doModifyLevel(this.home, this.modifiedLevel, this.name, this.viewable, this.elevation, this.floorThickness, this.height, this.elevationIndex);
        }
    }
    LevelModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.LevelController.LevelModificationUndoableEdit";
    LevelModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified level.
     * @param {Level} level
     * @class
     */
    export class ModifiedLevel {
        level: Level;

        name: string;

        viewable: boolean;

        elevation: number;

        floorThickness: number;

        height: number;

        elevationIndex: number;

        public constructor(level: Level) {
            if (this.level === undefined) { this.level = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.viewable === undefined) { this.viewable = false; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.floorThickness === undefined) { this.floorThickness = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.elevationIndex === undefined) { this.elevationIndex = 0; }
            this.level = level;
            this.name = level.getName();
            this.viewable = level.isViewable();
            this.elevation = level.getElevation();
            this.floorThickness = level.getFloorThickness();
            this.height = level.getHeight();
            this.elevationIndex = level.getElevationIndex();
        }

        public getLevel(): Level {
            return this.level;
        }

        public getElevation(): number {
            return this.elevation;
        }

        public getElevationIndex(): number {
            return this.elevationIndex;
        }

        public reset() {
            this.level.setName(this.name);
            this.level.setViewable(this.viewable);
            this.level.setFloorThickness(this.floorThickness);
            this.level.setHeight(this.height);
        }
    }
    ModifiedLevel["__class"] = "com.eteks.sweethome3d.viewcontroller.LevelController.ModifiedLevel";

}


/**
 * Creates the controller of home furniture view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class HomeFurnitureController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ textureController: TextureChoiceController;

    /*private*/ modelMaterialsController: ModelMaterialsController;

    /*private*/ homeFurnitureView: DialogView;

    /*private*/ icon: Content;

    /*private*/ name: string;

    /*private*/ description: string;

    /*private*/ additionalProperties: any;

    /*private*/ priceEditable: boolean;

    /*private*/ price: Big;

    /*private*/ valueAddedTaxPercentageEditable: boolean;

    /*private*/ valueAddedTaxPercentage: Big;

    /*private*/ nameVisible: boolean;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ elevation: number;

    /*private*/ angleInDegrees: number;

    /*private*/ angle: number;

    /*private*/ rollAndPitchEditable: boolean;

    /*private*/ roll: number;

    /*private*/ pitch: number;

    /*private*/ horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis;

    /*private*/ width: number;

    /*private*/ proportionalWidth: number;

    /*private*/ depth: number;

    /*private*/ proportionalDepth: number;

    /*private*/ height: number;

    /*private*/ proportionalHeight: number;

    /*private*/ proportional: boolean;

    /*private*/ modelTransformations: Transformation[];

    /*private*/ modelPresetTransformationsNames: Array<string>;

    /*private*/ modelPresetTransformations: Array<Transformation[]>;

    /*private*/ color: number;

    /*private*/ paint: HomeFurnitureController.FurniturePaint;

    /*private*/ shininess: HomeFurnitureController.FurnitureShininess;

    /*private*/ visible: boolean;

    /*private*/ modelMirrored: boolean;

    /*private*/ basePlanItem: boolean;

    /*private*/ basePlanItemEnabled: boolean;

    /*private*/ lightPowerEditable: boolean;

    /*private*/ lightPower: number;

    /*private*/ resizable: boolean;

    /*private*/ deformable: boolean;

    /*private*/ widthDepthDeformable: boolean;

    /*private*/ texturable: boolean;

    /*private*/ visibleEditable: boolean;

    /*private*/ doorOrWindow: boolean;

    /*private*/ wallThickness: number;

    /*private*/ wallDistance: number;

    /*private*/ wallWidth: number;

    /*private*/ wallLeft: number;

    /*private*/ wallHeight: number;

    /*private*/ wallTop: number;

    /*private*/ sashes: Sash[];

    public constructor(home?: any, preferences?: any, viewFactory?: any, contentManager?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.textureController === undefined) { this.textureController = null; }
            if (this.modelMaterialsController === undefined) { this.modelMaterialsController = null; }
            if (this.homeFurnitureView === undefined) { this.homeFurnitureView = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.additionalProperties === undefined) { this.additionalProperties = null; }
            if (this.priceEditable === undefined) { this.priceEditable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentageEditable === undefined) { this.valueAddedTaxPercentageEditable = false; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.nameVisible === undefined) { this.nameVisible = null; }
            if (this.x === undefined) { this.x = null; }
            if (this.y === undefined) { this.y = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.angleInDegrees === undefined) { this.angleInDegrees = null; }
            if (this.angle === undefined) { this.angle = null; }
            if (this.rollAndPitchEditable === undefined) { this.rollAndPitchEditable = false; }
            if (this.roll === undefined) { this.roll = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.horizontalAxis === undefined) { this.horizontalAxis = null; }
            if (this.width === undefined) { this.width = null; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = null; }
            if (this.depth === undefined) { this.depth = null; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = null; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.modelPresetTransformationsNames === undefined) { this.modelPresetTransformationsNames = null; }
            if (this.modelPresetTransformations === undefined) { this.modelPresetTransformations = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.paint === undefined) { this.paint = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.visible === undefined) { this.visible = null; }
            if (this.modelMirrored === undefined) { this.modelMirrored = null; }
            if (this.basePlanItem === undefined) { this.basePlanItem = null; }
            if (this.basePlanItemEnabled === undefined) { this.basePlanItemEnabled = false; }
            if (this.lightPowerEditable === undefined) { this.lightPowerEditable = false; }
            if (this.lightPower === undefined) { this.lightPower = null; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.visibleEditable === undefined) { this.visibleEditable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.sashes === undefined) { this.sashes = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.contentManager = contentManager;
            this.undoSupport = undoSupport;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.updateProperties();
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && contentManager instanceof <any>javax.swing.undo.UndoableEditSupport) || contentManager === null) && undoSupport === undefined) {
            let __args = arguments;
            let undoSupport: any = __args[3];
            {
                let __args = arguments;
                let contentManager: any = null;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.textureController === undefined) { this.textureController = null; }
                if (this.modelMaterialsController === undefined) { this.modelMaterialsController = null; }
                if (this.homeFurnitureView === undefined) { this.homeFurnitureView = null; }
                if (this.icon === undefined) { this.icon = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.description === undefined) { this.description = null; }
                if (this.additionalProperties === undefined) { this.additionalProperties = null; }
                if (this.priceEditable === undefined) { this.priceEditable = false; }
                if (this.price === undefined) { this.price = null; }
                if (this.valueAddedTaxPercentageEditable === undefined) { this.valueAddedTaxPercentageEditable = false; }
                if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
                if (this.nameVisible === undefined) { this.nameVisible = null; }
                if (this.x === undefined) { this.x = null; }
                if (this.y === undefined) { this.y = null; }
                if (this.elevation === undefined) { this.elevation = null; }
                if (this.angleInDegrees === undefined) { this.angleInDegrees = null; }
                if (this.angle === undefined) { this.angle = null; }
                if (this.rollAndPitchEditable === undefined) { this.rollAndPitchEditable = false; }
                if (this.roll === undefined) { this.roll = null; }
                if (this.pitch === undefined) { this.pitch = null; }
                if (this.horizontalAxis === undefined) { this.horizontalAxis = null; }
                if (this.width === undefined) { this.width = null; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = null; }
                if (this.depth === undefined) { this.depth = null; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = null; }
                if (this.height === undefined) { this.height = null; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = null; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.modelTransformations === undefined) { this.modelTransformations = null; }
                if (this.modelPresetTransformationsNames === undefined) { this.modelPresetTransformationsNames = null; }
                if (this.modelPresetTransformations === undefined) { this.modelPresetTransformations = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.paint === undefined) { this.paint = null; }
                if (this.shininess === undefined) { this.shininess = null; }
                if (this.visible === undefined) { this.visible = null; }
                if (this.modelMirrored === undefined) { this.modelMirrored = null; }
                if (this.basePlanItem === undefined) { this.basePlanItem = null; }
                if (this.basePlanItemEnabled === undefined) { this.basePlanItemEnabled = false; }
                if (this.lightPowerEditable === undefined) { this.lightPowerEditable = false; }
                if (this.lightPower === undefined) { this.lightPower = null; }
                if (this.resizable === undefined) { this.resizable = false; }
                if (this.deformable === undefined) { this.deformable = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.texturable === undefined) { this.texturable = false; }
                if (this.visibleEditable === undefined) { this.visibleEditable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallWidth === undefined) { this.wallWidth = 0; }
                if (this.wallLeft === undefined) { this.wallLeft = 0; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.wallTop === undefined) { this.wallTop = 0; }
                if (this.sashes === undefined) { this.sashes = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.contentManager = contentManager;
                this.undoSupport = undoSupport;
                this.propertyChangeSupport = new PropertyChangeSupport(this);
                this.updateProperties();
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.textureController === undefined) { this.textureController = null; }
            if (this.modelMaterialsController === undefined) { this.modelMaterialsController = null; }
            if (this.homeFurnitureView === undefined) { this.homeFurnitureView = null; }
            if (this.icon === undefined) { this.icon = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.additionalProperties === undefined) { this.additionalProperties = null; }
            if (this.priceEditable === undefined) { this.priceEditable = false; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentageEditable === undefined) { this.valueAddedTaxPercentageEditable = false; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.nameVisible === undefined) { this.nameVisible = null; }
            if (this.x === undefined) { this.x = null; }
            if (this.y === undefined) { this.y = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.angleInDegrees === undefined) { this.angleInDegrees = null; }
            if (this.angle === undefined) { this.angle = null; }
            if (this.rollAndPitchEditable === undefined) { this.rollAndPitchEditable = false; }
            if (this.roll === undefined) { this.roll = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.horizontalAxis === undefined) { this.horizontalAxis = null; }
            if (this.width === undefined) { this.width = null; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = null; }
            if (this.depth === undefined) { this.depth = null; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = null; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.modelPresetTransformationsNames === undefined) { this.modelPresetTransformationsNames = null; }
            if (this.modelPresetTransformations === undefined) { this.modelPresetTransformations = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.paint === undefined) { this.paint = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.visible === undefined) { this.visible = null; }
            if (this.modelMirrored === undefined) { this.modelMirrored = null; }
            if (this.basePlanItem === undefined) { this.basePlanItem = null; }
            if (this.basePlanItemEnabled === undefined) { this.basePlanItemEnabled = false; }
            if (this.lightPowerEditable === undefined) { this.lightPowerEditable = false; }
            if (this.lightPower === undefined) { this.lightPower = null; }
            if (this.resizable === undefined) { this.resizable = false; }
            if (this.deformable === undefined) { this.deformable = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.texturable === undefined) { this.texturable = false; }
            if (this.visibleEditable === undefined) { this.visibleEditable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.sashes === undefined) { this.sashes = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the texture controller of the piece.
     * @return {TextureChoiceController}
     */
    public getTextureController(): TextureChoiceController {
        if (this.textureController == null) {
            this.textureController = new TextureChoiceController(this.preferences.getLocalizedString(HomeFurnitureController, "textureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.textureController.addPropertyChangeListener("TEXTURE", new HomeFurnitureController.HomeFurnitureController$0(this));
        }
        return this.textureController;
    }

    /**
     * Returns the model materials controller of the piece.
     * @return {ModelMaterialsController}
     */
    public getModelMaterialsController(): ModelMaterialsController {
        if (this.modelMaterialsController == null) {
            this.modelMaterialsController = new ModelMaterialsController(this.preferences.getLocalizedString(HomeFurnitureController, "modelMaterialsTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.modelMaterialsController.addPropertyChangeListener("MATERIALS", new HomeFurnitureController.HomeFurnitureController$1(this));
            const sizeChangeListener: PropertyChangeListener = new HomeFurnitureController.HomeFurnitureController$2(this);
            this.addPropertyChangeListener("WIDTH", sizeChangeListener);
            this.addPropertyChangeListener("DEPTH", sizeChangeListener);
            this.addPropertyChangeListener("HEIGHT", sizeChangeListener);
            this.addPropertyChangeListener("MODEL_TRANSFORMATIONS", new HomeFurnitureController.HomeFurnitureController$3(this));
        }
        return this.modelMaterialsController;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.homeFurnitureView == null) {
            this.homeFurnitureView = this.viewFactory.createHomeFurnitureView(this.preferences, this);
        }
        return this.homeFurnitureView;
    }

    /**
     * Returns the content manager associated to this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from selected furniture in the home edited by this controller.
     */
    updateProperties() {
        const selectedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(this.home.getSelectedItems());
        const textureController: TextureChoiceController = this.getTextureController();
        const modelMaterialsController: ModelMaterialsController = this.getModelMaterialsController();
        if (/* isEmpty */(selectedFurniture.length == 0)) {
            this.setIcon(null);
            this.setName(null);
            this.setNameVisible(null);
            this.setDescription(null);
            this.setAdditionalProperties(null);
            this.setPrice(null, false);
            this.priceEditable = false;
            this.setValueAddedTaxPercentage(null);
            this.valueAddedTaxPercentageEditable = false;
            this.setX(null);
            this.setY(null);
            this.setElevation(null);
            this.basePlanItemEnabled = false;
            this.setAngleInDegrees(null);
            this.setRoll(null);
            this.setPitch(null);
            this.setHorizontalAxis(null);
            this.rollAndPitchEditable = false;
            this.setWidth$java_lang_Float$boolean$boolean$boolean(null, true, false, false);
            this.setDepth$java_lang_Float$boolean$boolean$boolean(null, true, false, false);
            this.setHeight$java_lang_Float$boolean$boolean(null, true, false);
            this.setColor(null);
            if (textureController != null) {
                textureController.setTexture(null);
            }
            if (modelMaterialsController != null) {
                modelMaterialsController.setMaterials(null);
                modelMaterialsController.setModel(null);
                modelMaterialsController.setModelCreator(null);
            }
            this.setPaint(null);
            this.setModelTransformations$com_eteks_sweethome3d_model_Transformation_A(null);
            this.modelPresetTransformationsNames = /* emptyList */[];
            this.modelPresetTransformations = /* emptyList */[];
            this.doorOrWindow = false;
            this.wallThickness = 1;
            this.wallDistance = 0;
            this.wallWidth = 1;
            this.wallLeft = 0;
            this.wallHeight = 1;
            this.wallTop = 0;
            this.sashes = [];
            this.setShininess(null);
            this.visibleEditable = false;
            this.setVisible(null);
            this.setModelMirrored(null);
            this.lightPowerEditable = false;
            this.setLightPower(null);
            this.setResizable(true);
            this.setDeformable(true);
            this.setTexturable(true);
            this.setProportional(false);
        } else {
            const firstPiece: HomePieceOfFurniture = /* get */selectedFurniture[0];
            let icon: Content = firstPiece.getIcon();
            if (icon != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(icon,/* get */selectedFurniture[i].getIcon()))) {
                            icon = null;
                            break;
                        }
                    };
                }
            }
            this.setIcon(icon);
            let name: string = firstPiece.getName();
            if (name != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (!(name === /* get */selectedFurniture[i].getName())) {
                            name = null;
                            break;
                        }
                    };
                }
            }
            this.setName(name);
            let nameVisible: boolean = firstPiece.isNameVisible();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (nameVisible !== /* get */selectedFurniture[i].isNameVisible()) {
                        nameVisible = null;
                        break;
                    }
                };
            }
            this.setNameVisible(nameVisible);
            let description: string = firstPiece.getDescription();
            if (description != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (!(description === /* get */selectedFurniture[i].getDescription())) {
                            description = null;
                            break;
                        }
                    };
                }
            }
            this.setDescription(description);
            if (/* size */(<number>selectedFurniture.length) === 1) {
                const additionalProperties: any = <any>({});
                {
                    let array = this.home.getFurnitureAdditionalProperties();
                    for (let index = 0; index < array.length; index++) {
                        let property = array[index];
                        {
                            const propertyName: string = property.getName();
                            if (property.isModifiable()) {
                                /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>additionalProperties, property, firstPiece.isContentProperty(propertyName) ? firstPiece.getContentProperty(propertyName) : firstPiece.getProperty(propertyName));
                            }
                        }
                    }
                }
                this.setAdditionalProperties(/* size */((m) => { if (m.entries == null) m.entries = []; return m.entries.length; })(<any>additionalProperties) > 0 ? additionalProperties : null);
            } else {
                this.setAdditionalProperties(null);
            }
            let priceEditable: boolean = this.preferences.getCurrency() != null;
            if (priceEditable) {
                for (let i: number = 0; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (/* get */selectedFurniture[i] != null && /* get */selectedFurniture[i] instanceof <any>HomeFurnitureGroup) {
                            priceEditable = false;
                            break;
                        }
                    };
                }
            }
            this.priceEditable = priceEditable;
            if (priceEditable) {
                let price: Big = firstPiece.getPrice();
                if (price != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                        {
                            if (!/* equals */((/* get */selectedFurniture[i].getPrice()) != null ? price.eq(/* get */selectedFurniture[i].getPrice()) : (price === (/* get */selectedFurniture[i].getPrice())))) {
                                price = null;
                                break;
                            }
                        };
                    }
                }
                this.setPrice(price, false);
                this.valueAddedTaxPercentageEditable = this.preferences.isValueAddedTaxEnabled();
                let valueAddedTaxPercentage: Big = firstPiece.getValueAddedTaxPercentage();
                if (valueAddedTaxPercentage != null) {
                    for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                        {
                            if (!/* equals */((/* get */selectedFurniture[i].getValueAddedTaxPercentage()) != null ? valueAddedTaxPercentage.eq(/* get */selectedFurniture[i].getValueAddedTaxPercentage()) : (valueAddedTaxPercentage === (/* get */selectedFurniture[i].getValueAddedTaxPercentage())))) {
                                valueAddedTaxPercentage = null;
                                break;
                            }
                        };
                    }
                }
                this.setValueAddedTaxPercentage(valueAddedTaxPercentage);
            } else {
                this.setPrice(null, false);
                this.setValueAddedTaxPercentage(null);
                this.valueAddedTaxPercentageEditable = false;
            }
            let x: number = firstPiece.getX();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */x !== /* get */selectedFurniture[i].getX()) {
                        x = null;
                        break;
                    }
                };
            }
            this.setX(x);
            let y: number = firstPiece.getY();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */y !== /* get */selectedFurniture[i].getY()) {
                        y = null;
                        break;
                    }
                };
            }
            this.setY(y);
            let elevation: number = firstPiece.getElevation();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */elevation !== /* get */selectedFurniture[i].getElevation()) {
                        elevation = null;
                        break;
                    }
                };
            }
            this.setElevation(elevation);
            let basePlanItemEnabled: boolean = !firstPiece.isDoorOrWindow();
            for (let i: number = 1; !basePlanItemEnabled && i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (!/* get */selectedFurniture[i].isDoorOrWindow()) {
                        basePlanItemEnabled = true;
                    }
                };
            }
            this.basePlanItemEnabled = basePlanItemEnabled;
            let basePlanItem: boolean = !firstPiece.isMovable();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* booleanValue */basePlanItem !== !/* get */selectedFurniture[i].isMovable()) {
                        basePlanItem = null;
                        break;
                    }
                };
            }
            this.setBasePlanItem(basePlanItem);
            let angle: number = firstPiece.getAngle();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */angle !== /* get */selectedFurniture[i].getAngle()) {
                        angle = null;
                        break;
                    }
                };
            }
            this.setAngle(angle);
            let rollAndPitchEditable: boolean = true;
            for (let i: number = 0; rollAndPitchEditable && i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurniture[i];
                    rollAndPitchEditable = piece.isHorizontallyRotatable() && piece.getStaircaseCutOutShape() == null;
                };
            }
            this.rollAndPitchEditable = rollAndPitchEditable;
            if (this.rollAndPitchEditable) {
                let roll: number = firstPiece.getRoll();
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (/* floatValue */roll !== /* get */selectedFurniture[i].getRoll()) {
                            roll = null;
                            break;
                        }
                    };
                }
                this.setRoll(roll);
                let pitch: number = firstPiece.getPitch();
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (/* floatValue */pitch !== /* get */selectedFurniture[i].getPitch()) {
                            pitch = null;
                            break;
                        }
                    };
                }
                this.setPitch(pitch);
                if (roll == null && pitch == null || (roll != null && roll !== 0 && pitch != null && pitch !== 0) || (roll != null && roll === 0 && pitch != null && pitch === 0)) {
                    this.setHorizontalAxis(null);
                } else if (roll == null && pitch != null && pitch === 0 || roll != null && roll !== 0) {
                    this.setHorizontalAxis(HomeFurnitureController.FurnitureHorizontalAxis.ROLL);
                } else {
                    this.setHorizontalAxis(HomeFurnitureController.FurnitureHorizontalAxis.PITCH);
                }
            } else {
                this.setRoll(null);
                this.setPitch(null);
                this.setHorizontalAxis(null);
            }
            let width: number = firstPiece.getWidth();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */width !== /* get */selectedFurniture[i].getWidth()) {
                        width = null;
                        break;
                    }
                };
            }
            this.setWidth$java_lang_Float$boolean$boolean$boolean(width, true, false, false);
            let depth: number = firstPiece.getDepth();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */depth !== /* get */selectedFurniture[i].getDepth()) {
                        depth = null;
                        break;
                    }
                };
            }
            this.setDepth$java_lang_Float$boolean$boolean$boolean(depth, true, false, false);
            let height: number = firstPiece.getHeight();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* floatValue */height !== /* get */selectedFurniture[i].getHeight()) {
                        height = null;
                        break;
                    }
                };
            }
            this.setHeight$java_lang_Float$boolean$boolean(height, true, false);
            const selectedFurnitureWithoutGroups: Array<HomePieceOfFurniture> = this.getFurnitureWithoutGroups(selectedFurniture);
            const firstPieceExceptGroup: HomePieceOfFurniture = /* get */selectedFurnitureWithoutGroups[0];
            let color: number = firstPieceExceptGroup.getColor();
            if (color != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurnitureWithoutGroups.length); i++) {
                    {
                        if (!(color === /* get */selectedFurnitureWithoutGroups[i].getColor())) {
                            color = null;
                            break;
                        }
                    };
                }
            }
            this.setColor(color);
            let texture: HomeTexture = firstPieceExceptGroup.getTexture();
            if (texture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurnitureWithoutGroups.length); i++) {
                    {
                        if (!texture.equals(/* get */selectedFurnitureWithoutGroups[i].getTexture())) {
                            texture = null;
                            break;
                        }
                    };
                }
            }
            if (textureController != null) {
                textureController.setTexture(texture);
            }
            let modelMaterials: HomeMaterial[] = firstPieceExceptGroup.getModelMaterials();
            let model: Content = firstPieceExceptGroup.getModel();
            let creator: string = firstPieceExceptGroup.getCreator();
            if (model != null) {
                for (let i: number = 1; i < /* size */(<number>selectedFurnitureWithoutGroups.length); i++) {
                    {
                        const piece: HomePieceOfFurniture = /* get */selectedFurnitureWithoutGroups[i];
                        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(modelMaterials, piece.getModelMaterials()) || model !== piece.getModel()) {
                            modelMaterials = null;
                            model = null;
                            creator = null;
                            break;
                        }
                    };
                }
            }
            if (modelMaterialsController != null) {
                modelMaterialsController.setMaterials(modelMaterials);
                modelMaterialsController.setModel(model);
                modelMaterialsController.setModelCreator(creator);
                modelMaterialsController.setModelSize(firstPieceExceptGroup.getWidth(), firstPieceExceptGroup.getDepth(), firstPieceExceptGroup.getHeight());
                modelMaterialsController.setModelRotation(firstPieceExceptGroup.getModelRotation());
                modelMaterialsController.setModelTransformations(firstPieceExceptGroup.getModelTransformations());
                modelMaterialsController.setModelFlags(firstPieceExceptGroup.getModelFlags());
            }
            let defaultColorsAndTextures: boolean = true;
            for (let i: number = 0; i < /* size */(<number>selectedFurnitureWithoutGroups.length); i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurnitureWithoutGroups[i];
                    if (piece.getColor() != null || piece.getTexture() != null || piece.getModelMaterials() != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (color != null) {
                this.setPaint(HomeFurnitureController.FurniturePaint.COLORED);
            } else if (texture != null) {
                this.setPaint(HomeFurnitureController.FurniturePaint.TEXTURED);
            } else if (modelMaterials != null) {
                this.setPaint(HomeFurnitureController.FurniturePaint.MODEL_MATERIALS);
            } else if (defaultColorsAndTextures) {
                this.setPaint(HomeFurnitureController.FurniturePaint.DEFAULT);
            } else {
                this.setPaint(null);
            }
            let modelTransformations: Transformation[] = firstPiece.getModelTransformations();
            if (/* size */(<number>selectedFurniture.length) !== 1 || (firstPiece != null && firstPiece instanceof <any>HomeFurnitureGroup)) {
                modelTransformations = null;
            } else {
                if (modelTransformations == null) {
                    modelTransformations = [];
                }
                if (firstPiece != null && firstPiece instanceof <any>HomeDoorOrWindow) {
                    const editedDoorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>firstPiece;
                    this.doorOrWindow = true;
                    this.wallThickness = editedDoorOrWindow.getWallThickness();
                    this.wallDistance = editedDoorOrWindow.getWallDistance();
                    this.wallWidth = editedDoorOrWindow.getWallWidth();
                    this.wallLeft = editedDoorOrWindow.getWallLeft();
                    this.wallHeight = editedDoorOrWindow.getWallHeight();
                    this.wallTop = editedDoorOrWindow.getWallTop();
                    this.sashes = editedDoorOrWindow.getSashes();
                }
            }
            this.setModelTransformations$com_eteks_sweethome3d_model_Transformation_A(modelTransformations);
            this.modelPresetTransformationsNames = <any>([]);
            this.modelPresetTransformations = <any>([]);
            if (/* size */(<number>selectedFurniture.length) === 1 && !(firstPiece != null && firstPiece instanceof <any>HomeFurnitureGroup) && firstPiece.getCatalogId() != null) {
                const catalogPiece: CatalogPieceOfFurniture = this.preferences.getFurnitureCatalog().getPieceOfFurnitureWithId(firstPiece.getCatalogId());
                if (catalogPiece != null) {
                    let i: number = 1;
                    for (let presetTransformationsName: string = catalogPiece.getProperty("modelPresetTransformationsName_" + i); presetTransformationsName != null; presetTransformationsName = catalogPiece.getProperty("modelPresetTransformationsName_" + ++i)) {
                        {
                            const presetTransformations: string = catalogPiece.getProperty("modelPresetTransformations_" + i);
                            if (presetTransformations != null) {
                                const strings: string[] = presetTransformations.trim().split(/\s+/);
                                if (strings.length % 13 === 0) {
                                    const transformations: Transformation[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })((strings.length / 13 | 0));
                                    try {
                                        for (let j: number = 0; j < strings.length; j += 12) {
                                            {
                                                const transformationName: string = strings[j++];
                                                const matrix: number[][] = [[/* parseFloat */parseFloat(strings[j + 0]), /* parseFloat */parseFloat(strings[j + 1]), /* parseFloat */parseFloat(strings[j + 2]), /* parseFloat */parseFloat(strings[j + 3])], [/* parseFloat */parseFloat(strings[j + 4]), /* parseFloat */parseFloat(strings[j + 5]), /* parseFloat */parseFloat(strings[j + 6]), /* parseFloat */parseFloat(strings[j + 7])], [/* parseFloat */parseFloat(strings[j + 8]), /* parseFloat */parseFloat(strings[j + 9]), /* parseFloat */parseFloat(strings[j + 10]), /* parseFloat */parseFloat(strings[j + 11])]];
                                                transformations[(j / 13 | 0)] = new Transformation(transformationName, matrix);
                                            };
                                        }
                                    /* add */(this.modelPresetTransformationsNames.push(presetTransformationsName) > 0);
                                    /* add */(this.modelPresetTransformations.push(transformations) > 0);
                                    } catch (ex) {
                                        console.info("Invalid value in preset transformations matrices for " + firstPiece.getCatalogId() + "\n" + ex);
                                    }
                                }
                            }
                        };
                    }
                }
            }
            const firstPieceShininess: number = firstPieceExceptGroup.getShininess();
            let shininess: HomeFurnitureController.FurnitureShininess = firstPieceShininess == null ? HomeFurnitureController.FurnitureShininess.DEFAULT : (/* floatValue */firstPieceShininess === 0 ? HomeFurnitureController.FurnitureShininess.MATT : HomeFurnitureController.FurnitureShininess.SHINY);
            for (let i: number = 1; i < /* size */(<number>selectedFurnitureWithoutGroups.length); i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurnitureWithoutGroups[i];
                    if (firstPieceShininess !== piece.getShininess() || (firstPieceShininess != null && !(firstPieceShininess === piece.getShininess()))) {
                        shininess = null;
                        break;
                    }
                };
            }
            this.setShininess(shininess);
            let visibleEditable: boolean = true;
            const homeFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    if (!/* contains */(homeFurniture.indexOf(<any>(piece)) >= 0)) {
                        visibleEditable = false;
                        break;
                    }
                }
            }
            this.visibleEditable = visibleEditable;
            if (visibleEditable) {
                let visible: boolean = firstPiece.isVisible();
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (visible !== /* get */selectedFurniture[i].isVisible()) {
                            visible = null;
                            break;
                        }
                    };
                }
                this.setVisible(visible);
            } else {
                this.setVisible(null);
            }
            let modelMirrored: boolean = firstPiece.isModelMirrored();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (modelMirrored !== /* get */selectedFurniture[i].isModelMirrored()) {
                        modelMirrored = null;
                        break;
                    }
                };
            }
            this.setModelMirrored(modelMirrored);
            let lightPowerEditable: boolean = (firstPiece != null && firstPiece instanceof <any>HomeLight);
            for (let i: number = 1; lightPowerEditable && i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    lightPowerEditable = (/* get */selectedFurniture[i] != null && /* get */selectedFurniture[i] instanceof <any>HomeLight);
                };
            }
            this.lightPowerEditable = lightPowerEditable;
            if (lightPowerEditable) {
                let lightPower: number = (<HomeLight>firstPiece).getPower();
                for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                    {
                        if (/* floatValue */lightPower !== (<HomeLight>/* get */selectedFurniture[i]).getPower()) {
                            lightPower = null;
                            break;
                        }
                    };
                }
                this.setLightPower(lightPower);
            } else {
                this.setLightPower(null);
            }
            let resizable: boolean = firstPiece.isResizable();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* booleanValue */resizable !== /* get */selectedFurniture[i].isResizable()) {
                        resizable = null;
                        break;
                    }
                };
            }
            this.setResizable(resizable != null && /* booleanValue */resizable);
            let deformable: boolean = true;
            for (let i: number = 0; deformable && i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurniture[i];
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        {
                            let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                            for (let index = 0; index < array.length; index++) {
                                let childPiece = array[index];
                                {
                                    if (!childPiece.isDeformable() || childPiece.isHorizontallyRotated() || childPiece.getModelTransformations() != null) {
                                        deformable = false;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        deformable = piece.isDeformable() && piece.getModelTransformations() == null;
                    }
                };
            }
            this.setDeformable(deformable);
            if (!this.isDeformable()) {
                this.setProportional(true);
            }
            this.widthDepthDeformable = true;
            for (let i: number = 0; this.widthDepthDeformable && i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurniture[i];
                    this.widthDepthDeformable = piece.isWidthDepthDeformable();
                };
            }
            let texturable: boolean = firstPiece.isTexturable();
            for (let i: number = 1; i < /* size */(<number>selectedFurniture.length); i++) {
                {
                    if (/* booleanValue */texturable !== /* get */selectedFurniture[i].isTexturable()) {
                        texturable = null;
                        break;
                    }
                };
            }
            this.setTexturable(texturable == null || /* booleanValue */texturable);
        }
    }

    /**
     * Returns all the pieces of the given <code>furniture</code> list except groups.
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    getFurnitureWithoutGroups(furniture: Array<HomePieceOfFurniture>): Array<HomePieceOfFurniture> {
        const pieces: Array<HomePieceOfFurniture> = <any>([]);
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(pieces, this.getFurnitureWithoutGroups((<HomeFurnitureGroup>piece).getFurniture()));
                } else {
                    /* add */(pieces.push(piece) > 0);
                }
            }
        }
        return pieces;
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * @param {string} property
     * @return {boolean}
     */
    public isPropertyEditable(property: any): boolean {
        switch ((property)) {
            case "ADDITIONAL_PROPERTIES":
                return this.getAdditionalProperties() != null;
            case "PRICE":
                return this.isPriceEditable();
            case "VALUE_ADDED_TAX_PERCENTAGE":
                return this.isValueAddedTaxPercentageEditable();
            case "ROLL":
            case "PITCH":
                return this.isRollAndPitchEditable();
            case "MODEL_TRANSFORMATIONS":
                return this.getModelTransformations() != null;
            case "LIGHT_POWER":
                return this.isLightPowerEditable();
            case "VISIBLE":
                return this.visibleEditable;
            default:
                return true;
        }
    }

    /**
     * Sets the edited icon.
     * @param {Object} icon
     * @private
     */
    setIcon(icon: Content) {
        if (icon !== this.icon) {
            const oldIcon: Content = this.icon;
            this.icon = icon;
            this.propertyChangeSupport.firePropertyChange(/* name */"ICON", oldIcon, icon);
        }
    }

    /**
     * Returns the edited icon.
     * @return {Object}
     */
    public getIcon(): Content {
        return this.icon;
    }

    /**
     * Sets the edited name.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name) {
            const oldName: string = this.name;
            this.name = name;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns the edited name.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets whether furniture name is visible or not.
     * @param {boolean} nameVisible
     */
    public setNameVisible(nameVisible: boolean) {
        if (nameVisible !== this.nameVisible) {
            const oldNameVisible: boolean = this.nameVisible;
            this.nameVisible = nameVisible;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAME_VISIBLE", oldNameVisible, nameVisible);
        }
    }

    /**
     * Returns whether furniture name should be drawn or not.
     * @return {boolean}
     */
    public getNameVisible(): boolean {
        return this.nameVisible;
    }

    /**
     * Sets the edited description.
     * @param {string} description
     */
    public setDescription(description: string) {
        if (description !== this.description) {
            const oldDescription: string = this.description;
            this.description = description;
            this.propertyChangeSupport.firePropertyChange(/* name */"DESCRIPTION", oldDescription, description);
        }
    }

    /**
     * Returns the edited description.
     * @return {string}
     */
    public getDescription(): string {
        return this.description;
    }

    /**
     * Sets additional edited properties.
     * @param {Object} additionalProperties
     */
    public setAdditionalProperties(additionalProperties: any) {
        if (additionalProperties !== this.additionalProperties && (additionalProperties == null || !/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(additionalProperties, this.additionalProperties)))) {
            const oldAdditionalProperties: any = this.additionalProperties;
            this.additionalProperties = additionalProperties != null ? <any>(((o) => { let r = {}; r['entries'] = o.entries != null ? o.entries.slice() : null; return r; })(additionalProperties)) : null;
            this.propertyChangeSupport.firePropertyChange(/* name */"ADDITIONAL_PROPERTIES", oldAdditionalProperties, additionalProperties);
        }
    }

    /**
     * Returns additional edited properties.
     * @return {Object}
     */
    public getAdditionalProperties(): any {
        return this.additionalProperties;
    }

    public setPrice(price: Big, updateCurrencyAndValueAddedTaxPercentage: boolean = true) {
        if (price !== this.price && (price == null || !/* equals */((this.price) != null ? price.eq(this.price) : (price === (this.price))))) {
            const oldPrice: Big = this.price;
            this.price = price;
            this.propertyChangeSupport.firePropertyChange(/* name */"PRICE", oldPrice, price);
            if (updateCurrencyAndValueAddedTaxPercentage) {
                if (price != null && this.isValueAddedTaxPercentageEditable() && this.getValueAddedTaxPercentage() == null && /* size */(<number>Home.getFurnitureSubList(this.home.getSelectedItems()).length) === 1) {
                    this.setValueAddedTaxPercentage(this.preferences.getDefaultValueAddedTaxPercentage());
                }
            }
        }
    }

    /**
     * Returns the edited price.
     * @return {Big}
     */
    public getPrice(): Big {
        return this.price;
    }

    /**
     * Returns whether the price can be edited or not.
     * @return {boolean}
     */
    public isPriceEditable(): boolean {
        return this.priceEditable;
    }

    /**
     * Sets the edited Value Added Tax percentage.
     * @param {Big} valueAddedTaxPercentage
     */
    public setValueAddedTaxPercentage(valueAddedTaxPercentage: Big) {
        if (valueAddedTaxPercentage !== this.valueAddedTaxPercentage && (valueAddedTaxPercentage == null || !/* equals */((this.valueAddedTaxPercentage) != null ? valueAddedTaxPercentage.eq(this.valueAddedTaxPercentage) : (valueAddedTaxPercentage === (this.valueAddedTaxPercentage))))) {
            const oldValueAddedTaxPercentage: Big = this.valueAddedTaxPercentage;
            this.valueAddedTaxPercentage = valueAddedTaxPercentage;
            this.propertyChangeSupport.firePropertyChange(/* name */"VALUE_ADDED_TAX_PERCENTAGE", oldValueAddedTaxPercentage, valueAddedTaxPercentage);
        }
    }

    /**
     * Returns edited Value Added Tax percentage.
     * @return {Big}
     */
    public getValueAddedTaxPercentage(): Big {
        return this.valueAddedTaxPercentage;
    }

    /**
     * Returns whether the Value Added Tax percentage can be edited or not.
     * @return {boolean}
     */
    public isValueAddedTaxPercentageEditable(): boolean {
        return this.valueAddedTaxPercentageEditable;
    }

    /**
     * Sets the edited abscissa.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.propertyChangeSupport.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the edited abscissa.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the edited ordinate.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the edited ordinate.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the edited elevation.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns the edited elevation.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    public setAngleInDegrees(angleInDegrees: number, updateAngle: boolean = true) {
        if (angleInDegrees !== this.angleInDegrees) {
            const oldAngleInDegrees: number = this.angleInDegrees;
            this.angleInDegrees = angleInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"ANGLE_IN_DEGREES", oldAngleInDegrees, angleInDegrees);
            if (updateAngle) {
                if (this.angleInDegrees == null) {
                    this.setAngle(null, false);
                } else {
                    this.setAngle(new Number(/* toRadians */(x => x * Math.PI / 180)(this.angleInDegrees)).valueOf(), false);
                }
            }
        }
    }

    /**
     * Returns the edited angle in degrees.
     * @return {number}
     */
    public getAngleInDegrees(): number {
        return this.angleInDegrees;
    }

    public setAngle(angle: number, updateAngleInDegrees: boolean = true) {
        if (angle !== this.angle) {
            const oldAngle: number = this.angle;
            this.angle = angle;
            this.propertyChangeSupport.firePropertyChange(/* name */"ANGLE", oldAngle, angle);
            if (updateAngleInDegrees) {
                if (angle == null) {
                    this.setAngleInDegrees(null, false);
                } else {
                    this.setAngleInDegrees((<number>(Math.round(/* toDegrees */(x => x * 180 / Math.PI)(angle)) + 360) | 0) % 360, false);
                }
            }
        }
    }

    /**
     * Returns the edited angle in radians.
     * @return {number}
     */
    public getAngle(): number {
        return this.angle;
    }

    /**
     * Returns whether roll and pitch angles can be edited.
     * @return {boolean}
     */
    public isRollAndPitchEditable(): boolean {
        return this.rollAndPitchEditable;
    }

    /**
     * Sets the edited roll angle in radians.
     * @param {number} roll
     */
    public setRoll(roll: number) {
        if (roll !== this.roll) {
            const oldRoll: number = this.roll;
            this.roll = roll;
            this.propertyChangeSupport.firePropertyChange(/* name */"ROLL", oldRoll, roll);
        }
    }

    /**
     * Returns the edited roll angle in radians.
     * @return {number}
     */
    public getRoll(): number {
        return this.roll;
    }

    /**
     * Sets the edited pitch in radians.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.propertyChangeSupport.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
    }

    /**
     * Returns the edited pitch in radians.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Sets the edited horizontal axis.
     * @param {HomeFurnitureController.FurnitureHorizontalAxis} horizontalAxis
     */
    public setHorizontalAxis(horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis) {
        if (horizontalAxis !== this.horizontalAxis) {
            const oldAxis: HomeFurnitureController.FurnitureHorizontalAxis = this.horizontalAxis;
            this.horizontalAxis = horizontalAxis;
            this.propertyChangeSupport.firePropertyChange(/* name */"HORIZONTAL_AXIS", oldAxis, horizontalAxis);
        }
    }

    /**
     * Returns the edited horizontal axis.
     * @return {HomeFurnitureController.FurnitureHorizontalAxis}
     */
    public getHorizontalAxis(): HomeFurnitureController.FurnitureHorizontalAxis {
        return this.horizontalAxis;
    }

    /**
     * Returns <code>true</code> if base plan item is an enabled property.
     * @return {boolean}
     */
    public isBasePlanItemEnabled(): boolean {
        return this.basePlanItemEnabled;
    }

    /**
     * Returns <code>true</code> if base plan item is an enabled property.
     * @deprecated the method is wrongly named and should be replaced by <code>isBasePlanItemEnabled</code>.
     * @return {boolean}
     */
    public isBasePlanItemEditable(): boolean {
        return this.basePlanItemEnabled;
    }

    /**
     * Sets whether furniture is a base plan item or not.
     * @param {boolean} basePlanItem
     */
    public setBasePlanItem(basePlanItem: boolean) {
        if (basePlanItem !== this.basePlanItem) {
            const oldMovable: boolean = this.basePlanItem;
            this.basePlanItem = basePlanItem;
            this.propertyChangeSupport.firePropertyChange(/* name */"BASE_PLAN_ITEM", oldMovable, basePlanItem);
        }
    }

    /**
     * Returns whether furniture is a base plan item or not.
     * @return {boolean}
     */
    public getBasePlanItem(): boolean {
        return this.basePlanItem;
    }

    public setWidth$java_lang_Float(width: number) {
        this.setWidth$java_lang_Float$boolean$boolean$boolean(width, false, this.isProportional() || !this.widthDepthDeformable, this.isProportional());
    }

    public setWidth$java_lang_Float$boolean$boolean$boolean(width: number, keepProportionalWidthUnchanged: boolean, updateDepth: boolean, updateHeight: boolean) {
        const adjustedWidth: number = width != null ? Math.max(width, 0.001) : null;
        if (adjustedWidth === width || adjustedWidth != null && (adjustedWidth === width) || !keepProportionalWidthUnchanged) {
            this.proportionalWidth = width;
        }
        if (adjustedWidth == null && this.width != null || adjustedWidth != null && !(adjustedWidth === this.width)) {
            const oldWidth: number = this.width;
            this.width = adjustedWidth;
            this.propertyChangeSupport.firePropertyChange(/* name */"WIDTH", oldWidth, adjustedWidth);
            if (oldWidth != null && adjustedWidth != null) {
                const ratio: number = adjustedWidth / oldWidth;
                if (updateDepth && this.proportionalDepth != null) {
                    this.setDepth$java_lang_Float$boolean$boolean$boolean(this.proportionalDepth * ratio, true, false, false);
                }
                if (updateHeight && this.proportionalHeight != null) {
                    this.setHeight$java_lang_Float$boolean$boolean(this.proportionalHeight * ratio, true, false);
                }
            } else {
                if (updateDepth) {
                    this.setDepth$java_lang_Float$boolean$boolean$boolean(null, false, false, false);
                }
                if (updateHeight) {
                    this.setHeight$java_lang_Float$boolean$boolean(null, false, false);
                }
            }
        }
    }

    public setWidth(width?: any, keepProportionalWidthUnchanged?: any, updateDepth?: any, updateHeight?: any) {
        if (((typeof width === 'number') || width === null) && ((typeof keepProportionalWidthUnchanged === 'boolean') || keepProportionalWidthUnchanged === null) && ((typeof updateDepth === 'boolean') || updateDepth === null) && ((typeof updateHeight === 'boolean') || updateHeight === null)) {
            return <any>this.setWidth$java_lang_Float$boolean$boolean$boolean(width, keepProportionalWidthUnchanged, updateDepth, updateHeight);
        } else if (((typeof width === 'number') || width === null) && keepProportionalWidthUnchanged === undefined && updateDepth === undefined && updateHeight === undefined) {
            return <any>this.setWidth$java_lang_Float(width);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the edited width.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    public setDepth$java_lang_Float(depth: number) {
        this.setDepth$java_lang_Float$boolean$boolean$boolean(depth, false, this.isProportional() || !this.widthDepthDeformable, this.isProportional());
    }

    public setDepth$java_lang_Float$boolean$boolean$boolean(depth: number, keepProportionalDepthUnchanged: boolean, updateWidth: boolean, updateHeight: boolean) {
        const adjustedDepth: number = depth != null ? Math.max(depth, 0.001) : null;
        if (adjustedDepth === depth || adjustedDepth != null && (adjustedDepth === depth) || !keepProportionalDepthUnchanged) {
            this.proportionalDepth = depth;
        }
        if (adjustedDepth == null && this.depth != null || adjustedDepth != null && !(adjustedDepth === this.depth)) {
            const oldDepth: number = this.depth;
            this.depth = adjustedDepth;
            this.propertyChangeSupport.firePropertyChange(/* name */"DEPTH", oldDepth, adjustedDepth);
            if (oldDepth != null && adjustedDepth != null) {
                const ratio: number = adjustedDepth / oldDepth;
                if (updateWidth && this.proportionalWidth != null) {
                    this.setWidth$java_lang_Float$boolean$boolean$boolean(this.proportionalWidth * ratio, true, false, false);
                }
                if (updateHeight && this.proportionalHeight != null) {
                    this.setHeight$java_lang_Float$boolean$boolean(this.proportionalHeight * ratio, true, false);
                }
            } else {
                if (updateWidth) {
                    this.setWidth$java_lang_Float$boolean$boolean$boolean(null, false, false, false);
                }
                if (updateHeight) {
                    this.setHeight$java_lang_Float$boolean$boolean(null, false, false);
                }
            }
        }
    }

    public setDepth(depth?: any, keepProportionalDepthUnchanged?: any, updateWidth?: any, updateHeight?: any) {
        if (((typeof depth === 'number') || depth === null) && ((typeof keepProportionalDepthUnchanged === 'boolean') || keepProportionalDepthUnchanged === null) && ((typeof updateWidth === 'boolean') || updateWidth === null) && ((typeof updateHeight === 'boolean') || updateHeight === null)) {
            return <any>this.setDepth$java_lang_Float$boolean$boolean$boolean(depth, keepProportionalDepthUnchanged, updateWidth, updateHeight);
        } else if (((typeof depth === 'number') || depth === null) && keepProportionalDepthUnchanged === undefined && updateWidth === undefined && updateHeight === undefined) {
            return <any>this.setDepth$java_lang_Float(depth);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the edited depth.
     * @return {number}
     */
    public getDepth(): number {
        return this.depth;
    }

    public setHeight$java_lang_Float(height: number) {
        this.setHeight$java_lang_Float$boolean$boolean(height, false, this.isProportional());
    }

    public setHeight$java_lang_Float$boolean$boolean(height: number, keepProportionalHeightUnchanged: boolean, updateWidthAndDepth: boolean) {
        const adjustedHeight: number = height != null ? Math.max(height, 0.001) : null;
        if (adjustedHeight === height || adjustedHeight != null && (adjustedHeight === height) || !keepProportionalHeightUnchanged) {
            this.proportionalHeight = height;
        }
        if (adjustedHeight == null && this.height != null || adjustedHeight != null && !(adjustedHeight === this.height)) {
            const oldHeight: number = this.height;
            this.height = adjustedHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, adjustedHeight);
            if (updateWidthAndDepth) {
                if (oldHeight != null && adjustedHeight != null) {
                    const ratio: number = adjustedHeight / oldHeight;
                    if (this.proportionalWidth != null) {
                        this.setWidth$java_lang_Float$boolean$boolean$boolean(this.proportionalWidth * ratio, true, false, false);
                    }
                    if (this.proportionalDepth != null) {
                        this.setDepth$java_lang_Float$boolean$boolean$boolean(this.proportionalDepth * ratio, true, false, false);
                    }
                } else {
                    this.setWidth$java_lang_Float$boolean$boolean$boolean(null, false, false, false);
                    this.setDepth$java_lang_Float$boolean$boolean$boolean(null, false, false, false);
                }
            }
        }
    }

    public setHeight(height?: any, keepProportionalHeightUnchanged?: any, updateWidthAndDepth?: any) {
        if (((typeof height === 'number') || height === null) && ((typeof keepProportionalHeightUnchanged === 'boolean') || keepProportionalHeightUnchanged === null) && ((typeof updateWidthAndDepth === 'boolean') || updateWidthAndDepth === null)) {
            return <any>this.setHeight$java_lang_Float$boolean$boolean(height, keepProportionalHeightUnchanged, updateWidthAndDepth);
        } else if (((typeof height === 'number') || height === null) && keepProportionalHeightUnchanged === undefined && updateWidthAndDepth === undefined) {
            return <any>this.setHeight$java_lang_Float(height);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the edited height.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets whether furniture proportions should be kept.
     * @param {boolean} proportional
     */
    public setProportional(proportional: boolean) {
        if (proportional !== this.proportional) {
            const oldProportional: boolean = this.proportional;
            this.proportional = proportional;
            this.propertyChangeSupport.firePropertyChange(/* name */"PROPORTIONAL", oldProportional, proportional);
        }
    }

    /**
     * Returns whether furniture proportions should be kept or not.
     * @return {boolean}
     */
    public isProportional(): boolean {
        return this.proportional;
    }

    /**
     * Sets the edited color.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the edited color.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets whether the piece is colored, textured, uses customized materials or unknown painted.
     * @param {HomeFurnitureController.FurniturePaint} paint
     */
    public setPaint(paint: HomeFurnitureController.FurniturePaint) {
        if (paint !== this.paint) {
            const oldPaint: HomeFurnitureController.FurniturePaint = this.paint;
            this.paint = paint;
            this.propertyChangeSupport.firePropertyChange(/* name */"PAINT", oldPaint, paint);
        }
    }

    /**
     * Returns whether the piece is colored, textured, uses customized materials or unknown painted.
     * @return {HomeFurnitureController.FurniturePaint}
     */
    public getPaint(): HomeFurnitureController.FurniturePaint {
        return this.paint;
    }

    public setModelTransformations$com_eteks_sweethome3d_model_Transformation_A(modelTransformations: Transformation[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(modelTransformations, this.modelTransformations)) {
            const oldModelTransformations: Transformation[] = this.modelTransformations;
            this.modelTransformations = modelTransformations;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL_TRANSFORMATIONS", oldModelTransformations, modelTransformations);
            this.setDeformable(modelTransformations == null || modelTransformations.length === 0);
            this.setProportional(modelTransformations != null && modelTransformations.length > 0);
        }
    }

    public setModelTransformations$com_eteks_sweethome3d_model_Transformation_A$float$float$float$float$float$float(transformations: Transformation[], x: number, y: number, elevation: number, width: number, depth: number, height: number) {
        if (this.doorOrWindow) {
            const currentX: number = this.getX();
            const currentY: number = this.getY();
            const currentElevation: number = this.getElevation();
            const currentWidth: number = this.getWidth();
            const currentDepth: number = this.getDepth();
            const currentHeight: number = this.getHeight();
            const angle: number = -this.getAngle();
            const currentXAlongWidth: number = <number>(currentX * Math.cos(angle) - currentY * Math.sin(angle));
            const updatedXAlongWidth: number = <number>(x * Math.cos(angle) - y * Math.sin(angle));
            const currentWallLeft: number = this.wallLeft * currentWidth;
            const wallWidth: number = this.wallWidth * currentWidth;
            let newWallLeft: number;
            if (this.getModelMirrored()) {
                const xWallLeft: number = currentWallLeft - currentXAlongWidth - currentWidth / 2;
                newWallLeft = xWallLeft + updatedXAlongWidth + width / 2;
            } else {
                const xWallLeft: number = currentWallLeft + currentXAlongWidth - currentWidth / 2;
                newWallLeft = xWallLeft - updatedXAlongWidth + width / 2;
            }
            const currentYAlongDepth: number = <number>(currentX * Math.sin(angle) + currentY * Math.cos(angle));
            const updatedYAlongDepth: number = <number>(x * Math.sin(angle) + y * Math.cos(angle));
            const currentWallDistance: number = this.wallDistance * currentDepth;
            const wallThickness: number = this.wallThickness * currentDepth;
            const yWallBack: number = currentYAlongDepth - currentDepth / 2 + currentWallDistance;
            const newWallDistance: number = yWallBack - updatedYAlongDepth + depth / 2;
            const currentWallTop: number = this.wallTop * currentHeight;
            const wallHeight: number = this.wallHeight * currentHeight;
            const newWallTop: number = currentWallTop + elevation + height - (currentElevation + currentHeight);
            const sashes: Sash[] = this.sashes;
            for (let i: number = 0; i < sashes.length; i++) {
                {
                    const sash: Sash = sashes[i];
                    let xAxis: number = sash.getXAxis() * currentWidth;
                    xAxis += newWallLeft - currentWallLeft;
                    let yAxis: number = sash.getYAxis() * currentDepth;
                    yAxis += newWallDistance - currentWallDistance;
                    sashes[i] = new Sash(xAxis / width, yAxis / depth, sash.getWidth() * currentWidth / width, sash.getStartAngle(), sash.getEndAngle());
                };
            }
            this.wallThickness = wallThickness / depth;
            this.wallDistance = newWallDistance / depth;
            this.wallWidth = wallWidth / width;
            this.wallLeft = newWallLeft / width;
            this.wallHeight = wallHeight / height;
            this.wallTop = newWallTop / height;
            this.sashes = sashes;
        }
        this.setModelTransformations$com_eteks_sweethome3d_model_Transformation_A(transformations);
        this.setX(x);
        this.setY(y);
        this.setWidth$java_lang_Float$boolean$boolean$boolean(width, false, false, false);
        this.setDepth$java_lang_Float$boolean$boolean$boolean(depth, false, false, false);
        this.setHeight$java_lang_Float$boolean$boolean(height, false, false);
    }

    /**
     * Sets model transformations and updated dimensions of the edited piece.
     * @param {com.eteks.sweethome3d.model.Transformation[]} transformations
     * @param {number} x
     * @param {number} y
     * @param {number} elevation
     * @param {number} width
     * @param {number} depth
     * @param {number} height
     */
    public setModelTransformations(transformations?: any, x?: any, y?: any, elevation?: any, width?: any, depth?: any, height?: any) {
        if (((transformations != null && transformations instanceof <any>Array && (transformations.length == 0 || transformations[0] == null || (transformations[0] != null && transformations[0] instanceof <any>Transformation))) || transformations === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof elevation === 'number') || elevation === null) && ((typeof width === 'number') || width === null) && ((typeof depth === 'number') || depth === null) && ((typeof height === 'number') || height === null)) {
            return <any>this.setModelTransformations$com_eteks_sweethome3d_model_Transformation_A$float$float$float$float$float$float(transformations, x, y, elevation, width, depth, height);
        } else if (((transformations != null && transformations instanceof <any>Array && (transformations.length == 0 || transformations[0] == null || (transformations[0] != null && transformations[0] instanceof <any>Transformation))) || transformations === null) && x === undefined && y === undefined && elevation === undefined && width === undefined && depth === undefined && height === undefined) {
            return <any>this.setModelTransformations$com_eteks_sweethome3d_model_Transformation_A(transformations);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns model transformations.
     * @return {com.eteks.sweethome3d.model.Transformation[]}
     */
    public getModelTransformations(): Transformation[] {
        return this.modelTransformations;
    }

    /**
     * Returns the names of the available preset model transformations.
     * @return {string[]}
     */
    public getModelPresetTransformationsNames(): Array<string> {
        return /* unmodifiableList */this.modelPresetTransformationsNames.slice(0);
    }

    /**
     * Returns the preset model transformations at the given <code>index</code>.
     * @param {number} index
     * @return {com.eteks.sweethome3d.model.Transformation[]}
     */
    public getModelPresetTransformations(index: number): Transformation[] {
        return /* get */this.modelPresetTransformations[index];
    }

    /**
     * Sets whether the piece shininess is the default one, matt, shiny or unknown.
     * @param {HomeFurnitureController.FurnitureShininess} shininess
     */
    public setShininess(shininess: HomeFurnitureController.FurnitureShininess) {
        if (shininess !== this.shininess) {
            const oldShininess: HomeFurnitureController.FurnitureShininess = this.shininess;
            this.shininess = shininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"SHININESS", oldShininess, shininess);
        }
    }

    /**
     * Returns whether the piece is shininess is the default one, matt, shiny or unknown.
     * @return {HomeFurnitureController.FurnitureShininess}
     */
    public getShininess(): HomeFurnitureController.FurnitureShininess {
        return this.shininess;
    }

    /**
     * Sets whether furniture is visible or not.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        if (visible !== this.visible) {
            const oldVisible: boolean = this.visible;
            this.visible = visible;
            this.propertyChangeSupport.firePropertyChange(/* name */"VISIBLE", oldVisible, visible);
        }
    }

    /**
     * Returns whether furniture is visible or not.
     * @return {boolean}
     */
    public getVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether furniture model is mirrored or not.
     * @param {boolean} modelMirrored
     */
    public setModelMirrored(modelMirrored: boolean) {
        if (modelMirrored !== this.modelMirrored) {
            const oldModelMirrored: boolean = this.modelMirrored;
            this.modelMirrored = modelMirrored;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL_MIRRORED", oldModelMirrored, modelMirrored);
        }
    }

    /**
     * Returns whether furniture model is mirrored or not.
     * @return {boolean}
     */
    public getModelMirrored(): boolean {
        return this.modelMirrored;
    }

    /**
     * Returns <code>true</code> if light power is an editable property.
     * @return {boolean}
     */
    public isLightPowerEditable(): boolean {
        return this.lightPowerEditable;
    }

    /**
     * Returns the edited light power.
     * @return {number}
     */
    public getLightPower(): number {
        return this.lightPower;
    }

    /**
     * Sets the edited light power.
     * @param {number} lightPower
     */
    public setLightPower(lightPower: number) {
        if (lightPower !== this.lightPower) {
            const oldLightPower: number = this.lightPower;
            this.lightPower = lightPower;
            this.propertyChangeSupport.firePropertyChange(/* name */"LIGHT_POWER", oldLightPower, lightPower);
        }
    }

    /**
     * Sets whether furniture model can be resized or not.
     * @param {boolean} resizable
     * @private
     */
    setResizable(resizable: boolean) {
        if (resizable !== this.resizable) {
            const oldResizable: boolean = this.resizable;
            this.resizable = resizable;
            this.propertyChangeSupport.firePropertyChange(/* name */"RESIZABLE", oldResizable, resizable);
        }
    }

    /**
     * Returns whether furniture model can be resized or not.
     * @return {boolean}
     */
    public isResizable(): boolean {
        return this.resizable;
    }

    /**
     * Sets whether furniture model can be deformed or not.
     * @param {boolean} deformable
     * @private
     */
    setDeformable(deformable: boolean) {
        if (deformable !== this.deformable) {
            const oldDeformable: boolean = this.deformable;
            this.deformable = deformable;
            this.propertyChangeSupport.firePropertyChange(/* name */"DEFORMABLE", oldDeformable, deformable);
        }
    }

    /**
     * Returns whether furniture model can be deformed or not.
     * @return {boolean}
     */
    public isDeformable(): boolean {
        return this.deformable;
    }

    /**
     * Sets whether the color or the texture of the furniture model can be changed or not.
     * @param {boolean} texturable
     * @private
     */
    setTexturable(texturable: boolean) {
        if (texturable !== this.texturable) {
            const oldTexturable: boolean = this.texturable;
            this.texturable = texturable;
            this.propertyChangeSupport.firePropertyChange(/* name */"TEXTURABLE", oldTexturable, texturable);
        }
    }

    /**
     * Returns whether the color or the texture of the furniture model can be changed or not.
     * @return {boolean}
     */
    public isTexturable(): boolean {
        return this.texturable;
    }

    /**
     * Controls the modification of selected furniture in the edited home.
     */
    public modifyFurniture() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(oldSelection);
        if (!/* isEmpty */(selectedFurniture.length == 0)) {
            const name: string = this.getName();
            const nameVisible: boolean = this.getNameVisible();
            const description: string = this.getDescription();
            const editedProperties: any = this.getAdditionalProperties();
            let additionalProperties: any;
            if (editedProperties == null) {
                additionalProperties = null;
            } else {
                additionalProperties = <any>({});
                {
                    let array = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>editedProperties);
                    for (let index = 0; index < array.length; index++) {
                        let entry = array[index];
                        {
                            /* put */(additionalProperties[entry.getKey().getName()] = entry.getValue());
                        }
                    }
                }
            }
            const price: Big = this.getPrice();
            const removePrice: boolean = /* size */(<number>selectedFurniture.length) === 1 && price == null;
            const valueAddedTaxPercentage: Big = this.getValueAddedTaxPercentage();
            const removeValueAddedTaxPercentage: boolean = /* size */(<number>selectedFurniture.length) === 1 && valueAddedTaxPercentage == null;
            const currency: string = this.preferences.getCurrency();
            const x: number = this.getX();
            const y: number = this.getY();
            const elevation: number = this.getElevation();
            const angle: number = this.getAngle();
            const roll: number = this.getRoll();
            const pitch: number = this.getPitch();
            const horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis = this.getHorizontalAxis();
            const basePlanItem: boolean = this.getBasePlanItem();
            const width: number = this.getWidth();
            const depth: number = this.getDepth();
            const height: number = this.getHeight();
            const proportional: boolean = this.isProportional() && (width == null || depth == null || height == null);
            const paint: HomeFurnitureController.FurniturePaint = this.getPaint();
            const color: number = paint === HomeFurnitureController.FurniturePaint.COLORED ? this.getColor() : null;
            const textureController: TextureChoiceController = this.getTextureController();
            let texture: HomeTexture;
            if (textureController != null && paint === HomeFurnitureController.FurniturePaint.TEXTURED) {
                texture = textureController.getTexture();
            } else {
                texture = null;
            }
            const modelMaterialsController: ModelMaterialsController = this.getModelMaterialsController();
            let modelMaterials: HomeMaterial[];
            if (modelMaterialsController != null && paint === HomeFurnitureController.FurniturePaint.MODEL_MATERIALS) {
                modelMaterials = modelMaterialsController.getMaterials();
            } else {
                modelMaterials = null;
            }
            const modelTransformations: Transformation[] = this.getModelTransformations();
            const defaultShininess: boolean = this.getShininess() === HomeFurnitureController.FurnitureShininess.DEFAULT;
            const shininess: number = this.getShininess() === HomeFurnitureController.FurnitureShininess.SHINY ? new Number(0.5).valueOf() : (this.getShininess() === HomeFurnitureController.FurnitureShininess.MATT ? new Number(0).valueOf() : null);
            const visible: boolean = this.getVisible();
            const modelMirrored: boolean = this.getModelMirrored();
            const lightPower: number = this.getLightPower();
            const modifiedFurniture: HomeFurnitureController.ModifiedPieceOfFurniture[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedFurniture.length));
            for (let i: number = 0; i < modifiedFurniture.length; i++) {
                {
                    const piece: HomePieceOfFurniture = /* get */selectedFurniture[i];
                    if (piece != null && piece instanceof <any>HomeLight) {
                        modifiedFurniture[i] = new HomeFurnitureController.ModifiedLight(<HomeLight>piece);
                    } else if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                        modifiedFurniture[i] = new HomeFurnitureController.ModifiedDoorOrWindow(<HomeDoorOrWindow>piece);
                    } else if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        modifiedFurniture[i] = new HomeFurnitureController.ModifiedFurnitureGroup(<HomeFurnitureGroup>piece);
                    } else {
                        modifiedFurniture[i] = new HomeFurnitureController.ModifiedPieceOfFurniture(piece);
                    }
                };
            }
            HomeFurnitureController.doModifyFurniture(modifiedFurniture, name, nameVisible, description, additionalProperties, price, removePrice, valueAddedTaxPercentage, removeValueAddedTaxPercentage, currency, x, y, elevation, angle, roll, pitch, horizontalAxis, basePlanItem, width, depth, height, proportional, modelTransformations, this.wallThickness, this.wallDistance, this.wallWidth, this.wallLeft, this.wallHeight, this.wallTop, this.sashes, paint, color, texture, modelMaterials, defaultShininess, shininess, visible, modelMirrored, lightPower);
            if (this.undoSupport != null) {
                const newSelection: Array<Selectable> = this.home.getSelectedItems();
                this.undoSupport.postEdit(new HomeFurnitureController.FurnitureModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), /* toArray */newSelection.slice(0), modifiedFurniture, name, nameVisible, description, additionalProperties, price, removePrice, valueAddedTaxPercentage, removeValueAddedTaxPercentage, currency, x, y, elevation, angle, roll, pitch, horizontalAxis, basePlanItem, width, depth, height, proportional, modelTransformations, this.wallThickness, this.wallDistance, this.wallWidth, this.wallLeft, this.wallHeight, this.wallTop, this.sashes, paint, color, texture, modelMaterials, defaultShininess, shininess, visible, modelMirrored, lightPower));
            }
            if (name != null) {
                this.preferences.addAutoCompletionString("HomePieceOfFurnitureName", name);
            }
            if (description != null) {
                this.preferences.addAutoCompletionString("HomePieceOfFurnitureDescription", description);
            }
            if (valueAddedTaxPercentage != null) {
                this.preferences.setDefaultValueAddedTaxPercentage(valueAddedTaxPercentage);
            }
        }
    }

    /**
     * Modifies furniture properties with the values in parameter.
     * @param {com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedPieceOfFurniture[]} modifiedFurniture
     * @param {string} name
     * @param {boolean} nameVisible
     * @param {string} description
     * @param {Object} additionalProperties
     * @param {Big} price
     * @param {boolean} removePrice
     * @param {Big} valueAddedTaxPercentage
     * @param {boolean} removeValueAddedTaxPercenage
     * @param {string} currency
     * @param {number} x
     * @param {number} y
     * @param {number} elevation
     * @param {number} angle
     * @param {number} roll
     * @param {number} pitch
     * @param {HomeFurnitureController.FurnitureHorizontalAxis} horizontalAxis
     * @param {boolean} basePlanItem
     * @param {number} width
     * @param {number} depth
     * @param {number} height
     * @param {boolean} proportional
     * @param {com.eteks.sweethome3d.model.Transformation[]} modelTransformations
     * @param {number} wallThickness
     * @param {number} wallDistance
     * @param {number} wallWidth
     * @param {number} wallLeft
     * @param {number} wallHeight
     * @param {number} wallTop
     * @param {com.eteks.sweethome3d.model.Sash[]} sashes
     * @param {HomeFurnitureController.FurniturePaint} paint
     * @param {number} color
     * @param {HomeTexture} texture
     * @param {com.eteks.sweethome3d.model.HomeMaterial[]} modelMaterials
     * @param {boolean} defaultShininess
     * @param {number} shininess
     * @param {boolean} visible
     * @param {boolean} modelMirrored
     * @param {number} lightPower
     * @private
     */
    static doModifyFurniture(modifiedFurniture: HomeFurnitureController.ModifiedPieceOfFurniture[], name: string, nameVisible: boolean, description: string, additionalProperties: any, price: Big, removePrice: boolean, valueAddedTaxPercentage: Big, removeValueAddedTaxPercenage: boolean, currency: string, x: number, y: number, elevation: number, angle: number, roll: number, pitch: number, horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis, basePlanItem: boolean, width: number, depth: number, height: number, proportional: boolean, modelTransformations: Transformation[], wallThickness: number, wallDistance: number, wallWidth: number, wallLeft: number, wallHeight: number, wallTop: number, sashes: Sash[], paint: HomeFurnitureController.FurniturePaint, color: number, texture: HomeTexture, modelMaterials: HomeMaterial[], defaultShininess: boolean, shininess: number, visible: boolean, modelMirrored: boolean, lightPower: number) {
        for (let index = 0; index < modifiedFurniture.length; index++) {
            let modifiedPiece = modifiedFurniture[index];
            {
                const piece: HomePieceOfFurniture = modifiedPiece.getPieceOfFurniture();
                if (name != null) {
                    piece.setName(name);
                }
                if (nameVisible != null) {
                    piece.setNameVisible(nameVisible);
                }
                if (additionalProperties != null) {
                    {
                        let array = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function () { return this.k }, getValue: function () { return this.v } }); return s; })(additionalProperties);
                        for (let index1 = 0; index1 < array.length; index1++) {
                            let property = array[index1];
                            {
                                piece.setProperty$java_lang_String$java_lang_Object(property.getKey(), property.getValue());
                            }
                        }
                    }
                }
                if (modifiedFurniture.length === 1 || description != null) {
                    piece.setDescription(description);
                }
                if (!(piece != null && piece instanceof <any>HomeFurnitureGroup)) {
                    if (price != null || removePrice) {
                        if (price !== piece.getPrice() && (price == null || !/* equals */((piece.getPrice()) != null ? price.eq(piece.getPrice()) : (price === (piece.getPrice()))))) {
                            piece.setCurrency(price != null ? currency : null);
                        }
                        if (price != null) {
                            try {
                                price = /* setScale */price.round(/* getDefaultFractionDigits */(['JPY', 'VND'].indexOf(currency) >= 0 ? 0 : 2));
                            } catch (ex) {
                            }
                        }
                        piece.setPrice(price);
                    }
                    if (valueAddedTaxPercentage != null || removeValueAddedTaxPercenage) {
                        piece.setValueAddedTaxPercentage(valueAddedTaxPercentage);
                    }
                }
                if (x != null) {
                    piece.setX(x);
                }
                if (y != null) {
                    piece.setY(y);
                }
                if (elevation != null) {
                    piece.setElevation(elevation);
                }
                if (angle != null) {
                    piece.setAngle(angle);
                }
                if (horizontalAxis != null) {
                    switch ((horizontalAxis)) {
                        case HomeFurnitureController.FurnitureHorizontalAxis.ROLL:
                            if (roll != null) {
                                piece.setRoll(roll);
                                piece.setPitch(0);
                            }
                            break;
                        case HomeFurnitureController.FurnitureHorizontalAxis.PITCH:
                            if (pitch != null) {
                                piece.setPitch(pitch);
                                piece.setRoll(0);
                            }
                            break;
                    }
                }
                if (basePlanItem != null && !piece.isDoorOrWindow()) {
                    piece.setMovable(!basePlanItem);
                }
                if (piece.isResizable()) {
                    const oldWidth: number = piece.getWidth();
                    const oldDepth: number = piece.getDepth();
                    const deformable: boolean = !proportional && piece.isDeformable();
                    if (deformable) {
                        if (width != null) {
                            piece.setWidth(width);
                        } else if (depth != null && !piece.isWidthDepthDeformable()) {
                            piece.setWidth(piece.getWidth() * depth / oldDepth);
                        }
                        if (depth != null) {
                            piece.setDepth(depth);
                        } else if (width != null && !piece.isWidthDepthDeformable()) {
                            piece.setDepth(piece.getDepth() * width / oldWidth);
                        }
                        if (height != null) {
                            piece.setHeight(height);
                        }
                    } else {
                        if (width != null) {
                            piece.scale(width / piece.getWidth());
                        } else if (depth != null) {
                            piece.scale(depth / piece.getDepth());
                        } else if (height != null) {
                            piece.scale(height / piece.getHeight());
                        }
                    }
                    if (modelMirrored != null) {
                        piece.setModelMirrored(modelMirrored);
                    }
                    if ((piece != null && piece instanceof <any>HomeDoorOrWindow) && modifiedFurniture.length === 1 && !/* deepEquals */(JSON.stringify(piece.getModelTransformations()) === JSON.stringify(modelTransformations != null && modelTransformations.length > 0 ? modelTransformations : null))) {
                        const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                        doorOrWindow.setWallThickness(wallThickness);
                        doorOrWindow.setWallDistance(wallDistance);
                        doorOrWindow.setWallWidth(wallWidth);
                        doorOrWindow.setWallLeft(wallLeft);
                        doorOrWindow.setWallHeight(wallHeight);
                        doorOrWindow.setWallTop(wallTop);
                        doorOrWindow.setSashes(sashes);
                    }
                }
                if (piece.isTexturable()) {
                    if (paint != null) {
                        switch ((paint)) {
                            case HomeFurnitureController.FurniturePaint.DEFAULT:
                                piece.setColor(null);
                                piece.setTexture(null);
                                piece.setModelMaterials(null);
                                break;
                            case HomeFurnitureController.FurniturePaint.COLORED:
                                piece.setColor(color);
                                piece.setTexture(null);
                                piece.setModelMaterials(null);
                                break;
                            case HomeFurnitureController.FurniturePaint.TEXTURED:
                                piece.setColor(null);
                                piece.setTexture(texture);
                                piece.setModelMaterials(null);
                                break;
                            case HomeFurnitureController.FurniturePaint.MODEL_MATERIALS:
                                piece.setColor(null);
                                piece.setTexture(null);
                                piece.setModelMaterials(modelMaterials);
                                break;
                        }
                    }
                    if (defaultShininess) {
                        piece.setShininess(null);
                    } else if (shininess != null) {
                        piece.setShininess(shininess);
                    }
                }
                if (modelTransformations != null) {
                    piece.setModelTransformations(modelTransformations.length > 0 ? modelTransformations : null);
                }
                if (visible != null) {
                    piece.setVisible(visible);
                }
                if (lightPower != null) {
                    (<HomeLight>piece).setPower(lightPower);
                }
            }
        }
    }

    /**
     * Restores furniture properties from the values stored in <code>modifiedFurniture</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedPieceOfFurniture[]} modifiedFurniture
     * @private
     */
    static undoModifyFurniture(modifiedFurniture: HomeFurnitureController.ModifiedPieceOfFurniture[]) {
        for (let index = 0; index < modifiedFurniture.length; index++) {
            let modifiedPiece = modifiedFurniture[index];
            {
                modifiedPiece.reset();
            }
        }
    }
}
HomeFurnitureController["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController";
HomeFurnitureController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace HomeFurnitureController {

    /**
     * The possible values for {@linkplain #getPaint() paint type}.
     * @enum
     * @property {HomeFurnitureController.FurniturePaint} DEFAULT
     * @property {HomeFurnitureController.FurniturePaint} COLORED
     * @property {HomeFurnitureController.FurniturePaint} TEXTURED
     * @property {HomeFurnitureController.FurniturePaint} MODEL_MATERIALS
     * @class
     */
    export enum FurniturePaint {
        DEFAULT, COLORED, TEXTURED, MODEL_MATERIALS
    }

    /**
     * The possible values for {@linkplain #getShininess() shininess type}.
     * @enum
     * @property {HomeFurnitureController.FurnitureShininess} DEFAULT
     * @property {HomeFurnitureController.FurnitureShininess} MATT
     * @property {HomeFurnitureController.FurnitureShininess} SHINY
     * @class
     */
    export enum FurnitureShininess {
        DEFAULT, MATT, SHINY
    }

    /**
     * The possible values for {@linkplain #getHorizontalAxis() horizontal axis}.
     * @enum
     * @property {HomeFurnitureController.FurnitureHorizontalAxis} ROLL
     * @property {HomeFurnitureController.FurnitureHorizontalAxis} PITCH
     * @class
     */
    export enum FurnitureHorizontalAxis {
        ROLL, PITCH
    }

    /**
     * Undoable edit for furniture modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class FurnitureModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        modifiedFurniture: HomeFurnitureController.ModifiedPieceOfFurniture[];

        oldSelection: Selectable[];

        newSelection: Selectable[];

        name: string;

        nameVisible: boolean;

        description: string;

        additionalProperties: any;

        price: Big;

        removePrice: boolean;

        currency: string;

        valueAddedTaxPercentage: Big;

        removeValueAddedTaxPercentage: boolean;

        x: number;

        y: number;

        elevation: number;

        angle: number;

        roll: number;

        pitch: number;

        horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis;

        basePlanItem: boolean;

        width: number;

        depth: number;

        height: number;

        proportional: boolean;

        modelTransformations: Transformation[];

        paint: HomeFurnitureController.FurniturePaint;

        color: number;

        texture: HomeTexture;

        modelMaterials: HomeMaterial[];

        defaultShininess: boolean;

        shininess: number;

        visible: boolean;

        modelMirrored: boolean;

        lightPower: number;

        wallThickness: number;

        wallDistance: number;

        wallWidth: number;

        wallLeft: number;

        wallHeight: number;

        wallTop: number;

        sashes: Sash[];

        widthsInPlan: number[];

        depthsInPlan: number[];

        heightsInPlan: number[];

        constructor(home: Home, preferences: any, oldSelection: Selectable[], newSelection: Selectable[], modifiedFurniture: HomeFurnitureController.ModifiedPieceOfFurniture[], name: string, nameVisible: boolean, description: string, additionalProperties: any, price: Big, removePrice: boolean, valueAddedTaxPercentage: Big, removeValueAddedTaxPercenage: boolean, currency: string, x: number, y: number, elevation: number, angle: number, roll: number, pitch: number, horizontalAxis: HomeFurnitureController.FurnitureHorizontalAxis, basePlanItem: boolean, width: number, depth: number, height: number, proportional: boolean, modelTransformations: Transformation[], wallThickness: number, wallDistance: number, wallWidth: number, wallLeft: number, wallHeight: number, wallTop: number, sashes: Sash[], paint: HomeFurnitureController.FurniturePaint, color: number, texture: HomeTexture, modelMaterials: HomeMaterial[], defaultShininess: boolean, shininess: number, visible: boolean, modelMirrored: boolean, lightPower: number) {
            super(preferences, HomeFurnitureController, "undoModifyFurnitureName");
            if (this.home === undefined) { this.home = null; }
            if (this.modifiedFurniture === undefined) { this.modifiedFurniture = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.newSelection === undefined) { this.newSelection = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = null; }
            if (this.description === undefined) { this.description = null; }
            if (this.additionalProperties === undefined) { this.additionalProperties = null; }
            if (this.price === undefined) { this.price = null; }
            if (this.removePrice === undefined) { this.removePrice = false; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.removeValueAddedTaxPercentage === undefined) { this.removeValueAddedTaxPercentage = false; }
            if (this.x === undefined) { this.x = null; }
            if (this.y === undefined) { this.y = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            if (this.angle === undefined) { this.angle = null; }
            if (this.roll === undefined) { this.roll = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.horizontalAxis === undefined) { this.horizontalAxis = null; }
            if (this.basePlanItem === undefined) { this.basePlanItem = null; }
            if (this.width === undefined) { this.width = null; }
            if (this.depth === undefined) { this.depth = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.paint === undefined) { this.paint = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.defaultShininess === undefined) { this.defaultShininess = false; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.visible === undefined) { this.visible = null; }
            if (this.modelMirrored === undefined) { this.modelMirrored = null; }
            if (this.lightPower === undefined) { this.lightPower = null; }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.widthsInPlan === undefined) { this.widthsInPlan = null; }
            if (this.depthsInPlan === undefined) { this.depthsInPlan = null; }
            if (this.heightsInPlan === undefined) { this.heightsInPlan = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.newSelection = newSelection;
            this.modifiedFurniture = modifiedFurniture;
            this.name = name;
            this.nameVisible = nameVisible;
            this.description = description;
            this.additionalProperties = additionalProperties;
            this.price = price;
            this.removePrice = removePrice;
            this.valueAddedTaxPercentage = valueAddedTaxPercentage;
            this.removeValueAddedTaxPercentage = removeValueAddedTaxPercenage;
            this.currency = currency;
            this.x = x;
            this.y = y;
            this.elevation = elevation;
            this.angle = angle;
            this.roll = roll;
            this.pitch = pitch;
            this.horizontalAxis = horizontalAxis;
            this.basePlanItem = basePlanItem;
            this.width = width;
            this.depth = depth;
            this.height = height;
            this.proportional = proportional;
            this.modelTransformations = modelTransformations;
            this.wallThickness = wallThickness;
            this.wallDistance = wallDistance;
            this.wallWidth = wallWidth;
            this.wallLeft = wallLeft;
            this.wallHeight = wallHeight;
            this.wallTop = wallTop;
            this.sashes = sashes;
            this.paint = paint;
            this.color = color;
            this.texture = texture;
            this.modelMaterials = modelMaterials;
            this.defaultShininess = defaultShininess;
            this.shininess = shininess;
            this.visible = visible;
            this.modelMirrored = modelMirrored;
            this.lightPower = lightPower;
            this.widthsInPlan = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(modifiedFurniture.length);
            this.depthsInPlan = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(modifiedFurniture.length);
            this.heightsInPlan = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(modifiedFurniture.length);
            for (let i: number = 0; i < modifiedFurniture.length; i++) {
                {
                    const piece: HomePieceOfFurniture = modifiedFurniture[i].getPieceOfFurniture();
                    this.widthsInPlan[i] = piece.getWidthInPlan();
                    this.depthsInPlan[i] = piece.getDepthInPlan();
                    this.heightsInPlan[i] = piece.getHeightInPlan();
                };
            }
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            HomeFurnitureController.undoModifyFurniture(this.modifiedFurniture);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            HomeFurnitureController.doModifyFurniture(this.modifiedFurniture, this.name, this.nameVisible, this.description, this.additionalProperties, this.price, this.removePrice, this.valueAddedTaxPercentage, this.removeValueAddedTaxPercentage, this.currency, this.x, this.y, this.elevation, this.angle, this.roll, this.pitch, this.horizontalAxis, this.basePlanItem, this.width, this.depth, this.height, this.proportional, this.modelTransformations, this.wallThickness, this.wallDistance, this.wallWidth, this.wallLeft, this.wallHeight, this.wallTop, this.sashes, this.paint, this.color, this.texture, this.modelMaterials, this.defaultShininess, this.shininess, this.visible, this.modelMirrored, this.lightPower);
            for (let i: number = 0; i < this.modifiedFurniture.length; i++) {
                {
                    const piece: HomePieceOfFurniture = this.modifiedFurniture[i].getPieceOfFurniture();
                    piece.setWidthInPlan(this.widthsInPlan[i]);
                    piece.setDepthInPlan(this.depthsInPlan[i]);
                    piece.setHeightInPlan(this.heightsInPlan[i]);
                };
            }
            this.home.setSelectedItems(/* asList */this.newSelection.slice(0));
        }
    }
    FurnitureModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.FurnitureModificationUndoableEdit";
    FurnitureModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified piece of furniture.
     * @param {HomePieceOfFurniture} piece
     * @class
     */
    export class ModifiedPieceOfFurniture {
        piece: HomePieceOfFurniture;

        name: string;

        nameVisible: boolean;

        description: string;

        properties: any;

        price: Big;

        valueAddedTaxPercentage: Big;

        currency: string;

        x: number;

        y: number;

        elevation: number;

        angle: number;

        roll: number;

        pitch: number;

        movable: boolean;

        width: number;

        depth: number;

        height: number;

        widthInPlan: number;

        depthInPlan: number;

        heightInPlan: number;

        modelTransformations: Transformation[];

        color: number;

        texture: HomeTexture;

        modelMaterials: HomeMaterial[];

        shininess: number;

        visible: boolean;

        modelMirrored: boolean;

        public constructor(piece: HomePieceOfFurniture) {
            if (this.piece === undefined) { this.piece = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.nameVisible === undefined) { this.nameVisible = false; }
            if (this.description === undefined) { this.description = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.price === undefined) { this.price = null; }
            if (this.valueAddedTaxPercentage === undefined) { this.valueAddedTaxPercentage = null; }
            if (this.currency === undefined) { this.currency = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.angle === undefined) { this.angle = 0; }
            if (this.roll === undefined) { this.roll = 0; }
            if (this.pitch === undefined) { this.pitch = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.widthInPlan === undefined) { this.widthInPlan = 0; }
            if (this.depthInPlan === undefined) { this.depthInPlan = 0; }
            if (this.heightInPlan === undefined) { this.heightInPlan = 0; }
            if (this.modelTransformations === undefined) { this.modelTransformations = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.texture === undefined) { this.texture = null; }
            if (this.modelMaterials === undefined) { this.modelMaterials = null; }
            if (this.shininess === undefined) { this.shininess = null; }
            if (this.visible === undefined) { this.visible = false; }
            if (this.modelMirrored === undefined) { this.modelMirrored = false; }
            this.piece = piece;
            this.name = piece.getName();
            this.nameVisible = piece.isNameVisible();
            this.description = piece.getDescription();
            const propertyNames: Array<string> = piece.getPropertyNames();
            if (/* size */(<number>propertyNames.length) === 0) {
                this.properties = /* emptyMap */{};
            } else if (/* size */(<number>propertyNames.length) === 1) {
                const name: string = /* iterator */((a) => { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } } })(propertyNames).next();
                this.properties = /* singletonMap */(k => { let o = {}; o[k] = <any><any>(piece.isContentProperty(name) ? piece.getContentProperty(name) : piece.getProperty(name)); return o; })(name);
            } else {
                this.properties = <any>({});
                for (let index = 0; index < propertyNames.length; index++) {
                    let name = propertyNames[index];
                    {
                        /* put */(this.properties[name] = piece.isContentProperty(name) ? piece.getContentProperty(name) : piece.getProperty(name));
                    }
                }
            }
            this.price = piece.getPrice();
            this.valueAddedTaxPercentage = piece.getValueAddedTaxPercentage();
            this.currency = piece.getCurrency();
            this.x = piece.getX();
            this.y = piece.getY();
            this.elevation = piece.getElevation();
            this.angle = piece.getAngle();
            this.roll = piece.getRoll();
            this.pitch = piece.getPitch();
            this.movable = piece.isMovable();
            this.width = piece.getWidth();
            this.depth = piece.getDepth();
            this.height = piece.getHeight();
            this.widthInPlan = piece.getWidthInPlan();
            this.depthInPlan = piece.getDepthInPlan();
            this.heightInPlan = piece.getHeightInPlan();
            this.modelTransformations = piece.getModelTransformations();
            this.color = piece.getColor();
            this.texture = piece.getTexture();
            this.modelMaterials = piece.getModelMaterials();
            this.shininess = piece.getShininess();
            this.visible = piece.isVisible();
            this.modelMirrored = piece.isModelMirrored();
        }

        public getPieceOfFurniture(): HomePieceOfFurniture {
            return this.piece;
        }

        public reset() {
            this.piece.setName(this.name);
            this.piece.setNameVisible(this.nameVisible);
            this.piece.setDescription(this.description);
            const propertyNames: Array<string> = this.piece.getPropertyNames();
            for (let index = 0; index < propertyNames.length; index++) {
                let name = propertyNames[index];
                {
                    this.piece.setProperty$java_lang_String$java_lang_Object(name, /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name));
                }
            }
            {
                let array = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function () { return this.k }, getValue: function () { return this.v } }); return s; })(this.properties);
                for (let index = 0; index < array.length; index++) {
                    let entry = array[index];
                    {
                        if (!/* contains */(propertyNames.indexOf(<any>(entry.getKey())) >= 0)) {
                            this.piece.setProperty$java_lang_String$java_lang_Object(entry.getKey(), entry.getValue());
                        }
                    }
                }
            }
            if (!(this.piece != null && this.piece instanceof <any>HomeFurnitureGroup)) {
                this.piece.setPrice(this.price);
                this.piece.setValueAddedTaxPercentage(this.valueAddedTaxPercentage);
                this.piece.setCurrency(this.currency);
            }
            this.piece.setX(this.x);
            this.piece.setY(this.y);
            this.piece.setElevation(this.elevation);
            this.piece.setAngle(this.angle);
            if (this.piece.isHorizontallyRotatable()) {
                this.piece.setRoll(this.roll);
                this.piece.setPitch(this.pitch);
            }
            this.piece.setMovable(this.movable);
            if (this.piece.isResizable()) {
                this.piece.setWidth(this.width);
                this.piece.setDepth(this.depth);
                this.piece.setHeight(this.height);
                this.piece.setModelMirrored(this.modelMirrored);
            }
            this.piece.setWidthInPlan(this.widthInPlan);
            this.piece.setDepthInPlan(this.depthInPlan);
            this.piece.setHeightInPlan(this.heightInPlan);
            this.piece.setModelTransformations(this.modelTransformations);
            if (this.piece.isTexturable()) {
                this.piece.setColor(this.color);
                this.piece.setTexture(this.texture);
                this.piece.setModelMaterials(this.modelMaterials);
                this.piece.setShininess(this.shininess);
            }
            this.piece.setVisible(this.visible);
        }
    }
    ModifiedPieceOfFurniture["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedPieceOfFurniture";


    /**
     * Stores the current properties values of a modified door or window.
     * @param {HomeDoorOrWindow} doorOrWindow
     * @class
     * @extends HomeFurnitureController.ModifiedPieceOfFurniture
     */
    export class ModifiedDoorOrWindow extends HomeFurnitureController.ModifiedPieceOfFurniture {
        boundToWall: boolean;

        wallThickness: number;

        wallDistance: number;

        wallWidth: number;

        wallLeft: number;

        wallHeight: number;

        wallTop: number;

        sashes: Sash[];

        public constructor(doorOrWindow: HomeDoorOrWindow) {
            super(doorOrWindow);
            if (this.boundToWall === undefined) { this.boundToWall = false; }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.sashes === undefined) { this.sashes = null; }
            this.boundToWall = doorOrWindow.isBoundToWall();
            this.wallThickness = doorOrWindow.getWallThickness();
            this.wallDistance = doorOrWindow.getWallDistance();
            this.wallWidth = doorOrWindow.getWallWidth();
            this.wallLeft = doorOrWindow.getWallLeft();
            this.wallHeight = doorOrWindow.getWallHeight();
            this.wallTop = doorOrWindow.getWallTop();
            this.sashes = doorOrWindow.getSashes();
        }

        public reset() {
            super.reset();
            const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>this.getPieceOfFurniture();
            doorOrWindow.setBoundToWall(this.boundToWall);
            doorOrWindow.setWallThickness(this.wallThickness);
            doorOrWindow.setWallDistance(this.wallDistance);
            doorOrWindow.setWallWidth(this.wallWidth);
            doorOrWindow.setWallLeft(this.wallLeft);
            doorOrWindow.setWallHeight(this.wallHeight);
            doorOrWindow.setWallTop(this.wallTop);
            doorOrWindow.setSashes(this.sashes);
        }
    }
    ModifiedDoorOrWindow["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedDoorOrWindow";


    /**
     * Stores the current properties values of a modified light.
     * @param {HomeLight} light
     * @class
     * @extends HomeFurnitureController.ModifiedPieceOfFurniture
     */
    export class ModifiedLight extends HomeFurnitureController.ModifiedPieceOfFurniture {
        power: number;

        public constructor(light: HomeLight) {
            super(light);
            if (this.power === undefined) { this.power = 0; }
            this.power = light.getPower();
        }

        public reset() {
            super.reset();
            (<HomeLight>this.getPieceOfFurniture()).setPower(this.power);
        }
    }
    ModifiedLight["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedLight";


    /**
     * Stores the current properties values of a modified group.
     * @param {HomeFurnitureGroup} group
     * @class
     * @extends HomeFurnitureController.ModifiedPieceOfFurniture
     */
    export class ModifiedFurnitureGroup extends HomeFurnitureController.ModifiedPieceOfFurniture {
        groupFurnitureX: number[];

        groupFurnitureY: number[];

        groupFurnitureWidth: number[];

        groupFurnitureDepth: number[];

        groupFurnitureColor: number[];

        groupFurnitureTexture: HomeTexture[];

        groupFurnitureModelMaterials: HomeMaterial[][];

        groupFurnitureShininess: number[];

        public constructor(group: HomeFurnitureGroup) {
            super(group);
            if (this.groupFurnitureX === undefined) { this.groupFurnitureX = null; }
            if (this.groupFurnitureY === undefined) { this.groupFurnitureY = null; }
            if (this.groupFurnitureWidth === undefined) { this.groupFurnitureWidth = null; }
            if (this.groupFurnitureDepth === undefined) { this.groupFurnitureDepth = null; }
            if (this.groupFurnitureColor === undefined) { this.groupFurnitureColor = null; }
            if (this.groupFurnitureTexture === undefined) { this.groupFurnitureTexture = null; }
            if (this.groupFurnitureModelMaterials === undefined) { this.groupFurnitureModelMaterials = null; }
            if (this.groupFurnitureShininess === undefined) { this.groupFurnitureShininess = null; }
            const groupFurniture: Array<HomePieceOfFurniture> = this.getGroupFurniture(<HomeFurnitureGroup>group);
            this.groupFurnitureX = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureY = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureWidth = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureDepth = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureColor = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureTexture = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureShininess = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>groupFurniture.length));
            this.groupFurnitureModelMaterials = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>groupFurniture.length));
            for (let i: number = 0; i < /* size */(<number>groupFurniture.length); i++) {
                {
                    const groupPiece: HomePieceOfFurniture = /* get */groupFurniture[i];
                    this.groupFurnitureX[i] = groupPiece.getX();
                    this.groupFurnitureY[i] = groupPiece.getY();
                    this.groupFurnitureWidth[i] = groupPiece.getWidth();
                    this.groupFurnitureDepth[i] = groupPiece.getDepth();
                    this.groupFurnitureColor[i] = groupPiece.getColor();
                    this.groupFurnitureTexture[i] = groupPiece.getTexture();
                    this.groupFurnitureShininess[i] = groupPiece.getShininess();
                    this.groupFurnitureModelMaterials[i] = groupPiece.getModelMaterials();
                };
            }
        }

        public reset() {
            super.reset();
            const group: HomeFurnitureGroup = <HomeFurnitureGroup>this.getPieceOfFurniture();
            const groupFurniture: Array<HomePieceOfFurniture> = this.getGroupFurniture(group);
            for (let i: number = 0; i < /* size */(<number>groupFurniture.length); i++) {
                {
                    const groupPiece: HomePieceOfFurniture = /* get */groupFurniture[i];
                    if (group.isResizable()) {
                        groupPiece.setX(this.groupFurnitureX[i]);
                        groupPiece.setY(this.groupFurnitureY[i]);
                        groupPiece.setWidth(this.groupFurnitureWidth[i]);
                        groupPiece.setDepth(this.groupFurnitureDepth[i]);
                    }
                    if (group.isTexturable() && !(groupPiece != null && groupPiece instanceof <any>HomeFurnitureGroup)) {
                        groupPiece.setColor(this.groupFurnitureColor[i]);
                        groupPiece.setTexture(this.groupFurnitureTexture[i]);
                        groupPiece.setModelMaterials(this.groupFurnitureModelMaterials[i]);
                        groupPiece.setShininess(this.groupFurnitureShininess[i]);
                    }
                };
            }
        }

        /**
         * Returns all the children of the given <code>furnitureGroup</code>.
         * @param {HomeFurnitureGroup} furnitureGroup
         * @return {HomePieceOfFurniture[]}
         * @private
         */
        getGroupFurniture(furnitureGroup: HomeFurnitureGroup): Array<HomePieceOfFurniture> {
            const pieces: Array<HomePieceOfFurniture> = <any>([]);
            {
                let array = furnitureGroup.getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let piece = array[index];
                    {
                        /* add */(pieces.push(piece) > 0);
                        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(pieces, this.getGroupFurniture(<HomeFurnitureGroup>piece));
                        }
                    }
                }
            }
            return pieces;
        }
    }
    ModifiedFurnitureGroup["__class"] = "com.eteks.sweethome3d.viewcontroller.HomeFurnitureController.ModifiedFurnitureGroup";


    export class HomeFurnitureController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setPaint(HomeFurnitureController.FurniturePaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeFurnitureController$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setPaint(HomeFurnitureController.FurniturePaint.MODEL_MATERIALS);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeFurnitureController$2 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (this.__parent.getWidth() != null && this.__parent.getDepth() != null && this.__parent.getHeight() != null) {
                this.__parent.modelMaterialsController.setModelSize(this.__parent.getWidth(), this.__parent.getDepth(), this.__parent.getHeight());
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class HomeFurnitureController$3 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (this.__parent.getModelTransformations() != null) {
                this.__parent.modelMaterialsController.setModelTransformations(this.__parent.getModelTransformations());
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * Creates the controller of home furniture view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class FurnitureController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ furnitureView: View;

    /*private*/ leadSelectedPieceOfFurniture: HomePieceOfFurniture;

    public constructor(home?: any, preferences?: any, viewFactory?: any, contentManager?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureView === undefined) { this.furnitureView = null; }
            if (this.leadSelectedPieceOfFurniture === undefined) { this.leadSelectedPieceOfFurniture = null; }
            this.home = home;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.contentManager = contentManager;
            this.addModelListeners();
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && contentManager === undefined && undoSupport === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let contentManager: any = null;
                let undoSupport: any = null;
                if (this.home === undefined) { this.home = null; }
                if (this.preferences === undefined) { this.preferences = null; }
                if (this.viewFactory === undefined) { this.viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureView === undefined) { this.furnitureView = null; }
                if (this.leadSelectedPieceOfFurniture === undefined) { this.leadSelectedPieceOfFurniture = null; }
                this.home = home;
                this.preferences = preferences;
                this.viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                this.addModelListeners();
            }
            if (this.home === undefined) { this.home = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureView === undefined) { this.furnitureView = null; }
            if (this.leadSelectedPieceOfFurniture === undefined) { this.leadSelectedPieceOfFurniture = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): View {
        if (this.furnitureView == null) {
            this.furnitureView = this.viewFactory.createFurnitureView(this.home, this.preferences, this);
        }
        return this.furnitureView;
    }

    addModelListeners() {
        this.home.addSelectionListener(new FurnitureController.FurnitureController$0(this));
        const furnitureChangeListener: PropertyChangeListener = new FurnitureController.FurnitureController$1(this);
        {
            let array = this.home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    piece.addPropertyChangeListener(furnitureChangeListener);
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        {
                            let array1 = (<HomeFurnitureGroup>piece).getAllFurniture();
                            for (let index1 = 0; index1 < array1.length; index1++) {
                                let childPiece = array1[index1];
                                {
                                    childPiece.addPropertyChangeListener(furnitureChangeListener);
                                }
                            }
                        }
                    }
                }
            }
        }
        this.home.addFurnitureListener((ev: CollectionEvent<HomePieceOfFurniture>) => {
            const piece: HomePieceOfFurniture = ev.getItem();
            if (ev.getType() === CollectionEvent.Type.ADD) {
                piece.addPropertyChangeListener(furnitureChangeListener);
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.addPropertyChangeListener(furnitureChangeListener);
                            }
                        }
                    }
                }
            } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                piece.removePropertyChangeListener(furnitureChangeListener);
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.removePropertyChangeListener(furnitureChangeListener);
                            }
                        }
                    }
                }
            }
        });
    }

    public addFurniture$java_util_List(furniture: Array<HomePieceOfFurniture>) {
        this.addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, null, null, null);
    }

    public addFurniture$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture: Array<HomePieceOfFurniture>, beforePiece: HomePieceOfFurniture) {
        this.addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, null, null, beforePiece);
    }

    /**
     * Controls new furniture added to the given group.
     * Once added the furniture will be selected in view
     * and undo support will receive a new undoable edit.
     * @param {HomePieceOfFurniture[]} furniture the furniture to add.
     * @param {HomeFurnitureGroup} group     the group to which furniture will be added.
     */
    public addFurnitureToGroup(furniture: Array<HomePieceOfFurniture>, group: HomeFurnitureGroup) {
        if (group == null) {
            throw new IllegalArgumentException("Group shouldn\'t be null");
        }
        this.addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, null, group, null);
    }

    public addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture: Array<HomePieceOfFurniture>, furnitureLevels: Level[], group: HomeFurnitureGroup, beforePiece: HomePieceOfFurniture) {
        const oldBasePlanLocked: boolean = this.home.isBasePlanLocked();
        const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const newFurniture: HomePieceOfFurniture[] = /* toArray */furniture.slice(0);
        const newFurnitureIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>furniture.length));
        let insertIndex: number = group == null ? /* size */(<number>this.home.getFurniture().length) : /* size */(<number>group.getFurniture().length);
        if (beforePiece != null) {
            let parentFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
            group = FurnitureController.getPieceOfFurnitureGroup(beforePiece, null, parentFurniture);
            if (group != null) {
                parentFurniture = group.getFurniture();
            }
            insertIndex = parentFurniture.indexOf(beforePiece);
        }
        const newFurnitureGroups: HomeFurnitureGroup[] = group != null ? (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>furniture.length)) : null;
        let basePlanLocked: boolean = oldBasePlanLocked;
        let levelUpdated: boolean = group != null || furnitureLevels == null;
        for (let i: number = 0; i < newFurnitureIndex.length; i++) {
            {
                newFurnitureIndex[i] = insertIndex++;
                basePlanLocked = !this.isPieceOfFurniturePartOfBasePlan(newFurniture[i]) && basePlanLocked;
                if (furnitureLevels != null) {
                    levelUpdated = furnitureLevels[i] == null || levelUpdated;
                }
                if (newFurnitureGroups != null) {
                    newFurnitureGroups[i] = group;
                }
            };
        }
        const newFurnitureLevels: Level[] = levelUpdated ? null : furnitureLevels;
        const newBasePlanLocked: boolean = basePlanLocked;
        const furnitureLevel: Level = group != null ? group.getLevel() : this.home.getSelectedLevel();
        FurnitureController.doAddFurniture(this.home, newFurniture, newFurnitureGroups, newFurnitureIndex, furnitureLevel, newFurnitureLevels, newBasePlanLocked, false);
        if (this.undoSupport != null) {
            this.undoSupport.postEdit(new FurnitureController.FurnitureAdditionUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), oldBasePlanLocked, allLevelsSelection, newFurniture, newFurnitureIndex, newFurnitureGroups, newFurnitureLevels, furnitureLevel, newBasePlanLocked));
        }
    }

    public addFurniture(furniture?: any, furnitureLevels?: any, group?: any, beforePiece?: any) {
        if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((furnitureLevels != null && furnitureLevels instanceof <any>Array && (furnitureLevels.length == 0 || furnitureLevels[0] == null || (furnitureLevels[0] != null && furnitureLevels[0] instanceof <any>Level))) || furnitureLevels === null) && ((group != null && group instanceof <any>HomeFurnitureGroup) || group === null) && ((beforePiece != null && beforePiece instanceof <any>HomePieceOfFurniture) || beforePiece === null)) {
            return <any>this.addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, furnitureLevels, group, beforePiece);
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((furnitureLevels != null && furnitureLevels instanceof <any>HomePieceOfFurniture) || furnitureLevels === null) && group === undefined && beforePiece === undefined) {
            return <any>this.addFurniture$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, furnitureLevels);
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && furnitureLevels === undefined && group === undefined && beforePiece === undefined) {
            return <any>this.addFurniture$java_util_List(furniture);
        } else throw new Error('invalid overload');
    }

    static doAddFurniture(home: Home, furniture: HomePieceOfFurniture[], furnitureGroups: HomeFurnitureGroup[], furnitureIndex: number[], furnitureLevel: Level, furnitureLevels: Level[], basePlanLocked: boolean, allLevelsSelection: boolean) {
        for (let i: number = 0; i < furnitureIndex.length; i++) {
            {
                if (furnitureGroups != null && furnitureGroups[i] != null) {
                    home.addPieceOfFurnitureToGroup(furniture[i], furnitureGroups[i], furnitureIndex[i]);
                    furniture[i].setVisible(furnitureGroups[i].isVisible());
                } else {
                    home.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(furniture[i], furnitureIndex[i]);
                }
                furniture[i].setLevel(furnitureLevels != null ? furnitureLevels[i] : furnitureLevel);
            };
        }
        home.setBasePlanLocked(basePlanLocked);
        home.setSelectedItems(/* asList */furniture.slice(0));
        home.setAllLevelsSelection(allLevelsSelection);
    }

    /**
     * Controls the deletion of the current selected furniture in home.
     * Once the selected furniture is deleted, undo support will receive a new undoable edit.
     */
    public deleteSelection() {
        this.deleteFurniture(Home.getFurnitureSubList(this.home.getSelectedItems()));
    }

    /**
     * Deletes the furniture of <code>deletedFurniture</code> from home.
     * Once the selected furniture is deleted, undo support will receive a new undoable edit.
     * @param {HomePieceOfFurniture[]} deletedFurniture
     */
    public deleteFurniture(deletedFurniture: Array<HomePieceOfFurniture>) {
        const basePlanLocked: boolean = this.home.isBasePlanLocked();
        const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const homeFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
        deletedFurniture = <any>(deletedFurniture.slice(0));
        const homeGroups: Array<HomeFurnitureGroup> = <any>([]);
        FurnitureController.searchGroups(homeFurniture, homeGroups);
        let updated: boolean;
        do {
            {
                updated = false;
                for (let index = 0; index < homeGroups.length; index++) {
                    let group = homeGroups[index];
                    {
                        const groupFurniture: Array<HomePieceOfFurniture> = group.getFurniture();
                        if (/* containsAll */((a, r) => { for (let i = 0; i < r.length; i++) { if (a.indexOf(<any>r[i]) < 0) return false; } return true; })(deletedFurniture, groupFurniture)) {
                        /* removeAll */((a, r) => { let b = false; for (let i = 0; i < r.length; i++) { let ndx = a.indexOf(r[i]); if (ndx >= 0) { a.splice(ndx, 1); b = true; } } return b; })(deletedFurniture, groupFurniture);
                        /* add */(deletedFurniture.push(group) > 0);
                            updated = true;
                        }
                    }
                }
            }
        } while ((updated));
        const deletedFurnitureMap: any = <any>({});
        let deletedFurnitureCount: number = 0;
        for (let index = 0; index < deletedFurniture.length; index++) {
            let piece = deletedFurniture[index];
            {
                if (this.isPieceOfFurnitureDeletable(piece)) {
                    const group: HomeFurnitureGroup = FurnitureController.getPieceOfFurnitureGroup(piece, null, homeFurniture);
                    let sortedMap: any = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>deletedFurnitureMap, group);
                    if (sortedMap == null) {
                        sortedMap = <any>({});
                        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>deletedFurnitureMap, group, sortedMap);
                    }
                    if (group == null) {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, homeFurniture.indexOf(piece), piece);
                    } else {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, group.getFurniture().indexOf(piece), piece);
                    }
                    deletedFurnitureCount++;
                }
            }
        }
        const furniture: HomePieceOfFurniture[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(deletedFurnitureCount);
        const furnitureIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(furniture.length);
        const furnitureLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(furniture.length);
        const furnitureGroups: HomeFurnitureGroup[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(furniture.length);
        let i: number = 0;
        {
            let array = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>deletedFurnitureMap);
            for (let index = 0; index < array.length; index++) {
                let sortedMapEntry = array[index];
                {
                    {
                        let array1 = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>sortedMapEntry.getValue());
                        for (let index1 = 0; index1 < array1.length; index1++) {
                            let pieceEntry = array1[index1];
                            {
                                furniture[i] = pieceEntry.getValue();
                                furnitureIndex[i] = pieceEntry.getKey();
                                furnitureLevels[i] = furniture[i].getLevel();
                                furnitureGroups[i++] = sortedMapEntry.getKey();
                            }
                        }
                    }
                }
            }
        }
        FurnitureController.doDeleteFurniture(this.home, furniture, basePlanLocked, false);
        if (this.undoSupport != null) {
            this.undoSupport.postEdit(new FurnitureController.FurnitureDeletionUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), basePlanLocked, allLevelsSelection, furniture, furnitureIndex, furnitureGroups, furnitureLevels));
        }
    }

    static doDeleteFurniture(home: Home, furniture: HomePieceOfFurniture[], basePlanLocked: boolean, allLevelsSelection: boolean) {
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                home.deletePieceOfFurniture(piece);
            }
        }
        home.setBasePlanLocked(basePlanLocked);
        home.setAllLevelsSelection(allLevelsSelection);
    }

    /**
     * Searches all the groups among furniture and its children.
     * @param {HomePieceOfFurniture[]} furniture
     * @param {HomeFurnitureGroup[]} groups
     * @private
     */
    static searchGroups(furniture: Array<HomePieceOfFurniture>, groups: Array<HomeFurnitureGroup>) {
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    /* add */(groups.push(<HomeFurnitureGroup>piece) > 0);
                    FurnitureController.searchGroups((<HomeFurnitureGroup>piece).getFurniture(), groups);
                }
            }
        }
    }

    /**
     * Returns the furniture group that contains the given <code>piece</code> or <code>null</code> if it can't be found.
     * @param {HomePieceOfFurniture} piece
     * @param {HomeFurnitureGroup} furnitureGroup
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomeFurnitureGroup}
     * @private
     */
    static getPieceOfFurnitureGroup(piece: HomePieceOfFurniture, furnitureGroup: HomeFurnitureGroup, furniture: Array<HomePieceOfFurniture>): HomeFurnitureGroup {
        for (let index = 0; index < furniture.length; index++) {
            let homePiece = furniture[index];
            {
                if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(homePiece, piece))) {
                    return furnitureGroup;
                } else if (homePiece != null && homePiece instanceof <any>HomeFurnitureGroup) {
                    const group: HomeFurnitureGroup = FurnitureController.getPieceOfFurnitureGroup(piece, <HomeFurnitureGroup>homePiece, (<HomeFurnitureGroup>homePiece).getFurniture());
                    if (group != null) {
                        return group;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Reorders the selected furniture in home to place it before the given piece.
     * @param {HomePieceOfFurniture} beforePiece
     */
    public moveSelectedFurnitureBefore(beforePiece: HomePieceOfFurniture) {
        const movedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(this.home.getSelectedItems());
        if (!/* isEmpty */(movedFurniture.length == 0)) {
            const furnitureLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>movedFurniture.length));
            for (let i: number = 0; i < furnitureLevels.length; i++) {
                {
                    furnitureLevels[i] = /* get */movedFurniture[i].getLevel();
                };
            }
            this.undoSupport.beginUpdate();
            this.deleteFurniture(movedFurniture);
            this.addFurniture$java_util_List$com_eteks_sweethome3d_model_Level_A$com_eteks_sweethome3d_model_HomeFurnitureGroup$com_eteks_sweethome3d_model_HomePieceOfFurniture(movedFurniture, furnitureLevels, null, beforePiece);
            this.undoSupport.postEdit(new LocalizedUndoableEdit(this.preferences, FurnitureController, "undoReorderName"));
            this.undoSupport.endUpdate();
        }
    }

    public setSelectedFurniture$java_util_List(selectedFurniture: Array<HomePieceOfFurniture>) {
        this.setSelectedFurniture$java_util_List$boolean(selectedFurniture, true);
    }

    public setSelectedFurniture$java_util_List$boolean(selectedFurniture: Array<HomePieceOfFurniture>, resetSelection: boolean) {
        if (this.home.isBasePlanLocked()) {
            selectedFurniture = this.getFurnitureNotPartOfBasePlan(selectedFurniture);
        }
        if (resetSelection) {
            this.home.setSelectedItems(selectedFurniture);
            this.home.setAllLevelsSelection(false);
        } else {
            const selectedItems: Array<Selectable> = <any>(this.home.getSelectedItems().slice(0));
            selectedFurniture = <any>(selectedFurniture.slice(0));
            for (let i: number = /* size */(<number>selectedItems.length) - 1; i >= 0; i--) {
                {
                    const item: Selectable = /* get */selectedItems[i];
                    if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        const index: number = selectedFurniture.indexOf(<HomePieceOfFurniture><any>item);
                        if (index >= 0) {
                        /* remove */selectedFurniture.splice(index, 1)[0];
                        } else {
                        /* remove */selectedItems.splice(i, 1)[0];
                        }
                    }
                };
            }
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(selectedItems, selectedFurniture);
            this.home.setSelectedItems(selectedItems);
        }
    }

    /**
     * Updates the selected furniture in home, unselecting all other kinds of selected objects
     * when <code>resetSelection</code> is <code>true</code>.
     * @param {HomePieceOfFurniture[]} selectedFurniture
     * @param {boolean} resetSelection
     */
    public setSelectedFurniture(selectedFurniture?: any, resetSelection?: any) {
        if (((selectedFurniture != null && (selectedFurniture instanceof Array)) || selectedFurniture === null) && ((typeof resetSelection === 'boolean') || resetSelection === null)) {
            return <any>this.setSelectedFurniture$java_util_List$boolean(selectedFurniture, resetSelection);
        } else if (((selectedFurniture != null && (selectedFurniture instanceof Array)) || selectedFurniture === null) && resetSelection === undefined) {
            return <any>this.setSelectedFurniture$java_util_List(selectedFurniture);
        } else throw new Error('invalid overload');
    }

    /**
     * Selects all furniture in home.
     */
    public selectAll() {
        this.setSelectedFurniture$java_util_List(this.home.getFurniture());
    }

    /**
     * Returns <code>true</code> if the given <code>piece</code> isn't movable.
     * @param {HomePieceOfFurniture} piece
     * @return {boolean}
     */
    isPieceOfFurniturePartOfBasePlan(piece: HomePieceOfFurniture): boolean {
        return !piece.isMovable() || piece.isDoorOrWindow();
    }

    /**
     * Returns <code>true</code> if the given <code>piece</code> may be moved.
     * Default implementation always returns <code>true</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {boolean}
     */
    isPieceOfFurnitureMovable(piece: HomePieceOfFurniture): boolean {
        return true;
    }

    /**
     * Returns <code>true</code> if the given <code>piece</code> may be deleted.
     * Default implementation always returns <code>true</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {boolean}
     */
    isPieceOfFurnitureDeletable(piece: HomePieceOfFurniture): boolean {
        return true;
    }

    /**
     * Returns a new home piece of furniture created from an other given <code>piece</code> of furniture.
     * @param {Object} piece
     * @return {HomePieceOfFurniture}
     */
    public createHomePieceOfFurniture(piece: PieceOfFurniture): HomePieceOfFurniture {
        const properties: Array<string> = <any>(piece.getPropertyNames().slice(0));
        for (let i: number = /* size */(<number>properties.length) - 1; i >= 0; i--) {
            {
                const property: string = /* get */properties[i];
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(property, "modelPresetTransformationsName_") || /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(property, "modelPresetTransformations_")) {
                /* remove */properties.splice(i, 1)[0];
                }
            };
        }
        const copiedProperties: string[] = /* toArray */properties.slice(0);
        if (piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.DoorOrWindow") >= 0)) {
            return new HomeDoorOrWindow(<DoorOrWindow><any>piece, copiedProperties);
        } else if (piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Light") >= 0)) {
            return new HomeLight(<Light><any>piece, copiedProperties);
        } else if (piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.ShelfUnit") >= 0)) {
            return new HomeShelfUnit(<ShelfUnit><any>piece, copiedProperties);
        } else {
            return new HomePieceOfFurniture(piece, copiedProperties);
        }
    }

    /**
     * Returns the furniture among the given list that are not part of the base plan.
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    getFurnitureNotPartOfBasePlan(furniture: Array<HomePieceOfFurniture>): Array<HomePieceOfFurniture> {
        const furnitureNotPartOfBasePlan: Array<HomePieceOfFurniture> = <any>([]);
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (!this.isPieceOfFurniturePartOfBasePlan(piece)) {
                    /* add */(furnitureNotPartOfBasePlan.push(piece) > 0);
                }
            }
        }
        return furnitureNotPartOfBasePlan;
    }

    public toggleFurnitureSort$java_lang_String(furniturePropertyName: string) {
        if (furniturePropertyName === this.home.getFurnitureSortedPropertyName()) {
            this.home.setFurnitureSortedPropertyName(null);
        } else {
            this.home.setFurnitureSortedPropertyName(furniturePropertyName);
        }
    }

    /**
     * Uses <code>furniturePropertyName</code> to sort home furniture
     * or cancels home furniture sort if home is already sorted on <code>furnitureProperty</code>
     * @param {string} furniturePropertyName a property of {@link HomePieceOfFurniture} class.
     */
    public toggleFurnitureSort(furniturePropertyName?: any) {
        if (((typeof furniturePropertyName === 'string') || furniturePropertyName === null)) {
            return <any>this.toggleFurnitureSort$java_lang_String(furniturePropertyName);
        } else if (((typeof furniturePropertyName === 'number') || furniturePropertyName === null)) {
            return <any>this.toggleFurnitureSort$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furniturePropertyName);
        } else throw new Error('invalid overload');
    }

    public toggleFurnitureSort$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furnitureProperty: any) {
        if (/* equals */(furnitureProperty == this.home.getFurnitureSortedProperty())) {
            this.home.setFurnitureSortedProperty(null);
        } else {
            this.home.setFurnitureSortedProperty(furnitureProperty);
        }
    }

    /**
     * Toggles home furniture sort order.
     */
    public toggleFurnitureSortOrder() {
        this.home.setFurnitureDescendingSorted(!this.home.isFurnitureDescendingSorted());
    }

    public sortFurniture$java_lang_String(furniturePropertyName: string) {
        const oldPropertyName: string = this.home.getFurnitureSortedPropertyName();
        const oldDescending: boolean = this.home.isFurnitureDescendingSorted();
        let descending: boolean = false;
        if (furniturePropertyName === oldPropertyName) {
            if (oldDescending) {
                furniturePropertyName = null;
            } else {
                descending = true;
            }
        }
        this.home.setFurnitureSortedPropertyName(furniturePropertyName);
        this.home.setFurnitureDescendingSorted(descending);
    }

    /**
     * Controls the sort of the furniture in home. If home furniture isn't sorted
     * or is sorted on an other property, it will be sorted on the given
     * <code>furnitureProperty</code> in ascending order. If home furniture is already
     * sorted on the given <code>furnitureProperty</code>, it will be sorted in descending
     * order, if the sort is in ascending order, otherwise it won't be sorted at all
     * and home furniture will be listed in insertion order.
     * @param {string} furniturePropertyName  the furniture property on which the view wants
     * to sort the furniture it displays.
     */
    public sortFurniture(furniturePropertyName?: any) {
        if (((typeof furniturePropertyName === 'string') || furniturePropertyName === null)) {
            return <any>this.sortFurniture$java_lang_String(furniturePropertyName);
        } else if (((typeof furniturePropertyName === 'number') || furniturePropertyName === null)) {
            return <any>this.sortFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furniturePropertyName);
        } else throw new Error('invalid overload');
    }

    public sortFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furnitureProperty: any) {
        const oldProperty: any = this.home.getFurnitureSortedProperty();
        const oldDescending: boolean = this.home.isFurnitureDescendingSorted();
        let descending: boolean = false;
        if (/* equals */(furnitureProperty == oldProperty)) {
            if (oldDescending) {
                furnitureProperty = null;
            } else {
                descending = true;
            }
        }
        this.home.setFurnitureSortedProperty(furnitureProperty);
        this.home.setFurnitureDescendingSorted(descending);
    }

    /**
     * Updates the furniture visible properties in home.
     * @param {string[]} furnitureVisiblePropertyNames
     */
    public setFurnitureVisiblePropertyNames(furnitureVisiblePropertyNames: Array<string>) {
        this.home.setFurnitureVisiblePropertyNames(furnitureVisiblePropertyNames);
    }

    /**
     * Updates the furniture visible properties in home.
     * @deprecated {@link #setFurnitureVisibleProperties(List<HomePieceOfFurniture.SortableProperty>)}
     * should be replaced by calls to {@link #setFurnitureVisiblePropertyNames(List<String>)}
     * to allow displaying additional properties.
     * @param {string[]} furnitureVisibleProperties
     */
    public setFurnitureVisibleProperties(furnitureVisibleProperties: Array<any>) {
        this.home.setFurnitureVisibleProperties(furnitureVisibleProperties);
    }

    public toggleFurnitureVisibleProperty$java_lang_String(furniturePropertyName: string) {
        const furnitureVisiblePropertyNames: Array<string> = <any>(this.home.getFurnitureVisiblePropertyNames().slice(0));
        if (/* contains */(furnitureVisiblePropertyNames.indexOf(<any>(furniturePropertyName)) >= 0)) {
            /* remove */(a => { let index = a.indexOf(furniturePropertyName); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(furnitureVisiblePropertyNames);
            if (/* isEmpty */(furnitureVisiblePropertyNames.length == 0)) {
                /* add */(furnitureVisiblePropertyNames.push(/* name */"NAME") > 0);
            }
        } else {
            const propertiesOrder: Array<string> = <any>(/* asList */[/* name */"CATALOG_ID", /* name */"NAME", /* name */"DESCRIPTION", /* name */"CREATOR", /* name */"LICENSE", /* name */"WIDTH", /* name */"DEPTH", /* name */"HEIGHT", /* name */"X", /* name */"Y", /* name */"ELEVATION", /* name */"ANGLE", /* name */"LEVEL", /* name */"MODEL_SIZE", /* name */"COLOR", /* name */"TEXTURE", /* name */"MOVABLE", /* name */"DOOR_OR_WINDOW", /* name */"VISIBLE", /* name */"PRICE", /* name */"VALUE_ADDED_TAX_PERCENTAGE", /* name */"VALUE_ADDED_TAX", /* name */"PRICE_VALUE_ADDED_TAX_INCLUDED"].slice(0).slice(0));
            {
                let array = this.home.getFurnitureAdditionalProperties();
                for (let index = 0; index < array.length; index++) {
                    let property = array[index];
                    {
                        /* add */(propertiesOrder.push(property.getName()) > 0);
                    }
                }
            }
            let propertyIndex: number = propertiesOrder.indexOf(furniturePropertyName) - 1;
            if (propertyIndex > 0) {
                while ((propertyIndex > 0)) {
                    {
                        const visiblePropertyIndex: number = furnitureVisiblePropertyNames.indexOf(/* get */propertiesOrder[propertyIndex]);
                        if (visiblePropertyIndex >= 0) {
                            propertyIndex = visiblePropertyIndex + 1;
                            break;
                        } else {
                            propertyIndex--;
                        }
                    }
                };
            }
            if (propertyIndex < 0) {
                propertyIndex = 0;
            }
            /* add */furnitureVisiblePropertyNames.splice(propertyIndex, 0, furniturePropertyName);
        }
        this.home.setFurnitureVisiblePropertyNames(furnitureVisiblePropertyNames);
    }

    /**
     * Toggles furniture property visibility in home.
     * @param {string} furniturePropertyName
     */
    public toggleFurnitureVisibleProperty(furniturePropertyName?: any) {
        if (((typeof furniturePropertyName === 'string') || furniturePropertyName === null)) {
            return <any>this.toggleFurnitureVisibleProperty$java_lang_String(furniturePropertyName);
        } else if (((typeof furniturePropertyName === 'number') || furniturePropertyName === null)) {
            return <any>this.toggleFurnitureVisibleProperty$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furniturePropertyName);
        } else throw new Error('invalid overload');
    }

    public toggleFurnitureVisibleProperty$com_eteks_sweethome3d_model_HomePieceOfFurniture_SortableProperty(furnitureProperty: any) {
        this.toggleFurnitureVisibleProperty$java_lang_String(/* name */furnitureProperty);
    }

    /**
     * Controls the modification of selected furniture.
     */
    public modifySelectedFurniture() {
        if (!/* isEmpty */(Home.getFurnitureSubList(this.home.getSelectedItems()).length == 0)) {
            new HomeFurnitureController(this.home, this.preferences, this.viewFactory, this.contentManager, this.undoSupport).displayView(this.getView());
        }
    }

    /**
     * Controls the modification of the visibility of the selected piece of furniture.
     */
    public toggleSelectedFurnitureVisibility() {
        if (/* size */(<number>Home.getFurnitureSubList(this.home.getSelectedItems()).length) === 1) {
            const controller: HomeFurnitureController = new HomeFurnitureController(this.home, this.preferences, this.viewFactory, this.contentManager, this.undoSupport);
            controller.setVisible(!controller.getVisible());
            controller.modifyFurniture();
        }
    }

    /**
     * Groups the selected furniture as one piece of furniture.
     */
    public groupSelectedFurniture() {
        const selectedFurniture: HomePieceOfFurniture[] = this.getMovableSelectedFurniture();
        if (selectedFurniture.length > 0) {
            const basePlanLocked: boolean = this.home.isBasePlanLocked();
            const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const homeFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
            const groupedFurnitureMap: any = <any>({});
            let groupedFurnitureCount: number = 0;
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    const group: HomeFurnitureGroup = FurnitureController.getPieceOfFurnitureGroup(piece, null, homeFurniture);
                    let sortedMap: any = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>groupedFurnitureMap, group);
                    if (sortedMap == null) {
                        sortedMap = <any>({});
                        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>groupedFurnitureMap, group, sortedMap);
                    }
                    if (group == null) {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, homeFurniture.indexOf(piece), piece);
                    } else {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, group.getFurniture().indexOf(piece), piece);
                    }
                    groupedFurnitureCount++;
                }
            }
            const groupedPieces: HomePieceOfFurniture[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groupedFurnitureCount);
            const groupedPiecesIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(groupedPieces.length);
            const groupedPiecesLevel: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groupedPieces.length);
            const groupedPiecesElevation: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(groupedPieces.length);
            const groupedPiecesVisible: boolean[] = (s => { let a = []; while (s-- > 0) a.push(false); return a; })(groupedPieces.length);
            const groupedPiecesGroups: HomeFurnitureGroup[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groupedPieces.length);
            let minLevel: Level = this.home.getSelectedLevel();
            let i: number = 0;
            {
                let array = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>groupedFurnitureMap);
                for (let index = 0; index < array.length; index++) {
                    let sortedMapEntry = array[index];
                    {
                        {
                            let array1 = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>sortedMapEntry.getValue());
                            for (let index1 = 0; index1 < array1.length; index1++) {
                                let pieceEntry = array1[index1];
                                {
                                    const piece: HomePieceOfFurniture = pieceEntry.getValue();
                                    groupedPieces[i] = piece;
                                    groupedPiecesIndex[i] = pieceEntry.getKey();
                                    groupedPiecesLevel[i] = piece.getLevel();
                                    groupedPiecesElevation[i] = piece.getElevation();
                                    groupedPiecesVisible[i] = piece.isVisible();
                                    groupedPiecesGroups[i] = sortedMapEntry.getKey();
                                    if (groupedPiecesLevel[i] != null) {
                                        if (minLevel == null || groupedPiecesLevel[i].getElevation() < minLevel.getElevation()) {
                                            minLevel = groupedPiecesLevel[i];
                                        }
                                    }
                                    i++;
                                }
                            }
                        }
                    }
                }
            }
            let newGroup: HomeFurnitureGroup;
            const groupedFurniture: Array<HomePieceOfFurniture> = /* asList */groupedPieces.slice(0);
            if (groupedFurniture.indexOf(this.leadSelectedPieceOfFurniture) > 0) {
                newGroup = this.createHomeFurnitureGroup$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(groupedFurniture, this.leadSelectedPieceOfFurniture);
            } else {
                newGroup = this.createHomeFurnitureGroup$java_util_List(groupedFurniture);
            }
            const groupPiecesNewElevation: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(groupedPieces.length);
            i = 0;
            for (let index = 0; index < groupedPieces.length; index++) {
                let piece = groupedPieces[index];
                {
                    groupPiecesNewElevation[i++] = piece.getElevation();
                }
            }
            const homeSortedMap: any = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>groupedFurnitureMap, null);
            const groupIndex: number = homeSortedMap != null ? /* lastKey */(function (map) { return map.entries[map.entries.length - 1].key; })(homeSortedMap) + 1 - groupedPieces.length : /* size */(<number>homeFurniture.length);
            const movable: boolean = newGroup.isMovable();
            const groupLevel: Level = minLevel;
            FurnitureController.doGroupFurniture(this.home, groupedPieces, [newGroup], null, [groupIndex], [groupLevel], basePlanLocked, false);
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(new FurnitureController.FurnitureGroupingUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), basePlanLocked, allLevelsSelection, groupedPieces, groupedPiecesIndex, groupedPiecesGroups, groupedPiecesLevel, groupedPiecesElevation, groupedPiecesVisible, newGroup, groupIndex, groupLevel, groupPiecesNewElevation, movable));
            }
        }
    }

    createHomeFurnitureGroup$java_util_List(furniture: Array<HomePieceOfFurniture>): HomeFurnitureGroup {
        return this.createHomeFurnitureGroup$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, /* get */furniture[0]);
    }

    public createHomeFurnitureGroup$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture: Array<HomePieceOfFurniture>, leadingPiece: HomePieceOfFurniture): HomeFurnitureGroup {
        const furnitureGroupName: string = this.preferences.getLocalizedString(FurnitureController, "groupName", FurnitureController.getFurnitureGroupCount(this.home.getFurniture()) + 1);
        const furnitureGroup: HomeFurnitureGroup = new HomeFurnitureGroup(furniture, leadingPiece, furnitureGroupName);
        return furnitureGroup;
    }

    /**
     * Returns a new furniture group for the given furniture list.
     * @param {HomePieceOfFurniture[]} furniture
     * @param {HomePieceOfFurniture} leadingPiece
     * @return {HomeFurnitureGroup}
     */
    public createHomeFurnitureGroup(furniture?: any, leadingPiece?: any): HomeFurnitureGroup {
        if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((leadingPiece != null && leadingPiece instanceof <any>HomePieceOfFurniture) || leadingPiece === null)) {
            return <any>this.createHomeFurnitureGroup$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, leadingPiece);
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && leadingPiece === undefined) {
            return <any>this.createHomeFurnitureGroup$java_util_List(furniture);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the count of furniture groups among the given list.
     * @param {HomePieceOfFurniture[]} furniture
     * @return {number}
     * @private
     */
    static getFurnitureGroupCount(furniture: Array<HomePieceOfFurniture>): number {
        let i: number = 0;
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    i += 1 + FurnitureController.getFurnitureGroupCount((<HomeFurnitureGroup>piece).getFurniture());
                }
            }
        }
        return i;
    }

    static doGroupFurniture(home: Home, groupedPieces: HomePieceOfFurniture[], groups: HomeFurnitureGroup[], groupsGroups: HomeFurnitureGroup[], groupsIndex: number[], groupsLevels: Level[], basePlanLocked: boolean, allLevelsSelection: boolean) {
        FurnitureController.doDeleteFurniture(home, groupedPieces, basePlanLocked, allLevelsSelection);
        FurnitureController.doAddFurniture(home, groups, groupsGroups, groupsIndex, null, groupsLevels, basePlanLocked, allLevelsSelection);
    }

    static doUngroupFurniture(home: Home, groups: HomeFurnitureGroup[], ungroupedPieces: HomePieceOfFurniture[], ungroupedPiecesGroups: HomeFurnitureGroup[], ungroupedPiecesIndex: number[], ungroupedPiecesLevels: Level[], basePlanLocked: boolean, allLevelsSelection: boolean) {
        FurnitureController.doDeleteFurniture(home, groups, basePlanLocked, allLevelsSelection);
        FurnitureController.doAddFurniture(home, ungroupedPieces, ungroupedPiecesGroups, ungroupedPiecesIndex, null, ungroupedPiecesLevels, basePlanLocked, allLevelsSelection);
    }

    /**
     * Ungroups the selected groups of furniture.
     */
    public ungroupSelectedFurniture() {
        const movableSelectedFurnitureGroups: Array<HomeFurnitureGroup> = <any>([]);
        {
            let array = this.home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>HomeFurnitureGroup) {
                        const group: HomeFurnitureGroup = <HomeFurnitureGroup><any>item;
                        if (this.isPieceOfFurnitureMovable(group)) {
                            /* add */(movableSelectedFurnitureGroups.push(group) > 0);
                        }
                    }
                }
            }
        }
        if (!/* isEmpty */(movableSelectedFurnitureGroups.length == 0)) {
            const homeFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
            const oldBasePlanLocked: boolean = this.home.isBasePlanLocked();
            const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const groupsMap: any = <any>({});
            let groupsCount: number = 0;
            for (let index = 0; index < movableSelectedFurnitureGroups.length; index++) {
                let piece = movableSelectedFurnitureGroups[index];
                {
                    const groupGroup: HomeFurnitureGroup = FurnitureController.getPieceOfFurnitureGroup(piece, null, homeFurniture);
                    let sortedMap: any = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>groupsMap, groupGroup);
                    if (sortedMap == null) {
                        sortedMap = <any>({});
                        /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>groupsMap, groupGroup, sortedMap);
                    }
                    if (groupGroup == null) {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, homeFurniture.indexOf(piece), piece);
                    } else {
                        /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, groupGroup.getFurniture().indexOf(piece), piece);
                    }
                    groupsCount++;
                }
            }
            const groups: HomeFurnitureGroup[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groupsCount);
            const groupsGroups: HomeFurnitureGroup[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groups.length);
            const groupsIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(groups.length);
            const groupsLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(groups.length);
            let i: number = 0;
            const ungroupedPiecesList: Array<HomePieceOfFurniture> = <any>([]);
            const ungroupedPiecesIndexList: Array<number> = <any>([]);
            const ungroupedPiecesGroupsList: Array<HomeFurnitureGroup> = <any>([]);
            {
                let array = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>groupsMap);
                for (let index = 0; index < array.length; index++) {
                    let sortedMapEntry = array[index];
                    {
                        const sortedMap: any = sortedMapEntry.getValue();
                        let endIndex: number = /* lastKey */(function (map) { return map.entries[map.entries.length - 1].key; })(sortedMap) + 1 - /* size */((m) => { if (m.entries == null) m.entries = []; return m.entries.length; })(<any>sortedMap);
                        {
                            let array1 = /* entrySet */((m) => { if (m.entries == null) m.entries = []; return m.entries; })(<any>sortedMap);
                            for (let index1 = 0; index1 < array1.length; index1++) {
                                let groupEntry = array1[index1];
                                {
                                    const group: HomeFurnitureGroup = groupEntry.getValue();
                                    groups[i] = group;
                                    groupsGroups[i] = sortedMapEntry.getKey();
                                    groupsIndex[i] = groupEntry.getKey();
                                    groupsLevels[i++] = group.getLevel();
                                    {
                                        let array2 = group.getFurniture();
                                        for (let index2 = 0; index2 < array2.length; index2++) {
                                            let groupPiece = array2[index2];
                                            {
                                                /* add */(ungroupedPiecesList.push(groupPiece) > 0);
                                                /* add */(ungroupedPiecesGroupsList.push(sortedMapEntry.getKey()) > 0);
                                                /* add */(ungroupedPiecesIndexList.push(endIndex++) > 0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            const ungroupedPieces: HomePieceOfFurniture[] = /* toArray */ungroupedPiecesList.slice(0);
            const ungroupedPiecesGroups: HomeFurnitureGroup[] = /* toArray */ungroupedPiecesGroupsList.slice(0);
            const ungroupedPiecesIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(ungroupedPieces.length);
            const ungroupedPiecesLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(ungroupedPieces.length);
            let basePlanLocked: boolean = oldBasePlanLocked;
            for (i = 0; i < ungroupedPieces.length; i++) {
                {
                    ungroupedPiecesIndex[i] = /* get */ungroupedPiecesIndexList[i];
                    ungroupedPiecesLevels[i] = ungroupedPieces[i].getLevel();
                    basePlanLocked = !this.isPieceOfFurniturePartOfBasePlan(ungroupedPieces[i]) && basePlanLocked;
                };
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            FurnitureController.doUngroupFurniture(this.home, groups, ungroupedPieces, ungroupedPiecesGroups, ungroupedPiecesIndex, ungroupedPiecesLevels, newBasePlanLocked, false);
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(new FurnitureController.FurnitureUngroupingUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), oldBasePlanLocked, allLevelsSelection, groups, groupsIndex, groupsGroups, groupsLevels, ungroupedPieces, ungroupedPiecesIndex, ungroupedPiecesGroups, ungroupedPiecesLevels, newBasePlanLocked));
            }
        }
    }

    public importFurniture$() {
        new ImportedFurnitureWizardController(this.home, this.preferences, this, this.viewFactory, this.contentManager, this.undoSupport).displayView(this.getView());
    }

    public importFurniture$java_lang_String(modelName: string) {
        new ImportedFurnitureWizardController(this.home, modelName, this.preferences, this, this.viewFactory, this.contentManager, this.undoSupport).displayView(this.getView());
    }

    /**
     * Displays the wizard that helps to import furniture to home with a
     * given model name.
     * @param {string} modelName
     */
    public importFurniture(modelName?: any) {
        if (((typeof modelName === 'string') || modelName === null)) {
            return <any>this.importFurniture$java_lang_String(modelName);
        } else if (modelName === undefined) {
            return <any>this.importFurniture$();
        } else throw new Error('invalid overload');
    }

    /**
     * Controls the alignment of selected furniture on top of the first selected piece.
     */
    public alignSelectedFurnitureOnTop() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureTopAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on bottom of the first selected piece.
     */
    public alignSelectedFurnitureOnBottom() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureBottomAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on left of the first selected piece.
     */
    public alignSelectedFurnitureOnLeft() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureLeftAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on right of the first selected piece.
     */
    public alignSelectedFurnitureOnRight() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureRightAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on the front side of the first selected piece.
     */
    public alignSelectedFurnitureOnFrontSide() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureFrontSideAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on the back side of the first selected piece.
     */
    public alignSelectedFurnitureOnBackSide() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureBackSideAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on the left side of the first selected piece.
     */
    public alignSelectedFurnitureOnLeftSide() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureLeftSideAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on the right side of the first selected piece.
     */
    public alignSelectedFurnitureOnRightSide() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureRightSideAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Controls the alignment of selected furniture on the sides of the first selected piece.
     */
    public alignSelectedFurnitureSideBySide() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        this.alignSelectedFurniture(new FurnitureController.FurnitureSideBySideAlignmentUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), this.getMovableSelectedFurniture(), this.leadSelectedPieceOfFurniture));
    }

    /**
     * Returns a list containing aligned furniture and lead piece sorted in the order of their distribution along
     * a line orthogonal to the given axis.
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} furniture
     * @param {HomePieceOfFurniture} leadPiece
     * @param {java.awt.geom.Line2D} orthogonalAxis
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    static sortFurniture(furniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture, orthogonalAxis: java.awt.geom.Line2D): Array<HomePieceOfFurniture> {
        const sortedFurniture: Array<HomePieceOfFurniture> = <any>([]);
        if (leadPiece != null) {
            /* add */(sortedFurniture.push(leadPiece) > 0);
        }
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(sortedFurniture, /* asList */furniture.slice(0));
        /* sort */((l, c) => { if ((<any>c).compare) l.sort((e1, e2) => (<any>c).compare(e1, e2)); else l.sort(<any>c); })(sortedFurniture, new FurnitureController.FurnitureController$2(orthogonalAxis));
        return sortedFurniture;
    }

    /**
     * Aligns the given <code>piece</code> along the front or back side of the lead piece and its left or right side
     * at a distance equal to <code>sideDistance</code>, and returns the width of the bounding box of
     * the <code>piece</code> along the back side axis.
     * @param {HomePieceOfFurniture} piece
     * @param {HomePieceOfFurniture} leadPiece
     * @param {java.awt.geom.Line2D} frontOrBackLine
     * @param {boolean} frontLine
     * @param {java.awt.geom.Line2D} centerLine
     * @param {number} sideDistance
     * @return {number}
     * @private
     */
    static alignPieceOfFurnitureAlongSides(piece: HomePieceOfFurniture, leadPiece: HomePieceOfFurniture, frontOrBackLine: java.awt.geom.Line2D, frontLine: boolean, centerLine: java.awt.geom.Line2D, sideDistance: number): number {
        let distance: number = frontOrBackLine.relativeCCW(piece.getX(), piece.getY()) * frontOrBackLine.ptLineDist(piece.getX(), piece.getY()) + FurnitureController.getPieceBoundingRectangleHeight(piece, -leadPiece.getAngle()) / 2;
        if (frontLine) {
            distance = -distance;
        }
        const sinLeadPieceAngle: number = Math.sin(leadPiece.getAngle());
        const cosLeadPieceAngle: number = Math.cos(leadPiece.getAngle());
        let deltaX: number = <number>(-distance * sinLeadPieceAngle);
        let deltaY: number = <number>(distance * cosLeadPieceAngle);
        const rotatedBoundingBoxWidth: number = FurnitureController.getPieceBoundingRectangleWidth(piece, -leadPiece.getAngle());
        if (centerLine != null) {
            let location: number = centerLine.relativeCCW(piece.getX(), piece.getY());
            if (location === 0) {
                location = frontLine ? 1 : -1;
            }
            distance = sideDistance + location * (centerLine.ptLineDist(piece.getX(), piece.getY()) - rotatedBoundingBoxWidth / 2);
            deltaX += <number>(distance * cosLeadPieceAngle);
            deltaY += <number>(distance * sinLeadPieceAngle);
        }
        piece.move(deltaX, deltaY);
        return rotatedBoundingBoxWidth;
    }

    /**
     * Aligns the given <code>piece</code> along the left or right side of the lead piece.
     * @param {HomePieceOfFurniture} piece
     * @param {HomePieceOfFurniture} leadPiece
     * @param {java.awt.geom.Line2D} leftOrRightLine
     * @param {boolean} rightLine
     * @private
     */
    static alignPieceOfFurnitureAlongLeftOrRightSides(piece: HomePieceOfFurniture, leadPiece: HomePieceOfFurniture, leftOrRightLine: java.awt.geom.Line2D, rightLine: boolean) {
        let distance: number = leftOrRightLine.relativeCCW(piece.getX(), piece.getY()) * leftOrRightLine.ptLineDist(piece.getX(), piece.getY()) + FurnitureController.getPieceBoundingRectangleWidth(piece, -leadPiece.getAngle()) / 2;
        if (rightLine) {
            distance = -distance;
        }
        piece.move(<number>(distance * Math.cos(leadPiece.getAngle())), <number>(distance * Math.sin(leadPiece.getAngle())));
    }

    /**
     * Returns the bounding box width of the given piece when it's rotated of an additional angle.
     * @param {HomePieceOfFurniture} piece
     * @param {number} additionalAngle
     * @return {number}
     * @private
     */
    static getPieceBoundingRectangleWidth(piece: HomePieceOfFurniture, additionalAngle: number): number {
        return Math.abs(piece.getWidthInPlan() * Math.cos(additionalAngle + piece.getAngle())) + Math.abs(piece.getDepthInPlan() * Math.sin(additionalAngle + piece.getAngle()));
    }

    /**
     * Returns the bounding box height of the given piece when it's rotated of an additional angle.
     * @param {HomePieceOfFurniture} piece
     * @param {number} additionalAngle
     * @return {number}
     * @private
     */
    static getPieceBoundingRectangleHeight(piece: HomePieceOfFurniture, additionalAngle: number): number {
        return Math.abs(piece.getWidthInPlan() * Math.sin(additionalAngle + piece.getAngle())) + Math.abs(piece.getDepthInPlan() * Math.cos(additionalAngle + piece.getAngle()));
    }

    /**
     * Controls the alignment of selected furniture.
     * @param {FurnitureController.FurnitureAlignmentUndoableEdit} alignmentEdit
     * @private
     */
    alignSelectedFurniture(alignmentEdit: FurnitureController.FurnitureAlignmentUndoableEdit) {
        const selectedFurniture: HomePieceOfFurniture[] = this.getMovableSelectedFurniture();
        if (selectedFurniture.length >= 2) {
            this.home.setSelectedItems(/* asList */selectedFurniture.slice(0));
            alignmentEdit.alignFurniture$();
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(alignmentEdit);
            }
        }
    }

    getMovableSelectedFurniture(): HomePieceOfFurniture[] {
        const movableSelectedFurniture: Array<HomePieceOfFurniture> = <any>([]);
        {
            let array = this.home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                        if (this.isPieceOfFurnitureMovable(piece)) {
                            /* add */(movableSelectedFurniture.push(piece) > 0);
                        }
                    }
                }
            }
        }
        return /* toArray */movableSelectedFurniture.slice(0);
    }

    static undoAlignFurniture(alignedFurniture: HomePieceOfFurniture[], x: number[], y: number[]) {
        for (let i: number = 0; i < alignedFurniture.length; i++) {
            {
                const piece: HomePieceOfFurniture = alignedFurniture[i];
                piece.setX(x[i]);
                piece.setY(y[i]);
            };
        }
    }

    /**
     * Returns the minimum abscissa of the vertices of <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {number}
     * @private
     */
    static getMinX(piece: HomePieceOfFurniture): number {
        const points: number[][] = piece.getPoints();
        let minX: number = Infinity;
        for (let index = 0; index < points.length; index++) {
            let point = points[index];
            {
                minX = Math.min(minX, point[0]);
            }
        }
        return minX;
    }

    /**
     * Returns the maximum abscissa of the vertices of <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {number}
     * @private
     */
    static getMaxX(piece: HomePieceOfFurniture): number {
        const points: number[][] = piece.getPoints();
        let maxX: number = -Infinity;
        for (let index = 0; index < points.length; index++) {
            let point = points[index];
            {
                maxX = Math.max(maxX, point[0]);
            }
        }
        return maxX;
    }

    /**
     * Returns the minimum ordinate of the vertices of <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {number}
     * @private
     */
    static getMinY(piece: HomePieceOfFurniture): number {
        const points: number[][] = piece.getPoints();
        let minY: number = Infinity;
        for (let index = 0; index < points.length; index++) {
            let point = points[index];
            {
                minY = Math.min(minY, point[1]);
            }
        }
        return minY;
    }

    /**
     * Returns the maximum ordinate of the vertices of <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @return {number}
     * @private
     */
    static getMaxY(piece: HomePieceOfFurniture): number {
        const points: number[][] = piece.getPoints();
        let maxY: number = -Infinity;
        for (let index = 0; index < points.length; index++) {
            let point = points[index];
            {
                maxY = Math.max(maxY, point[1]);
            }
        }
        return maxY;
    }

    /**
     * Controls the distribution of the selected furniture along horizontal axis.
     */
    public distributeSelectedFurnitureHorizontally() {
        this.distributeSelectedFurniture(true);
    }

    /**
     * Controls the distribution of the selected furniture along vertical axis.
     */
    public distributeSelectedFurnitureVertically() {
        this.distributeSelectedFurniture(false);
    }

    /**
     * Controls the distribution of the selected furniture along the axis orthogonal to the given one.
     * @param {boolean} horizontal
     */
    public distributeSelectedFurniture(horizontal: boolean) {
        const alignedFurniture: HomePieceOfFurniture[] = this.getMovableSelectedFurniture();
        if (alignedFurniture.length >= 3) {
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const oldX: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(alignedFurniture.length);
            const oldY: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(alignedFurniture.length);
            for (let i: number = 0; i < alignedFurniture.length; i++) {
                {
                    oldX[i] = alignedFurniture[i].getX();
                    oldY[i] = alignedFurniture[i].getY();
                };
            }
            this.home.setSelectedItems(/* asList */alignedFurniture.slice(0));
            FurnitureController.doDistributeFurnitureAlongAxis(alignedFurniture, horizontal);
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(new FurnitureController.FurnitureDistributionUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), oldX, oldY, alignedFurniture, horizontal));
            }
        }
    }

    static doDistributeFurnitureAlongAxis(alignedFurniture: HomePieceOfFurniture[], horizontal: boolean) {
        const orthogonalAxis: java.awt.geom.Line2D = horizontal ? new java.awt.geom.Line2D.Float(0, 0, 0, -1) : new java.awt.geom.Line2D.Float(0, 0, 1, 0);
        const furnitureHorizontallySorted: Array<HomePieceOfFurniture> = FurnitureController.sortFurniture(alignedFurniture, null, orthogonalAxis);
        const axisAngle: number = <number>(horizontal ? 0 : Math.PI / 2);
        const firstPiece: HomePieceOfFurniture = /* get */furnitureHorizontallySorted[0];
        const firstPieceBoundingRectangleHalfWidth: number = FurnitureController.getPieceBoundingRectangleWidth(firstPiece, axisAngle) / 2;
        const lastPiece: HomePieceOfFurniture = /* get */furnitureHorizontallySorted[/* size */(<number>furnitureHorizontallySorted.length) - 1];
        const lastPieceBoundingRectangleHalfWidth: number = FurnitureController.getPieceBoundingRectangleWidth(lastPiece, axisAngle) / 2;
        let gap: number = Math.abs(orthogonalAxis.ptLineDist(lastPiece.getX(), lastPiece.getY()) * orthogonalAxis.relativeCCW(lastPiece.getX(), lastPiece.getY()) - orthogonalAxis.ptLineDist(firstPiece.getX(), firstPiece.getY()) * orthogonalAxis.relativeCCW(firstPiece.getX(), firstPiece.getY())) - lastPieceBoundingRectangleHalfWidth - firstPieceBoundingRectangleHalfWidth;
        const furnitureWidthsAlongAxis: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>furnitureHorizontallySorted.length) - 2);
        for (let i: number = 1; i < /* size */(<number>furnitureHorizontallySorted.length) - 1; i++) {
            {
                const piece: HomePieceOfFurniture = /* get */furnitureHorizontallySorted[i];
                furnitureWidthsAlongAxis[i - 1] = FurnitureController.getPieceBoundingRectangleWidth(piece, axisAngle);
                gap -= furnitureWidthsAlongAxis[i - 1];
            };
        }
        gap /= /* size */(<number>furnitureHorizontallySorted.length) - 1;
        let xOrY: number = (horizontal ? firstPiece.getX() : firstPiece.getY()) + <number>(firstPieceBoundingRectangleHalfWidth + gap);
        for (let i: number = 1; i < /* size */(<number>furnitureHorizontallySorted.length) - 1; i++) {
            {
                const piece: HomePieceOfFurniture = /* get */furnitureHorizontallySorted[i];
                if (horizontal) {
                    piece.setX(<number>(xOrY + furnitureWidthsAlongAxis[i - 1] / 2));
                } else {
                    piece.setY(<number>(xOrY + furnitureWidthsAlongAxis[i - 1] / 2));
                }
                xOrY += gap + furnitureWidthsAlongAxis[i - 1];
            };
        }
    }

    /**
     * Resets the elevation of the selected furniture to its default elevation.
     */
    public resetFurnitureElevation() {
        const selectedFurniture: HomePieceOfFurniture[] = this.getMovableSelectedFurniture();
        if (selectedFurniture.length >= 1) {
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const furnitureOldElevation: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(selectedFurniture.length);
            const furnitureNewElevation: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(selectedFurniture.length);
            for (let i: number = 0; i < selectedFurniture.length; i++) {
                {
                    const piece: HomePieceOfFurniture = selectedFurniture[i];
                    furnitureOldElevation[i] = piece.getElevation();
                    const highestSurroundingPiece: HomePieceOfFurniture = this.getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List(piece, /* asList */selectedFurniture.slice(0));
                    if (highestSurroundingPiece != null) {
                        let elevation: number = highestSurroundingPiece.getElevation();
                        if (highestSurroundingPiece.isHorizontallyRotated()) {
                            elevation += highestSurroundingPiece.getHeightInPlan();
                        } else {
                            elevation += highestSurroundingPiece.getHeight() * highestSurroundingPiece.getDropOnTopElevation();
                        }
                        if (highestSurroundingPiece.getLevel() != null) {
                            elevation += highestSurroundingPiece.getLevel().getElevation() - piece.getLevel().getElevation();
                        }
                        furnitureNewElevation[i] = Math.max(0, elevation);
                    } else {
                        furnitureNewElevation[i] = 0;
                    }
                };
            }
            this.home.setSelectedItems(/* asList */selectedFurniture.slice(0));
            FurnitureController.doSetFurnitureElevation(selectedFurniture, furnitureNewElevation);
            if (this.undoSupport != null) {
                this.undoSupport.postEdit(new FurnitureController.FurnitureElevationResetUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), furnitureOldElevation, selectedFurniture, furnitureNewElevation));
            }
        }
    }

    static doSetFurnitureElevation(selectedFurniture: HomePieceOfFurniture[], furnitureNewElevation: number[]) {
        for (let i: number = 0; i < selectedFurniture.length; i++) {
            {
                selectedFurniture[i].setElevation(furnitureNewElevation[i]);
            };
        }
    }

    getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece: HomePieceOfFurniture): HomePieceOfFurniture {
        const ignoredFurniture: Array<HomePieceOfFurniture> = /* emptyList */[];
        return this.getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List(piece, ignoredFurniture);
    }

    public getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List(piece: HomePieceOfFurniture, ignoredFurniture: Array<HomePieceOfFurniture>): HomePieceOfFurniture {
        let highestSurroundingPiece: HomePieceOfFurniture = null;
        let highestElevation: number = 1.4E-45;
        {
            let array = this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List$float$boolean(piece, ignoredFurniture, 0.05, false);
            for (let index = 0; index < array.length; index++) {
                let surroundingPiece = array[index];
                {
                    let elevation: number = surroundingPiece.getElevation();
                    if (surroundingPiece.isHorizontallyRotated()) {
                        elevation += surroundingPiece.getHeightInPlan();
                    } else {
                        elevation += surroundingPiece.getHeight() * surroundingPiece.getDropOnTopElevation();
                    }
                    if (elevation > highestElevation) {
                        highestElevation = elevation;
                        highestSurroundingPiece = surroundingPiece;
                    }
                }
            }
        }
        return highestSurroundingPiece;
    }

    public getHighestSurroundingPieceOfFurniture(piece?: any, ignoredFurniture?: any): HomePieceOfFurniture {
        if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && ((ignoredFurniture != null && (ignoredFurniture instanceof Array)) || ignoredFurniture === null)) {
            return <any>this.getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List(piece, ignoredFurniture);
        } else if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && ignoredFurniture === undefined) {
            return <any>this.getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
        } else throw new Error('invalid overload');
    }

    getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece: HomePieceOfFurniture): Array<HomePieceOfFurniture> {
        const ignoredFurniture: Array<HomePieceOfFurniture> = /* emptyList */[];
        return this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List$float$boolean(piece, ignoredFurniture, 0.2, true);
    }

    public getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List$float$boolean(piece: HomePieceOfFurniture, ignoredFurniture: Array<HomePieceOfFurniture>, marginError: number, includeShelfUnits: boolean): Array<HomePieceOfFurniture> {
        const piecePoints: number[][] = piece.getPoints();
        const margin: number = Math.min(piece.getWidthInPlan(), piece.getDepthInPlan()) * marginError;
        const surroundingFurniture: Array<HomePieceOfFurniture> = <any>([]);
        {
            let array = this.getFurnitureInSameGroup(piece);
            for (let index = 0; index < array.length; index++) {
                let homePiece = array[index];
                {
                    if (homePiece !== piece && !/* contains */(ignoredFurniture.indexOf(<any>(homePiece)) >= 0) && this.isPieceOfFurnitureVisibleAtSelectedLevel(homePiece) && (homePiece.getDropOnTopElevation() >= 0 || (includeShelfUnits && (homePiece != null && homePiece instanceof <any>HomeShelfUnit)))) {
                        let surroundingPieceContainsPiece: boolean = true;
                        for (let index1 = 0; index1 < piecePoints.length; index1++) {
                            let point = piecePoints[index1];
                            {
                                if (!homePiece.containsPoint(point[0], point[1], margin)) {
                                    surroundingPieceContainsPiece = false;
                                    break;
                                }
                            }
                        }
                        if (surroundingPieceContainsPiece) {
                            /* add */(surroundingFurniture.push(homePiece) > 0);
                        }
                    }
                }
            }
        }
        return surroundingFurniture;
    }

    public getSurroundingFurniture(piece?: any, ignoredFurniture?: any, marginError?: any, includeShelfUnits?: any): Array<HomePieceOfFurniture> {
        if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && ((ignoredFurniture != null && (ignoredFurniture instanceof Array)) || ignoredFurniture === null) && ((typeof marginError === 'number') || marginError === null) && ((typeof includeShelfUnits === 'boolean') || includeShelfUnits === null)) {
            return <any>this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$java_util_List$float$boolean(piece, ignoredFurniture, marginError, includeShelfUnits);
        } else if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && ignoredFurniture === undefined && marginError === undefined && includeShelfUnits === undefined) {
            return <any>this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the furniture list of the given <code>piece</code> which belongs to same group
     * or home furniture if it doesn't belong to home furniture.
     * @param {HomePieceOfFurniture} piece
     * @return {HomePieceOfFurniture[]}
     */
    getFurnitureInSameGroup(piece: HomePieceOfFurniture): Array<HomePieceOfFurniture> {
        const homeFurniture: Array<HomePieceOfFurniture> = this.home.getFurniture();
        const furnitureInSameGroup: Array<HomePieceOfFurniture> = FurnitureController.getFurnitureInSameGroup(piece, homeFurniture);
        if (furnitureInSameGroup != null) {
            return furnitureInSameGroup;
        } else {
            return homeFurniture;
        }
    }

    static getFurnitureInSameGroup(piece: HomePieceOfFurniture, furniture: Array<HomePieceOfFurniture>): Array<HomePieceOfFurniture> {
        for (let index = 0; index < furniture.length; index++) {
            let piece2 = furniture[index];
            {
                if (piece2 === piece) {
                    return furniture;
                } else if (piece2 != null && piece2 instanceof <any>HomeFurnitureGroup) {
                    const siblingFurniture: Array<HomePieceOfFurniture> = FurnitureController.getFurnitureInSameGroup(piece, (<HomeFurnitureGroup>piece2).getFurniture());
                    if (siblingFurniture != null) {
                        return siblingFurniture;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns <code>true</code> if the given piece is viewable and
     * its height and elevation make it viewable at the selected level in home.
     * @param {HomePieceOfFurniture} piece
     * @return {boolean}
     */
    isPieceOfFurnitureVisibleAtSelectedLevel(piece: HomePieceOfFurniture): boolean {
        const selectedLevel: Level = this.home.getSelectedLevel();
        return piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isViewable()) && (piece.getLevel() === selectedLevel || piece.isAtLevel(selectedLevel));
    }

    /**
     * Controls the change of value of a visual property in home.
     * @deprecated {@link #setVisualProperty(String, Object) setVisualProperty} should be replaced by a call to
     * {@link #setHomeProperty(String, String)} to ensure the property can be easily saved and read.
     * @param {string} propertyName
     * @param {Object} propertyValue
     */
    public setVisualProperty(propertyName: string, propertyValue: any) {
        this.home.setVisualProperty(propertyName, propertyValue);
    }

    /**
     * Controls the change of value of a property in home.
     * @param {string} propertyName
     * @param {string} propertyValue
     */
    public setHomeProperty(propertyName: string, propertyValue: string) {
        this.home.setProperty(propertyName, propertyValue);
    }
}
FurnitureController["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController";
FurnitureController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace FurnitureController {

    /**
     * Undoable edit for furniture added to home.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} newFurniture
     * @param {int[]} newFurnitureIndex
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} newFurnitureGroups
     * @param {com.eteks.sweethome3d.model.Level[]} newFurnitureLevels
     * @param {Level} furnitureLevel
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureAdditionUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        allLevelsSelection: boolean;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        newFurniture: HomePieceOfFurniture[];

        newFurnitureIndex: number[];

        newFurnitureGroups: HomeFurnitureGroup[];

        newFurnitureLevels: Level[];

        furnitureLevel: Level;

        newBasePlanLocked: boolean;

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, allLevelsSelection: boolean, newFurniture: HomePieceOfFurniture[], newFurnitureIndex: number[], newFurnitureGroups: HomeFurnitureGroup[], newFurnitureLevels: Level[], furnitureLevel: Level, newBasePlanLocked: boolean) {
            super(preferences, FurnitureController, "undoAddFurnitureName");
            if (this.home === undefined) { this.home = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.newFurniture === undefined) { this.newFurniture = null; }
            if (this.newFurnitureIndex === undefined) { this.newFurnitureIndex = null; }
            if (this.newFurnitureGroups === undefined) { this.newFurnitureGroups = null; }
            if (this.newFurnitureLevels === undefined) { this.newFurnitureLevels = null; }
            if (this.furnitureLevel === undefined) { this.furnitureLevel = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.allLevelsSelection = allLevelsSelection;
            this.newFurniture = newFurniture;
            this.newFurnitureIndex = newFurnitureIndex;
            this.newFurnitureGroups = newFurnitureGroups;
            this.newFurnitureLevels = newFurnitureLevels;
            this.furnitureLevel = furnitureLevel;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.doDeleteFurniture(this.home, this.newFurniture, this.oldBasePlanLocked, this.allLevelsSelection);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            FurnitureController.doAddFurniture(this.home, this.newFurniture, this.newFurnitureGroups, this.newFurnitureIndex, this.furnitureLevel, this.newFurnitureLevels, this.newBasePlanLocked, false);
        }
    }
    FurnitureAdditionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureAdditionUndoableEdit";
    FurnitureAdditionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture deleted from home.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} basePlanLocked
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} furniture
     * @param {int[]} furnitureIndex
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} furnitureGroups
     * @param {com.eteks.sweethome3d.model.Level[]} furnitureLevels
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureDeletionUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        basePlanLocked: boolean;

        allLevelsSelection: boolean;

        furniture: HomePieceOfFurniture[];

        furnitureIndex: number[];

        furnitureGroups: HomeFurnitureGroup[];

        furnitureLevels: Level[];

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], basePlanLocked: boolean, allLevelsSelection: boolean, furniture: HomePieceOfFurniture[], furnitureIndex: number[], furnitureGroups: HomeFurnitureGroup[], furnitureLevels: Level[]) {
            super(preferences, FurnitureController, "undoDeleteSelectionName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureIndex === undefined) { this.furnitureIndex = null; }
            if (this.furnitureGroups === undefined) { this.furnitureGroups = null; }
            if (this.furnitureLevels === undefined) { this.furnitureLevels = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.basePlanLocked = basePlanLocked;
            this.allLevelsSelection = allLevelsSelection;
            this.furniture = furniture;
            this.furnitureIndex = furnitureIndex;
            this.furnitureGroups = furnitureGroups;
            this.furnitureLevels = furnitureLevels;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.doAddFurniture(this.home, this.furniture, this.furnitureGroups, this.furnitureIndex, null, this.furnitureLevels, this.basePlanLocked, this.allLevelsSelection);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.furniture.slice(0));
            FurnitureController.doDeleteFurniture(this.home, this.furniture, this.basePlanLocked, false);
        }
    }
    FurnitureDeletionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureDeletionUndoableEdit";
    FurnitureDeletionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture grouping.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} basePlanLocked
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} groupedPieces
     * @param {int[]} groupedPiecesIndex
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} groupedPiecesGroups
     * @param {com.eteks.sweethome3d.model.Level[]} groupedPiecesLevel
     * @param {float[]} groupedPiecesElevation
     * @param {boolean[]} groupedPiecesVisible
     * @param {HomeFurnitureGroup} newGroup
     * @param {number} groupIndex
     * @param {Level} groupLevel
     * @param {float[]} groupPiecesNewElevation
     * @param {boolean} movable
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureGroupingUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        basePlanLocked: boolean;

        allLevelsSelection: boolean;

        groupedPieces: HomePieceOfFurniture[];

        groupedPiecesIndex: number[];

        groupedPiecesGroups: HomeFurnitureGroup[];

        groupedPiecesLevel: Level[];

        groupedPiecesElevation: number[];

        groupedPiecesVisible: boolean[];

        newGroup: HomeFurnitureGroup;

        groupIndex: number;

        groupLevel: Level;

        groupPiecesNewElevation: number[];

        movable: boolean;

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], basePlanLocked: boolean, allLevelsSelection: boolean, groupedPieces: HomePieceOfFurniture[], groupedPiecesIndex: number[], groupedPiecesGroups: HomeFurnitureGroup[], groupedPiecesLevel: Level[], groupedPiecesElevation: number[], groupedPiecesVisible: boolean[], newGroup: HomeFurnitureGroup, groupIndex: number, groupLevel: Level, groupPiecesNewElevation: number[], movable: boolean) {
            super(preferences, FurnitureController, "undoGroupName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.groupedPieces === undefined) { this.groupedPieces = null; }
            if (this.groupedPiecesIndex === undefined) { this.groupedPiecesIndex = null; }
            if (this.groupedPiecesGroups === undefined) { this.groupedPiecesGroups = null; }
            if (this.groupedPiecesLevel === undefined) { this.groupedPiecesLevel = null; }
            if (this.groupedPiecesElevation === undefined) { this.groupedPiecesElevation = null; }
            if (this.groupedPiecesVisible === undefined) { this.groupedPiecesVisible = null; }
            if (this.newGroup === undefined) { this.newGroup = null; }
            if (this.groupIndex === undefined) { this.groupIndex = 0; }
            if (this.groupLevel === undefined) { this.groupLevel = null; }
            if (this.groupPiecesNewElevation === undefined) { this.groupPiecesNewElevation = null; }
            if (this.movable === undefined) { this.movable = false; }
            this.home = home;
            this.basePlanLocked = basePlanLocked;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.groupedPieces = groupedPieces;
            this.groupedPiecesIndex = groupedPiecesIndex;
            this.groupedPiecesGroups = groupedPiecesGroups;
            this.groupedPiecesLevel = groupedPiecesLevel;
            this.groupedPiecesElevation = groupedPiecesElevation;
            this.groupedPiecesVisible = groupedPiecesVisible;
            this.newGroup = newGroup;
            this.groupIndex = groupIndex;
            this.groupLevel = groupLevel;
            this.groupPiecesNewElevation = groupPiecesNewElevation;
            this.movable = movable;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.doUngroupFurniture(this.home, [this.newGroup], this.groupedPieces, this.groupedPiecesGroups, this.groupedPiecesIndex, this.groupedPiecesLevel, this.basePlanLocked, this.allLevelsSelection);
            for (let i: number = 0; i < this.groupedPieces.length; i++) {
                {
                    this.groupedPieces[i].setElevation(this.groupedPiecesElevation[i]);
                    this.groupedPieces[i].setVisible(this.groupedPiecesVisible[i]);
                };
            }
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            for (let i: number = 0; i < this.groupedPieces.length; i++) {
                {
                    this.groupedPieces[i].setElevation(this.groupPiecesNewElevation[i]);
                    this.groupedPieces[i].setLevel(null);
                };
            }
            this.newGroup.setMovable(this.movable);
            this.newGroup.setVisible(true);
            FurnitureController.doGroupFurniture(this.home, this.groupedPieces, [this.newGroup], null, [this.groupIndex], [this.groupLevel], this.basePlanLocked, false);
        }
    }
    FurnitureGroupingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureGroupingUndoableEdit";
    FurnitureGroupingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture ungrouping.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} groups
     * @param {int[]} groupsIndex
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} groupsGroups
     * @param {com.eteks.sweethome3d.model.Level[]} groupsLevels
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} ungroupedPieces
     * @param {int[]} ungroupedPiecesIndex
     * @param {com.eteks.sweethome3d.model.HomeFurnitureGroup[]} ungroupedPiecesGroups
     * @param {com.eteks.sweethome3d.model.Level[]} ungroupedPiecesLevels
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureUngroupingUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldBasePlanLocked: boolean;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        groups: HomeFurnitureGroup[];

        groupsIndex: number[];

        groupsGroups: HomeFurnitureGroup[];

        groupsLevels: Level[];

        ungroupedPieces: HomePieceOfFurniture[];

        ungroupedPiecesIndex: number[];

        ungroupedPiecesGroups: HomeFurnitureGroup[];

        ungroupedPiecesLevels: Level[];

        newBasePlanLocked: boolean;

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, allLevelsSelection: boolean, groups: HomeFurnitureGroup[], groupsIndex: number[], groupsGroups: HomeFurnitureGroup[], groupsLevels: Level[], ungroupedPieces: HomePieceOfFurniture[], ungroupedPiecesIndex: number[], ungroupedPiecesGroups: HomeFurnitureGroup[], ungroupedPiecesLevels: Level[], newBasePlanLocked: boolean) {
            super(preferences, FurnitureController, "undoUngroupName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.groups === undefined) { this.groups = null; }
            if (this.groupsIndex === undefined) { this.groupsIndex = null; }
            if (this.groupsGroups === undefined) { this.groupsGroups = null; }
            if (this.groupsLevels === undefined) { this.groupsLevels = null; }
            if (this.ungroupedPieces === undefined) { this.ungroupedPieces = null; }
            if (this.ungroupedPiecesIndex === undefined) { this.ungroupedPiecesIndex = null; }
            if (this.ungroupedPiecesGroups === undefined) { this.ungroupedPiecesGroups = null; }
            if (this.ungroupedPiecesLevels === undefined) { this.ungroupedPiecesLevels = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.allLevelsSelection = allLevelsSelection;
            this.groups = groups;
            this.groupsIndex = groupsIndex;
            this.groupsGroups = groupsGroups;
            this.groupsLevels = groupsLevels;
            this.ungroupedPieces = ungroupedPieces;
            this.ungroupedPiecesIndex = ungroupedPiecesIndex;
            this.ungroupedPiecesGroups = ungroupedPiecesGroups;
            this.ungroupedPiecesLevels = ungroupedPiecesLevels;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.doGroupFurniture(this.home, this.ungroupedPieces, this.groups, this.groupsGroups, this.groupsIndex, this.groupsLevels, this.oldBasePlanLocked, this.allLevelsSelection);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            FurnitureController.doUngroupFurniture(this.home, this.groups, this.ungroupedPieces, this.ungroupedPiecesGroups, this.ungroupedPiecesIndex, this.ungroupedPiecesLevels, this.newBasePlanLocked, false);
        }
    }
    FurnitureUngroupingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureUngroupingUndoableEdit";
    FurnitureUngroupingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture alignment.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} selectedFurniture
     * @param {HomePieceOfFurniture} leadPiece
     * @class
     * @extends LocalizedUndoableEdit
     */
    export abstract class FurnitureAlignmentUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        selectedFurniture: HomePieceOfFurniture[];

        leadPiece: HomePieceOfFurniture;

        alignedFurniture: HomePieceOfFurniture[];

        oldX: number[];

        oldY: number[];

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(preferences, FurnitureController, "undoAlignName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.selectedFurniture === undefined) { this.selectedFurniture = null; }
            if (this.leadPiece === undefined) { this.leadPiece = null; }
            if (this.alignedFurniture === undefined) { this.alignedFurniture = null; }
            if (this.oldX === undefined) { this.oldX = null; }
            if (this.oldY === undefined) { this.oldY = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.selectedFurniture = selectedFurniture;
            this.leadPiece = leadPiece;
            this.alignedFurniture = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(leadPiece == null ? selectedFurniture.length : selectedFurniture.length - 1);
            this.oldX = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(this.alignedFurniture.length);
            this.oldY = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(this.alignedFurniture.length);
            let i: number = 0;
            for (let index = 0; index < selectedFurniture.length; index++) {
                let piece = selectedFurniture[index];
                {
                    if (piece !== leadPiece) {
                        this.alignedFurniture[i] = piece;
                        this.oldX[i] = piece.getX();
                        this.oldY[i] = piece.getY();
                        i++;
                    }
                }
            }
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.undoAlignFurniture(this.alignedFurniture, this.oldX, this.oldY);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.selectedFurniture.slice(0));
            this.alignFurniture$();
        }

        public alignFurniture$() {
            this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(this.alignedFurniture, this.leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }

        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureAlignmentUndoableEdit";
    FurnitureAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture distribution.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {float[]} oldX
     * @param {float[]} oldY
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
     * @param {boolean} horizontal
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureDistributionUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        oldX: number[];

        oldY: number[];

        alignedFurniture: HomePieceOfFurniture[];

        horizontal: boolean;

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], oldX: number[], oldY: number[], alignedFurniture: HomePieceOfFurniture[], horizontal: boolean) {
            super(preferences, FurnitureController, "undoDistributeName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldX === undefined) { this.oldX = null; }
            if (this.oldY === undefined) { this.oldY = null; }
            if (this.alignedFurniture === undefined) { this.alignedFurniture = null; }
            if (this.horizontal === undefined) { this.horizontal = false; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldX = oldX;
            this.oldY = oldY;
            this.alignedFurniture = alignedFurniture;
            this.horizontal = horizontal;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.undoAlignFurniture(this.alignedFurniture, this.oldX, this.oldY);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.alignedFurniture.slice(0));
            FurnitureController.doDistributeFurnitureAlongAxis(this.alignedFurniture, this.horizontal);
        }
    }
    FurnitureDistributionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureDistributionUndoableEdit";
    FurnitureDistributionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for furniture elevation reset.
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {float[]} furnitureOldElevation
     * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} selectedFurniture
     * @param {float[]} furnitureNewElevation
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FurnitureElevationResetUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        furnitureOldElevation: number[];

        selectedFurniture: HomePieceOfFurniture[];

        furnitureNewElevation: number[];

        public constructor(home: Home, preferences: any, oldSelection: Selectable[], furnitureOldElevation: number[], selectedFurniture: HomePieceOfFurniture[], furnitureNewElevation: number[]) {
            super(preferences, FurnitureController, "undoResetElevation");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.furnitureOldElevation === undefined) { this.furnitureOldElevation = null; }
            if (this.selectedFurniture === undefined) { this.selectedFurniture = null; }
            if (this.furnitureNewElevation === undefined) { this.furnitureNewElevation = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.furnitureOldElevation = furnitureOldElevation;
            this.selectedFurniture = selectedFurniture;
            this.furnitureNewElevation = furnitureNewElevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            FurnitureController.doSetFurnitureElevation(this.selectedFurniture, this.furnitureOldElevation);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.selectedFurniture.slice(0));
            FurnitureController.doSetFurnitureElevation(this.selectedFurniture, this.furnitureNewElevation);
        }
    }
    FurnitureElevationResetUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureElevationResetUndoableEdit";
    FurnitureElevationResetUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureTopAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const minYLeadPiece: number = FurnitureController.getMinY(leadPiece);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    const minY: number = FurnitureController.getMinY(piece);
                    piece.setY(piece.getY() + minYLeadPiece - minY);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureTopAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureTopAlignmentUndoableEdit";
    FurnitureTopAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureBottomAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const maxYLeadPiece: number = FurnitureController.getMaxY(leadPiece);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    const maxY: number = FurnitureController.getMaxY(piece);
                    piece.setY(piece.getY() + maxYLeadPiece - maxY);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureBottomAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureBottomAlignmentUndoableEdit";
    FurnitureBottomAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureLeftAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const minXLeadPiece: number = FurnitureController.getMinX(leadPiece);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    const minX: number = FurnitureController.getMinX(piece);
                    piece.setX(piece.getX() + minXLeadPiece - minX);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureLeftAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureLeftAlignmentUndoableEdit";
    FurnitureLeftAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureRightAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const maxXLeadPiece: number = FurnitureController.getMaxX(leadPiece);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    const maxX: number = FurnitureController.getMaxX(piece);
                    piece.setX(piece.getX() + maxXLeadPiece - maxX);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureRightAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureRightAlignmentUndoableEdit";
    FurnitureRightAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureFrontSideAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const points: number[][] = leadPiece.getPoints();
            const frontLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(points[2][0], points[2][1], points[3][0], points[3][1]);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    FurnitureController.alignPieceOfFurnitureAlongSides(piece, leadPiece, frontLine, true, null, 0);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureFrontSideAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureFrontSideAlignmentUndoableEdit";
    FurnitureFrontSideAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureBackSideAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const points: number[][] = leadPiece.getPoints();
            const backLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(points[0][0], points[0][1], points[1][0], points[1][1]);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    FurnitureController.alignPieceOfFurnitureAlongSides(piece, leadPiece, backLine, false, null, 0);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureBackSideAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureBackSideAlignmentUndoableEdit";
    FurnitureBackSideAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureLeftSideAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const points: number[][] = leadPiece.getPoints();
            const leftLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(points[3][0], points[3][1], points[0][0], points[0][1]);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let piece = alignedFurniture[index];
                {
                    FurnitureController.alignPieceOfFurnitureAlongLeftOrRightSides(piece, leadPiece, leftLine, false);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureLeftSideAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureLeftSideAlignmentUndoableEdit";
    FurnitureLeftSideAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureRightSideAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const points: number[][] = leadPiece.getPoints();
            const rightLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(points[1][0], points[1][1], points[2][0], points[2][1]);
            for (let index = 0; index < alignedFurniture.length; index++) {
                let alignedPiece = alignedFurniture[index];
                {
                    FurnitureController.alignPieceOfFurnitureAlongLeftOrRightSides(alignedPiece, leadPiece, rightLine, true);
                }
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureRightSideAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureRightSideAlignmentUndoableEdit";
    FurnitureRightSideAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureSideBySideAlignmentUndoableEdit extends FurnitureController.FurnitureAlignmentUndoableEdit {
        public constructor(home: Home, preferences: any, oldSelection: Selectable[], selectedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            super(home, preferences, oldSelection, selectedFurniture, leadPiece);
        }

        public alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture: HomePieceOfFurniture[], leadPiece: HomePieceOfFurniture) {
            const points: number[][] = leadPiece.getPoints();
            const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(leadPiece.getX(), leadPiece.getY(), (points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2);
            const furnitureSortedAlongBackLine: Array<HomePieceOfFurniture> = FurnitureController.sortFurniture(alignedFurniture, leadPiece, centerLine);
            const leadPieceIndex: number = furnitureSortedAlongBackLine.indexOf(leadPiece);
            const backLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(points[0][0], points[0][1], points[1][0], points[1][1]);
            let sideDistance: number = leadPiece.getWidthInPlan() / 2;
            for (let i: number = leadPieceIndex + 1; i < /* size */(<number>furnitureSortedAlongBackLine.length); i++) {
                {
                    sideDistance += FurnitureController.alignPieceOfFurnitureAlongSides(/* get */furnitureSortedAlongBackLine[i], leadPiece, backLine, false, centerLine, sideDistance);
                };
            }
            sideDistance = -leadPiece.getWidthInPlan() / 2;
            for (let i: number = leadPieceIndex - 1; i >= 0; i--) {
                {
                    sideDistance -= FurnitureController.alignPieceOfFurnitureAlongSides(/* get */furnitureSortedAlongBackLine[i], leadPiece, backLine, false, centerLine, sideDistance);
                };
            }
        }

        /**
         * 
         * @param {com.eteks.sweethome3d.model.HomePieceOfFurniture[]} alignedFurniture
         * @param {HomePieceOfFurniture} leadPiece
         * @private
         */
        public alignFurniture(alignedFurniture?: any, leadPiece?: any) {
            if (((alignedFurniture != null && alignedFurniture instanceof <any>Array && (alignedFurniture.length == 0 || alignedFurniture[0] == null || (alignedFurniture[0] != null && alignedFurniture[0] instanceof <any>HomePieceOfFurniture))) || alignedFurniture === null) && ((leadPiece != null && leadPiece instanceof <any>HomePieceOfFurniture) || leadPiece === null)) {
                return <any>this.alignFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture_A$com_eteks_sweethome3d_model_HomePieceOfFurniture(alignedFurniture, leadPiece);
            } else if (alignedFurniture === undefined && leadPiece === undefined) {
                return <any>this.alignFurniture$();
            } else throw new Error('invalid overload');
        }
    }
    FurnitureSideBySideAlignmentUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.FurnitureController.FurnitureSideBySideAlignmentUndoableEdit";
    FurnitureSideBySideAlignmentUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class FurnitureController$0 implements SelectionListener {
        public __parent: any;
        public selectionChanged(ev: SelectionEvent) {
            const selectedFurniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(this.__parent.home.getSelectedItems());
            if (/* isEmpty */(selectedFurniture.length == 0)) {
                this.__parent.leadSelectedPieceOfFurniture = null;
            } else if (this.__parent.leadSelectedPieceOfFurniture == null || /* size */(<number>selectedFurniture.length) === 1 || selectedFurniture.indexOf(this.__parent.leadSelectedPieceOfFurniture) === -1) {
                this.__parent.leadSelectedPieceOfFurniture = /* get */selectedFurniture[0];
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }
    FurnitureController$0["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];



    export class FurnitureController$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (/* name */"MOVABLE" === ev.getPropertyName()) {
                const piece: HomePieceOfFurniture = <HomePieceOfFurniture>ev.getSource();
                if (this.__parent.home.isBasePlanLocked() && this.__parent.isPieceOfFurniturePartOfBasePlan(piece)) {
                    let selectedItems: Array<Selectable> = this.__parent.home.getSelectedItems();
                    if (/* contains */(selectedItems.indexOf(<any>(piece)) >= 0)) {
                        selectedItems = <any>(selectedItems.slice(0));
                        /* remove */(a => { let index = a.indexOf(piece); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems);
                        this.__parent.home.setSelectedItems(selectedItems);
                    }
                }
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class FurnitureController$2 {
        public compare(p1: HomePieceOfFurniture, p2: HomePieceOfFurniture): number {
            return /* compare */(this.orthogonalAxis.ptLineDistSq(p2.getX(), p2.getY()) * this.orthogonalAxis.relativeCCW(p2.getX(), p2.getY()) - this.orthogonalAxis.ptLineDistSq(p1.getX(), p1.getY()) * this.orthogonalAxis.relativeCCW(p1.getX(), p1.getY()));
        }

        constructor(private orthogonalAxis: any) {
        }
    }

}


/**
 * Creates the controller of 3D view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class Home3DAttributesController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ groundTextureController: TextureChoiceController;

    /*private*/ skyTextureController: TextureChoiceController;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ home3DAttributesView: DialogView;

    /*private*/ groundColor: number;

    /*private*/ groundPaint: Home3DAttributesController.EnvironmentPaint;

    /*private*/ backgroundImageVisibleOnGround3D: boolean;

    /*private*/ skyColor: number;

    /*private*/ skyPaint: Home3DAttributesController.EnvironmentPaint;

    /*private*/ lightColor: number;

    /*private*/ wallsAlpha: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.groundTextureController === undefined) { this.groundTextureController = null; }
        if (this.skyTextureController === undefined) { this.skyTextureController = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.home3DAttributesView === undefined) { this.home3DAttributesView = null; }
        if (this.groundColor === undefined) { this.groundColor = 0; }
        if (this.groundPaint === undefined) { this.groundPaint = null; }
        if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
        if (this.skyColor === undefined) { this.skyColor = 0; }
        if (this.skyPaint === undefined) { this.skyPaint = null; }
        if (this.lightColor === undefined) { this.lightColor = 0; }
        if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the texture controller of the ground.
     * @return {TextureChoiceController}
     */
    public getGroundTextureController(): TextureChoiceController {
        if (this.groundTextureController == null) {
            this.groundTextureController = new TextureChoiceController(this.preferences.getLocalizedString(Home3DAttributesController, "groundTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.groundTextureController.addPropertyChangeListener("TEXTURE", new Home3DAttributesController.Home3DAttributesController$0(this));
        }
        return this.groundTextureController;
    }

    /**
     * Returns the texture controller of the sky.
     * @return {TextureChoiceController}
     */
    public getSkyTextureController(): TextureChoiceController {
        if (this.skyTextureController == null) {
            this.skyTextureController = new TextureChoiceController(this.preferences.getLocalizedString(Home3DAttributesController, "skyTextureTitle"), false, this.preferences, this.viewFactory, this.contentManager);
            this.skyTextureController.addPropertyChangeListener("TEXTURE", new Home3DAttributesController.Home3DAttributesController$1(this));
        }
        return this.skyTextureController;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.home3DAttributesView == null) {
            this.home3DAttributesView = this.viewFactory.createHome3DAttributesView(this.preferences, this);
        }
        return this.home3DAttributesView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from the 3D attributes of the home edited by this controller.
     */
    updateProperties() {
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        this.setGroundColor(homeEnvironment.getGroundColor());
        const groundTexture: HomeTexture = homeEnvironment.getGroundTexture();
        this.getGroundTextureController().setTexture(groundTexture);
        if (groundTexture != null) {
            this.setGroundPaint(Home3DAttributesController.EnvironmentPaint.TEXTURED);
        } else {
            this.setGroundPaint(Home3DAttributesController.EnvironmentPaint.COLORED);
        }
        this.setBackgroundImageVisibleOnGround3D(homeEnvironment.isBackgroundImageVisibleOnGround3D());
        this.setSkyColor(homeEnvironment.getSkyColor());
        const skyTexture: HomeTexture = homeEnvironment.getSkyTexture();
        this.getSkyTextureController().setTexture(skyTexture);
        if (skyTexture != null) {
            this.setSkyPaint(Home3DAttributesController.EnvironmentPaint.TEXTURED);
        } else {
            this.setSkyPaint(Home3DAttributesController.EnvironmentPaint.COLORED);
        }
        this.setLightColor(homeEnvironment.getLightColor());
        this.setWallsAlpha(homeEnvironment.getWallsAlpha());
    }

    /**
     * Sets the edited ground color.
     * @param {number} groundColor
     */
    public setGroundColor(groundColor: number) {
        if (groundColor !== this.groundColor) {
            const oldGroundColor: number = this.groundColor;
            this.groundColor = groundColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"GROUND_COLOR", oldGroundColor, groundColor);
            this.setGroundPaint(Home3DAttributesController.EnvironmentPaint.COLORED);
        }
    }

    /**
     * Returns the edited ground color.
     * @return {number}
     */
    public getGroundColor(): number {
        return this.groundColor;
    }

    /**
     * Sets whether the ground is colored or textured.
     * @param {Home3DAttributesController.EnvironmentPaint} groundPaint
     */
    public setGroundPaint(groundPaint: Home3DAttributesController.EnvironmentPaint) {
        if (groundPaint !== this.groundPaint) {
            const oldGroundPaint: Home3DAttributesController.EnvironmentPaint = this.groundPaint;
            this.groundPaint = groundPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"GROUND_PAINT", oldGroundPaint, groundPaint);
        }
    }

    /**
     * Returns whether the ground is colored or textured.
     * @return {Home3DAttributesController.EnvironmentPaint}
     */
    public getGroundPaint(): Home3DAttributesController.EnvironmentPaint {
        return this.groundPaint;
    }

    /**
     * Returns <code>true</code> if the background image should be displayed on the ground in 3D.
     * @return {boolean}
     */
    public isBackgroundImageVisibleOnGround3D(): boolean {
        return this.backgroundImageVisibleOnGround3D;
    }

    /**
     * Sets whether the background image should be displayed on the ground in 3D.
     * @param {boolean} backgroundImageVisibleOnGround3D
     */
    public setBackgroundImageVisibleOnGround3D(backgroundImageVisibleOnGround3D: boolean) {
        if (this.backgroundImageVisibleOnGround3D !== backgroundImageVisibleOnGround3D) {
            this.backgroundImageVisibleOnGround3D = backgroundImageVisibleOnGround3D;
            this.propertyChangeSupport.firePropertyChange(/* name */"BACKGROUND_IMAGE_VISIBLE_ON_GROUND_3D", !backgroundImageVisibleOnGround3D, backgroundImageVisibleOnGround3D);
        }
    }

    /**
     * Sets the edited sky color.
     * @param {number} skyColor
     */
    public setSkyColor(skyColor: number) {
        if (skyColor !== this.skyColor) {
            const oldSkyColor: number = this.skyColor;
            this.skyColor = skyColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"SKY_COLOR", oldSkyColor, skyColor);
        }
    }

    /**
     * Returns the edited sky color.
     * @return {number}
     */
    public getSkyColor(): number {
        return this.skyColor;
    }

    /**
     * Sets whether the sky is colored or textured.
     * @param {Home3DAttributesController.EnvironmentPaint} skyPaint
     */
    public setSkyPaint(skyPaint: Home3DAttributesController.EnvironmentPaint) {
        if (skyPaint !== this.skyPaint) {
            const oldSkyPaint: Home3DAttributesController.EnvironmentPaint = this.skyPaint;
            this.skyPaint = skyPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"SKY_PAINT", oldSkyPaint, skyPaint);
        }
    }

    /**
     * Returns whether the sky is colored or textured.
     * @return {Home3DAttributesController.EnvironmentPaint}
     */
    public getSkyPaint(): Home3DAttributesController.EnvironmentPaint {
        return this.skyPaint;
    }

    /**
     * Sets the edited light color.
     * @param {number} lightColor
     */
    public setLightColor(lightColor: number) {
        if (lightColor !== this.lightColor) {
            const oldLightColor: number = this.lightColor;
            this.lightColor = lightColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"LIGHT_COLOR", oldLightColor, lightColor);
        }
    }

    /**
     * Returns the edited light color.
     * @return {number}
     */
    public getLightColor(): number {
        return this.lightColor;
    }

    /**
     * Sets the edited walls transparency alpha.
     * @param {number} wallsAlpha
     */
    public setWallsAlpha(wallsAlpha: number) {
        if (wallsAlpha !== this.wallsAlpha) {
            const oldWallsAlpha: number = this.wallsAlpha;
            this.wallsAlpha = wallsAlpha;
            this.propertyChangeSupport.firePropertyChange(/* name */"WALLS_ALPHA", oldWallsAlpha, wallsAlpha);
        }
    }

    /**
     * Returns the edited walls transparency alpha.
     * @return {number}
     */
    public getWallsAlpha(): number {
        return this.wallsAlpha;
    }

    /**
     * Controls the modification of the 3D attributes of the edited home.
     */
    public modify3DAttributes() {
        const groundColor: number = this.getGroundColor();
        const groundTexture: HomeTexture = this.getGroundPaint() === Home3DAttributesController.EnvironmentPaint.TEXTURED ? this.getGroundTextureController().getTexture() : null;
        const backgroundImageVisibleOnGround3D: boolean = this.isBackgroundImageVisibleOnGround3D();
        const skyColor: number = this.getSkyColor();
        const skyTexture: HomeTexture = this.getSkyPaint() === Home3DAttributesController.EnvironmentPaint.TEXTURED ? this.getSkyTextureController().getTexture() : null;
        const lightColor: number = this.getLightColor();
        const wallsAlpha: number = this.getWallsAlpha();
        const homeEnvironment: HomeEnvironment = this.home.getEnvironment();
        const oldGroundColor: number = homeEnvironment.getGroundColor();
        const oldBackgroundImageVisibleOnGround3D: boolean = homeEnvironment.isBackgroundImageVisibleOnGround3D();
        const oldGroundTexture: HomeTexture = homeEnvironment.getGroundTexture();
        const oldSkyColor: number = homeEnvironment.getSkyColor();
        const oldSkyTexture: HomeTexture = homeEnvironment.getSkyTexture();
        const oldLightColor: number = homeEnvironment.getLightColor();
        const oldWallsAlpha: number = homeEnvironment.getWallsAlpha();
        Home3DAttributesController.doModify3DAttributes(this.home, groundColor, groundTexture, backgroundImageVisibleOnGround3D, skyColor, skyTexture, lightColor, wallsAlpha);
        if (this.undoSupport != null) {
            this.undoSupport.postEdit(new Home3DAttributesController.Home3DAttributesModificationUndoableEdit(this.home, this.preferences, oldGroundColor, oldGroundTexture, oldBackgroundImageVisibleOnGround3D, oldSkyColor, oldSkyTexture, oldLightColor, oldWallsAlpha, groundColor, groundTexture, backgroundImageVisibleOnGround3D, skyColor, skyTexture, lightColor, wallsAlpha));
        }
    }

    /**
     * Modifies the 3D attributes of the given <code>home</code>.
     * @param {Home} home
     * @param {number} groundColor
     * @param {HomeTexture} groundTexture
     * @param {boolean} backgroundImageVisibleOnGround3D
     * @param {number} skyColor
     * @param {HomeTexture} skyTexture
     * @param {number} lightColor
     * @param {number} wallsAlpha
     * @private
     */
    static doModify3DAttributes(home: Home, groundColor: number, groundTexture: HomeTexture, backgroundImageVisibleOnGround3D: boolean, skyColor: number, skyTexture: HomeTexture, lightColor: number, wallsAlpha: number) {
        const homeEnvironment: HomeEnvironment = home.getEnvironment();
        homeEnvironment.setGroundColor(groundColor);
        homeEnvironment.setGroundTexture(groundTexture);
        homeEnvironment.setBackgroundImageVisibleOnGround3D(backgroundImageVisibleOnGround3D);
        homeEnvironment.setSkyColor(skyColor);
        homeEnvironment.setSkyTexture(skyTexture);
        homeEnvironment.setLightColor(lightColor);
        homeEnvironment.setWallsAlpha(wallsAlpha);
    }
}
Home3DAttributesController["__class"] = "com.eteks.sweethome3d.viewcontroller.Home3DAttributesController";
Home3DAttributesController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace Home3DAttributesController {

    /**
     * The possible values for {@linkplain #getGroundPaint() ground paint type}.
     * @enum
     * @property {Home3DAttributesController.EnvironmentPaint} COLORED
     * @property {Home3DAttributesController.EnvironmentPaint} TEXTURED
     * @class
     */
    export enum EnvironmentPaint {
        COLORED, TEXTURED
    }

    /**
     * Undoable edit for 3D attributes modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class Home3DAttributesModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldGroundColor: number;

        oldGroundTexture: HomeTexture;

        oldBackgroundImageVisibleOnGround3D: boolean;

        oldSkyColor: number;

        oldSkyTexture: HomeTexture;

        oldLightColor: number;

        oldWallsAlpha: number;

        groundColor: number;

        groundTexture: HomeTexture;

        backgroundImageVisibleOnGround3D: boolean;

        skyColor: number;

        skyTexture: HomeTexture;

        lightColor: number;

        wallsAlpha: number;

        constructor(home: Home, preferences: any, oldGroundColor: number, oldGroundTexture: HomeTexture, oldBackgroundImageVisibleOnGround3D: boolean, oldSkyColor: number, oldSkyTexture: HomeTexture, oldLightColor: number, oldWallsAlpha: number, groundColor: number, groundTexture: HomeTexture, backgroundImageVisibleOnGround3D: boolean, skyColor: number, skyTexture: HomeTexture, lightColor: number, wallsAlpha: number) {
            super(preferences, Home3DAttributesController, "undoModify3DAttributesName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldGroundColor === undefined) { this.oldGroundColor = 0; }
            if (this.oldGroundTexture === undefined) { this.oldGroundTexture = null; }
            if (this.oldBackgroundImageVisibleOnGround3D === undefined) { this.oldBackgroundImageVisibleOnGround3D = false; }
            if (this.oldSkyColor === undefined) { this.oldSkyColor = 0; }
            if (this.oldSkyTexture === undefined) { this.oldSkyTexture = null; }
            if (this.oldLightColor === undefined) { this.oldLightColor = 0; }
            if (this.oldWallsAlpha === undefined) { this.oldWallsAlpha = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.backgroundImageVisibleOnGround3D === undefined) { this.backgroundImageVisibleOnGround3D = false; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.skyTexture === undefined) { this.skyTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            this.home = home;
            this.oldGroundColor = oldGroundColor;
            this.oldGroundTexture = oldGroundTexture;
            this.oldBackgroundImageVisibleOnGround3D = oldBackgroundImageVisibleOnGround3D;
            this.oldSkyColor = oldSkyColor;
            this.oldSkyTexture = oldSkyTexture;
            this.oldLightColor = oldLightColor;
            this.oldWallsAlpha = oldWallsAlpha;
            this.groundColor = groundColor;
            this.groundTexture = groundTexture;
            this.backgroundImageVisibleOnGround3D = backgroundImageVisibleOnGround3D;
            this.skyColor = skyColor;
            this.skyTexture = skyTexture;
            this.lightColor = lightColor;
            this.wallsAlpha = wallsAlpha;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            Home3DAttributesController.doModify3DAttributes(this.home, this.oldGroundColor, this.oldGroundTexture, this.oldBackgroundImageVisibleOnGround3D, this.oldSkyColor, this.oldSkyTexture, this.oldLightColor, this.oldWallsAlpha);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            Home3DAttributesController.doModify3DAttributes(this.home, this.groundColor, this.groundTexture, this.backgroundImageVisibleOnGround3D, this.skyColor, this.skyTexture, this.lightColor, this.wallsAlpha);
        }
    }
    Home3DAttributesModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.Home3DAttributesController.Home3DAttributesModificationUndoableEdit";
    Home3DAttributesModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    export class Home3DAttributesController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setGroundPaint(Home3DAttributesController.EnvironmentPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class Home3DAttributesController$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setSkyPaint(Home3DAttributesController.EnvironmentPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * Creates the controller of page setup with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 * @ignore
 */
export class PageSetupController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ pageSetupView: DialogView;

    /*private*/ print: HomePrint;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.pageSetupView === undefined) { this.pageSetupView = null; }
        if (this.print === undefined) { this.print = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.setPrint(home.getPrint());
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.pageSetupView == null) {
            this.pageSetupView = this.viewFactory.createPageSetupView(this.preferences, this);
        }
        return this.pageSetupView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Sets the edited print attributes.
     * @param {HomePrint} print
     */
    public setPrint(print: HomePrint) {
        if (print !== this.print) {
            const oldPrint: HomePrint = this.print;
            this.print = print;
            this.propertyChangeSupport.firePropertyChange(/* name */"PRINT", oldPrint, print);
        }
    }

    /**
     * Returns the edited print attributes.
     * @return {HomePrint}
     */
    public getPrint(): HomePrint {
        return this.print;
    }

    /**
     * Returns home printable levels.
     * @return {Level[]}
     */
    public getPrintableLevels(): Array<Level> {
        return this.home.getLevels();
    }

    /**
     * Controls the modification of home print attributes.
     */
    public modifyPageSetup() {
        const oldHomePrint: HomePrint = this.home.getPrint();
        const homePrint: HomePrint = this.getPrint();
        this.home.setPrint(homePrint);
        const undoableEdit: javax.swing.undo.UndoableEdit = new PageSetupController.HomePrintModificationUndoableEdit(this.home, this.preferences, oldHomePrint, homePrint);
        this.undoSupport.postEdit(undoableEdit);
    }
}
PageSetupController["__class"] = "com.eteks.sweethome3d.viewcontroller.PageSetupController";
PageSetupController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace PageSetupController {

    /**
     * Undoable edit for home print modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class HomePrintModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldHomePrint: HomePrint;

        homePrint: HomePrint;

        constructor(home: Home, preferences: any, oldHomePrint: HomePrint, homePrint: HomePrint) {
            super(preferences, PageSetupController, "undoPageSetupName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldHomePrint === undefined) { this.oldHomePrint = null; }
            if (this.homePrint === undefined) { this.homePrint = null; }
            this.home = home;
            this.oldHomePrint = oldHomePrint;
            this.homePrint = homePrint;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setPrint(this.oldHomePrint);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setPrint(this.homePrint);
        }
    }
    HomePrintModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PageSetupController.HomePrintModificationUndoableEdit";
    HomePrintModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];


}


/**
 * Creates the controller of label creation with undo support.
 * @param {Home} home
 * @param {number} x
 * @param {number} y
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class LabelController implements Controller {
    /*private*/ home: Home;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ labelView: DialogView;

    /*private*/ text: string;

    /*private*/ alignment: TextStyle.Alignment;

    /*private*/ fontName: string;

    /*private*/ fontNameSet: boolean;

    /*private*/ fontSize: number;

    /*private*/ color: number;

    /*private*/ pitch: number;

    /*private*/ pitchEnabled: boolean;

    /*private*/ elevation: number;

    public constructor(home?: any, x?: any, y?: any, preferences?: any, viewFactory?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            if (this.home === undefined) { this.home = null; }
            if (this.x === undefined) { this.x = null; }
            if (this.y === undefined) { this.y = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.labelView === undefined) { this.labelView = null; }
            if (this.text === undefined) { this.text = null; }
            if (this.alignment === undefined) { this.alignment = null; }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontNameSet === undefined) { this.fontNameSet = false; }
            if (this.fontSize === undefined) { this.fontSize = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.pitchEnabled === undefined) { this.pitchEnabled = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            this.home = home;
            this.x = x;
            this.y = y;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.alignment = TextStyle.Alignment.CENTER;
            this.fontName = preferences.getDefaultFontName();
            this.fontNameSet = true;
            this.fontSize = preferences.getDefaultTextStyle(Label).getFontSize();
            this.pitchEnabled = false;
            this.elevation = 0.0;
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((x != null && x instanceof <any>UserPreferences) || x === null) && ((y != null && (y.constructor != null && y.constructor["__interfaces"] != null && y.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || y === null) && ((preferences != null && preferences instanceof <any>javax.swing.undo.UndoableEditSupport) || preferences === null) && viewFactory === undefined && undoSupport === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let undoSupport: any = __args[3];
            if (this.home === undefined) { this.home = null; }
            if (this.x === undefined) { this.x = null; }
            if (this.y === undefined) { this.y = null; }
            if (this.preferences === undefined) { this.preferences = null; }
            if (this.viewFactory === undefined) { this.viewFactory = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.labelView === undefined) { this.labelView = null; }
            if (this.text === undefined) { this.text = null; }
            if (this.alignment === undefined) { this.alignment = null; }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontNameSet === undefined) { this.fontNameSet = false; }
            if (this.fontSize === undefined) { this.fontSize = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.pitchEnabled === undefined) { this.pitchEnabled = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            this.home = home;
            this.x = null;
            this.y = null;
            this.preferences = preferences;
            this.viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.propertyChangeSupport = new PropertyChangeSupport(this);
            this.updateProperties();
        } else throw new Error('invalid overload');
    }

    /**
     * Updates edited properties from selected labels in the home edited by this controller.
     */
    updateProperties() {
        const selectedLabels: Array<Label> = Home.getLabelsSubList(this.home.getSelectedItems());
        if (/* isEmpty */(selectedLabels.length == 0)) {
            this.setText(null);
            this.setFontName(null);
            this.fontNameSet = false;
            this.setFontSize(null);
            this.setAlignment(null);
            this.setColor(null);
            this.setPitch(null);
            this.pitchEnabled = false;
            this.setElevation(null);
        } else {
            const firstLabel: Label = /* get */selectedLabels[0];
            let text: string = firstLabel.getText();
            if (text != null) {
                for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                    {
                        if (!(text === /* get */selectedLabels[i].getText())) {
                            text = null;
                            break;
                        }
                    };
                }
            }
            this.setText(text);
            let alignment: TextStyle.Alignment = firstLabel.getStyle() != null ? firstLabel.getStyle().getAlignment() : TextStyle.Alignment.CENTER;
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    const label: Label = /* get */selectedLabels[i];
                    if (!/* Enum.equals */(<any>(alignment) === <any>(label.getStyle() != null ? label.getStyle().getAlignment() : TextStyle.Alignment.CENTER))) {
                        alignment = null;
                        break;
                    }
                };
            }
            this.setAlignment(alignment);
            const fontName: string = firstLabel.getStyle() != null ? firstLabel.getStyle().getFontName() : null;
            let fontNameSet: boolean = true;
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    const label: Label = /* get */selectedLabels[i];
                    if (!(fontName == null && (label.getStyle() == null || label.getStyle().getFontName() == null) || fontName != null && label.getStyle() != null && (fontName === label.getStyle().getFontName()))) {
                        fontNameSet = false;
                        break;
                    }
                };
            }
            this.setFontName(fontName);
            this.fontNameSet = fontNameSet;
            const labelDefaultFontSize: number = this.preferences.getDefaultTextStyle(Label).getFontSize();
            let fontSize: number = firstLabel.getStyle() != null ? firstLabel.getStyle().getFontSize() : labelDefaultFontSize;
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    const label: Label = /* get */selectedLabels[i];
                    if (!(fontSize === (label.getStyle() != null ? label.getStyle().getFontSize() : labelDefaultFontSize))) {
                        fontSize = null;
                        break;
                    }
                };
            }
            this.setFontSize(fontSize);
            let color: number = firstLabel.getColor();
            if (color != null) {
                for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                    {
                        if (!(color === /* get */selectedLabels[i].getColor())) {
                            color = null;
                            break;
                        }
                    };
                }
            }
            this.setColor(color);
            let pitch: number = firstLabel.getPitch();
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    const label: Label = /* get */selectedLabels[i];
                    if (!(pitch == null && label.getPitch() == null || pitch != null && (pitch === label.getPitch()))) {
                        pitch = null;
                        break;
                    }
                };
            }
            this.setPitch(pitch);
            let pitchEnabled: boolean = firstLabel.getPitch() != null;
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    if (!(pitchEnabled === (/* get */selectedLabels[i].getPitch() != null))) {
                        pitchEnabled = null;
                        break;
                    }
                };
            }
            this.pitchEnabled = pitchEnabled;
            let elevation: number = firstLabel.getElevation();
            for (let i: number = 1; i < /* size */(<number>selectedLabels.length); i++) {
                {
                    if (/* floatValue */elevation !== /* get */selectedLabels[i].getElevation()) {
                        elevation = null;
                        break;
                    }
                };
            }
            this.setElevation(elevation);
        }
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.labelView == null) {
            this.labelView = this.viewFactory.createLabelView(this.x == null, this.preferences, this);
        }
        return this.labelView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Sets the edited text.
     * @param {string} text
     */
    public setText(text: string) {
        if (text !== this.text) {
            const oldText: string = this.text;
            this.text = text;
            this.propertyChangeSupport.firePropertyChange(/* name */"TEXT", oldText, text);
        }
    }

    /**
     * Returns the edited text.
     * @return {string}
     */
    public getText(): string {
        return this.text;
    }

    /**
     * Sets the edited text alignment.
     * @param {TextStyle.Alignment} alignment
     */
    public setAlignment(alignment: TextStyle.Alignment) {
        if (alignment !== this.alignment) {
            const oldAlignment: TextStyle.Alignment = this.alignment;
            this.alignment = alignment;
            this.propertyChangeSupport.firePropertyChange(/* name */"ALIGNMENT", oldAlignment, alignment);
        }
    }

    /**
     * Returns the edited text alignment.
     * @return {TextStyle.Alignment}
     */
    public getAlignment(): TextStyle.Alignment {
        return this.alignment;
    }

    /**
     * Sets the edited font name.
     * @param {string} fontName
     */
    public setFontName(fontName: string) {
        if (fontName !== this.fontName) {
            const oldFontName: string = this.fontName;
            this.fontName = fontName;
            this.propertyChangeSupport.firePropertyChange(/* name */"FONT_NAME", oldFontName, fontName);
            this.fontNameSet = true;
        }
    }

    /**
     * Returns the edited font name or <code>null</code> for default system font.
     * @return {string}
     */
    public getFontName(): string {
        return this.fontName;
    }

    /**
     * Sets the edited font size.
     * @param {number} fontSize
     */
    public setFontSize(fontSize: number) {
        if (fontSize !== this.fontSize) {
            const oldFontSize: number = this.fontSize;
            this.fontSize = fontSize;
            this.propertyChangeSupport.firePropertyChange(/* name */"FONT_SIZE", oldFontSize, fontSize);
        }
    }

    /**
     * Returns the edited font size.
     * @return {number}
     */
    public getFontSize(): number {
        return this.fontSize;
    }

    /**
     * Returns <code>true</code> if all edited labels use the same font name.
     * @return {boolean}
     */
    public isFontNameSet(): boolean {
        return this.fontNameSet;
    }

    /**
     * Sets the edited color.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the edited color.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the edited pitch.
     * @param {number} pitch
     */
    public setPitch(pitch: number) {
        if (pitch !== this.pitch) {
            const oldPitch: number = this.pitch;
            this.pitch = pitch;
            this.propertyChangeSupport.firePropertyChange(/* name */"PITCH", oldPitch, pitch);
        }
        this.pitchEnabled = pitch != null;
    }

    /**
     * Returns the edited pitch.
     * @return {number}
     */
    public getPitch(): number {
        return this.pitch;
    }

    /**
     * Returns <code>Boolean.TRUE</code> if all edited labels are viewed in 3D,
     * or <code>Boolean.FALSE</code> if no label is viewed in 3D.
     * @return {boolean}
     */
    public isPitchEnabled(): boolean {
        return this.pitchEnabled;
    }

    /**
     * Sets the edited elevation.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns the edited elevation.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    public createLabel$java_lang_String$float$float(text: string, x: number, y: number): Label {
        const label: Label = new Label(text, x, y);
        this.home.addLabel(label);
        return label;
    }

    /**
     * Returns a new label instance placed at the given coordinates and added to home.
     * @param {string} text
     * @param {number} x
     * @param {number} y
     * @return {Label}
     */
    public createLabel(text?: any, x?: any, y?: any): any {
        if (((typeof text === 'string') || text === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            return <any>this.createLabel$java_lang_String$float$float(text, x, y);
        } else if (text === undefined && x === undefined && y === undefined) {
            return <any>this.createLabel$();
        } else throw new Error('invalid overload');
    }

    public createLabel$() {
        const text: string = this.getText();
        if (text != null && text.trim().length > 0) {
            const oldSelection: Array<Selectable> = this.home.getSelectedItems();
            const basePlanLocked: boolean = this.home.isBasePlanLocked();
            const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
            const label: Label = this.createLabel$java_lang_String$float$float(text, this.x, this.y);
            const alignment: TextStyle.Alignment = this.getAlignment();
            const fontName: string = this.getFontName();
            const fontSize: number = this.getFontSize();
            if (fontName != null || fontSize != null || this.getPitch() != null) {
                let style: TextStyle = this.preferences.getDefaultTextStyle(Label);
                if (fontName != null) {
                    style = style.deriveStyle$java_lang_String(fontName);
                }
                if (fontSize != null) {
                    style = style.deriveStyle$float(fontSize);
                }
                if (alignment != null) {
                    style = style.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(alignment);
                }
                label.setStyle(style);
            }
            if (this.color != null) {
                label.setColor(this.color);
            }
            label.setColor(this.getColor());
            label.setPitch(this.getPitch());
            label.setElevation(this.getElevation());
            const newBasePlanLocked: boolean = basePlanLocked && !this.isLabelPartOfBasePlan(label);
            LabelController.doAddAndSelectLabel(this.home, label, false, newBasePlanLocked);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new LabelController.LabelCreationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), basePlanLocked, allLevelsSelection, label, newBasePlanLocked);
                this.undoSupport.postEdit(undoableEdit);
            }
            if (text.indexOf('\n') < 0) {
                this.preferences.addAutoCompletionString("LabelText", text);
            }
        }
    }

    /**
     * Adds label to home and selects it.
     * @param {Home} home
     * @param {Label} label
     * @param {boolean} addToHome
     * @param {boolean} basePlanLocked
     * @private
     */
    static doAddAndSelectLabel(home: Home, label: Label, addToHome: boolean, basePlanLocked: boolean) {
        if (addToHome) {
            home.addLabel(label);
        }
        home.setBasePlanLocked(basePlanLocked);
        home.setSelectedItems(/* asList */[label].slice(0));
        home.setAllLevelsSelection(false);
    }

    /**
     * Deletes label from home.
     * @param {Home} home
     * @param {Label} label
     * @param {boolean} basePlanLocked
     * @private
     */
    static doDeleteLabel(home: Home, label: Label, basePlanLocked: boolean) {
        home.deleteLabel(label);
        home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Returns <code>true</code>.
     * @param {Label} label
     * @return {boolean}
     */
    isLabelPartOfBasePlan(label: Label): boolean {
        return true;
    }

    /**
     * Controls the modification of selected labels.
     */
    public modifyLabels() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedLabels: Array<Label> = Home.getLabelsSubList(oldSelection);
        if (!/* isEmpty */(selectedLabels.length == 0)) {
            let text: string = this.getText();
            if (text != null && text.trim().length === 0) {
                text = null;
            }
            const alignment: TextStyle.Alignment = this.getAlignment();
            const fontName: string = this.getFontName();
            const fontNameSet: boolean = this.isFontNameSet();
            const fontSize: number = this.getFontSize();
            const color: number = this.getColor();
            const pitch: number = this.getPitch();
            const pitchEnabled: boolean = this.isPitchEnabled();
            const elevation: number = this.getElevation();
            const modifiedLabels: LabelController.ModifiedLabel[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedLabels.length));
            for (let i: number = 0; i < modifiedLabels.length; i++) {
                {
                    modifiedLabels[i] = new LabelController.ModifiedLabel(/* get */selectedLabels[i]);
                };
            }
            const defaultStyle: TextStyle = this.preferences.getDefaultTextStyle(Label);
            LabelController.doModifyLabels(modifiedLabels, text, alignment, fontName, fontNameSet, fontSize, defaultStyle, color, pitch, pitchEnabled, elevation);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new LabelController.LabelModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), modifiedLabels, text, alignment, fontName, fontNameSet, fontSize, defaultStyle, color, pitch, pitchEnabled, elevation);
                this.undoSupport.postEdit(undoableEdit);
            }
            if (text != null && text.indexOf('\n') < 0) {
                this.preferences.addAutoCompletionString("LabelText", text);
            }
        }
    }

    /**
     * Modifies labels properties with the values in parameter.
     * @param {com.eteks.sweethome3d.viewcontroller.LabelController.ModifiedLabel[]} modifiedLabels
     * @param {string} text
     * @param {TextStyle.Alignment} alignment
     * @param {string} fontName
     * @param {boolean} fontNameSet
     * @param {number} fontSize
     * @param {TextStyle} defaultStyle
     * @param {number} color
     * @param {number} pitch
     * @param {boolean} pitchEnabled
     * @param {number} elevation
     * @private
     */
    static doModifyLabels(modifiedLabels: LabelController.ModifiedLabel[], text: string, alignment: TextStyle.Alignment, fontName: string, fontNameSet: boolean, fontSize: number, defaultStyle: TextStyle, color: number, pitch: number, pitchEnabled: boolean, elevation: number) {
        for (let index = 0; index < modifiedLabels.length; index++) {
            let modifiedLabel = modifiedLabels[index];
            {
                const label: Label = modifiedLabel.getLabel();
                if (text != null) {
                    label.setText(text);
                }
                if (alignment != null) {
                    label.setStyle(label.getStyle() != null ? label.getStyle().deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(alignment) : defaultStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(alignment));
                }
                if (fontNameSet) {
                    label.setStyle(label.getStyle() != null ? label.getStyle().deriveStyle$java_lang_String(fontName) : defaultStyle.deriveStyle$java_lang_String(fontName));
                }
                if (fontSize != null) {
                    label.setStyle(label.getStyle() != null ? label.getStyle().deriveStyle$float(fontSize) : defaultStyle.deriveStyle$float(fontSize));
                }
                if (color != null) {
                    label.setColor(color);
                }
                if (pitchEnabled != null) {
                    if (false === pitchEnabled) {
                        label.setPitch(null);
                    } else if (pitch != null) {
                        label.setPitch(pitch);
                        if (label.getStyle() == null) {
                            label.setStyle(defaultStyle);
                        }
                    }
                }
                if (elevation != null) {
                    label.setElevation(elevation);
                }
            }
        }
    }

    /**
     * Restores label properties from the values stored in <code>modifiedLabels</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.LabelController.ModifiedLabel[]} modifiedLabels
     * @private
     */
    static undoModifyLabels(modifiedLabels: LabelController.ModifiedLabel[]) {
        for (let index = 0; index < modifiedLabels.length; index++) {
            let modifiedPiece = modifiedLabels[index];
            {
                modifiedPiece.reset();
            }
        }
    }
}
LabelController["__class"] = "com.eteks.sweethome3d.viewcontroller.LabelController";
LabelController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace LabelController {

    /**
     * Undoable edit for label creation. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class LabelCreationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        label: Label;

        newBasePlanLocked: boolean;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, label: Label, newBasePlanLocked: boolean) {
            super(preferences, LabelController, "undoCreateLabelName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.label === undefined) { this.label = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.label = label;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            LabelController.doDeleteLabel(this.home, this.label, this.oldBasePlanLocked);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
            this.home.setAllLevelsSelection(this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            LabelController.doAddAndSelectLabel(this.home, this.label, true, this.newBasePlanLocked);
        }
    }
    LabelCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.LabelController.LabelCreationUndoableEdit";
    LabelCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for label modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class LabelModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        modifiedLabels: LabelController.ModifiedLabel[];

        text: string;

        alignment: TextStyle.Alignment;

        fontName: string;

        fontNameSet: boolean;

        fontSize: number;

        defaultStyle: TextStyle;

        color: number;

        pitch: number;

        pitchEnabled: boolean;

        elevation: number;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], modifiedLabels: LabelController.ModifiedLabel[], text: string, alignment: TextStyle.Alignment, fontName: string, fontNameSet: boolean, fontSize: number, defaultStyle: TextStyle, color: number, pitch: number, pitchEnabled: boolean, elevation: number) {
            super(preferences, LabelController, "undoModifyLabelsName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.modifiedLabels === undefined) { this.modifiedLabels = null; }
            if (this.text === undefined) { this.text = null; }
            if (this.alignment === undefined) { this.alignment = null; }
            if (this.fontName === undefined) { this.fontName = null; }
            if (this.fontNameSet === undefined) { this.fontNameSet = false; }
            if (this.fontSize === undefined) { this.fontSize = null; }
            if (this.defaultStyle === undefined) { this.defaultStyle = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.pitchEnabled === undefined) { this.pitchEnabled = null; }
            if (this.elevation === undefined) { this.elevation = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.modifiedLabels = modifiedLabels;
            this.text = text;
            this.alignment = alignment;
            this.fontName = fontName;
            this.fontNameSet = fontNameSet;
            this.fontSize = fontSize;
            this.defaultStyle = defaultStyle;
            this.color = color;
            this.pitch = pitch;
            this.pitchEnabled = pitchEnabled;
            this.elevation = elevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            LabelController.undoModifyLabels(this.modifiedLabels);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            LabelController.doModifyLabels(this.modifiedLabels, this.text, this.alignment, this.fontName, this.fontNameSet, this.fontSize, this.defaultStyle, this.color, this.pitch, this.pitchEnabled, this.elevation);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }
    }
    LabelModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.LabelController.LabelModificationUndoableEdit";
    LabelModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified label.
     * @param {Label} label
     * @class
     */
    export class ModifiedLabel {
        label: Label;

        text: string;

        style: TextStyle;

        color: number;

        pitch: number;

        elevation: number;

        public constructor(label: Label) {
            if (this.label === undefined) { this.label = null; }
            if (this.text === undefined) { this.text = null; }
            if (this.style === undefined) { this.style = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.pitch === undefined) { this.pitch = null; }
            if (this.elevation === undefined) { this.elevation = 0; }
            this.label = label;
            this.text = label.getText();
            this.style = label.getStyle();
            this.color = label.getColor();
            this.pitch = label.getPitch();
            this.elevation = label.getElevation();
        }

        public getLabel(): Label {
            return this.label;
        }

        public reset() {
            this.label.setText(this.text);
            this.label.setStyle(this.style);
            this.label.setColor(this.color);
            this.label.setPitch(this.pitch);
            this.label.setElevation(this.elevation);
        }
    }
    ModifiedLabel["__class"] = "com.eteks.sweethome3d.viewcontroller.LabelController.ModifiedLabel";

}


/**
 * Creates the controller of wall view with undo support.
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @author Emmanuel Puybaret
 */
export class WallController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ leftSideTextureController: TextureChoiceController;

    /*private*/ leftSideBaseboardController: BaseboardChoiceController;

    /*private*/ rightSideTextureController: TextureChoiceController;

    /*private*/ rightSideBaseboardController: BaseboardChoiceController;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ wallView: DialogView;

    /*private*/ editablePoints: boolean;

    /*private*/ xStart: number;

    /*private*/ yStart: number;

    /*private*/ xEnd: number;

    /*private*/ yEnd: number;

    /*private*/ length: number;

    /*private*/ distanceToEndPoint: number;

    /*private*/ leftSideColor: number;

    /*private*/ leftSidePaint: WallController.WallPaint;

    /*private*/ leftSideShininess: number;

    /*private*/ rightSideColor: number;

    /*private*/ rightSidePaint: WallController.WallPaint;

    /*private*/ rightSideShininess: number;

    /*private*/ pattern: TextureImage;

    /*private*/ topColor: number;

    /*private*/ topPaint: WallController.WallPaint;

    /*private*/ shape: WallController.WallShape;

    /*private*/ rectangularWallHeight: number;

    /*private*/ slopingWallHeightAtStart: number;

    /*private*/ sloppingWallHeightAtEnd: number;

    /*private*/ thickness: number;

    /*private*/ arcExtentInDegrees: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.leftSideTextureController === undefined) { this.leftSideTextureController = null; }
        if (this.leftSideBaseboardController === undefined) { this.leftSideBaseboardController = null; }
        if (this.rightSideTextureController === undefined) { this.rightSideTextureController = null; }
        if (this.rightSideBaseboardController === undefined) { this.rightSideBaseboardController = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.wallView === undefined) { this.wallView = null; }
        if (this.editablePoints === undefined) { this.editablePoints = false; }
        if (this.xStart === undefined) { this.xStart = null; }
        if (this.yStart === undefined) { this.yStart = null; }
        if (this.xEnd === undefined) { this.xEnd = null; }
        if (this.yEnd === undefined) { this.yEnd = null; }
        if (this.length === undefined) { this.length = null; }
        if (this.distanceToEndPoint === undefined) { this.distanceToEndPoint = null; }
        if (this.leftSideColor === undefined) { this.leftSideColor = null; }
        if (this.leftSidePaint === undefined) { this.leftSidePaint = null; }
        if (this.leftSideShininess === undefined) { this.leftSideShininess = null; }
        if (this.rightSideColor === undefined) { this.rightSideColor = null; }
        if (this.rightSidePaint === undefined) { this.rightSidePaint = null; }
        if (this.rightSideShininess === undefined) { this.rightSideShininess = null; }
        if (this.pattern === undefined) { this.pattern = null; }
        if (this.topColor === undefined) { this.topColor = null; }
        if (this.topPaint === undefined) { this.topPaint = null; }
        if (this.shape === undefined) { this.shape = null; }
        if (this.rectangularWallHeight === undefined) { this.rectangularWallHeight = null; }
        if (this.slopingWallHeightAtStart === undefined) { this.slopingWallHeightAtStart = null; }
        if (this.sloppingWallHeightAtEnd === undefined) { this.sloppingWallHeightAtEnd = null; }
        if (this.thickness === undefined) { this.thickness = null; }
        if (this.arcExtentInDegrees === undefined) { this.arcExtentInDegrees = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the texture controller of the wall left side.
     * @return {TextureChoiceController}
     */
    public getLeftSideTextureController(): TextureChoiceController {
        if (this.leftSideTextureController == null) {
            this.leftSideTextureController = new TextureChoiceController(this.preferences.getLocalizedString(WallController, "leftSideTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.leftSideTextureController.addPropertyChangeListener("TEXTURE", new WallController.WallController$0(this));
        }
        return this.leftSideTextureController;
    }

    /**
     * Returns the controller of the wall left side baseboard.
     * @return {BaseboardChoiceController}
     */
    public getLeftSideBaseboardController(): BaseboardChoiceController {
        if (this.leftSideBaseboardController == null) {
            this.leftSideBaseboardController = new BaseboardChoiceController(this.preferences, this.viewFactory, this.contentManager);
        }
        return this.leftSideBaseboardController;
    }

    /**
     * Returns the texture controller of the wall right side.
     * @return {TextureChoiceController}
     */
    public getRightSideTextureController(): TextureChoiceController {
        if (this.rightSideTextureController == null) {
            this.rightSideTextureController = new TextureChoiceController(this.preferences.getLocalizedString(WallController, "rightSideTextureTitle"), this.preferences, this.viewFactory, this.contentManager);
            this.rightSideTextureController.addPropertyChangeListener("TEXTURE", new WallController.WallController$1(this));
        }
        return this.rightSideTextureController;
    }

    /**
     * Returns the controller of the wall right side baseboard.
     * @return {BaseboardChoiceController}
     */
    public getRightSideBaseboardController(): BaseboardChoiceController {
        if (this.rightSideBaseboardController == null) {
            this.rightSideBaseboardController = new BaseboardChoiceController(this.preferences, this.viewFactory, this.contentManager);
        }
        return this.rightSideBaseboardController;
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.wallView == null) {
            this.wallView = this.viewFactory.createWallView(this.preferences, this);
        }
        return this.wallView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates edited properties from selected walls in the home edited by this controller.
     */
    updateProperties() {
        const selectedWalls: Array<Wall> = Home.getWallsSubList(this.home.getSelectedItems());
        if (/* isEmpty */(selectedWalls.length == 0)) {
            this.setXStart(null);
            this.setYStart(null);
            this.setXEnd(null);
            this.setYEnd(null);
            this.setEditablePoints(false);
            this.setLeftSideColor(null);
            this.getLeftSideTextureController().setTexture(null);
            this.setLeftSidePaint(null);
            this.setLeftSideShininess(null);
            this.getLeftSideBaseboardController().setVisible(null);
            this.getLeftSideBaseboardController().setThickness(null);
            this.getLeftSideBaseboardController().setHeight(null);
            this.getLeftSideBaseboardController().setColor(null);
            this.getLeftSideBaseboardController().getTextureController().setTexture(null);
            this.getLeftSideBaseboardController().setPaint(null);
            this.setRightSideColor(null);
            this.getRightSideTextureController().setTexture(null);
            this.setRightSidePaint(null);
            this.setRightSideShininess(null);
            this.getRightSideBaseboardController().setVisible(null);
            this.getRightSideBaseboardController().setThickness(null);
            this.getRightSideBaseboardController().setHeight(null);
            this.getRightSideBaseboardController().setColor(null);
            this.getRightSideBaseboardController().getTextureController().setTexture(null);
            this.getRightSideBaseboardController().setPaint(null);
            this.setPattern(null);
            this.setTopColor(null);
            this.setTopPaint(null);
            this.setRectangularWallHeight(null);
            this.setSlopingWallHeightAtStart(null);
            this.setSlopingWallHeightAtEnd(null);
            this.setShape(null);
            this.setThickness(null);
            this.setArcExtentInDegrees(null);
        } else {
            const firstWall: Wall = /* get */selectedWalls[0];
            const multipleSelection: boolean = /* size */(<number>selectedWalls.length) > 1;
            this.setEditablePoints(!multipleSelection);
            let xStart: number = firstWall.getXStart();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(xStart === /* get */selectedWalls[i].getXStart())) {
                        xStart = null;
                        break;
                    }
                };
            }
            this.setXStart(xStart);
            let yStart: number = firstWall.getYStart();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(yStart === /* get */selectedWalls[i].getYStart())) {
                        yStart = null;
                        break;
                    }
                };
            }
            this.setYStart(yStart);
            let xEnd: number = firstWall.getXEnd();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(xEnd === /* get */selectedWalls[i].getXEnd())) {
                        xEnd = null;
                        break;
                    }
                };
            }
            this.setXEnd(xEnd);
            let yEnd: number = firstWall.getYEnd();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(yEnd === /* get */selectedWalls[i].getYEnd())) {
                        yEnd = null;
                        break;
                    }
                };
            }
            this.setYEnd(yEnd);
            let leftSideColor: number = firstWall.getLeftSideColor();
            if (leftSideColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!(leftSideColor === /* get */selectedWalls[i].getLeftSideColor())) {
                            leftSideColor = null;
                            break;
                        }
                    };
                }
            }
            this.setLeftSideColor(leftSideColor);
            let leftSideTexture: HomeTexture = firstWall.getLeftSideTexture();
            if (leftSideTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!leftSideTexture.equals(/* get */selectedWalls[i].getLeftSideTexture())) {
                            leftSideTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getLeftSideTextureController().setTexture(leftSideTexture);
            let defaultColorsAndTextures: boolean = true;
            for (let i: number = 0; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const wall: Wall = /* get */selectedWalls[i];
                    if (wall.getLeftSideColor() != null || wall.getLeftSideTexture() != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (leftSideColor != null) {
                this.setLeftSidePaint(WallController.WallPaint.COLORED);
            } else if (leftSideTexture != null) {
                this.setLeftSidePaint(WallController.WallPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.setLeftSidePaint(WallController.WallPaint.DEFAULT);
            } else {
                this.setLeftSidePaint(null);
            }
            let leftSideShininess: number = firstWall.getLeftSideShininess();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(leftSideShininess === /* get */selectedWalls[i].getLeftSideShininess())) {
                        leftSideShininess = null;
                        break;
                    }
                };
            }
            this.setLeftSideShininess(leftSideShininess);
            let leftSideBaseboardVisible: boolean = firstWall.getLeftSideBaseboard() != null;
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (leftSideBaseboardVisible !== (/* get */selectedWalls[i].getLeftSideBaseboard() != null)) {
                        leftSideBaseboardVisible = null;
                        break;
                    }
                };
            }
            this.getLeftSideBaseboardController().setVisible(leftSideBaseboardVisible);
            const firstWallLeftSideBaseboard: Baseboard = firstWall.getLeftSideBaseboard();
            let leftSideBaseboardThickness: number = firstWallLeftSideBaseboard != null ? firstWallLeftSideBaseboard.getThickness() : this.preferences.getNewWallBaseboardThickness();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getLeftSideBaseboard();
                    if (!(leftSideBaseboardThickness === (baseboard != null ? baseboard.getThickness() : this.preferences.getNewWallBaseboardThickness()))) {
                        leftSideBaseboardThickness = null;
                        break;
                    }
                };
            }
            this.getLeftSideBaseboardController().setThickness(leftSideBaseboardThickness);
            let leftSideBaseboardHeight: number = firstWallLeftSideBaseboard != null ? firstWallLeftSideBaseboard.getHeight() : this.preferences.getNewWallBaseboardHeight();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getLeftSideBaseboard();
                    if (!(leftSideBaseboardHeight === (baseboard != null ? baseboard.getHeight() : this.preferences.getNewWallBaseboardHeight()))) {
                        leftSideBaseboardHeight = null;
                        break;
                    }
                };
            }
            this.getLeftSideBaseboardController().setHeight(leftSideBaseboardHeight);
            let leftSideBaseboardColor: number = firstWallLeftSideBaseboard != null ? firstWallLeftSideBaseboard.getColor() : null;
            if (leftSideBaseboardColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        const baseboard: Baseboard = /* get */selectedWalls[i].getLeftSideBaseboard();
                        if (baseboard == null || !(leftSideBaseboardColor === baseboard.getColor())) {
                            leftSideBaseboardColor = null;
                            break;
                        }
                    };
                }
            }
            this.getLeftSideBaseboardController().setColor(leftSideBaseboardColor);
            let leftSideBaseboardTexture: HomeTexture = firstWallLeftSideBaseboard != null ? firstWallLeftSideBaseboard.getTexture() : null;
            if (leftSideBaseboardTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        const baseboard: Baseboard = /* get */selectedWalls[i].getLeftSideBaseboard();
                        if (baseboard == null || !leftSideBaseboardTexture.equals(baseboard.getTexture())) {
                            leftSideBaseboardTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getLeftSideBaseboardController().getTextureController().setTexture(leftSideBaseboardTexture);
            defaultColorsAndTextures = true;
            for (let i: number = 0; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getLeftSideBaseboard();
                    if (baseboard != null && (baseboard.getColor() != null || baseboard.getTexture() != null)) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (leftSideBaseboardColor != null) {
                this.getLeftSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.COLORED);
            } else if (leftSideBaseboardTexture != null) {
                this.getLeftSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.getLeftSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.DEFAULT);
            } else {
                this.getLeftSideBaseboardController().setPaint(null);
            }
            let rightSideColor: number = firstWall.getRightSideColor();
            if (rightSideColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!(rightSideColor === /* get */selectedWalls[i].getRightSideColor())) {
                            rightSideColor = null;
                            break;
                        }
                    };
                }
            }
            this.setRightSideColor(rightSideColor);
            let rightSideTexture: HomeTexture = firstWall.getRightSideTexture();
            if (rightSideTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!rightSideTexture.equals(/* get */selectedWalls[i].getRightSideTexture())) {
                            rightSideTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getRightSideTextureController().setTexture(rightSideTexture);
            defaultColorsAndTextures = true;
            for (let i: number = 0; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const wall: Wall = /* get */selectedWalls[i];
                    if (wall.getRightSideColor() != null || wall.getRightSideTexture() != null) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (rightSideColor != null) {
                this.setRightSidePaint(WallController.WallPaint.COLORED);
            } else if (rightSideTexture != null) {
                this.setRightSidePaint(WallController.WallPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.setRightSidePaint(WallController.WallPaint.DEFAULT);
            } else {
                this.setRightSidePaint(null);
            }
            let rightSideShininess: number = firstWall.getRightSideShininess();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!(rightSideShininess === /* get */selectedWalls[i].getRightSideShininess())) {
                        rightSideShininess = null;
                        break;
                    }
                };
            }
            this.setRightSideShininess(rightSideShininess);
            let rightSideBaseboardVisible: boolean = firstWall.getRightSideBaseboard() != null;
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (rightSideBaseboardVisible !== (/* get */selectedWalls[i].getRightSideBaseboard() != null)) {
                        rightSideBaseboardVisible = null;
                        break;
                    }
                };
            }
            this.getRightSideBaseboardController().setVisible(rightSideBaseboardVisible);
            const firstWallRightSideBaseboard: Baseboard = firstWall.getRightSideBaseboard();
            let rightSideBaseboardThickness: number = firstWallRightSideBaseboard != null ? firstWallRightSideBaseboard.getThickness() : this.preferences.getNewWallBaseboardThickness();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getRightSideBaseboard();
                    if (!(rightSideBaseboardThickness === (baseboard != null ? baseboard.getThickness() : this.preferences.getNewWallBaseboardThickness()))) {
                        rightSideBaseboardThickness = null;
                        break;
                    }
                };
            }
            this.getRightSideBaseboardController().setThickness(rightSideBaseboardThickness);
            let rightSideBaseboardHeight: number = firstWallRightSideBaseboard != null ? firstWallRightSideBaseboard.getHeight() : this.preferences.getNewWallBaseboardHeight();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getRightSideBaseboard();
                    if (!(rightSideBaseboardHeight === (baseboard != null ? baseboard.getHeight() : this.preferences.getNewWallBaseboardHeight()))) {
                        rightSideBaseboardHeight = null;
                        break;
                    }
                };
            }
            this.getRightSideBaseboardController().setHeight(rightSideBaseboardHeight);
            let rightSideBaseboardColor: number = firstWallRightSideBaseboard != null ? firstWallRightSideBaseboard.getColor() : null;
            if (rightSideBaseboardColor != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        const baseboard: Baseboard = /* get */selectedWalls[i].getRightSideBaseboard();
                        if (baseboard == null || !(rightSideBaseboardColor === baseboard.getColor())) {
                            rightSideBaseboardColor = null;
                            break;
                        }
                    };
                }
            }
            this.getRightSideBaseboardController().setColor(rightSideBaseboardColor);
            let rightSideBaseboardTexture: HomeTexture = firstWallRightSideBaseboard != null ? firstWallRightSideBaseboard.getTexture() : null;
            if (rightSideBaseboardTexture != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        const baseboard: Baseboard = /* get */selectedWalls[i].getRightSideBaseboard();
                        if (baseboard == null || !rightSideBaseboardTexture.equals(baseboard.getTexture())) {
                            rightSideBaseboardTexture = null;
                            break;
                        }
                    };
                }
            }
            this.getRightSideBaseboardController().getTextureController().setTexture(rightSideBaseboardTexture);
            defaultColorsAndTextures = true;
            for (let i: number = 0; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const baseboard: Baseboard = /* get */selectedWalls[i].getRightSideBaseboard();
                    if (baseboard != null && (baseboard.getColor() != null || baseboard.getTexture() != null)) {
                        defaultColorsAndTextures = false;
                        break;
                    }
                };
            }
            if (rightSideBaseboardColor != null) {
                this.getRightSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.COLORED);
            } else if (rightSideBaseboardTexture != null) {
                this.getRightSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.TEXTURED);
            } else if (defaultColorsAndTextures) {
                this.getRightSideBaseboardController().setPaint(BaseboardChoiceController.BaseboardPaint.DEFAULT);
            } else {
                this.getRightSideBaseboardController().setPaint(null);
            }
            let pattern: TextureImage = firstWall.getPattern();
            if (pattern == null) {
                pattern = this.preferences.getWallPattern();
            }
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    let otherPattern: TextureImage = /* get */selectedWalls[i].getPattern();
                    if (otherPattern == null) {
                        otherPattern = this.preferences.getWallPattern();
                    }
                    if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(pattern, otherPattern))) {
                        pattern = null;
                        break;
                    }
                };
            }
            this.setPattern(pattern);
            let topColor: number = firstWall.getTopColor();
            let defaultTopColor: boolean;
            if (topColor != null) {
                defaultTopColor = false;
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!(topColor === /* get */selectedWalls[i].getTopColor())) {
                            topColor = null;
                            break;
                        }
                    };
                }
            } else {
                defaultTopColor = true;
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (/* get */selectedWalls[i].getTopColor() != null) {
                            defaultTopColor = false;
                            break;
                        }
                    };
                }
            }
            this.setTopColor(topColor);
            if (defaultTopColor) {
                this.setTopPaint(WallController.WallPaint.DEFAULT);
            } else if (topColor != null) {
                this.setTopPaint(WallController.WallPaint.COLORED);
            } else {
                this.setTopPaint(null);
            }
            let height: number = firstWall.getHeight();
            if (height == null && firstWall.getHeight() == null) {
                height = this.home.getWallHeight();
            }
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    const wall: Wall = /* get */selectedWalls[i];
                    const wallHeight: number = wall.getHeight() == null ? this.home.getWallHeight() : wall.getHeight();
                    if (height !== wallHeight) {
                        height = null;
                        break;
                    }
                };
            }
            this.setRectangularWallHeight(height);
            this.setSlopingWallHeightAtStart(height);
            let heightAtEnd: number = firstWall.getHeightAtEnd();
            if (heightAtEnd != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!(heightAtEnd === /* get */selectedWalls[i].getHeightAtEnd())) {
                            heightAtEnd = null;
                            break;
                        }
                    };
                }
            }
            this.setSlopingWallHeightAtEnd(heightAtEnd == null && /* size */(<number>selectedWalls.length) === 1 ? height : heightAtEnd);
            let allWallsRectangular: boolean = !firstWall.isTrapezoidal();
            let allWallsTrapezoidal: boolean = firstWall.isTrapezoidal();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (!/* get */selectedWalls[i].isTrapezoidal()) {
                        allWallsTrapezoidal = false;
                    } else {
                        allWallsRectangular = false;
                    }
                };
            }
            if (allWallsRectangular) {
                this.setShape(WallController.WallShape.RECTANGULAR_WALL);
            } else if (allWallsTrapezoidal) {
                this.setShape(WallController.WallShape.SLOPING_WALL);
            } else {
                this.setShape(null);
            }
            let thickness: number = firstWall.getThickness();
            for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                {
                    if (thickness !== /* get */selectedWalls[i].getThickness()) {
                        thickness = null;
                        break;
                    }
                };
            }
            this.setThickness(thickness);
            let arcExtent: number = firstWall.getArcExtent();
            if (arcExtent != null) {
                for (let i: number = 1; i < /* size */(<number>selectedWalls.length); i++) {
                    {
                        if (!(arcExtent === /* get */selectedWalls[i].getArcExtent())) {
                            arcExtent = null;
                            break;
                        }
                    };
                }
            }
            if (arcExtent != null) {
                this.setArcExtentInDegrees(<number>/* toDegrees */(x => x * 180 / Math.PI)(arcExtent));
            } else {
                this.setArcExtentInDegrees(/* size */(<number>selectedWalls.length) === 1 ? new Number(0).valueOf() : null);
            }
        }
    }

    /**
     * Sets the edited abscissa of the start point.
     * @param {number} xStart
     */
    public setXStart(xStart: number) {
        if (xStart !== this.xStart) {
            const oldXStart: number = this.xStart;
            this.xStart = xStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"X_START", oldXStart, xStart);
            this.updateLength();
            this.updateDistanceToEndPoint();
        }
    }

    /**
     * Returns the edited abscissa of the start point.
     * @return {number}
     */
    public getXStart(): number {
        return this.xStart;
    }

    /**
     * Sets the edited ordinate of the start point.
     * @param {number} yStart
     */
    public setYStart(yStart: number) {
        if (yStart !== this.yStart) {
            const oldYStart: number = this.yStart;
            this.yStart = yStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y_START", oldYStart, yStart);
            this.updateLength();
            this.updateDistanceToEndPoint();
        }
    }

    /**
     * Returns the edited ordinate of the start point.
     * @return {number}
     */
    public getYStart(): number {
        return this.yStart;
    }

    /**
     * Sets the edited abscissa of the end point.
     * @param {number} xEnd
     */
    public setXEnd(xEnd: number) {
        if (xEnd !== this.xEnd) {
            const oldXEnd: number = this.xEnd;
            this.xEnd = xEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"X_END", oldXEnd, xEnd);
            this.updateLength();
            this.updateDistanceToEndPoint();
        }
    }

    /**
     * Returns the edited abscissa of the end point.
     * @return {number}
     */
    public getXEnd(): number {
        return this.xEnd;
    }

    /**
     * Sets the edited ordinate of the end point.
     * @param {number} yEnd
     */
    public setYEnd(yEnd: number) {
        if (yEnd !== this.yEnd) {
            const oldYEnd: number = this.yEnd;
            this.yEnd = yEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y_END", oldYEnd, yEnd);
            this.updateLength();
            this.updateDistanceToEndPoint();
        }
    }

    /**
     * Returns the edited ordinate of the end point.
     * @return {number}
     */
    public getYEnd(): number {
        return this.yEnd;
    }

    /**
     * Updates the edited length after its coordinates change.
     * @private
     */
    updateLength() {
        const xStart: number = this.getXStart();
        const yStart: number = this.getYStart();
        const xEnd: number = this.getXEnd();
        const yEnd: number = this.getYEnd();
        if (xStart != null && yStart != null && xEnd != null && yEnd != null) {
            const wall: Wall = new Wall(xStart, yStart, xEnd, yEnd, 0, 0);
            const arcExtent: number = this.getArcExtentInDegrees();
            if (arcExtent != null) {
                wall.setArcExtent(<number>/* toRadians */(x => x * Math.PI / 180)(arcExtent));
            }
            this.setLength(wall.getLength(), false);
        } else {
            this.setLength(null, false);
        }
    }

    /**
     * Returns the edited length.
     * @return {number}
     */
    public getLength(): number {
        return this.length;
    }

    public setLength(length: number, updateEndPoint: boolean = true) {
        if (length !== this.length) {
            const oldLength: number = this.length;
            this.length = length;
            this.propertyChangeSupport.firePropertyChange(/* name */"LENGTH", oldLength, length);
            if (updateEndPoint) {
                const xStart: number = this.getXStart();
                const yStart: number = this.getYStart();
                const xEnd: number = this.getXEnd();
                const yEnd: number = this.getYEnd();
                if (xStart != null && yStart != null && xEnd != null && yEnd != null && length != null) {
                    if (this.getArcExtentInDegrees() != null && /* floatValue */this.getArcExtentInDegrees() === 0) {
                        const wallAngle: number = Math.atan2(yStart - yEnd, xEnd - xStart);
                        this.setXEnd(<number>(xStart + length * Math.cos(wallAngle)));
                        this.setYEnd(<number>(yStart - length * Math.sin(wallAngle)));
                    } else {
                        throw new UnsupportedOperationException("Computing end point of a round wall from its length not supported");
                    }
                } else {
                    this.setXEnd(null);
                    this.setYEnd(null);
                }
            }
        }
    }

    /**
     * Updates the edited distance to end point after its coordinates change.
     * @private
     */
    updateDistanceToEndPoint() {
        const xStart: number = this.getXStart();
        const yStart: number = this.getYStart();
        const xEnd: number = this.getXEnd();
        const yEnd: number = this.getYEnd();
        if (xStart != null && yStart != null && xEnd != null && yEnd != null) {
            this.setDistanceToEndPoint(<number>java.awt.geom.Point2D.distance(xStart, yStart, xEnd, yEnd), false);
        } else {
            this.setDistanceToEndPoint(null, false);
        }
    }

    public setDistanceToEndPoint(distanceToEndPoint: number, updateEndPoint: boolean = true) {
        if (distanceToEndPoint !== this.distanceToEndPoint) {
            const oldDistance: number = this.distanceToEndPoint;
            this.distanceToEndPoint = distanceToEndPoint;
            this.propertyChangeSupport.firePropertyChange(/* name */"DISTANCE_TO_END_POINT", oldDistance, distanceToEndPoint);
            if (updateEndPoint) {
                const xStart: number = this.getXStart();
                const yStart: number = this.getYStart();
                const xEnd: number = this.getXEnd();
                const yEnd: number = this.getYEnd();
                if (xStart != null && yStart != null && xEnd != null && yEnd != null && distanceToEndPoint != null) {
                    const wallAngle: number = Math.atan2(yStart - yEnd, xEnd - xStart);
                    this.setXEnd(<number>(xStart + distanceToEndPoint * Math.cos(wallAngle)));
                    this.setYEnd(<number>(yStart - distanceToEndPoint * Math.sin(wallAngle)));
                } else {
                    this.setXEnd(null);
                    this.setYEnd(null);
                }
            }
        }
    }

    /**
     * Returns the edited distance to end point.
     * @return {number}
     */
    public getDistanceToEndPoint(): number {
        return this.distanceToEndPoint;
    }

    /**
     * Sets whether the point coordinates can be be edited or not.
     * @param {boolean} editablePoints
     */
    public setEditablePoints(editablePoints: boolean) {
        if (editablePoints !== this.editablePoints) {
            this.editablePoints = editablePoints;
            this.propertyChangeSupport.firePropertyChange(/* name */"EDITABLE_POINTS", !editablePoints, editablePoints);
        }
    }

    /**
     * Returns whether the point coordinates can be be edited or not.
     * @return {boolean}
     */
    public isEditablePoints(): boolean {
        return this.editablePoints;
    }

    /**
     * Sets the edited color of the left side.
     * @param {number} leftSideColor
     */
    public setLeftSideColor(leftSideColor: number) {
        if (leftSideColor !== this.leftSideColor) {
            const oldLeftSideColor: number = this.leftSideColor;
            this.leftSideColor = leftSideColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"LEFT_SIDE_COLOR", oldLeftSideColor, leftSideColor);
            this.setLeftSidePaint(WallController.WallPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the left side.
     * @return {number}
     */
    public getLeftSideColor(): number {
        return this.leftSideColor;
    }

    /**
     * Sets whether the left side is colored, textured or unknown painted.
     * @param {WallController.WallPaint} leftSidePaint
     */
    public setLeftSidePaint(leftSidePaint: WallController.WallPaint) {
        if (leftSidePaint !== this.leftSidePaint) {
            const oldLeftSidePaint: WallController.WallPaint = this.leftSidePaint;
            this.leftSidePaint = leftSidePaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"LEFT_SIDE_PAINT", oldLeftSidePaint, leftSidePaint);
        }
    }

    /**
     * Returns whether the left side is colored, textured or unknown painted.
     * @return {WallController.WallPaint} {@link WallPaint#COLORED}, {@link WallPaint#TEXTURED} or <code>null</code>
     */
    public getLeftSidePaint(): WallController.WallPaint {
        return this.leftSidePaint;
    }

    /**
     * Sets the edited left side shininess.
     * @param {number} leftSideShininess
     */
    public setLeftSideShininess(leftSideShininess: number) {
        if (leftSideShininess !== this.leftSideShininess) {
            const oldLeftSideShininess: number = this.leftSideShininess;
            this.leftSideShininess = leftSideShininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"LEFT_SIDE_SHININESS", oldLeftSideShininess, leftSideShininess);
        }
    }

    /**
     * Returns the edited left side shininess.
     * @return {number}
     */
    public getLeftSideShininess(): number {
        return this.leftSideShininess;
    }

    /**
     * Sets the edited color of the right side.
     * @param {number} rightSideColor
     */
    public setRightSideColor(rightSideColor: number) {
        if (rightSideColor !== this.rightSideColor) {
            const oldRightSideColor: number = this.rightSideColor;
            this.rightSideColor = rightSideColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"RIGHT_SIDE_COLOR", oldRightSideColor, rightSideColor);
            this.setRightSidePaint(WallController.WallPaint.COLORED);
        }
    }

    /**
     * Returns the edited color of the right side.
     * @return {number}
     */
    public getRightSideColor(): number {
        return this.rightSideColor;
    }

    /**
     * Sets whether the right side is colored, textured or unknown painted.
     * @param {WallController.WallPaint} rightSidePaint
     */
    public setRightSidePaint(rightSidePaint: WallController.WallPaint) {
        if (rightSidePaint !== this.rightSidePaint) {
            const oldRightSidePaint: WallController.WallPaint = this.rightSidePaint;
            this.rightSidePaint = rightSidePaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"RIGHT_SIDE_PAINT", oldRightSidePaint, rightSidePaint);
        }
    }

    /**
     * Returns whether the right side is colored, textured or unknown painted.
     * @return {WallController.WallPaint} {@link WallPaint#COLORED}, {@link WallPaint#TEXTURED} or <code>null</code>
     */
    public getRightSidePaint(): WallController.WallPaint {
        return this.rightSidePaint;
    }

    /**
     * Sets the edited right side shininess.
     * @param {number} rightSideShininess
     */
    public setRightSideShininess(rightSideShininess: number) {
        if (rightSideShininess !== this.rightSideShininess) {
            const oldRightSideShininess: number = this.rightSideShininess;
            this.rightSideShininess = rightSideShininess;
            this.propertyChangeSupport.firePropertyChange(/* name */"RIGHT_SIDE_SHININESS", oldRightSideShininess, rightSideShininess);
        }
    }

    /**
     * Returns the edited right side shininess.
     * @return {number}
     */
    public getRightSideShininess(): number {
        return this.rightSideShininess;
    }

    /**
     * Sets the pattern of edited wall in plan, and notifies
     * listeners of this change.
     * @param {Object} pattern
     */
    public setPattern(pattern: TextureImage) {
        if (this.pattern !== pattern) {
            const oldPattern: TextureImage = this.pattern;
            this.pattern = pattern;
            this.propertyChangeSupport.firePropertyChange(/* name */"PATTERN", oldPattern, pattern);
        }
    }

    /**
     * Returns the pattern of edited wall in plan.
     * @return {Object}
     */
    public getPattern(): TextureImage {
        return this.pattern;
    }

    /**
     * Sets the edited top color in the 3D view.
     * @param {number} topColor
     */
    public setTopColor(topColor: number) {
        if (topColor !== this.topColor) {
            const oldTopColor: number = this.topColor;
            this.topColor = topColor;
            this.propertyChangeSupport.firePropertyChange(/* name */"TOP_COLOR", oldTopColor, topColor);
        }
    }

    /**
     * Returns the edited top color in the 3D view.
     * @return {number}
     */
    public getTopColor(): number {
        return this.topColor;
    }

    /**
     * Sets whether the top of the wall in the 3D view uses default rendering, is colored, or unknown painted.
     * @param {WallController.WallPaint} topPaint
     */
    public setTopPaint(topPaint: WallController.WallPaint) {
        if (topPaint !== this.topPaint) {
            const oldTopPaint: WallController.WallPaint = this.topPaint;
            this.topPaint = topPaint;
            this.propertyChangeSupport.firePropertyChange(/* name */"TOP_PAINT", oldTopPaint, topPaint);
        }
    }

    /**
     * Returns whether the top of the wall in the 3D view uses default rendering, is colored, or unknown painted.
     * @return {WallController.WallPaint} {@link WallPaint#DEFAULT}, {@link WallPaint#COLORED} or <code>null</code>
     */
    public getTopPaint(): WallController.WallPaint {
        return this.topPaint;
    }

    /**
     * Sets whether the edited wall is a rectangular wall, a sloping wall or unknown.
     * @param {WallController.WallShape} shape
     */
    public setShape(shape: WallController.WallShape) {
        if (shape !== this.shape) {
            const oldShape: WallController.WallShape = this.shape;
            this.shape = shape;
            this.propertyChangeSupport.firePropertyChange(/* name */"SHAPE", oldShape, shape);
            if (shape === WallController.WallShape.RECTANGULAR_WALL) {
                if (this.rectangularWallHeight != null) {
                    this.getLeftSideBaseboardController().setMaxHeight(this.rectangularWallHeight);
                    this.getRightSideBaseboardController().setMaxHeight(this.rectangularWallHeight);
                }
            } else if (shape === WallController.WallShape.SLOPING_WALL) {
                if (this.slopingWallHeightAtStart != null && this.sloppingWallHeightAtEnd != null) {
                    const baseboardMaxHeight: number = Math.max(this.sloppingWallHeightAtEnd, this.slopingWallHeightAtStart);
                    this.getLeftSideBaseboardController().setMaxHeight(baseboardMaxHeight);
                    this.getRightSideBaseboardController().setMaxHeight(baseboardMaxHeight);
                } else if (this.slopingWallHeightAtStart != null) {
                    this.getLeftSideBaseboardController().setMaxHeight(this.slopingWallHeightAtStart);
                    this.getRightSideBaseboardController().setMaxHeight(this.slopingWallHeightAtStart);
                } else if (this.sloppingWallHeightAtEnd != null) {
                    this.getLeftSideBaseboardController().setMaxHeight(this.sloppingWallHeightAtEnd);
                    this.getRightSideBaseboardController().setMaxHeight(this.sloppingWallHeightAtEnd);
                }
            }
        }
    }

    /**
     * Returns whether the edited wall is a rectangular wall, a sloping wall or unknown.
     * @return {WallController.WallShape}
     */
    public getShape(): WallController.WallShape {
        return this.shape;
    }

    /**
     * Sets the edited height of a rectangular wall.
     * @param {number} rectangularWallHeight
     */
    public setRectangularWallHeight(rectangularWallHeight: number) {
        if (rectangularWallHeight !== this.rectangularWallHeight) {
            const oldRectangularWallHeight: number = this.rectangularWallHeight;
            this.rectangularWallHeight = rectangularWallHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"RECTANGULAR_WALL_HEIGHT", oldRectangularWallHeight, rectangularWallHeight);
            this.setShape(WallController.WallShape.RECTANGULAR_WALL);
            if (rectangularWallHeight != null) {
                this.getLeftSideBaseboardController().setMaxHeight(rectangularWallHeight);
                this.getRightSideBaseboardController().setMaxHeight(rectangularWallHeight);
            }
        }
    }

    /**
     * Returns the edited height of a rectangular wall.
     * @return {number}
     */
    public getRectangularWallHeight(): number {
        return this.rectangularWallHeight;
    }

    /**
     * Sets the edited height at start of a sloping wall.
     * @param {number} slopingWallHeightAtStart
     */
    public setSlopingWallHeightAtStart(slopingWallHeightAtStart: number) {
        if (slopingWallHeightAtStart !== this.slopingWallHeightAtStart) {
            const oldSlopingHeightHeightAtStart: number = this.slopingWallHeightAtStart;
            this.slopingWallHeightAtStart = slopingWallHeightAtStart;
            this.propertyChangeSupport.firePropertyChange(/* name */"SLOPING_WALL_HEIGHT_AT_START", oldSlopingHeightHeightAtStart, slopingWallHeightAtStart);
            this.setShape(WallController.WallShape.SLOPING_WALL);
            if (slopingWallHeightAtStart != null) {
                let baseboardMaxHeight: number = this.sloppingWallHeightAtEnd != null ? Math.max(this.sloppingWallHeightAtEnd, slopingWallHeightAtStart) : slopingWallHeightAtStart;
                baseboardMaxHeight = Math.max(baseboardMaxHeight, this.preferences.getLengthUnit().getMinimumLength());
                this.getLeftSideBaseboardController().setMaxHeight(baseboardMaxHeight);
                this.getRightSideBaseboardController().setMaxHeight(baseboardMaxHeight);
            }
        }
    }

    /**
     * Returns the edited height at start of a sloping wall.
     * @return {number}
     */
    public getSlopingWallHeightAtStart(): number {
        return this.slopingWallHeightAtStart;
    }

    /**
     * Sets the edited height at end of a sloping wall.
     * @param {number} sloppingWallHeightAtEnd
     */
    public setSlopingWallHeightAtEnd(sloppingWallHeightAtEnd: number) {
        if (sloppingWallHeightAtEnd !== this.sloppingWallHeightAtEnd) {
            const oldSlopingWallHeightAtEnd: number = this.sloppingWallHeightAtEnd;
            this.sloppingWallHeightAtEnd = sloppingWallHeightAtEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"SLOPING_WALL_HEIGHT_AT_END", oldSlopingWallHeightAtEnd, sloppingWallHeightAtEnd);
            this.setShape(WallController.WallShape.SLOPING_WALL);
            if (sloppingWallHeightAtEnd != null) {
                let baseboardMaxHeight: number = this.slopingWallHeightAtStart != null ? Math.max(this.slopingWallHeightAtStart, sloppingWallHeightAtEnd) : sloppingWallHeightAtEnd;
                baseboardMaxHeight = Math.max(baseboardMaxHeight, this.preferences.getLengthUnit().getMinimumLength());
                this.getLeftSideBaseboardController().setMaxHeight(baseboardMaxHeight);
                this.getRightSideBaseboardController().setMaxHeight(baseboardMaxHeight);
            }
        }
    }

    /**
     * Returns the edited height at end of a sloping wall.
     * @return {number}
     */
    public getSlopingWallHeightAtEnd(): number {
        return this.sloppingWallHeightAtEnd;
    }

    /**
     * Sets the edited thickness.
     * @param {number} thickness
     */
    public setThickness(thickness: number) {
        if (thickness !== this.thickness) {
            const oldThickness: number = this.thickness;
            this.thickness = thickness;
            this.propertyChangeSupport.firePropertyChange(/* name */"THICKNESS", oldThickness, thickness);
        }
    }

    /**
     * Returns the edited thickness.
     * @return {number}
     */
    public getThickness(): number {
        return this.thickness;
    }

    /**
     * Sets the edited arc extent.
     * @param {number} arcExtentInDegrees
     */
    public setArcExtentInDegrees(arcExtentInDegrees: number) {
        if (arcExtentInDegrees !== this.arcExtentInDegrees) {
            const oldArcExtent: number = this.arcExtentInDegrees;
            this.arcExtentInDegrees = arcExtentInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"ARC_EXTENT_IN_DEGREES", oldArcExtent, arcExtentInDegrees);
        }
    }

    /**
     * Returns the edited arc extent.
     * @return {number}
     */
    public getArcExtentInDegrees(): number {
        return this.arcExtentInDegrees;
    }

    /**
     * Returns the length of wall after applying the edited arc extent.
     * @return {number} the arc length or null if data is missing to compute it
     */
    public getArcLength(): number {
        const xStart: number = this.getXStart();
        const yStart: number = this.getYStart();
        const xEnd: number = this.getXEnd();
        const yEnd: number = this.getYEnd();
        const arcExtentInDegrees: number = this.getArcExtentInDegrees();
        if (xStart != null && yStart != null && xEnd != null && yEnd != null && arcExtentInDegrees != null) {
            const wall: Wall = new Wall(xStart, yStart, xEnd, yEnd, 1.0E-5, 0);
            wall.setArcExtent(<number>/* toRadians */(x => x * Math.PI / 180)(arcExtentInDegrees));
            return wall.getLength();
        } else {
            return null;
        }
    }

    /**
     * Controls the modification of selected walls in edited home.
     */
    public modifyWalls() {
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const selectedWalls: Array<Wall> = Home.getWallsSubList(oldSelection);
        if (!/* isEmpty */(selectedWalls.length == 0)) {
            const xStart: number = this.getXStart();
            const yStart: number = this.getYStart();
            const xEnd: number = this.getXEnd();
            const yEnd: number = this.getYEnd();
            const leftSidePaint: WallController.WallPaint = this.getLeftSidePaint();
            const leftSideColor: number = leftSidePaint === WallController.WallPaint.COLORED ? this.getLeftSideColor() : null;
            const leftSideTexture: HomeTexture = leftSidePaint === WallController.WallPaint.TEXTURED ? this.getLeftSideTextureController().getTexture() : null;
            const leftSideShininess: number = this.getLeftSideShininess();
            const leftSideBaseboardVisible: boolean = this.getLeftSideBaseboardController().getVisible();
            const leftSideBaseboardThickness: number = this.getLeftSideBaseboardController().getThickness();
            let leftSideBaseboardHeight: number = this.getLeftSideBaseboardController().getHeight();
            const leftSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint = this.getLeftSideBaseboardController().getPaint();
            const leftSideBaseboardColor: number = leftSideBaseboardPaint === BaseboardChoiceController.BaseboardPaint.COLORED ? this.getLeftSideBaseboardController().getColor() : null;
            const leftSideBaseboardTexture: HomeTexture = leftSideBaseboardPaint === BaseboardChoiceController.BaseboardPaint.TEXTURED ? this.getLeftSideBaseboardController().getTextureController().getTexture() : null;
            const rightSidePaint: WallController.WallPaint = this.getRightSidePaint();
            const rightSideColor: number = rightSidePaint === WallController.WallPaint.COLORED ? this.getRightSideColor() : null;
            const rightSideTexture: HomeTexture = rightSidePaint === WallController.WallPaint.TEXTURED ? this.getRightSideTextureController().getTexture() : null;
            const rightSideShininess: number = this.getRightSideShininess();
            const rightSideBaseboardVisible: boolean = this.getRightSideBaseboardController().getVisible();
            const rightSideBaseboardThickness: number = this.getRightSideBaseboardController().getThickness();
            let rightSideBaseboardHeight: number = this.getRightSideBaseboardController().getHeight();
            const rightSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint = this.getRightSideBaseboardController().getPaint();
            const rightSideBaseboardColor: number = rightSideBaseboardPaint === BaseboardChoiceController.BaseboardPaint.COLORED ? this.getRightSideBaseboardController().getColor() : null;
            const rightSideBaseboardTexture: HomeTexture = rightSideBaseboardPaint === BaseboardChoiceController.BaseboardPaint.TEXTURED ? this.getRightSideBaseboardController().getTextureController().getTexture() : null;
            const pattern: TextureImage = this.getPattern();
            const modifiedTopColor: boolean = this.getTopPaint() != null;
            const topColor: number = this.getTopPaint() === WallController.WallPaint.COLORED ? this.getTopColor() : null;
            const thickness: number = this.getThickness();
            let arcExtent: number = this.getArcExtentInDegrees();
            if (arcExtent != null) {
                arcExtent = <number>/* toRadians */(x => x * Math.PI / 180)(arcExtent);
            }
            let height: number;
            if (this.getShape() === WallController.WallShape.SLOPING_WALL) {
                height = this.getSlopingWallHeightAtStart();
            } else if (this.getShape() === WallController.WallShape.RECTANGULAR_WALL) {
                height = this.getRectangularWallHeight();
            } else {
                height = null;
            }
            let heightAtEnd: number;
            if (this.getShape() === WallController.WallShape.SLOPING_WALL) {
                heightAtEnd = this.getSlopingWallHeightAtEnd();
            } else if (this.getShape() === WallController.WallShape.RECTANGULAR_WALL) {
                heightAtEnd = this.getRectangularWallHeight();
            } else {
                heightAtEnd = null;
            }
            if (height != null && heightAtEnd != null) {
                const maxHeight: number = Math.max(height, heightAtEnd);
                if (leftSideBaseboardHeight != null) {
                    leftSideBaseboardHeight = Math.min(leftSideBaseboardHeight, maxHeight);
                }
                if (rightSideBaseboardHeight != null) {
                    rightSideBaseboardHeight = Math.min(rightSideBaseboardHeight, maxHeight);
                }
            }
            const modifiedWalls: WallController.ModifiedWall[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>selectedWalls.length));
            for (let i: number = 0; i < modifiedWalls.length; i++) {
                {
                    modifiedWalls[i] = new WallController.ModifiedWall(/* get */selectedWalls[i]);
                };
            }
            WallController.doModifyWalls(modifiedWalls, this.preferences.getNewWallBaseboardThickness(), this.preferences.getNewWallBaseboardHeight(), xStart, yStart, xEnd, yEnd, leftSidePaint, leftSideColor, leftSideTexture, leftSideShininess, leftSideBaseboardVisible, leftSideBaseboardThickness, leftSideBaseboardHeight, leftSideBaseboardPaint, leftSideBaseboardColor, leftSideBaseboardTexture, rightSidePaint, rightSideColor, rightSideTexture, rightSideShininess, rightSideBaseboardVisible, rightSideBaseboardThickness, rightSideBaseboardHeight, rightSideBaseboardPaint, rightSideBaseboardColor, rightSideBaseboardTexture, pattern, modifiedTopColor, topColor, height, heightAtEnd, thickness, arcExtent);
            if (this.undoSupport != null) {
                const undoableEdit: javax.swing.undo.UndoableEdit = new WallController.WallsModificationUndoableEdit(this.home, this.preferences, /* toArray */oldSelection.slice(0), modifiedWalls, this.preferences.getNewWallBaseboardThickness(), this.preferences.getNewWallBaseboardHeight(), xStart, yStart, xEnd, yEnd, leftSidePaint, leftSideColor, leftSideTexture, leftSideShininess, leftSideBaseboardVisible, leftSideBaseboardThickness, leftSideBaseboardHeight, leftSideBaseboardPaint, leftSideBaseboardColor, leftSideBaseboardTexture, rightSidePaint, rightSideColor, rightSideTexture, rightSideShininess, rightSideBaseboardVisible, rightSideBaseboardThickness, rightSideBaseboardHeight, rightSideBaseboardPaint, rightSideBaseboardColor, rightSideBaseboardTexture, pattern, modifiedTopColor, topColor, height, heightAtEnd, thickness, arcExtent);
                this.undoSupport.postEdit(undoableEdit);
            }
        }
    }

    /**
     * Modifies walls properties with the values in parameter.
     * @param {com.eteks.sweethome3d.viewcontroller.WallController.ModifiedWall[]} modifiedWalls
     * @param {number} newWallBaseboardThickness
     * @param {number} newWallBaseboardHeight
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {WallController.WallPaint} leftSidePaint
     * @param {number} leftSideColor
     * @param {HomeTexture} leftSideTexture
     * @param {number} leftSideShininess
     * @param {boolean} leftSideBaseboardVisible
     * @param {number} leftSideBaseboardThickness
     * @param {number} leftSideBaseboardHeight
     * @param {BaseboardChoiceController.BaseboardPaint} leftSideBaseboardPaint
     * @param {number} leftSideBaseboardColor
     * @param {HomeTexture} leftSideBaseboardTexture
     * @param {WallController.WallPaint} rightSidePaint
     * @param {number} rightSideColor
     * @param {HomeTexture} rightSideTexture
     * @param {number} rightSideShininess
     * @param {boolean} rightSideBaseboardVisible
     * @param {number} rightSideBaseboardThickness
     * @param {number} rightSideBaseboardHeight
     * @param {BaseboardChoiceController.BaseboardPaint} rightSideBaseboardPaint
     * @param {number} rightSideBaseboardColor
     * @param {HomeTexture} rightSideBaseboardTexture
     * @param {Object} pattern
     * @param {boolean} modifiedTopColor
     * @param {number} topColor
     * @param {number} height
     * @param {number} heightAtEnd
     * @param {number} thickness
     * @param {number} arcExtent
     * @private
     */
    static doModifyWalls(modifiedWalls: WallController.ModifiedWall[], newWallBaseboardThickness: number, newWallBaseboardHeight: number, xStart: number, yStart: number, xEnd: number, yEnd: number, leftSidePaint: WallController.WallPaint, leftSideColor: number, leftSideTexture: HomeTexture, leftSideShininess: number, leftSideBaseboardVisible: boolean, leftSideBaseboardThickness: number, leftSideBaseboardHeight: number, leftSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint, leftSideBaseboardColor: number, leftSideBaseboardTexture: HomeTexture, rightSidePaint: WallController.WallPaint, rightSideColor: number, rightSideTexture: HomeTexture, rightSideShininess: number, rightSideBaseboardVisible: boolean, rightSideBaseboardThickness: number, rightSideBaseboardHeight: number, rightSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint, rightSideBaseboardColor: number, rightSideBaseboardTexture: HomeTexture, pattern: TextureImage, modifiedTopColor: boolean, topColor: number, height: number, heightAtEnd: number, thickness: number, arcExtent: number) {
        for (let index = 0; index < modifiedWalls.length; index++) {
            let modifiedWall = modifiedWalls[index];
            {
                const wall: Wall = modifiedWall.getWall();
                WallController.moveWallPoints(wall, xStart, yStart, xEnd, yEnd);
                if (leftSidePaint != null) {
                    switch ((leftSidePaint)) {
                        case WallController.WallPaint.DEFAULT:
                            wall.setLeftSideColor(null);
                            wall.setLeftSideTexture(null);
                            break;
                        case WallController.WallPaint.COLORED:
                            if (leftSideColor != null) {
                                wall.setLeftSideColor(leftSideColor);
                            }
                            wall.setLeftSideTexture(null);
                            break;
                        case WallController.WallPaint.TEXTURED:
                            wall.setLeftSideColor(null);
                            if (leftSideTexture != null) {
                                wall.setLeftSideTexture(leftSideTexture);
                            }
                            break;
                    }
                }
                if (leftSideShininess != null) {
                    wall.setLeftSideShininess(leftSideShininess);
                }
                if (leftSideBaseboardVisible === false) {
                    wall.setLeftSideBaseboard(null);
                } else {
                    const baseboard: Baseboard = wall.getLeftSideBaseboard();
                    if (leftSideBaseboardVisible === true || baseboard != null) {
                        const baseboardThickness: number = baseboard != null ? baseboard.getThickness() : newWallBaseboardThickness;
                        const baseboardHeight: number = baseboard != null ? baseboard.getHeight() : newWallBaseboardHeight;
                        let baseboardColor: number = baseboard != null ? baseboard.getColor() : null;
                        let baseboardTexture: HomeTexture = baseboard != null ? baseboard.getTexture() : null;
                        if (leftSideBaseboardPaint != null) {
                            switch ((leftSideBaseboardPaint)) {
                                case BaseboardChoiceController.BaseboardPaint.DEFAULT:
                                    baseboardColor = null;
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.COLORED:
                                    if (leftSideBaseboardColor != null) {
                                        baseboardColor = leftSideBaseboardColor;
                                    }
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.TEXTURED:
                                    baseboardColor = null;
                                    if (leftSideBaseboardTexture != null) {
                                        baseboardTexture = leftSideBaseboardTexture;
                                    }
                                    break;
                            }
                        }
                        wall.setLeftSideBaseboard(Baseboard.getInstance(leftSideBaseboardThickness != null ? leftSideBaseboardThickness : baseboardThickness, leftSideBaseboardHeight != null ? leftSideBaseboardHeight : baseboardHeight, baseboardColor, baseboardTexture));
                    }
                }
                if (rightSidePaint != null) {
                    switch ((rightSidePaint)) {
                        case WallController.WallPaint.DEFAULT:
                            wall.setRightSideColor(null);
                            wall.setRightSideTexture(null);
                            break;
                        case WallController.WallPaint.COLORED:
                            if (rightSideColor != null) {
                                wall.setRightSideColor(rightSideColor);
                            }
                            wall.setRightSideTexture(null);
                            break;
                        case WallController.WallPaint.TEXTURED:
                            wall.setRightSideColor(null);
                            if (rightSideTexture != null) {
                                wall.setRightSideTexture(rightSideTexture);
                            }
                            break;
                    }
                }
                if (rightSideShininess != null) {
                    wall.setRightSideShininess(rightSideShininess);
                }
                if (rightSideBaseboardVisible === false) {
                    wall.setRightSideBaseboard(null);
                } else {
                    const baseboard: Baseboard = wall.getRightSideBaseboard();
                    if (rightSideBaseboardVisible === true || baseboard != null) {
                        const baseboardThickness: number = baseboard != null ? baseboard.getThickness() : newWallBaseboardThickness;
                        const baseboardHeight: number = baseboard != null ? baseboard.getHeight() : newWallBaseboardHeight;
                        let baseboardColor: number = baseboard != null ? baseboard.getColor() : null;
                        let baseboardTexture: HomeTexture = baseboard != null ? baseboard.getTexture() : null;
                        if (rightSideBaseboardPaint != null) {
                            switch ((rightSideBaseboardPaint)) {
                                case BaseboardChoiceController.BaseboardPaint.DEFAULT:
                                    baseboardColor = null;
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.COLORED:
                                    if (rightSideBaseboardColor != null) {
                                        baseboardColor = rightSideBaseboardColor;
                                    }
                                    baseboardTexture = null;
                                    break;
                                case BaseboardChoiceController.BaseboardPaint.TEXTURED:
                                    baseboardColor = null;
                                    if (rightSideBaseboardTexture != null) {
                                        baseboardTexture = rightSideBaseboardTexture;
                                    }
                                    break;
                            }
                        }
                        wall.setRightSideBaseboard(Baseboard.getInstance(rightSideBaseboardThickness != null ? rightSideBaseboardThickness : baseboardThickness, rightSideBaseboardHeight != null ? rightSideBaseboardHeight : baseboardHeight, baseboardColor, baseboardTexture));
                    }
                }
                if (pattern != null) {
                    wall.setPattern(pattern);
                }
                if (modifiedTopColor) {
                    wall.setTopColor(topColor);
                }
                if (height != null) {
                    wall.setHeight(height);
                    if (heightAtEnd != null) {
                        if (heightAtEnd === height) {
                            wall.setHeightAtEnd(null);
                        } else {
                            wall.setHeightAtEnd(heightAtEnd);
                        }
                    }
                }
                if (thickness != null) {
                    wall.setThickness(/* floatValue */thickness);
                }
                if (arcExtent != null) {
                    if (/* floatValue */arcExtent === 0) {
                        wall.setArcExtent(null);
                    } else {
                        wall.setArcExtent(arcExtent);
                    }
                }
            }
        }
    }

    /**
     * Restores wall properties from the values stored in <code>modifiedWalls</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.WallController.ModifiedWall[]} modifiedWalls
     * @private
     */
    static undoModifyWalls(modifiedWalls: WallController.ModifiedWall[]) {
        for (let index = 0; index < modifiedWalls.length; index++) {
            let modifiedWall = modifiedWalls[index];
            {
                const wall: Wall = modifiedWall.getWall();
                WallController.moveWallPoints(wall, modifiedWall.getXStart(), modifiedWall.getYStart(), modifiedWall.getXEnd(), modifiedWall.getYEnd());
                wall.setLeftSideColor(modifiedWall.getLeftSideColor());
                wall.setLeftSideTexture(modifiedWall.getLeftSideTexture());
                wall.setLeftSideShininess(modifiedWall.getLeftSideShininess());
                wall.setLeftSideBaseboard(modifiedWall.getLeftSideBaseboard());
                wall.setRightSideColor(modifiedWall.getRightSideColor());
                wall.setRightSideTexture(modifiedWall.getRightSideTexture());
                wall.setRightSideShininess(modifiedWall.getRightSideShininess());
                wall.setRightSideBaseboard(modifiedWall.getRightSideBaseboard());
                wall.setPattern(modifiedWall.getPattern());
                wall.setTopColor(modifiedWall.getTopColor());
                wall.setHeight(modifiedWall.getHeight());
                wall.setHeightAtEnd(modifiedWall.getHeightAtEnd());
                wall.setThickness(modifiedWall.getThickness());
                wall.setArcExtent(modifiedWall.getArcExtent());
            }
        }
    }

    static moveWallPoints(wall: Wall, xStart: number, yStart: number, xEnd: number, yEnd: number) {
        const wallAtStart: Wall = wall.getWallAtStart();
        if (xStart != null) {
            wall.setXStart(xStart);
            if (wallAtStart != null) {
                if (wallAtStart.getWallAtStart() === wall) {
                    wallAtStart.setXStart(xStart);
                } else if (wallAtStart.getWallAtEnd() === wall) {
                    wallAtStart.setXEnd(xStart);
                }
            }
        }
        if (yStart != null) {
            wall.setYStart(yStart);
            if (wallAtStart != null) {
                if (wallAtStart.getWallAtStart() === wall) {
                    wallAtStart.setYStart(yStart);
                } else if (wallAtStart.getWallAtEnd() === wall) {
                    wallAtStart.setYEnd(yStart);
                }
            }
        }
        const wallAtEnd: Wall = wall.getWallAtEnd();
        if (xEnd != null) {
            wall.setXEnd(xEnd);
            if (wallAtEnd != null) {
                if (wallAtEnd.getWallAtStart() === wall) {
                    wallAtEnd.setXStart(xEnd);
                } else if (wallAtEnd.getWallAtEnd() === wall) {
                    wallAtEnd.setXEnd(xEnd);
                }
            }
        }
        if (yEnd != null) {
            wall.setYEnd(yEnd);
            if (wallAtEnd != null) {
                if (wallAtEnd.getWallAtStart() === wall) {
                    wallAtEnd.setYStart(yEnd);
                } else if (wallAtEnd.getWallAtEnd() === wall) {
                    wallAtEnd.setYEnd(yEnd);
                }
            }
        }
    }
}
WallController["__class"] = "com.eteks.sweethome3d.viewcontroller.WallController";
WallController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace WallController {

    /**
     * The possible values for {@linkplain #getShape() wall shape}.
     * @enum
     * @property {WallController.WallShape} RECTANGULAR_WALL
     * @property {WallController.WallShape} SLOPING_WALL
     * @class
     */
    export enum WallShape {
        RECTANGULAR_WALL, SLOPING_WALL
    }

    /**
     * The possible values for {@linkplain #getLeftSidePaint() wall paint type}.
     * @enum
     * @property {WallController.WallPaint} DEFAULT
     * @property {WallController.WallPaint} COLORED
     * @property {WallController.WallPaint} TEXTURED
     * @class
     */
    export enum WallPaint {
        DEFAULT, COLORED, TEXTURED
    }

    /**
     * Undoable edit for walls modification. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class WallsModificationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        modifiedWalls: WallController.ModifiedWall[];

        newWallBaseboardThickness: number;

        newWallBaseboardHeight: number;

        xStart: number;

        yStart: number;

        xEnd: number;

        yEnd: number;

        leftSidePaint: WallController.WallPaint;

        leftSideColor: number;

        leftSideTexture: HomeTexture;

        leftSideShininess: number;

        leftSideBaseboardVisible: boolean;

        leftSideBaseboardThickness: number;

        leftSideBaseboardHeight: number;

        leftSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint;

        leftSideBaseboardColor: number;

        leftSideBaseboardTexture: HomeTexture;

        rightSidePaint: WallController.WallPaint;

        rightSideColor: number;

        rightSideTexture: HomeTexture;

        rightSideShininess: number;

        rightSideBaseboardVisible: boolean;

        rightSideBaseboardThickness: number;

        rightSideBaseboardHeight: number;

        rightSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint;

        rightSideBaseboardColor: number;

        rightSideBaseboardTexture: HomeTexture;

        pattern: TextureImage;

        modifiedTopColor: boolean;

        topColor: number;

        height: number;

        heightAtEnd: number;

        thickness: number;

        arcExtent: number;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], modifiedWalls: WallController.ModifiedWall[], newWallBaseboardThickness: number, newWallBaseboardHeight: number, xStart: number, yStart: number, xEnd: number, yEnd: number, leftSidePaint: WallController.WallPaint, leftSideColor: number, leftSideTexture: HomeTexture, leftSideShininess: number, leftSideBaseboardVisible: boolean, leftSideBaseboardThickness: number, leftSideBaseboardHeight: number, leftSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint, leftSideBaseboardColor: number, leftSideBaseboardTexture: HomeTexture, rightSidePaint: WallController.WallPaint, rightSideColor: number, rightSideTexture: HomeTexture, rightSideShininess: number, rightSideBaseboardVisible: boolean, rightSideBaseboardThickness: number, rightSideBaseboardHeight: number, rightSideBaseboardPaint: BaseboardChoiceController.BaseboardPaint, rightSideBaseboardColor: number, rightSideBaseboardTexture: HomeTexture, pattern: TextureImage, modifiedTopColor: boolean, topColor: number, height: number, heightAtEnd: number, thickness: number, arcExtent: number) {
            super(preferences, WallController, "undoModifyWallsName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.modifiedWalls === undefined) { this.modifiedWalls = null; }
            if (this.newWallBaseboardThickness === undefined) { this.newWallBaseboardThickness = 0; }
            if (this.newWallBaseboardHeight === undefined) { this.newWallBaseboardHeight = 0; }
            if (this.xStart === undefined) { this.xStart = null; }
            if (this.yStart === undefined) { this.yStart = null; }
            if (this.xEnd === undefined) { this.xEnd = null; }
            if (this.yEnd === undefined) { this.yEnd = null; }
            if (this.leftSidePaint === undefined) { this.leftSidePaint = null; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = null; }
            if (this.leftSideBaseboardVisible === undefined) { this.leftSideBaseboardVisible = null; }
            if (this.leftSideBaseboardThickness === undefined) { this.leftSideBaseboardThickness = null; }
            if (this.leftSideBaseboardHeight === undefined) { this.leftSideBaseboardHeight = null; }
            if (this.leftSideBaseboardPaint === undefined) { this.leftSideBaseboardPaint = null; }
            if (this.leftSideBaseboardColor === undefined) { this.leftSideBaseboardColor = null; }
            if (this.leftSideBaseboardTexture === undefined) { this.leftSideBaseboardTexture = null; }
            if (this.rightSidePaint === undefined) { this.rightSidePaint = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = null; }
            if (this.rightSideBaseboardVisible === undefined) { this.rightSideBaseboardVisible = null; }
            if (this.rightSideBaseboardThickness === undefined) { this.rightSideBaseboardThickness = null; }
            if (this.rightSideBaseboardHeight === undefined) { this.rightSideBaseboardHeight = null; }
            if (this.rightSideBaseboardPaint === undefined) { this.rightSideBaseboardPaint = null; }
            if (this.rightSideBaseboardColor === undefined) { this.rightSideBaseboardColor = null; }
            if (this.rightSideBaseboardTexture === undefined) { this.rightSideBaseboardTexture = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.modifiedTopColor === undefined) { this.modifiedTopColor = false; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = null; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.modifiedWalls = modifiedWalls;
            this.newWallBaseboardThickness = newWallBaseboardThickness;
            this.newWallBaseboardHeight = newWallBaseboardHeight;
            this.xStart = xStart;
            this.yStart = yStart;
            this.xEnd = xEnd;
            this.yEnd = yEnd;
            this.leftSidePaint = leftSidePaint;
            this.leftSideColor = leftSideColor;
            this.leftSideShininess = leftSideShininess;
            this.leftSideBaseboardVisible = leftSideBaseboardVisible;
            this.leftSideBaseboardThickness = leftSideBaseboardThickness;
            this.leftSideBaseboardHeight = leftSideBaseboardHeight;
            this.leftSideBaseboardPaint = leftSideBaseboardPaint;
            this.leftSideBaseboardColor = leftSideBaseboardColor;
            this.leftSideBaseboardTexture = leftSideBaseboardTexture;
            this.rightSidePaint = rightSidePaint;
            this.rightSideColor = rightSideColor;
            this.rightSideTexture = rightSideTexture;
            this.leftSideTexture = leftSideTexture;
            this.rightSideShininess = rightSideShininess;
            this.rightSideBaseboardVisible = rightSideBaseboardVisible;
            this.rightSideBaseboardThickness = rightSideBaseboardThickness;
            this.rightSideBaseboardHeight = rightSideBaseboardHeight;
            this.rightSideBaseboardPaint = rightSideBaseboardPaint;
            this.rightSideBaseboardColor = rightSideBaseboardColor;
            this.rightSideBaseboardTexture = rightSideBaseboardTexture;
            this.pattern = pattern;
            this.modifiedTopColor = modifiedTopColor;
            this.topColor = topColor;
            this.height = height;
            this.heightAtEnd = heightAtEnd;
            this.thickness = thickness;
            this.arcExtent = arcExtent;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            WallController.undoModifyWalls(this.modifiedWalls);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            WallController.doModifyWalls(this.modifiedWalls, this.newWallBaseboardThickness, this.newWallBaseboardHeight, this.xStart, this.yStart, this.xEnd, this.yEnd, this.leftSidePaint, this.leftSideColor, this.leftSideTexture, this.leftSideShininess, this.leftSideBaseboardVisible, this.leftSideBaseboardThickness, this.leftSideBaseboardHeight, this.leftSideBaseboardPaint, this.leftSideBaseboardColor, this.leftSideBaseboardTexture, this.rightSidePaint, this.rightSideColor, this.rightSideTexture, this.rightSideShininess, this.rightSideBaseboardVisible, this.rightSideBaseboardThickness, this.rightSideBaseboardHeight, this.rightSideBaseboardPaint, this.rightSideBaseboardColor, this.rightSideBaseboardTexture, this.pattern, this.modifiedTopColor, this.topColor, this.height, this.heightAtEnd, this.thickness, this.arcExtent);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
        }
    }
    WallsModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.WallController.WallsModificationUndoableEdit";
    WallsModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the current properties values of a modified wall.
     * @param {Wall} wall
     * @class
     */
    export class ModifiedWall {
        wall: Wall;

        xStart: number;

        yStart: number;

        xEnd: number;

        yEnd: number;

        leftSideColor: number;

        leftSideTexture: HomeTexture;

        leftSideShininess: number;

        leftSideBaseboard: Baseboard;

        rightSideColor: number;

        rightSideTexture: HomeTexture;

        rightSideShininess: number;

        rightSideBaseboard: Baseboard;

        pattern: TextureImage;

        topColor: number;

        height: number;

        heightAtEnd: number;

        thickness: number;

        arcExtent: number;

        public constructor(wall: Wall) {
            if (this.wall === undefined) { this.wall = null; }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.leftSideColor === undefined) { this.leftSideColor = null; }
            if (this.leftSideTexture === undefined) { this.leftSideTexture = null; }
            if (this.leftSideShininess === undefined) { this.leftSideShininess = 0; }
            if (this.leftSideBaseboard === undefined) { this.leftSideBaseboard = null; }
            if (this.rightSideColor === undefined) { this.rightSideColor = null; }
            if (this.rightSideTexture === undefined) { this.rightSideTexture = null; }
            if (this.rightSideShininess === undefined) { this.rightSideShininess = 0; }
            if (this.rightSideBaseboard === undefined) { this.rightSideBaseboard = null; }
            if (this.pattern === undefined) { this.pattern = null; }
            if (this.topColor === undefined) { this.topColor = null; }
            if (this.height === undefined) { this.height = null; }
            if (this.heightAtEnd === undefined) { this.heightAtEnd = null; }
            if (this.thickness === undefined) { this.thickness = 0; }
            if (this.arcExtent === undefined) { this.arcExtent = null; }
            this.wall = wall;
            this.xStart = wall.getXStart();
            this.yStart = wall.getYStart();
            this.xEnd = wall.getXEnd();
            this.yEnd = wall.getYEnd();
            this.leftSideColor = wall.getLeftSideColor();
            this.leftSideTexture = wall.getLeftSideTexture();
            this.leftSideShininess = wall.getLeftSideShininess();
            this.leftSideBaseboard = wall.getLeftSideBaseboard();
            this.rightSideColor = wall.getRightSideColor();
            this.rightSideTexture = wall.getRightSideTexture();
            this.rightSideShininess = wall.getRightSideShininess();
            this.rightSideBaseboard = wall.getRightSideBaseboard();
            this.pattern = wall.getPattern();
            this.topColor = wall.getTopColor();
            this.height = wall.getHeight();
            this.heightAtEnd = wall.getHeightAtEnd();
            this.thickness = wall.getThickness();
            this.arcExtent = wall.getArcExtent();
        }

        public getWall(): Wall {
            return this.wall;
        }

        public getXStart(): number {
            return this.xStart;
        }

        public getXEnd(): number {
            return this.xEnd;
        }

        public getYStart(): number {
            return this.yStart;
        }

        public getYEnd(): number {
            return this.yEnd;
        }

        public getHeight(): number {
            return this.height;
        }

        public getHeightAtEnd(): number {
            return this.heightAtEnd;
        }

        public getLeftSideColor(): number {
            return this.leftSideColor;
        }

        public getLeftSideTexture(): HomeTexture {
            return this.leftSideTexture;
        }

        public getLeftSideShininess(): number {
            return this.leftSideShininess;
        }

        public getLeftSideBaseboard(): Baseboard {
            return this.leftSideBaseboard;
        }

        public getRightSideColor(): number {
            return this.rightSideColor;
        }

        public getRightSideTexture(): HomeTexture {
            return this.rightSideTexture;
        }

        public getRightSideShininess(): number {
            return this.rightSideShininess;
        }

        public getRightSideBaseboard(): Baseboard {
            return this.rightSideBaseboard;
        }

        public getPattern(): TextureImage {
            return this.pattern;
        }

        public getTopColor(): number {
            return this.topColor;
        }

        public getThickness(): number {
            return this.thickness;
        }

        public getArcExtent(): number {
            return this.arcExtent;
        }
    }
    ModifiedWall["__class"] = "com.eteks.sweethome3d.viewcontroller.WallController.ModifiedWall";


    export class WallController$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setLeftSidePaint(WallController.WallPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class WallController$1 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.setRightSidePaint(WallController.WallPaint.TEXTURED);
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}


/**
 * A MVC controller for the compass view.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 */
export class CompassController implements Controller {
    /*private*/ home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ compassView: DialogView;

    /*private*/ x: number;

    /*private*/ y: number;

    /*private*/ diameter: number;

    /*private*/ visible: boolean;

    /*private*/ northDirectionInDegrees: number;

    /*private*/ latitudeInDegrees: number;

    /*private*/ longitudeInDegrees: number;

    /*private*/ timeZone: string;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, undoSupport: javax.swing.undo.UndoableEditSupport) {
        if (this.home === undefined) { this.home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.compassView === undefined) { this.compassView = null; }
        if (this.x === undefined) { this.x = 0; }
        if (this.y === undefined) { this.y = 0; }
        if (this.diameter === undefined) { this.diameter = 0; }
        if (this.visible === undefined) { this.visible = false; }
        if (this.northDirectionInDegrees === undefined) { this.northDirectionInDegrees = 0; }
        if (this.latitudeInDegrees === undefined) { this.latitudeInDegrees = 0; }
        if (this.longitudeInDegrees === undefined) { this.longitudeInDegrees = 0; }
        if (this.timeZone === undefined) { this.timeZone = null; }
        this.home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.compassView == null) {
            this.compassView = this.viewFactory.createCompassView(this.preferences, this);
        }
        return this.compassView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Updates compass properties edited by this controller.
     */
    updateProperties() {
        const compass: Compass = this.home.getCompass();
        this.setX(compass.getX());
        this.setY(compass.getY());
        this.setDiameter(compass.getDiameter());
        this.setVisible(compass.isVisible());
        this.setNorthDirectionInDegrees(<number>/* toDegrees */(x => x * 180 / Math.PI)(compass.getNorthDirection()));
        this.setLatitudeInDegrees(<number>/* toDegrees */(x => x * 180 / Math.PI)(compass.getLatitude()));
        this.setLongitudeInDegrees(<number>/* toDegrees */(x => x * 180 / Math.PI)(compass.getLongitude()));
        this.setTimeZone(compass.getTimeZone());
    }

    /**
     * Returns the edited abscissa of the center.
     * @return {number}
     */
    public getX(): number {
        return this.x;
    }

    /**
     * Sets the edited abscissa of the center.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.x) {
            const oldX: number = this.x;
            this.x = x;
            this.propertyChangeSupport.firePropertyChange(/* name */"X", oldX, x);
        }
    }

    /**
     * Returns the edited ordinate of the center.
     * @return {number}
     */
    public getY(): number {
        return this.y;
    }

    /**
     * Sets the edited ordinate of the center.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.y) {
            const oldY: number = this.y;
            this.y = y;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y", oldY, y);
        }
    }

    /**
     * Returns the edited diameter.
     * @return {number}
     */
    public getDiameter(): number {
        return this.diameter;
    }

    /**
     * Sets the edited diameter.
     * @param {number} diameter
     */
    public setDiameter(diameter: number) {
        if (diameter !== this.diameter) {
            const oldDiameter: number = this.diameter;
            this.diameter = diameter;
            this.propertyChangeSupport.firePropertyChange(/* name */"DIAMETER", oldDiameter, diameter);
        }
    }

    /**
     * Returns whether compass is visible or not.
     * @return {boolean}
     */
    public isVisible(): boolean {
        return this.visible;
    }

    /**
     * Sets whether this compass is visible or not.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        if (visible !== this.visible) {
            this.visible = visible;
            this.propertyChangeSupport.firePropertyChange(/* name */"VISIBLE", !visible, visible);
        }
    }

    /**
     * Returns the edited North direction angle in degrees.
     * @return {number}
     */
    public getNorthDirectionInDegrees(): number {
        return this.northDirectionInDegrees;
    }

    /**
     * Sets the edited North direction angle.
     * @param {number} northDirectionInDegrees
     */
    public setNorthDirectionInDegrees(northDirectionInDegrees: number) {
        if (northDirectionInDegrees !== this.northDirectionInDegrees) {
            const oldNorthDirectionInDegrees: number = this.northDirectionInDegrees;
            this.northDirectionInDegrees = northDirectionInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"NORTH_DIRECTION_IN_DEGREES", oldNorthDirectionInDegrees, northDirectionInDegrees);
        }
    }

    /**
     * Returns the edited latitude in degrees.
     * @return {number}
     */
    public getLatitudeInDegrees(): number {
        return this.latitudeInDegrees;
    }

    /**
     * Sets the edited latitude in degrees.
     * @param {number} latitudeInDegrees
     */
    public setLatitudeInDegrees(latitudeInDegrees: number) {
        if (latitudeInDegrees !== this.latitudeInDegrees) {
            const oldLatitudeInDegrees: number = this.latitudeInDegrees;
            this.latitudeInDegrees = latitudeInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"LATITUDE_IN_DEGREES", oldLatitudeInDegrees, latitudeInDegrees);
        }
    }

    /**
     * Returns the edited longitude in degrees.
     * @return {number}
     */
    public getLongitudeInDegrees(): number {
        return this.longitudeInDegrees;
    }

    /**
     * Sets the edited longitude of the center.
     * @param {number} longitudeInDegrees
     */
    public setLongitudeInDegrees(longitudeInDegrees: number) {
        if (longitudeInDegrees !== this.longitudeInDegrees) {
            const oldLongitudeInDegrees: number = this.longitudeInDegrees;
            this.longitudeInDegrees = longitudeInDegrees;
            this.propertyChangeSupport.firePropertyChange(/* name */"LONGITUDE_IN_DEGREES", oldLongitudeInDegrees, longitudeInDegrees);
        }
    }

    /**
     * Returns the edited time zone identifier.
     * @return {string}
     */
    public getTimeZone(): string {
        return this.timeZone;
    }

    /**
     * Sets the edited time zone identifier.
     * @param {string} timeZone
     */
    public setTimeZone(timeZone: string) {
        if (!(timeZone === this.timeZone)) {
            const oldTimeZone: string = this.timeZone;
            this.timeZone = timeZone;
            this.propertyChangeSupport.firePropertyChange(/* name */"TIME_ZONE", oldTimeZone, timeZone);
        }
    }

    /**
     * Modifies home compass from the values stored in this controller.
     */
    public modifyCompass() {
        const x: number = this.getX();
        const y: number = this.getY();
        const diameter: number = this.getDiameter();
        const visible: boolean = this.isVisible();
        const northDirection: number = <number>/* toRadians */(x => x * Math.PI / 180)(this.getNorthDirectionInDegrees());
        const latitude: number = <number>/* toRadians */(x => x * Math.PI / 180)(this.getLatitudeInDegrees());
        const longitude: number = <number>/* toRadians */(x => x * Math.PI / 180)(this.getLongitudeInDegrees());
        const timeZone: string = this.getTimeZone();
        const undoableEdit: javax.swing.undo.UndoableEdit = new CompassController.CompassUndoableEdit(this.home.getCompass(), this.preferences, x, y, diameter, visible, northDirection, latitude, longitude, timeZone);
        CompassController.doModifyCompass(this.home.getCompass(), x, y, diameter, visible, northDirection, latitude, longitude, timeZone);
        this.undoSupport.postEdit(undoableEdit);
    }

    static doModifyCompass(compass: Compass, x: number, y: number, diameter: number, visible: boolean, northDirection: number, latitude: number, longitude: number, timeZone: string) {
        compass.setX(x);
        compass.setY(y);
        compass.setDiameter(diameter);
        compass.setVisible(visible);
        compass.setNorthDirection(northDirection);
        compass.setLatitude(latitude);
        compass.setLongitude(longitude);
        compass.setTimeZone(timeZone);
    }
}
CompassController["__class"] = "com.eteks.sweethome3d.viewcontroller.CompassController";
CompassController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace CompassController {

    /**
     * Undoable edit for compass. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @param {Compass} compass
     * @param {UserPreferences} preferences
     * @param {number} newX
     * @param {number} newY
     * @param {number} newDiameter
     * @param {boolean} newVisible
     * @param {number} newNorthDirection
     * @param {number} newLatitude
     * @param {number} newLongitude
     * @param {string} newTimeZone
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class CompassUndoableEdit extends LocalizedUndoableEdit {
        compass: Compass;

        oldX: number;

        oldY: number;

        oldDiameter: number;

        oldNorthDirection: number;

        oldLatitude: number;

        oldLongitude: number;

        oldTimeZone: string;

        oldVisible: boolean;

        newX: number;

        newY: number;

        newDiameter: number;

        newNorthDirection: number;

        newLatitude: number;

        newLongitude: number;

        newTimeZone: string;

        newVisible: boolean;

        public constructor(compass: Compass, preferences: any, newX: number, newY: number, newDiameter: number, newVisible: boolean, newNorthDirection: number, newLatitude: number, newLongitude: number, newTimeZone: string) {
            super(preferences, CompassController, "undoModifyCompassName");
            if (this.compass === undefined) { this.compass = null; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.oldDiameter === undefined) { this.oldDiameter = 0; }
            if (this.oldNorthDirection === undefined) { this.oldNorthDirection = 0; }
            if (this.oldLatitude === undefined) { this.oldLatitude = 0; }
            if (this.oldLongitude === undefined) { this.oldLongitude = 0; }
            if (this.oldTimeZone === undefined) { this.oldTimeZone = null; }
            if (this.oldVisible === undefined) { this.oldVisible = false; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            if (this.newDiameter === undefined) { this.newDiameter = 0; }
            if (this.newNorthDirection === undefined) { this.newNorthDirection = 0; }
            if (this.newLatitude === undefined) { this.newLatitude = 0; }
            if (this.newLongitude === undefined) { this.newLongitude = 0; }
            if (this.newTimeZone === undefined) { this.newTimeZone = null; }
            if (this.newVisible === undefined) { this.newVisible = false; }
            this.compass = compass;
            this.oldX = compass.getX();
            this.oldY = compass.getY();
            this.oldDiameter = compass.getDiameter();
            this.oldVisible = compass.isVisible();
            this.oldNorthDirection = compass.getNorthDirection();
            this.oldLatitude = compass.getLatitude();
            this.oldLongitude = compass.getLongitude();
            this.oldTimeZone = compass.getTimeZone();
            this.newX = newX;
            this.newY = newY;
            this.newDiameter = newDiameter;
            this.newVisible = newVisible;
            this.newNorthDirection = newNorthDirection;
            this.newLatitude = newLatitude;
            this.newLongitude = newLongitude;
            this.newTimeZone = newTimeZone;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            CompassController.doModifyCompass(this.compass, this.oldX, this.oldY, this.oldDiameter, this.oldVisible, this.oldNorthDirection, this.oldLatitude, this.oldLongitude, this.oldTimeZone);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            CompassController.doModifyCompass(this.compass, this.newX, this.newY, this.newDiameter, this.newVisible, this.newNorthDirection, this.newLatitude, this.newLongitude, this.newTimeZone);
        }
    }
    CompassUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.CompassController.CompassUndoableEdit";
    CompassUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];


}


/**
 * Creates a controller that edits a new imported home piece of furniture
 * with a given <code>modelName</code>.
 * @param {Home} home
 * @param {string} modelName
 * @param {UserPreferences} preferences
 * @param {FurnitureController} furnitureController
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @extends WizardController
 * @author Emmanuel Puybaret
 * @ignore
 */
export class ImportedFurnitureWizardController extends WizardController implements Controller {
    /*private*/ home: Home;

    /*private*/ piece: CatalogPieceOfFurniture;

    /*private*/ modelName: string;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences: any;

    /*private*/ furnitureController: FurnitureController;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ furnitureModelStepState: ImportedFurnitureWizardController.ImportedFurnitureWizardStepState;

    /*private*/ furnitureOrientationStepState: ImportedFurnitureWizardController.ImportedFurnitureWizardStepState;

    /*private*/ furnitureAttributesStepState: ImportedFurnitureWizardController.ImportedFurnitureWizardStepState;

    /*private*/ furnitureIconStepState: ImportedFurnitureWizardController.ImportedFurnitureWizardStepState;

    /*private*/ stepsView: ImportedFurnitureWizardStepsView;

    /*private*/ step: ImportedFurnitureWizardController.Step;

    /*private*/ name: string;

    /*private*/ creator: string;

    /*private*/ model: Content;

    /*private*/ width: number;

    /*private*/ proportionalWidth: number;

    /*private*/ depth: number;

    /*private*/ proportionalDepth: number;

    /*private*/ height: number;

    /*private*/ proportionalHeight: number;

    /*private*/ elevation: number;

    /*private*/ movable: boolean;

    /*private*/ doorOrWindow: boolean;

    /*private*/ staircaseCutOutShape: string;

    /*private*/ color: number;

    /*private*/ category: FurnitureCategory;

    /*private*/ modelSize: number;

    /*private*/ modelRotation: number[][];

    /*private*/ edgeColorMaterialHidden: boolean;

    /*private*/ backFaceShown: boolean;

    /*private*/ iconYaw: number;

    /*private*/ iconPitch: number;

    /*private*/ iconScale: number;

    /*private*/ proportional: boolean;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory: ViewFactory;

    public constructor(home?: any, piece?: any, modelName?: any, preferences?: any, furnitureController?: any, viewFactory?: any, contentManager?: any, undoSupport?: any) {
        if (((home != null && home instanceof <any>Home) || home === null) && ((piece != null && piece instanceof <any>CatalogPieceOfFurniture) || piece === null) && ((typeof modelName === 'string') || modelName === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((furnitureController != null && furnitureController instanceof <any>FurnitureController) || furnitureController === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null) && ((undoSupport != null && undoSupport instanceof <any>javax.swing.undo.UndoableEditSupport) || undoSupport === null)) {
            let __args = arguments;
            super(preferences, viewFactory);
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
            this.home = home;
            this.piece = piece;
            this.modelName = modelName;
            this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
            this.furnitureController = furnitureController;
            this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
            this.undoSupport = undoSupport;
            this.contentManager = contentManager;
            /* Use propertyChangeSupport defined in super class */;
            this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
            this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
            this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
            this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
            this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
            this.setStepState(this.furnitureModelStepState);
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((typeof piece === 'string') || piece === null) && ((modelName != null && modelName instanceof <any>UserPreferences) || modelName === null) && ((preferences != null && preferences instanceof <any>FurnitureController) || preferences === null) && ((furnitureController != null && (furnitureController.constructor != null && furnitureController.constructor["__interfaces"] != null && furnitureController.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || furnitureController === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && ((contentManager != null && contentManager instanceof <any>javax.swing.undo.UndoableEditSupport) || contentManager === null) && undoSupport === undefined) {
            let __args = arguments;
            let modelName: any = __args[1];
            let preferences: any = __args[2];
            let furnitureController: any = __args[3];
            let viewFactory: any = __args[4];
            let contentManager: any = __args[5];
            let undoSupport: any = __args[6];
            {
                let __args = arguments;
                let piece: any = null;
                super(preferences, viewFactory);
                if (this.home === undefined) { this.home = null; }
                if (this.piece === undefined) { this.piece = null; }
                if (this.modelName === undefined) { this.modelName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
                if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
                if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
                if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.modelSize === undefined) { this.modelSize = 0; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
                this.home = home;
                this.piece = piece;
                this.modelName = modelName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
                this.furnitureController = furnitureController;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
                this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
                this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
                this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
                this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
                this.setStepState(this.furnitureModelStepState);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
        } else if (((home != null && home instanceof <any>Home) || home === null) && ((piece != null && piece instanceof <any>UserPreferences) || piece === null) && ((modelName != null && modelName instanceof <any>FurnitureController) || modelName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((furnitureController != null && (furnitureController.constructor != null && furnitureController.constructor["__interfaces"] != null && furnitureController.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || furnitureController === null) && ((viewFactory != null && viewFactory instanceof <any>javax.swing.undo.UndoableEditSupport) || viewFactory === null) && contentManager === undefined && undoSupport === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let furnitureController: any = __args[2];
            let viewFactory: any = __args[3];
            let contentManager: any = __args[4];
            let undoSupport: any = __args[5];
            {
                let __args = arguments;
                let piece: any = null;
                let modelName: any = null;
                super(preferences, viewFactory);
                if (this.home === undefined) { this.home = null; }
                if (this.piece === undefined) { this.piece = null; }
                if (this.modelName === undefined) { this.modelName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
                if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
                if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
                if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.modelSize === undefined) { this.modelSize = 0; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
                this.home = home;
                this.piece = piece;
                this.modelName = modelName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
                this.furnitureController = furnitureController;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
                this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
                this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
                this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
                this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
                this.setStepState(this.furnitureModelStepState);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
        } else if (((typeof home === 'string') || home === null) && ((piece != null && piece instanceof <any>UserPreferences) || piece === null) && ((modelName != null && (modelName.constructor != null && modelName.constructor["__interfaces"] != null && modelName.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || modelName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || preferences === null) && furnitureController === undefined && viewFactory === undefined && contentManager === undefined && undoSupport === undefined) {
            let __args = arguments;
            let modelName: any = __args[0];
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let home: any = null;
                let piece: any = null;
                let furnitureController: any = null;
                let undoSupport: any = null;
                super(preferences, viewFactory);
                if (this.home === undefined) { this.home = null; }
                if (this.piece === undefined) { this.piece = null; }
                if (this.modelName === undefined) { this.modelName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
                if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
                if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
                if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.modelSize === undefined) { this.modelSize = 0; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
                this.home = home;
                this.piece = piece;
                this.modelName = modelName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
                this.furnitureController = furnitureController;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
                this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
                this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
                this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
                this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
                this.setStepState(this.furnitureModelStepState);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
        } else if (((home != null && home instanceof <any>CatalogPieceOfFurniture) || home === null) && ((piece != null && piece instanceof <any>UserPreferences) || piece === null) && ((modelName != null && (modelName.constructor != null && modelName.constructor["__interfaces"] != null && modelName.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || modelName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || preferences === null) && furnitureController === undefined && viewFactory === undefined && contentManager === undefined && undoSupport === undefined) {
            let __args = arguments;
            let piece: any = __args[0];
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let home: any = null;
                let modelName: any = null;
                let furnitureController: any = null;
                let undoSupport: any = null;
                super(preferences, viewFactory);
                if (this.home === undefined) { this.home = null; }
                if (this.piece === undefined) { this.piece = null; }
                if (this.modelName === undefined) { this.modelName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
                if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
                if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
                if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.modelSize === undefined) { this.modelSize = 0; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
                this.home = home;
                this.piece = piece;
                this.modelName = modelName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
                this.furnitureController = furnitureController;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
                this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
                this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
                this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
                this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
                this.setStepState(this.furnitureModelStepState);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
        } else if (((home != null && home instanceof <any>UserPreferences) || home === null) && ((piece != null && (piece.constructor != null && piece.constructor["__interfaces"] != null && piece.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || piece === null) && ((modelName != null && (modelName.constructor != null && modelName.constructor["__interfaces"] != null && modelName.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || modelName === null) && preferences === undefined && furnitureController === undefined && viewFactory === undefined && contentManager === undefined && undoSupport === undefined) {
            let __args = arguments;
            let preferences: any = __args[0];
            let viewFactory: any = __args[1];
            let contentManager: any = __args[2];
            {
                let __args = arguments;
                let home: any = null;
                let piece: any = null;
                let modelName: any = null;
                let furnitureController: any = null;
                let undoSupport: any = null;
                super(preferences, viewFactory);
                if (this.home === undefined) { this.home = null; }
                if (this.piece === undefined) { this.piece = null; }
                if (this.modelName === undefined) { this.modelName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
                if (this.furnitureController === undefined) { this.furnitureController = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.undoSupport === undefined) { this.undoSupport = null; }
                if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
                if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
                if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
                if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.model === undefined) { this.model = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
                if (this.depth === undefined) { this.depth = 0; }
                if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
                if (this.height === undefined) { this.height = 0; }
                if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
                if (this.elevation === undefined) { this.elevation = 0; }
                if (this.movable === undefined) { this.movable = false; }
                if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
                if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
                if (this.color === undefined) { this.color = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.modelSize === undefined) { this.modelSize = 0; }
                if (this.modelRotation === undefined) { this.modelRotation = null; }
                if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
                if (this.backFaceShown === undefined) { this.backFaceShown = false; }
                if (this.iconYaw === undefined) { this.iconYaw = 0; }
                if (this.iconPitch === undefined) { this.iconPitch = 0; }
                if (this.iconScale === undefined) { this.iconScale = 0; }
                if (this.proportional === undefined) { this.proportional = false; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
                this.home = home;
                this.piece = piece;
                this.modelName = modelName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = preferences;
                this.furnitureController = furnitureController;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = viewFactory;
                this.undoSupport = undoSupport;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getLocalizedString(ImportedFurnitureWizardController, piece == null ? "importFurnitureWizard.title" : "modifyFurnitureWizard.title"));
                this.furnitureModelStepState = new ImportedFurnitureWizardController.FurnitureModelStepState(this);
                this.furnitureOrientationStepState = new ImportedFurnitureWizardController.FurnitureOrientationStepState(this);
                this.furnitureAttributesStepState = new ImportedFurnitureWizardController.FurnitureAttributesStepState(this);
                this.furnitureIconStepState = new ImportedFurnitureWizardController.FurnitureIconStepState(this);
                this.setStepState(this.furnitureModelStepState);
            }
            if (this.home === undefined) { this.home = null; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.modelName === undefined) { this.modelName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences = null; }
            if (this.furnitureController === undefined) { this.furnitureController = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.undoSupport === undefined) { this.undoSupport = null; }
            if (this.furnitureModelStepState === undefined) { this.furnitureModelStepState = null; }
            if (this.furnitureOrientationStepState === undefined) { this.furnitureOrientationStepState = null; }
            if (this.furnitureAttributesStepState === undefined) { this.furnitureAttributesStepState = null; }
            if (this.furnitureIconStepState === undefined) { this.furnitureIconStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.model === undefined) { this.model = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.proportionalWidth === undefined) { this.proportionalWidth = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.proportionalDepth === undefined) { this.proportionalDepth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.proportionalHeight === undefined) { this.proportionalHeight = 0; }
            if (this.elevation === undefined) { this.elevation = 0; }
            if (this.movable === undefined) { this.movable = false; }
            if (this.doorOrWindow === undefined) { this.doorOrWindow = false; }
            if (this.staircaseCutOutShape === undefined) { this.staircaseCutOutShape = null; }
            if (this.color === undefined) { this.color = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.modelSize === undefined) { this.modelSize = 0; }
            if (this.modelRotation === undefined) { this.modelRotation = null; }
            if (this.edgeColorMaterialHidden === undefined) { this.edgeColorMaterialHidden = false; }
            if (this.backFaceShown === undefined) { this.backFaceShown = false; }
            if (this.iconYaw === undefined) { this.iconYaw = 0; }
            if (this.iconPitch === undefined) { this.iconPitch = 0; }
            if (this.iconScale === undefined) { this.iconScale = 0; }
            if (this.proportional === undefined) { this.proportional = false; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Imports piece in catalog and/or home and posts an undoable operation.
     */
    public finish() {
        let newPiece: CatalogPieceOfFurniture;
        const modelFlags: number = (this.isBackFaceShown() ? PieceOfFurniture.SHOW_BACK_FACE : 0) | (this.isEdgeColorMaterialHidden() ? PieceOfFurniture.HIDE_EDGE_COLOR_MATERIAL : 0);
        if (this.isDoorOrWindow()) {
            newPiece = new CatalogDoorOrWindow(this.getName(), this.getIcon(), this.getModel(), this.getWidth(), this.getDepth(), this.getHeight(), this.getElevation(), this.isMovable(), 1, 0, [], this.getColor(), this.getModelRotation(), modelFlags, this.getModelSize(), this.getCreator(), this.getIconYaw(), this.getIconPitch(), this.getIconScale(), this.isProportional());
        } else {
            newPiece = new CatalogPieceOfFurniture(this.getName(), this.getIcon(), this.getModel(), this.getWidth(), this.getDepth(), this.getHeight(), this.getElevation(), this.isMovable(), this.getStaircaseCutOutShape(), this.getColor(), this.getModelRotation(), modelFlags, this.getModelSize(), this.getCreator(), this.getIconYaw(), this.getIconPitch(), this.getIconScale(), this.isProportional());
        }
        if (this.home != null) {
            this.addPieceOfFurniture(this.furnitureController.createHomePieceOfFurniture(newPiece));
        }
        const catalog: FurnitureCatalog = this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences.getFurnitureCatalog();
        if (this.piece != null) {
            catalog.delete(this.piece);
        }
        if (this.category != null) {
            catalog.add(this.category, newPiece);
        }
    }

    /**
     * Controls new piece added to home.
     * Once added the furniture will be selected in view
     * and undo support will receive a new undoable edit.
     * @param {HomePieceOfFurniture} piece the piece of furniture to add.
     */
    public addPieceOfFurniture(piece: HomePieceOfFurniture) {
        const basePlanLocked: boolean = this.home.isBasePlanLocked();
        const allLevelsSelection: boolean = this.home.isAllLevelsSelection();
        const oldSelection: Array<Selectable> = this.home.getSelectedItems();
        const pieceIndex: number = /* size */(<number>this.home.getFurniture().length);
        this.home.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(piece, pieceIndex);
        this.home.setSelectedItems(/* asList */[piece]);
        if (!piece.isMovable() && basePlanLocked) {
            this.home.setBasePlanLocked(false);
        }
        this.home.setAllLevelsSelection(false);
        if (this.undoSupport != null) {
            const undoableEdit: javax.swing.undo.UndoableEdit = new ImportedFurnitureWizardController.PieceOfFurnitureImportationUndoableEdit(this.home, this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences, /* toArray */oldSelection.slice(0), basePlanLocked, allLevelsSelection, piece, pieceIndex);
            this.undoSupport.postEdit(undoableEdit);
        }
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Returns the current step state.
     * @return {ImportedFurnitureWizardController.ImportedFurnitureWizardStepState}
     */
    getStepState(): ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        return <ImportedFurnitureWizardController.ImportedFurnitureWizardStepState>super.getStepState();
    }

    /**
     * Returns the furniture choice step state.
     * @return {ImportedFurnitureWizardController.ImportedFurnitureWizardStepState}
     */
    getFurnitureModelStepState(): ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        return this.furnitureModelStepState;
    }

    /**
     * Returns the furniture orientation step state.
     * @return {ImportedFurnitureWizardController.ImportedFurnitureWizardStepState}
     */
    getFurnitureOrientationStepState(): ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        return this.furnitureOrientationStepState;
    }

    /**
     * Returns the furniture attributes step state.
     * @return {ImportedFurnitureWizardController.ImportedFurnitureWizardStepState}
     */
    getFurnitureAttributesStepState(): ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        return this.furnitureAttributesStepState;
    }

    /**
     * Returns the furniture icon step state.
     * @return {ImportedFurnitureWizardController.ImportedFurnitureWizardStepState}
     */
    getFurnitureIconStepState(): ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        return this.furnitureIconStepState;
    }

    /**
     * Returns the unique wizard view used for all steps.
     * @return {Object}
     */
    getStepsView(): ImportedFurnitureWizardStepsView {
        if (this.stepsView == null) {
            this.stepsView = this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_viewFactory.createImportedFurnitureWizardStepsView(this.piece, this.modelName, this.home != null, this.__com_eteks_sweethome3d_viewcontroller_ImportedFurnitureWizardController_preferences, this);
        }
        return this.stepsView;
    }

    /**
     * Switch in the wizard view to the given <code>step</code>.
     * @param {ImportedFurnitureWizardController.Step} step
     */
    setStep(step: ImportedFurnitureWizardController.Step) {
        if (step !== this.step) {
            const oldStep: ImportedFurnitureWizardController.Step = this.step;
            this.step = step;
            this.propertyChangeSupport.firePropertyChange(/* name */"STEP", oldStep, step);
        }
    }

    /**
     * Returns the current step in wizard view.
     * @return {ImportedFurnitureWizardController.Step}
     */
    public getStep(): ImportedFurnitureWizardController.Step {
        return this.step;
    }

    /**
     * Returns the model content of the imported piece.
     * @return {Object}
     */
    public getModel(): Content {
        return this.model;
    }

    /**
     * Sets the model content of the imported piece.
     * @param {Object} model
     */
    public setModel(model: Content) {
        if (model !== this.model) {
            const oldModel: Content = this.model;
            this.model = model;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL", oldModel, model);
        }
    }

    /**
     * Returns <code>true</code> if imported piece back face should be shown.
     * @return {boolean}
     */
    public isBackFaceShown(): boolean {
        return this.backFaceShown;
    }

    /**
     * Sets whether imported piece back face should be shown.
     * @param {boolean} backFaceShown
     */
    public setBackFaceShown(backFaceShown: boolean) {
        if (backFaceShown !== this.backFaceShown) {
            this.backFaceShown = backFaceShown;
            this.propertyChangeSupport.firePropertyChange(/* name */"BACK_FACE_SHOWN", !backFaceShown, backFaceShown);
        }
    }

    /**
     * Returns the model size of the imported piece.
     * @return {number}
     */
    public getModelSize(): number {
        return this.modelSize;
    }

    /**
     * Sets the model size of the content of the imported piece.
     * @param {number} modelSize
     */
    public setModelSize(modelSize: number) {
        if (modelSize !== this.modelSize) {
            const oldModelSize: number = this.modelSize;
            this.modelSize = modelSize;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL_SIZE", oldModelSize, modelSize);
        }
    }

    /**
     * Returns the pitch angle of the imported piece model.
     * @return {float[][]}
     */
    public getModelRotation(): number[][] {
        return this.modelRotation;
    }

    /**
     * Sets the orientation pitch angle of the imported piece model.
     * @param {float[][]} modelRotation
     */
    public setModelRotation(modelRotation: number[][]) {
        if (modelRotation !== this.modelRotation) {
            const oldModelRotation: number[][] = this.modelRotation;
            this.modelRotation = modelRotation;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODEL_ROTATION", oldModelRotation, modelRotation);
        }
    }

    /**
     * Returns <code>true</code> if edge color materials should be hidden.
     * @return {boolean}
     */
    public isEdgeColorMaterialHidden(): boolean {
        return this.edgeColorMaterialHidden;
    }

    /**
     * Sets whether edge color materials should be hidden or not.
     * @param {boolean} edgeColorMaterialHidden
     */
    public setEdgeColorMaterialHidden(edgeColorMaterialHidden: boolean) {
        if (edgeColorMaterialHidden !== this.edgeColorMaterialHidden) {
            this.edgeColorMaterialHidden = edgeColorMaterialHidden;
            this.propertyChangeSupport.firePropertyChange(/* name */"EDGE_COLOR_MATERIAL_HIDDEN", !edgeColorMaterialHidden, edgeColorMaterialHidden);
        }
    }

    /**
     * Returns the name of the imported piece.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of the imported piece.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name) {
            const oldName: string = this.name;
            this.name = name;
            if (this.propertyChangeSupport != null) {
                this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
            }
        }
    }

    /**
     * Returns the creator of the imported piece.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Sets the creator of the imported piece.
     * @param {string} creator
     */
    public setCreator(creator: string) {
        if (creator !== this.creator) {
            const oldCreator: string = this.creator;
            this.creator = creator;
            if (this.propertyChangeSupport != null) {
                this.propertyChangeSupport.firePropertyChange(/* name */"CREATOR", oldCreator, creator);
            }
        }
    }

    /**
     * Returns the width.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    public setWidth$float(width: number) {
        this.setWidth$float$boolean(width, false);
    }

    public setWidth$float$boolean(width: number, keepProportionalWidthUnchanged: boolean) {
        const adjustedWidth: number = Math.max(width, 0.001);
        if (adjustedWidth === width || !keepProportionalWidthUnchanged) {
            this.proportionalWidth = width;
        }
        if (adjustedWidth !== this.width) {
            const oldWidth: number = this.width;
            this.width = adjustedWidth;
            this.propertyChangeSupport.firePropertyChange(/* name */"WIDTH", oldWidth, adjustedWidth);
        }
    }

    /**
     * Sets the width of the imported piece.
     * @param {number} width
     * @param {boolean} keepProportionalWidthUnchanged
     * @private
     */
    public setWidth(width?: any, keepProportionalWidthUnchanged?: any) {
        if (((typeof width === 'number') || width === null) && ((typeof keepProportionalWidthUnchanged === 'boolean') || keepProportionalWidthUnchanged === null)) {
            return <any>this.setWidth$float$boolean(width, keepProportionalWidthUnchanged);
        } else if (((typeof width === 'number') || width === null) && keepProportionalWidthUnchanged === undefined) {
            return <any>this.setWidth$float(width);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the depth of the imported piece.
     * @return {number}
     */
    public getDepth(): number {
        return this.depth;
    }

    public setDepth$float(depth: number) {
        this.setDepth$float$boolean(depth, false);
    }

    public setDepth$float$boolean(depth: number, keepProportionalDepthUnchanged: boolean) {
        const adjustedDepth: number = Math.max(depth, 0.001);
        if (adjustedDepth === depth || !keepProportionalDepthUnchanged) {
            this.proportionalDepth = depth;
        }
        if (adjustedDepth !== this.depth) {
            const oldDepth: number = this.depth;
            this.depth = adjustedDepth;
            this.propertyChangeSupport.firePropertyChange(/* name */"DEPTH", oldDepth, adjustedDepth);
        }
    }

    /**
     * Sets the depth of the imported piece.
     * @param {number} depth
     * @param {boolean} keepProportionalDepthUnchanged
     * @private
     */
    public setDepth(depth?: any, keepProportionalDepthUnchanged?: any) {
        if (((typeof depth === 'number') || depth === null) && ((typeof keepProportionalDepthUnchanged === 'boolean') || keepProportionalDepthUnchanged === null)) {
            return <any>this.setDepth$float$boolean(depth, keepProportionalDepthUnchanged);
        } else if (((typeof depth === 'number') || depth === null) && keepProportionalDepthUnchanged === undefined) {
            return <any>this.setDepth$float(depth);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the height.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    public setHeight$float(height: number) {
        this.setHeight$float$boolean(height, false);
    }

    public setHeight$float$boolean(height: number, keepProportionalHeightUnchanged: boolean) {
        const adjustedHeight: number = Math.max(height, 0.001);
        if (adjustedHeight === height || !keepProportionalHeightUnchanged) {
            this.proportionalHeight = height;
        }
        if (adjustedHeight !== this.height) {
            const oldHeight: number = this.height;
            this.height = adjustedHeight;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, adjustedHeight);
        }
    }

    /**
     * Sets the size of the imported piece.
     * @param {number} height
     * @param {boolean} keepProportionalHeightUnchanged
     * @private
     */
    public setHeight(height?: any, keepProportionalHeightUnchanged?: any) {
        if (((typeof height === 'number') || height === null) && ((typeof keepProportionalHeightUnchanged === 'boolean') || keepProportionalHeightUnchanged === null)) {
            return <any>this.setHeight$float$boolean(height, keepProportionalHeightUnchanged);
        } else if (((typeof height === 'number') || height === null) && keepProportionalHeightUnchanged === undefined) {
            return <any>this.setHeight$float(height);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the elevation of the imported piece.
     * @return {number}
     */
    public getElevation(): number {
        return this.elevation;
    }

    /**
     * Sets the elevation of the imported piece.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.elevation) {
            const oldElevation: number = this.elevation;
            this.elevation = elevation;
            this.propertyChangeSupport.firePropertyChange(/* name */"ELEVATION", oldElevation, elevation);
        }
    }

    /**
     * Returns <code>true</code> if imported piece is movable.
     * @return {boolean}
     */
    public isMovable(): boolean {
        return this.movable;
    }

    /**
     * Sets whether imported piece is movable.
     * @param {boolean} movable
     */
    public setMovable(movable: boolean) {
        if (movable !== this.movable) {
            this.movable = movable;
            this.propertyChangeSupport.firePropertyChange(/* name */"MOVABLE", !movable, movable);
        }
    }

    /**
     * Returns <code>true</code> if imported piece is a door or a window.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return this.doorOrWindow;
    }

    /**
     * Sets whether imported piece is a door or a window.
     * @param {boolean} doorOrWindow
     */
    public setDoorOrWindow(doorOrWindow: boolean) {
        if (doorOrWindow !== this.doorOrWindow) {
            this.doorOrWindow = doorOrWindow;
            this.propertyChangeSupport.firePropertyChange(/* name */"DOOR_OR_WINDOW", !doorOrWindow, doorOrWindow);
            if (doorOrWindow) {
                this.setStaircaseCutOutShape(null);
                this.setMovable(false);
            }
        }
    }

    /**
     * Returns the shape used to cut out upper levels at its intersection with a staircase.
     * @return {string}
     */
    public getStaircaseCutOutShape(): string {
        return this.staircaseCutOutShape;
    }

    /**
     * Sets the shape used to cut out upper levels at its intersection with a staircase.
     * @param {string} staircaseCutOutShape
     */
    public setStaircaseCutOutShape(staircaseCutOutShape: string) {
        if (staircaseCutOutShape !== this.staircaseCutOutShape) {
            const oldStaircaseCutOutShape: string = this.staircaseCutOutShape;
            this.staircaseCutOutShape = staircaseCutOutShape;
            if (this.propertyChangeSupport != null) {
                this.propertyChangeSupport.firePropertyChange(/* name */"STAIRCASE_CUT_OUT_SHAPE", oldStaircaseCutOutShape, staircaseCutOutShape);
            }
            if (this.staircaseCutOutShape != null) {
                this.setDoorOrWindow(false);
                this.setMovable(false);
            }
        }
    }

    /**
     * Returns the color of the imported piece.
     * @return {number}
     */
    public getColor(): number {
        return this.color;
    }

    /**
     * Sets the color of the imported piece.
     * @param {number} color
     */
    public setColor(color: number) {
        if (color !== this.color) {
            const oldColor: number = this.color;
            this.color = color;
            this.propertyChangeSupport.firePropertyChange(/* name */"COLOR", oldColor, color);
        }
    }

    /**
     * Returns the category of the imported piece.
     * @return {FurnitureCategory}
     */
    public getCategory(): FurnitureCategory {
        return this.category;
    }

    /**
     * Sets the category of the imported piece.
     * @param {FurnitureCategory} category
     */
    public setCategory(category: FurnitureCategory) {
        if (category !== this.category) {
            const oldCategory: FurnitureCategory = this.category;
            this.category = category;
            this.propertyChangeSupport.firePropertyChange(/* name */"CATEGORY", oldCategory, category);
        }
    }

    /**
     * Returns the icon of the imported piece.
     * @return {Object}
     * @private
     */
    getIcon(): Content {
        return this.getStepsView().getIcon();
    }

    /**
     * Returns the yaw angle of the piece icon.
     * @return {number}
     */
    public getIconYaw(): number {
        return this.iconYaw;
    }

    /**
     * Sets the yaw angle of the piece icon.
     * @param {number} iconYaw
     */
    public setIconYaw(iconYaw: number) {
        if (iconYaw !== this.iconYaw) {
            const oldIconYaw: number = this.iconYaw;
            this.iconYaw = iconYaw;
            this.propertyChangeSupport.firePropertyChange(/* name */"ICON_YAW", oldIconYaw, iconYaw);
        }
    }

    /**
     * Returns the pitch angle of the piece icon.
     * @return {number}
     */
    public getIconPitch(): number {
        return this.iconPitch;
    }

    /**
     * Sets the pitch angle of the piece icon.
     * @param {number} iconPitch
     */
    public setIconPitch(iconPitch: number) {
        if (iconPitch !== this.iconPitch) {
            const oldIconPitch: number = this.iconPitch;
            this.iconPitch = iconPitch;
            this.propertyChangeSupport.firePropertyChange(/* name */"ICON_PITCH", oldIconPitch, iconPitch);
        }
    }

    /**
     * Returns the scale of the piece icon.
     * @return {number}
     */
    public getIconScale(): number {
        return this.iconScale;
    }

    /**
     * Sets the scale of the piece icon.
     * @param {number} iconScale
     */
    public setIconScale(iconScale: number) {
        if (iconScale !== this.iconScale) {
            const oldIconScale: number = this.iconScale;
            this.iconScale = iconScale;
            this.propertyChangeSupport.firePropertyChange(/* name */"ICON_SCALE", oldIconScale, iconScale);
        }
    }

    /**
     * Returns <code>true</code> if piece proportions should be kept.
     * @return {boolean}
     */
    public isProportional(): boolean {
        return this.proportional;
    }

    /**
     * Sets whether piece proportions should be kept or not.
     * @param {boolean} proportional
     */
    public setProportional(proportional: boolean) {
        if (proportional !== this.proportional) {
            this.proportional = proportional;
            this.propertyChangeSupport.firePropertyChange(/* name */"PROPORTIONAL", !proportional, proportional);
        }
    }

    /**
     * Returns <code>true</code> if piece name is valid.
     * @return {boolean}
     */
    public isPieceOfFurnitureNameValid(): boolean {
        return this.name != null && this.name.length > 0;
    }
}
ImportedFurnitureWizardController["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController";
ImportedFurnitureWizardController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace ImportedFurnitureWizardController {

    export enum Step {
        MODEL, ROTATION, ATTRIBUTES, ICON
    }

    /**
     * Undoable edit for piece importation. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class PieceOfFurnitureImportationUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        piece: HomePieceOfFurniture;

        pieceIndex: number;

        constructor(home: Home, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, piece: HomePieceOfFurniture, pieceIndex: number) {
            super(preferences, ImportedFurnitureWizardController, "undoImportFurnitureName");
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.pieceIndex === undefined) { this.pieceIndex = 0; }
            this.home = home;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.piece = piece;
            this.pieceIndex = pieceIndex;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.deletePieceOfFurniture(this.piece);
            this.home.setSelectedItems(/* asList */this.oldSelection.slice(0));
            this.home.setAllLevelsSelection(this.oldAllLevelsSelection);
            this.home.setBasePlanLocked(this.oldBasePlanLocked);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(this.piece, this.pieceIndex);
            this.home.setSelectedItems(/* asList */[this.piece]);
            if (!this.piece.isMovable() && this.oldBasePlanLocked) {
                this.home.setBasePlanLocked(false);
            }
            this.home.setAllLevelsSelection(false);
        }
    }
    PieceOfFurnitureImportationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.PieceOfFurnitureImportationUndoableEdit";
    PieceOfFurnitureImportationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Step state superclass. All step state share the same step view,
     * that will display a different component depending on their class name.
     * @extends WizardController.WizardControllerStepState
     * @class
     */
    export abstract class ImportedFurnitureWizardStepState extends WizardController.WizardControllerStepState {
        public __parent: any;
        icon: string;

        public abstract getStep(): ImportedFurnitureWizardController.Step;

        /**
         * 
         */
        public enter() {
            this.__parent.setStep(this.getStep());
        }

        /**
         * 
         * @return {Object}
         */
        public getView(): View {
            return this.__parent.getStepsView();
        }

        /**
         * 
         * @return {string}
         */
        public getIcon(): string {
            return this.icon;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            this.icon = /* getResource */"resources/importedFurnitureWizard.png";
        }
    }
    ImportedFurnitureWizardStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.ImportedFurnitureWizardStepState";


    /**
     * Furniture model step state (first step).
     * @extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState
     * @class
     */
    export class FurnitureModelStepState extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        public __parent: any;
        modelChangeListener: PropertyChangeListener;

        /**
         * 
         */
        public enter() {
            super.enter();
            this.setFirstStep(true);
            this.setNextStepEnabled(this.__parent.getModel() != null);
            this.__parent.addPropertyChangeListener("MODEL", this.modelChangeListener);
        }

        /**
         * 
         * @return {ImportedFurnitureWizardController.Step}
         */
        public getStep(): ImportedFurnitureWizardController.Step {
            return ImportedFurnitureWizardController.Step.MODEL;
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getFurnitureOrientationStepState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.removePropertyChangeListener("MODEL", this.modelChangeListener);
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            this.modelChangeListener = new FurnitureModelStepState.FurnitureModelStepState$0(this);
        }
    }
    FurnitureModelStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.FurnitureModelStepState";


    export namespace FurnitureModelStepState {

        export class FurnitureModelStepState$0 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.setNextStepEnabled(this.__parent.__parent.getModel() != null);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Furniture orientation step state (second step).
     * @extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState
     * @class
     */
    export class FurnitureOrientationStepState extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        public __parent: any;
        /**
         * 
         */
        public enter() {
            super.enter();
            this.setNextStepEnabled(true);
        }

        /**
         * 
         * @return {ImportedFurnitureWizardController.Step}
         */
        public getStep(): ImportedFurnitureWizardController.Step {
            return ImportedFurnitureWizardController.Step.ROTATION;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getFurnitureModelStepState());
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getFurnitureAttributesStepState());
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
        }
    }
    FurnitureOrientationStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.FurnitureOrientationStepState";


    /**
     * Furniture attributes step state (third step).
     * @extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState
     * @class
     */
    export class FurnitureAttributesStepState extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        public __parent: any;
        widthChangeListener: PropertyChangeListener;

        depthChangeListener: PropertyChangeListener;

        heightChangeListener: PropertyChangeListener;

        nameAndCategoryChangeListener: PropertyChangeListener;

        /**
         * 
         */
        public enter() {
            super.enter();
            this.__parent.addPropertyChangeListener("WIDTH", this.widthChangeListener);
            this.__parent.addPropertyChangeListener("DEPTH", this.depthChangeListener);
            this.__parent.addPropertyChangeListener("HEIGHT", this.heightChangeListener);
            this.__parent.addPropertyChangeListener("NAME", this.nameAndCategoryChangeListener);
            this.__parent.addPropertyChangeListener("CATEGORY", this.nameAndCategoryChangeListener);
            this.checkPieceOfFurnitureNameInCategory();
        }

        checkPieceOfFurnitureNameInCategory() {
            this.setNextStepEnabled(this.__parent.isPieceOfFurnitureNameValid());
        }

        /**
         * 
         * @return {ImportedFurnitureWizardController.Step}
         */
        public getStep(): ImportedFurnitureWizardController.Step {
            return ImportedFurnitureWizardController.Step.ATTRIBUTES;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getFurnitureOrientationStepState());
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getFurnitureIconStepState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.removePropertyChangeListener("WIDTH", this.widthChangeListener);
            this.__parent.removePropertyChangeListener("DEPTH", this.depthChangeListener);
            this.__parent.removePropertyChangeListener("HEIGHT", this.heightChangeListener);
            this.__parent.removePropertyChangeListener("NAME", this.nameAndCategoryChangeListener);
            this.__parent.removePropertyChangeListener("CATEGORY", this.nameAndCategoryChangeListener);
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            this.widthChangeListener = new FurnitureAttributesStepState.FurnitureAttributesStepState$0(this);
            this.depthChangeListener = new FurnitureAttributesStepState.FurnitureAttributesStepState$1(this);
            this.heightChangeListener = new FurnitureAttributesStepState.FurnitureAttributesStepState$2(this);
            this.nameAndCategoryChangeListener = new FurnitureAttributesStepState.FurnitureAttributesStepState$3(this);
        }
    }
    FurnitureAttributesStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.FurnitureAttributesStepState";


    export namespace FurnitureAttributesStepState {

        export class FurnitureAttributesStepState$0 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                if (this.__parent.__parent.isProportional()) {
                    this.__parent.__parent.removePropertyChangeListener("DEPTH", this.__parent.depthChangeListener);
                    this.__parent.__parent.removePropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
                    const ratio: number = <number>ev.getNewValue() / <number>ev.getOldValue();
                    this.__parent.__parent.setDepth(this.__parent.__parent.proportionalDepth * ratio, true);
                    this.__parent.__parent.setHeight(this.__parent.__parent.proportionalHeight * ratio, true);
                    this.__parent.__parent.addPropertyChangeListener("DEPTH", this.__parent.depthChangeListener);
                    this.__parent.__parent.addPropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
                }
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class FurnitureAttributesStepState$1 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                if (this.__parent.__parent.isProportional()) {
                    this.__parent.__parent.removePropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
                    this.__parent.__parent.removePropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
                    const ratio: number = <number>ev.getNewValue() / <number>ev.getOldValue();
                    this.__parent.__parent.setWidth(this.__parent.__parent.proportionalWidth * ratio, true);
                    this.__parent.__parent.setHeight(this.__parent.__parent.proportionalHeight * ratio, true);
                    this.__parent.__parent.addPropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
                    this.__parent.__parent.addPropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
                }
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class FurnitureAttributesStepState$2 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                if (this.__parent.__parent.isProportional()) {
                    this.__parent.__parent.removePropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
                    this.__parent.__parent.removePropertyChangeListener("DEPTH", this.__parent.depthChangeListener);
                    const ratio: number = <number>ev.getNewValue() / <number>ev.getOldValue();
                    this.__parent.__parent.setWidth(this.__parent.__parent.proportionalWidth * ratio, true);
                    this.__parent.__parent.setDepth(this.__parent.__parent.proportionalDepth * ratio, true);
                    this.__parent.__parent.addPropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
                    this.__parent.__parent.addPropertyChangeListener("DEPTH", this.__parent.depthChangeListener);
                }
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class FurnitureAttributesStepState$3 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.checkPieceOfFurnitureNameInCategory();
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Furniture icon step state (last step).
     * @extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState
     * @class
     */
    export class FurnitureIconStepState extends ImportedFurnitureWizardController.ImportedFurnitureWizardStepState {
        public __parent: any;
        /**
         * 
         */
        public enter() {
            super.enter();
            this.setLastStep(true);
            this.setNextStepEnabled(true);
        }

        /**
         * 
         * @return {ImportedFurnitureWizardController.Step}
         */
        public getStep(): ImportedFurnitureWizardController.Step {
            return ImportedFurnitureWizardController.Step.ICON;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getFurnitureAttributesStepState());
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
        }
    }
    FurnitureIconStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedFurnitureWizardController.FurnitureIconStepState";

}


/**
 * Creates a controller that edits a new catalog texture with a given
 * <code>textureName</code>.
 * @param {string} textureName
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 * @extends WizardController
 * @author Emmanuel Puybaret
 */
export class ImportedTextureWizardController extends WizardController implements Controller {
    /*private*/ texture: CatalogTexture;

    /*private*/ textureName: string;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences: any;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ textureImageStepState: ImportedTextureWizardController.ImportedTextureWizardStepState;

    /*private*/ textureAttributesStepState: ImportedTextureWizardController.ImportedTextureWizardStepState;

    /*private*/ stepsView: View;

    /*private*/ step: ImportedTextureWizardController.Step;

    /*private*/ image: Content;

    /*private*/ name: string;

    /*private*/ category: TexturesCategory;

    /*private*/ creator: string;

    /*private*/ width: number;

    /*private*/ height: number;

    public constructor(texture?: any, textureName?: any, preferences?: any, viewFactory?: any, contentManager?: any) {
        if (((texture != null && texture instanceof <any>CatalogTexture) || texture === null) && ((typeof textureName === 'string') || textureName === null) && ((preferences != null && preferences instanceof <any>UserPreferences) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || viewFactory === null) && ((contentManager != null && (contentManager.constructor != null && contentManager.constructor["__interfaces"] != null && contentManager.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || contentManager === null)) {
            let __args = arguments;
            super(preferences, viewFactory);
            if (this.texture === undefined) { this.texture = null; }
            if (this.textureName === undefined) { this.textureName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
            if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            this.texture = texture;
            this.textureName = textureName;
            this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = preferences;
            this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = viewFactory;
            this.contentManager = contentManager;
            /* Use propertyChangeSupport defined in super class */;
            this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences.getLocalizedString(ImportedTextureWizardController, texture == null ? "importTextureWizard.title" : "modifyTextureWizard.title"));
            this.textureImageStepState = new ImportedTextureWizardController.TextureImageStepState(this);
            this.textureAttributesStepState = new ImportedTextureWizardController.TextureAttributesStepState(this);
            this.setStepState(this.textureImageStepState);
        } else if (((typeof texture === 'string') || texture === null) && ((textureName != null && textureName instanceof <any>UserPreferences) || textureName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && contentManager === undefined) {
            let __args = arguments;
            let textureName: any = __args[0];
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let texture: any = null;
                super(preferences, viewFactory);
                if (this.texture === undefined) { this.texture = null; }
                if (this.textureName === undefined) { this.textureName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
                if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                this.texture = texture;
                this.textureName = textureName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = preferences;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = viewFactory;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences.getLocalizedString(ImportedTextureWizardController, texture == null ? "importTextureWizard.title" : "modifyTextureWizard.title"));
                this.textureImageStepState = new ImportedTextureWizardController.TextureImageStepState(this);
                this.textureAttributesStepState = new ImportedTextureWizardController.TextureAttributesStepState(this);
                this.setStepState(this.textureImageStepState);
            }
            if (this.texture === undefined) { this.texture = null; }
            if (this.textureName === undefined) { this.textureName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
            if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
        } else if (((texture != null && texture instanceof <any>CatalogTexture) || texture === null) && ((textureName != null && textureName instanceof <any>UserPreferences) || textureName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || preferences === null) && ((viewFactory != null && (viewFactory.constructor != null && viewFactory.constructor["__interfaces"] != null && viewFactory.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || viewFactory === null) && contentManager === undefined) {
            let __args = arguments;
            let preferences: any = __args[1];
            let viewFactory: any = __args[2];
            let contentManager: any = __args[3];
            {
                let __args = arguments;
                let textureName: any = null;
                super(preferences, viewFactory);
                if (this.texture === undefined) { this.texture = null; }
                if (this.textureName === undefined) { this.textureName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
                if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                this.texture = texture;
                this.textureName = textureName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = preferences;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = viewFactory;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences.getLocalizedString(ImportedTextureWizardController, texture == null ? "importTextureWizard.title" : "modifyTextureWizard.title"));
                this.textureImageStepState = new ImportedTextureWizardController.TextureImageStepState(this);
                this.textureAttributesStepState = new ImportedTextureWizardController.TextureAttributesStepState(this);
                this.setStepState(this.textureImageStepState);
            }
            if (this.texture === undefined) { this.texture = null; }
            if (this.textureName === undefined) { this.textureName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
            if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
        } else if (((texture != null && texture instanceof <any>UserPreferences) || texture === null) && ((textureName != null && (textureName.constructor != null && textureName.constructor["__interfaces"] != null && textureName.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ViewFactory") >= 0)) || textureName === null) && ((preferences != null && (preferences.constructor != null && preferences.constructor["__interfaces"] != null && preferences.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.viewcontroller.ContentManager") >= 0)) || preferences === null) && viewFactory === undefined && contentManager === undefined) {
            let __args = arguments;
            let preferences: any = __args[0];
            let viewFactory: any = __args[1];
            let contentManager: any = __args[2];
            {
                let __args = arguments;
                let texture: any = null;
                let textureName: any = null;
                super(preferences, viewFactory);
                if (this.texture === undefined) { this.texture = null; }
                if (this.textureName === undefined) { this.textureName = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
                if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
                if (this.contentManager === undefined) { this.contentManager = null; }
                if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
                if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
                if (this.stepsView === undefined) { this.stepsView = null; }
                if (this.step === undefined) { this.step = null; }
                if (this.image === undefined) { this.image = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.category === undefined) { this.category = null; }
                if (this.creator === undefined) { this.creator = null; }
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                this.texture = texture;
                this.textureName = textureName;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = preferences;
                this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = viewFactory;
                this.contentManager = contentManager;
                /* Use propertyChangeSupport defined in super class */;
                this.setTitle(this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences.getLocalizedString(ImportedTextureWizardController, texture == null ? "importTextureWizard.title" : "modifyTextureWizard.title"));
                this.textureImageStepState = new ImportedTextureWizardController.TextureImageStepState(this);
                this.textureAttributesStepState = new ImportedTextureWizardController.TextureAttributesStepState(this);
                this.setStepState(this.textureImageStepState);
            }
            if (this.texture === undefined) { this.texture = null; }
            if (this.textureName === undefined) { this.textureName = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences = null; }
            if (this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory = null; }
            if (this.contentManager === undefined) { this.contentManager = null; }
            if (this.textureImageStepState === undefined) { this.textureImageStepState = null; }
            if (this.textureAttributesStepState === undefined) { this.textureAttributesStepState = null; }
            if (this.stepsView === undefined) { this.stepsView = null; }
            if (this.step === undefined) { this.step = null; }
            if (this.image === undefined) { this.image = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.category === undefined) { this.category = null; }
            if (this.creator === undefined) { this.creator = null; }
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
        } else throw new Error('invalid overload');
    }

    /**
     * Changes background image in model and posts an undoable operation.
     */
    public finish() {
        const newTexture: CatalogTexture = new CatalogTexture(null, this.getName(), this.getImage(), this.getWidth(), this.getHeight(), this.getCreator(), true);
        const catalog: TexturesCatalog = this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences.getTexturesCatalog();
        if (this.texture != null) {
            catalog.delete(this.texture);
        }
        catalog.add(this.category, newTexture);
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Returns the current step state.
     * @return {ImportedTextureWizardController.ImportedTextureWizardStepState}
     */
    getStepState(): ImportedTextureWizardController.ImportedTextureWizardStepState {
        return <ImportedTextureWizardController.ImportedTextureWizardStepState>super.getStepState();
    }

    /**
     * Returns the texture image step state.
     * @return {ImportedTextureWizardController.ImportedTextureWizardStepState}
     */
    getTextureImageStepState(): ImportedTextureWizardController.ImportedTextureWizardStepState {
        return this.textureImageStepState;
    }

    /**
     * Returns the texture attributes step state.
     * @return {ImportedTextureWizardController.ImportedTextureWizardStepState}
     */
    getTextureAttributesStepState(): ImportedTextureWizardController.ImportedTextureWizardStepState {
        return this.textureAttributesStepState;
    }

    /**
     * Returns the unique wizard view used for all steps.
     * @return {Object}
     */
    getStepsView(): View {
        if (this.stepsView == null) {
            this.stepsView = this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_viewFactory.createImportedTextureWizardStepsView(this.texture, this.textureName, this.__com_eteks_sweethome3d_viewcontroller_ImportedTextureWizardController_preferences, this);
        }
        return this.stepsView;
    }

    /**
     * Switch in the wizard view to the given <code>step</code>.
     * @param {ImportedTextureWizardController.Step} step
     */
    setStep(step: ImportedTextureWizardController.Step) {
        if (step !== this.step) {
            const oldStep: ImportedTextureWizardController.Step = this.step;
            this.step = step;
            this.propertyChangeSupport.firePropertyChange(/* name */"STEP", oldStep, step);
        }
    }

    /**
     * Returns the current step in wizard view.
     * @return {ImportedTextureWizardController.Step}
     */
    public getStep(): ImportedTextureWizardController.Step {
        return this.step;
    }

    /**
     * Sets the image content of the imported texture.
     * @param {Object} image
     */
    public setImage(image: Content) {
        if (image !== this.image) {
            const oldImage: Content = this.image;
            this.image = image;
            this.propertyChangeSupport.firePropertyChange(/* name */"IMAGE", oldImage, image);
        }
    }

    /**
     * Returns the image content of the imported texture.
     * @return {Object}
     */
    public getImage(): Content {
        return this.image;
    }

    /**
     * Returns the name of the imported texture.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of the imported texture.
     * @param {string} name
     */
    public setName(name: string) {
        if (name !== this.name) {
            const oldName: string = this.name;
            this.name = name;
            if (this.propertyChangeSupport != null) {
                this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
            }
        }
    }

    /**
     * Returns the category of the imported texture.
     * @return {TexturesCategory}
     */
    public getCategory(): TexturesCategory {
        return this.category;
    }

    /**
     * Sets the category of the imported texture.
     * @param {TexturesCategory} category
     */
    public setCategory(category: TexturesCategory) {
        if (category !== this.category) {
            const oldCategory: TexturesCategory = this.category;
            this.category = category;
            this.propertyChangeSupport.firePropertyChange(/* name */"CATEGORY", oldCategory, category);
        }
    }

    /**
     * Returns the creator of the imported piece.
     * @return {string}
     */
    public getCreator(): string {
        return this.creator;
    }

    /**
     * Sets the creator of the imported piece.
     * @param {string} creator
     */
    public setCreator(creator: string) {
        if (creator !== this.creator) {
            const oldCreator: string = this.creator;
            this.creator = creator;
            if (this.propertyChangeSupport != null) {
                this.propertyChangeSupport.firePropertyChange(/* name */"CREATOR", oldCreator, creator);
            }
        }
    }

    /**
     * Returns the width.
     * @return {number}
     */
    public getWidth(): number {
        return this.width;
    }

    /**
     * Sets the width of the imported texture.
     * @param {number} width
     */
    public setWidth(width: number) {
        if (width !== this.width) {
            const oldWidth: number = this.width;
            this.width = width;
            this.propertyChangeSupport.firePropertyChange(/* name */"WIDTH", oldWidth, width);
        }
    }

    /**
     * Returns the height.
     * @return {number}
     */
    public getHeight(): number {
        return this.height;
    }

    /**
     * Sets the size of the imported texture.
     * @param {number} height
     */
    public setHeight(height: number) {
        if (height !== this.height) {
            const oldHeight: number = this.height;
            this.height = height;
            this.propertyChangeSupport.firePropertyChange(/* name */"HEIGHT", oldHeight, height);
        }
    }

    /**
     * Returns <code>true</code> if texture name is valid.
     * @return {boolean}
     */
    public isTextureNameValid(): boolean {
        return this.name != null && this.name.length > 0 && this.category != null;
    }
}
ImportedTextureWizardController["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedTextureWizardController";
ImportedTextureWizardController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace ImportedTextureWizardController {

    export enum Step {
        IMAGE, ATTRIBUTES
    }

    /**
     * Step state superclass. All step state share the same step view,
     * that will display a different component depending on their class name.
     * @extends WizardController.WizardControllerStepState
     * @class
     */
    export abstract class ImportedTextureWizardStepState extends WizardController.WizardControllerStepState {
        public __parent: any;
        icon: string;

        public abstract getStep(): ImportedTextureWizardController.Step;

        /**
         * 
         */
        public enter() {
            this.__parent.setStep(this.getStep());
        }

        /**
         * 
         * @return {Object}
         */
        public getView(): View {
            return this.__parent.getStepsView();
        }

        /**
         * 
         * @return {string}
         */
        public getIcon(): string {
            return this.icon;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            this.icon = /* getResource */"resources/importedTextureWizard.png";
        }
    }
    ImportedTextureWizardStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedTextureWizardController.ImportedTextureWizardStepState";


    /**
     * Texture image choice step state (first step).
     * @class
     * @extends ImportedTextureWizardController.ImportedTextureWizardStepState
     */
    export class TextureImageStepState extends ImportedTextureWizardController.ImportedTextureWizardStepState {
        public __parent: any;
        public constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            __parent.addPropertyChangeListener("IMAGE", new TextureImageStepState.TextureImageStepState$0(this));
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.setFirstStep(true);
            this.setNextStepEnabled(this.__parent.getImage() != null);
        }

        /**
         * 
         * @return {ImportedTextureWizardController.Step}
         */
        public getStep(): ImportedTextureWizardController.Step {
            return ImportedTextureWizardController.Step.IMAGE;
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getTextureAttributesStepState());
        }
    }
    TextureImageStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedTextureWizardController.TextureImageStepState";


    export namespace TextureImageStepState {

        export class TextureImageStepState$0 {
            public __parent: any;
            public propertyChange(evt: PropertyChangeEvent) {
                this.__parent.setNextStepEnabled(this.__parent.__parent.getImage() != null);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Texture image attributes step state (last step).
     * @class
     * @extends ImportedTextureWizardController.ImportedTextureWizardStepState
     */
    export class TextureAttributesStepState extends ImportedTextureWizardController.ImportedTextureWizardStepState {
        public __parent: any;
        widthChangeListener: PropertyChangeListener;

        heightChangeListener: PropertyChangeListener;

        nameAndCategoryChangeListener: PropertyChangeListener;

        public constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.widthChangeListener === undefined) { this.widthChangeListener = null; }
            if (this.heightChangeListener === undefined) { this.heightChangeListener = null; }
            if (this.nameAndCategoryChangeListener === undefined) { this.nameAndCategoryChangeListener = null; }
            this.widthChangeListener = new TextureAttributesStepState.TextureAttributesStepState$0(this);
            this.heightChangeListener = new TextureAttributesStepState.TextureAttributesStepState$1(this);
            this.nameAndCategoryChangeListener = new TextureAttributesStepState.TextureAttributesStepState$2(this);
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.setLastStep(true);
            this.__parent.addPropertyChangeListener("WIDTH", this.widthChangeListener);
            this.__parent.addPropertyChangeListener("HEIGHT", this.heightChangeListener);
            this.__parent.addPropertyChangeListener("NAME", this.nameAndCategoryChangeListener);
            this.__parent.addPropertyChangeListener("CATEGORY", this.nameAndCategoryChangeListener);
            this.setNextStepEnabled(this.__parent.isTextureNameValid());
        }

        /**
         * 
         * @return {ImportedTextureWizardController.Step}
         */
        public getStep(): ImportedTextureWizardController.Step {
            return ImportedTextureWizardController.Step.ATTRIBUTES;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getTextureImageStepState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.removePropertyChangeListener("WIDTH", this.widthChangeListener);
            this.__parent.removePropertyChangeListener("HEIGHT", this.heightChangeListener);
            this.__parent.removePropertyChangeListener("NAME", this.nameAndCategoryChangeListener);
            this.__parent.removePropertyChangeListener("CATEGORY", this.nameAndCategoryChangeListener);
        }
    }
    TextureAttributesStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.ImportedTextureWizardController.TextureAttributesStepState";


    export namespace TextureAttributesStepState {

        export class TextureAttributesStepState$0 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.__parent.removePropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
                const ratio: number = <number>ev.getNewValue() / <number>ev.getOldValue();
                this.__parent.__parent.setHeight(this.__parent.__parent.getHeight() * ratio);
                this.__parent.__parent.addPropertyChangeListener("HEIGHT", this.__parent.heightChangeListener);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class TextureAttributesStepState$1 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.__parent.removePropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
                const ratio: number = <number>ev.getNewValue() / <number>ev.getOldValue();
                this.__parent.__parent.setWidth(this.__parent.__parent.getWidth() * ratio);
                this.__parent.__parent.addPropertyChangeListener("WIDTH", this.__parent.widthChangeListener);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }


        export class TextureAttributesStepState$2 {
            public __parent: any;
            public propertyChange(ev: PropertyChangeEvent) {
                this.__parent.setNextStepEnabled(this.__parent.__parent.isTextureNameValid());
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }

}


/**
 * Wizard controller for background image in plan.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport
 * @class
 * @extends WizardController
 */
export class BackgroundImageWizardController extends WizardController implements Controller {
    /*private*/ home: Home;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences: any;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_viewFactory: ViewFactory;

    /*private*/ contentManager: ContentManager;

    /*private*/ undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ imageChoiceStepState: BackgroundImageWizardController.BackgroundImageWizardStepState;

    /*private*/ imageScaleStepState: BackgroundImageWizardController.BackgroundImageWizardStepState;

    /*private*/ imageOriginStepState: BackgroundImageWizardController.BackgroundImageWizardStepState;

    /*private*/ stepsView: View;

    /*private*/ step: BackgroundImageWizardController.Step;

    /*private*/ referenceBackgroundImage: BackgroundImage;

    /*private*/ image: Content;

    /*private*/ scaleDistance: number;

    /*private*/ scaleDistanceXStart: number;

    /*private*/ scaleDistanceYStart: number;

    /*private*/ scaleDistanceXEnd: number;

    /*private*/ scaleDistanceYEnd: number;

    /*private*/ xOrigin: number;

    /*private*/ yOrigin: number;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        super(preferences, viewFactory);
        if (this.home === undefined) { this.home = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_viewFactory = null; }
        if (this.contentManager === undefined) { this.contentManager = null; }
        if (this.undoSupport === undefined) { this.undoSupport = null; }
        if (this.imageChoiceStepState === undefined) { this.imageChoiceStepState = null; }
        if (this.imageScaleStepState === undefined) { this.imageScaleStepState = null; }
        if (this.imageOriginStepState === undefined) { this.imageOriginStepState = null; }
        if (this.stepsView === undefined) { this.stepsView = null; }
        if (this.step === undefined) { this.step = null; }
        if (this.referenceBackgroundImage === undefined) { this.referenceBackgroundImage = null; }
        if (this.image === undefined) { this.image = null; }
        if (this.scaleDistance === undefined) { this.scaleDistance = null; }
        if (this.scaleDistanceXStart === undefined) { this.scaleDistanceXStart = 0; }
        if (this.scaleDistanceYStart === undefined) { this.scaleDistanceYStart = 0; }
        if (this.scaleDistanceXEnd === undefined) { this.scaleDistanceXEnd = 0; }
        if (this.scaleDistanceYEnd === undefined) { this.scaleDistanceYEnd = 0; }
        if (this.xOrigin === undefined) { this.xOrigin = 0; }
        if (this.yOrigin === undefined) { this.yOrigin = 0; }
        this.home = home;
        this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences = preferences;
        this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_viewFactory = viewFactory;
        this.contentManager = contentManager;
        this.undoSupport = undoSupport;
        /* Use propertyChangeSupport defined in super class */;
        this.setTitle(preferences.getLocalizedString(BackgroundImageWizardController, "wizard.title"));
        this.setResizable(true);
        this.imageChoiceStepState = new BackgroundImageWizardController.ImageChoiceStepState(this);
        this.imageScaleStepState = new BackgroundImageWizardController.ImageScaleStepState(this);
        this.imageOriginStepState = new BackgroundImageWizardController.ImageOriginStepState(this);
        this.setStepState(this.imageChoiceStepState);
        const selectedLevel: Level = this.home.getSelectedLevel();
        if (selectedLevel != null) {
            const levels: Array<Level> = this.home.getLevels();
            const levelIndex: number = levels.indexOf(selectedLevel);
            for (let i: number = levelIndex - 1; i >= 0 && this.referenceBackgroundImage == null; i--) {
                {
                    this.referenceBackgroundImage = /* get */levels[i].getBackgroundImage();
                };
            }
            for (let i: number = levelIndex + 1; i < /* size */(<number>levels.length) && this.referenceBackgroundImage == null; i++) {
                {
                    this.referenceBackgroundImage = /* get */levels[i].getBackgroundImage();
                };
            }
        }
    }

    /**
     * Changes background image in model and posts an undoable operation.
     */
    public finish() {
        const selectedLevel: Level = this.home.getSelectedLevel();
        const oldImage: BackgroundImage = selectedLevel != null ? selectedLevel.getBackgroundImage() : this.home.getBackgroundImage();
        const scaleDistancePoints: number[][] = this.getScaleDistancePoints();
        const image: BackgroundImage = new BackgroundImage(this.getImage(), this.getScaleDistance(), scaleDistancePoints[0][0], scaleDistancePoints[0][1], scaleDistancePoints[1][0], scaleDistancePoints[1][1], this.getXOrigin(), this.getYOrigin());
        if (selectedLevel != null) {
            selectedLevel.setBackgroundImage(image);
        } else {
            this.home.setBackgroundImage(image);
        }
        const modification: boolean = oldImage == null;
        this.undoSupport.postEdit(new BackgroundImageWizardController.BackgroundImageUndoableEdit(this.home, this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences, selectedLevel, oldImage, image, modification));
    }

    /**
     * Returns the content manager of this controller.
     * @return {Object}
     */
    public getContentManager(): ContentManager {
        return this.contentManager;
    }

    /**
     * Returns the current step state.
     * @return {BackgroundImageWizardController.BackgroundImageWizardStepState}
     */
    getStepState(): BackgroundImageWizardController.BackgroundImageWizardStepState {
        return <BackgroundImageWizardController.BackgroundImageWizardStepState>super.getStepState();
    }

    /**
     * Returns the image choice step state.
     * @return {BackgroundImageWizardController.BackgroundImageWizardStepState}
     */
    getImageChoiceStepState(): BackgroundImageWizardController.BackgroundImageWizardStepState {
        return this.imageChoiceStepState;
    }

    /**
     * Returns the image origin step state.
     * @return {BackgroundImageWizardController.BackgroundImageWizardStepState}
     */
    getImageOriginStepState(): BackgroundImageWizardController.BackgroundImageWizardStepState {
        return this.imageOriginStepState;
    }

    /**
     * Returns the image scale step state.
     * @return {BackgroundImageWizardController.BackgroundImageWizardStepState}
     */
    getImageScaleStepState(): BackgroundImageWizardController.BackgroundImageWizardStepState {
        return this.imageScaleStepState;
    }

    /**
     * Returns the unique wizard view used for all steps.
     * @return {Object}
     */
    getStepsView(): View {
        if (this.stepsView == null) {
            const image: BackgroundImage = this.home.getSelectedLevel() != null ? this.home.getSelectedLevel().getBackgroundImage() : this.home.getBackgroundImage();
            this.stepsView = this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_viewFactory.createBackgroundImageWizardStepsView(image, this.__com_eteks_sweethome3d_viewcontroller_BackgroundImageWizardController_preferences, this);
        }
        return this.stepsView;
    }

    /**
     * Switch in the wizard view to the given <code>step</code>.
     * @param {BackgroundImageWizardController.Step} step
     */
    setStep(step: BackgroundImageWizardController.Step) {
        if (step !== this.step) {
            const oldStep: BackgroundImageWizardController.Step = this.step;
            this.step = step;
            this.propertyChangeSupport.firePropertyChange(/* name */"STEP", oldStep, step);
        }
    }

    /**
     * Returns the current step in wizard view.
     * @return {BackgroundImageWizardController.Step}
     */
    public getStep(): BackgroundImageWizardController.Step {
        return this.step;
    }

    /**
     * Returns the background image of another level that can be used to initialize
     * the scale values of the edited image.
     * @return {BackgroundImage}
     */
    public getReferenceBackgroundImage(): BackgroundImage {
        return this.referenceBackgroundImage;
    }

    /**
     * Sets the image content of the background image.
     * @param {Object} image
     */
    public setImage(image: Content) {
        if (image !== this.image) {
            const oldImage: Content = this.image;
            this.image = image;
            this.propertyChangeSupport.firePropertyChange(/* name */"IMAGE", oldImage, image);
        }
    }

    /**
     * Returns the image content of the background image.
     * @return {Object}
     */
    public getImage(): Content {
        return this.image;
    }

    /**
     * Sets the scale distance of the background image.
     * @param {number} scaleDistance
     */
    public setScaleDistance(scaleDistance: number) {
        if (scaleDistance !== this.scaleDistance) {
            const oldScaleDistance: number = this.scaleDistance;
            this.scaleDistance = scaleDistance;
            this.propertyChangeSupport.firePropertyChange(/* name */"SCALE_DISTANCE", oldScaleDistance, scaleDistance);
        }
    }

    /**
     * Returns the scale distance of the background image.
     * @return {number}
     */
    public getScaleDistance(): number {
        return this.scaleDistance;
    }

    /**
     * Sets the coordinates of the scale distance points of the background image.
     * @param {number} scaleDistanceXStart
     * @param {number} scaleDistanceYStart
     * @param {number} scaleDistanceXEnd
     * @param {number} scaleDistanceYEnd
     */
    public setScaleDistancePoints(scaleDistanceXStart: number, scaleDistanceYStart: number, scaleDistanceXEnd: number, scaleDistanceYEnd: number) {
        if (scaleDistanceXStart !== this.scaleDistanceXStart || scaleDistanceYStart !== this.scaleDistanceYStart || scaleDistanceXEnd !== this.scaleDistanceXEnd || scaleDistanceYEnd !== this.scaleDistanceYEnd) {
            const oldDistancePoints: number[][] = [[this.scaleDistanceXStart, this.scaleDistanceYStart], [this.scaleDistanceXEnd, this.scaleDistanceYEnd]];
            this.scaleDistanceXStart = scaleDistanceXStart;
            this.scaleDistanceYStart = scaleDistanceYStart;
            this.scaleDistanceXEnd = scaleDistanceXEnd;
            this.scaleDistanceYEnd = scaleDistanceYEnd;
            this.propertyChangeSupport.firePropertyChange(/* name */"SCALE_DISTANCE_POINTS", oldDistancePoints, [[scaleDistanceXStart, scaleDistanceYStart], [scaleDistanceXEnd, scaleDistanceYEnd]]);
        }
    }

    /**
     * Returns the coordinates of the scale distance points of the background image.
     * @return {float[][]}
     */
    public getScaleDistancePoints(): number[][] {
        return [[this.scaleDistanceXStart, this.scaleDistanceYStart], [this.scaleDistanceXEnd, this.scaleDistanceYEnd]];
    }

    /**
     * Sets the origin of the background image.
     * @param {number} xOrigin
     * @param {number} yOrigin
     */
    public setOrigin(xOrigin: number, yOrigin: number) {
        if (xOrigin !== this.xOrigin) {
            const oldXOrigin: number = this.xOrigin;
            this.xOrigin = xOrigin;
            this.propertyChangeSupport.firePropertyChange(/* name */"X_ORIGIN", oldXOrigin, xOrigin);
        }
        if (yOrigin !== this.yOrigin) {
            const oldYOrigin: number = this.yOrigin;
            this.yOrigin = yOrigin;
            this.propertyChangeSupport.firePropertyChange(/* name */"Y_ORIGIN", oldYOrigin, yOrigin);
        }
    }

    /**
     * Returns the abscissa of the origin of the background image.
     * @return {number}
     */
    public getXOrigin(): number {
        return this.xOrigin;
    }

    /**
     * Returns the ordinate of the origin of the background image.
     * @return {number}
     */
    public getYOrigin(): number {
        return this.yOrigin;
    }
}
BackgroundImageWizardController["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController";
BackgroundImageWizardController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace BackgroundImageWizardController {

    export enum Step {
        CHOICE, SCALE, ORIGIN
    }

    /**
     * Undoable edit for background image. This class isn't anonymous to avoid
     * being bound to controller and its view.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class BackgroundImageUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        level: Level;

        oldImage: BackgroundImage;

        image: BackgroundImage;

        constructor(home: Home, preferences: any, level: Level, oldImage: BackgroundImage, image: BackgroundImage, modification: boolean) {
            super(preferences, BackgroundImageWizardController, modification ? "undoImportBackgroundImageName" : "undoModifyBackgroundImageName");
            if (this.home === undefined) { this.home = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.oldImage === undefined) { this.oldImage = null; }
            if (this.image === undefined) { this.image = null; }
            this.home = home;
            this.level = level;
            this.oldImage = oldImage;
            this.image = image;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setSelectedLevel(this.level);
            if (this.level != null) {
                this.level.setBackgroundImage(this.oldImage);
            } else {
                this.home.setBackgroundImage(this.oldImage);
            }
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedLevel(this.level);
            if (this.level != null) {
                this.level.setBackgroundImage(this.image);
            } else {
                this.home.setBackgroundImage(this.image);
            }
        }
    }
    BackgroundImageUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController.BackgroundImageUndoableEdit";
    BackgroundImageUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Step state superclass. All step state share the same step view,
     * that will display a different component depending on their class name.
     * @extends WizardController.WizardControllerStepState
     * @class
     */
    export abstract class BackgroundImageWizardStepState extends WizardController.WizardControllerStepState {
        public __parent: any;
        icon: string;

        public abstract getStep(): BackgroundImageWizardController.Step;

        /**
         * 
         */
        public enter() {
            this.__parent.setStep(this.getStep());
        }

        /**
         * 
         * @return {Object}
         */
        public getView(): View {
            return this.__parent.getStepsView();
        }

        /**
         * 
         * @return {string}
         */
        public getIcon(): string {
            return this.icon;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            this.icon = /* getResource */"resources/backgroundImageWizard.png";
        }
    }
    BackgroundImageWizardStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController.BackgroundImageWizardStepState";


    /**
     * Image choice step state (first step).
     * @class
     * @extends BackgroundImageWizardController.BackgroundImageWizardStepState
     */
    export class ImageChoiceStepState extends BackgroundImageWizardController.BackgroundImageWizardStepState {
        public __parent: any;
        public constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            __parent.addPropertyChangeListener("IMAGE", new ImageChoiceStepState.ImageChoiceStepState$0(this));
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.setFirstStep(true);
            this.setNextStepEnabled(this.__parent.getImage() != null);
        }

        /**
         * 
         * @return {BackgroundImageWizardController.Step}
         */
        public getStep(): BackgroundImageWizardController.Step {
            return BackgroundImageWizardController.Step.CHOICE;
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getImageScaleStepState());
        }
    }
    ImageChoiceStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController.ImageChoiceStepState";


    export namespace ImageChoiceStepState {

        export class ImageChoiceStepState$0 {
            public __parent: any;
            public propertyChange(evt: PropertyChangeEvent) {
                this.__parent.setNextStepEnabled(this.__parent.__parent.getImage() != null);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Image scale step state (second step).
     * @class
     * @extends BackgroundImageWizardController.BackgroundImageWizardStepState
     */
    export class ImageScaleStepState extends BackgroundImageWizardController.BackgroundImageWizardStepState {
        public __parent: any;
        public constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            __parent.addPropertyChangeListener("SCALE_DISTANCE", new ImageScaleStepState.ImageScaleStepState$0(this));
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.setNextStepEnabled(this.__parent.getScaleDistance() != null);
        }

        /**
         * 
         * @return {BackgroundImageWizardController.Step}
         */
        public getStep(): BackgroundImageWizardController.Step {
            return BackgroundImageWizardController.Step.SCALE;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getImageChoiceStepState());
        }

        /**
         * 
         */
        public goToNextStep() {
            this.__parent.setStepState(this.__parent.getImageOriginStepState());
        }
    }
    ImageScaleStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController.ImageScaleStepState";


    export namespace ImageScaleStepState {

        export class ImageScaleStepState$0 {
            public __parent: any;
            public propertyChange(evt: PropertyChangeEvent) {
                this.__parent.setNextStepEnabled(this.__parent.__parent.getScaleDistance() != null);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Image origin step state (last step).
     * @extends BackgroundImageWizardController.BackgroundImageWizardStepState
     * @class
     */
    export class ImageOriginStepState extends BackgroundImageWizardController.BackgroundImageWizardStepState {
        public __parent: any;
        /**
         * 
         */
        public enter() {
            super.enter();
            this.setLastStep(true);
            this.setNextStepEnabled(true);
        }

        /**
         * 
         * @return {BackgroundImageWizardController.Step}
         */
        public getStep(): BackgroundImageWizardController.Step {
            return BackgroundImageWizardController.Step.ORIGIN;
        }

        /**
         * 
         */
        public goBackToPreviousStep() {
            this.__parent.setStepState(this.__parent.getImageScaleStepState());
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
        }
    }
    ImageOriginStepState["__class"] = "com.eteks.sweethome3d.viewcontroller.BackgroundImageWizardController.ImageOriginStepState";

}


/**
 * The controller of the photo creation view.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} view3D
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 * @extends AbstractPhotoController
 * @ignore
 */
export class PhotoController extends AbstractPhotoController {
    /*private*/ __com_eteks_sweethome3d_viewcontroller_PhotoController_home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ cameraChangeListener: PhotoController.CameraChangeListener;

    /*private*/ photoView: DialogView;

    /*private*/ time: number;

    /*private*/ lens: Camera.Lens;

    /*private*/ renderer: string;

    public constructor(home: Home, preferences: any, view3D: View, viewFactory: ViewFactory, contentManager: ContentManager) {
        super(home, preferences, view3D, contentManager);
        if (this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.cameraChangeListener === undefined) { this.cameraChangeListener = null; }
        if (this.photoView === undefined) { this.photoView = null; }
        if (this.time === undefined) { this.time = 0; }
        if (this.lens === undefined) { this.lens = null; }
        if (this.renderer === undefined) { this.renderer = null; }
        this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        /* Use propertyChangeSupport defined in super class */;
        this.cameraChangeListener = new PhotoController.CameraChangeListener(this);
        home.getCamera().addPropertyChangeListener(this.cameraChangeListener);
        home.addPropertyChangeListener("CAMERA", new PhotoController.HomeCameraChangeListener(this));
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.photoView == null) {
            this.photoView = this.viewFactory.createPhotoView(this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home, this.preferences, this);
        }
        return this.photoView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Updates edited properties from the photo creation preferences.
     */
    updateProperties() {
        if (this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home != null) {
            super.updateProperties();
            this.setTime(this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getCamera().getTime());
            this.setLens(this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getCamera().getLens());
            let renderer: string = this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getCamera().getRenderer();
            if (renderer == null) {
                renderer = this.preferences.getPhotoRenderer();
            }
            this.setRenderer(renderer, false);
        }
    }

    /**
     * Sets the edited time in UTC time zone.
     * @param {number} time
     */
    public setTime(time: number) {
        if (this.time !== time) {
            const oldTime: number = this.time;
            this.time = time;
            this.propertyChangeSupport.firePropertyChange(/* name */"TIME", oldTime, time);
            const homeCamera: Camera = this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getCamera();
            homeCamera.removePropertyChangeListener(this.cameraChangeListener);
            homeCamera.setTime(time);
            homeCamera.addPropertyChangeListener(this.cameraChangeListener);
        }
    }

    /**
     * Returns the edited time in UTC time zone.
     * @return {number}
     */
    public getTime(): number {
        return this.time;
    }

    /**
     * Sets the edited camera lens.
     * @param {Camera.Lens} lens
     */
    public setLens(lens: Camera.Lens) {
        if (this.lens !== lens) {
            const oldLens: Camera.Lens = this.lens;
            this.lens = lens;
            this.propertyChangeSupport.firePropertyChange(/* name */"LENS", oldLens, lens);
            if (lens === Camera.Lens.SPHERICAL) {
                this.setAspectRatio(AspectRatio.RATIO_2_1);
            } else if (lens === Camera.Lens.FISHEYE) {
                this.setAspectRatio(AspectRatio.SQUARE_RATIO);
            }
            this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getCamera().setLens(this.lens);
        }
    }

    /**
     * Returns the edited camera lens.
     * @return {Camera.Lens}
     */
    public getLens(): Camera.Lens {
        return this.lens;
    }

    public setRenderer(renderer: string, updatePreferences: boolean = true) {
        if (this.renderer !== renderer) {
            const oldRenderer: string = this.renderer;
            this.renderer = renderer;
            this.propertyChangeSupport.firePropertyChange(/* name */"RENDERER", oldRenderer, renderer);
            this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getTopCamera().setRenderer(this.renderer);
            this.__com_eteks_sweethome3d_viewcontroller_PhotoController_home.getObserverCamera().setRenderer(this.renderer);
            if (updatePreferences) {
                this.preferences.setPhotoRenderer(renderer);
            }
        }
    }

    /**
     * Returns the edited camera rendering engine.
     * @return {string}
     */
    public getRenderer(): string {
        return this.renderer;
    }
}
PhotoController["__class"] = "com.eteks.sweethome3d.viewcontroller.PhotoController";
PhotoController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace PhotoController {

    /**
     * Home camera listener that updates properties when home camera changes. This listener is bound to this controller
     * with a weak reference to avoid strong link between home and this controller.
     * @param {PhotoController} photoController
     * @class
     */
    export class HomeCameraChangeListener {
        photoController: PhotoController;

        public constructor(photoController: PhotoController) {
            if (this.photoController === undefined) { this.photoController = null; }
            this.photoController = <any>(photoController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: PhotoController = /* get */this.photoController;
            if (controller == null) {
                (<Home>ev.getSource()).removePropertyChangeListener("CAMERA", this);
            } else {
                (<Camera>ev.getOldValue()).removePropertyChangeListener(controller.cameraChangeListener);
                controller.updateProperties();
                (<Camera>ev.getNewValue()).addPropertyChangeListener(controller.cameraChangeListener);
            }
        }
    }
    HomeCameraChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.PhotoController.HomeCameraChangeListener";


    /**
     * Camera listener that updates properties when camera changes. This listener is bound to this controller
     * with a weak reference to avoid strong link between home and this controller.
     * @param {AbstractPhotoController} photoController
     * @class
     */
    export class CameraChangeListener {
        photoController: AbstractPhotoController;

        public constructor(photoController: AbstractPhotoController) {
            if (this.photoController === undefined) { this.photoController = null; }
            this.photoController = <any>(photoController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: AbstractPhotoController = /* get */this.photoController;
            if (controller == null) {
                (<Camera>ev.getSource()).removePropertyChangeListener(this);
            } else {
                controller.updateProperties();
            }
        }
    }
    CameraChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.PhotoController.CameraChangeListener";

}


/**
 * The controller of multiple photos creation view.
 * @author Emmanuel Puybaret
 * @param {Home} home
 * @param {UserPreferences} preferences
 * @param {Object} view3D
 * @param {Object} viewFactory
 * @param {Object} contentManager
 * @class
 * @extends AbstractPhotoController
 * @ignore
 */
export class PhotosController extends AbstractPhotoController {
    /*private*/ __com_eteks_sweethome3d_viewcontroller_PhotosController_home: Home;

    /*private*/ preferences: any;

    /*private*/ viewFactory: ViewFactory;

    /*private*/ photoView: DialogView;

    /*private*/ cameras: Array<Camera>;

    /*private*/ selectedCameras: Array<Camera>;

    /*private*/ fileFormat: string;

    /*private*/ fileCompressionQuality: number;

    public constructor(home: Home, preferences: any, view3D: View, viewFactory: ViewFactory, contentManager: ContentManager) {
        super(home, preferences, view3D, contentManager);
        if (this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home = null; }
        if (this.preferences === undefined) { this.preferences = null; }
        if (this.viewFactory === undefined) { this.viewFactory = null; }
        if (this.photoView === undefined) { this.photoView = null; }
        if (this.cameras === undefined) { this.cameras = null; }
        if (this.selectedCameras === undefined) { this.selectedCameras = null; }
        if (this.fileFormat === undefined) { this.fileFormat = null; }
        if (this.fileCompressionQuality === undefined) { this.fileCompressionQuality = null; }
        this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home = home;
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        /* Use propertyChangeSupport defined in super class */;
        this.cameras = /* emptyList */[];
        this.selectedCameras = /* emptyList */[];
        home.addPropertyChangeListener("STORED_CAMERAS", new PhotosController.HomeStoredCamerasChangeListener(this));
        this.updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): DialogView {
        if (this.photoView == null) {
            this.photoView = this.viewFactory.createPhotosView(this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home, this.preferences, this);
        }
        return this.photoView;
    }

    /**
     * Displays the view controlled by this controller.
     * @param {Object} parentView
     */
    public displayView(parentView: View) {
        this.getView().displayView(parentView);
    }

    /**
     * Updates edited properties from the photo creation preferences.
     */
    updateProperties() {
        if (this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home != null) {
            super.updateProperties();
            this.setCameras(this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home.getStoredCameras());
            this.setSelectedCameras(this.__com_eteks_sweethome3d_viewcontroller_PhotosController_home.getStoredCameras());
        }
    }

    /**
     * Returns the cameras available to create photos.
     * @return {Camera[]}
     */
    public getCameras(): Array<Camera> {
        return this.cameras;
    }

    /**
     * Sets the cameras available to create photos.
     * @param {Camera[]} cameras
     * @private
     */
    setCameras(cameras: Array<Camera>) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(cameras, this.cameras)) {
            const oldCameras: Array<Camera> = this.cameras;
            this.cameras = <any>(cameras.slice(0));
            this.propertyChangeSupport.firePropertyChange(/* name */"CAMERAS", /* unmodifiableList */oldCameras.slice(0), /* unmodifiableList */cameras.slice(0));
        }
    }

    /**
     * Returns the selected cameras to create photos.
     * @return {Camera[]}
     */
    public getSelectedCameras(): Array<Camera> {
        return this.selectedCameras;
    }

    /**
     * Sets the selected cameras to create photos.
     * @param {Camera[]} selectedCameras
     */
    public setSelectedCameras(selectedCameras: Array<Camera>) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(selectedCameras, this.selectedCameras)) {
            const oldSelectedCameras: Array<Camera> = this.selectedCameras;
            this.selectedCameras = <any>(selectedCameras.slice(0));
            this.propertyChangeSupport.firePropertyChange(/* name */"SELECTED_CAMERAS", /* unmodifiableList */oldSelectedCameras.slice(0), /* unmodifiableList */selectedCameras.slice(0));
        }
    }

    /**
     * Returns the format used to save image files.
     * @return {string}
     */
    public getFileFormat(): string {
        return this.fileFormat;
    }

    /**
     * Sets the format used to save image files.
     * @param {string} fileFormat
     */
    public setFileFormat(fileFormat: string) {
        if (fileFormat !== this.fileFormat) {
            const oldFileFormat: string = this.fileFormat;
            this.fileFormat = fileFormat;
            this.propertyChangeSupport.firePropertyChange(/* name */"FILE_FORMAT", oldFileFormat, fileFormat);
        }
    }

    /**
     * Returns the compression quality used to save image files.
     * @return {number}
     */
    public getFileCompressionQuality(): number {
        return this.fileCompressionQuality;
    }

    /**
     * Sets the compression quality used to save image files.
     * @param {number} fileCompressionQuality
     */
    public setFileCompressionQuality(fileCompressionQuality: number) {
        if (fileCompressionQuality !== this.fileCompressionQuality) {
            const oldFileCompressionQuality: number = this.fileCompressionQuality;
            this.fileCompressionQuality = fileCompressionQuality;
            this.propertyChangeSupport.firePropertyChange(/* name */"FILE_COMPRESSION_QUALITY", oldFileCompressionQuality, fileCompressionQuality);
        }
    }
}
PhotosController["__class"] = "com.eteks.sweethome3d.viewcontroller.PhotosController";
PhotosController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace PhotosController {

    /**
     * Home cameras listener that updates properties when home cameras change. This listener is bound to this controller
     * with a weak reference to avoid strong link between home and this controller.
     * @param {PhotosController} photoController
     * @class
     */
    export class HomeStoredCamerasChangeListener {
        photosController: PhotosController;

        public constructor(photoController: PhotosController) {
            if (this.photosController === undefined) { this.photosController = null; }
            this.photosController = <any>(photoController);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const controller: AbstractPhotoController = /* get */this.photosController;
            if (controller == null) {
                (<Home>ev.getSource()).removePropertyChangeListener("STORED_CAMERAS", this);
            } else {
                controller.updateProperties();
            }
        }
    }
    HomeStoredCamerasChangeListener["__class"] = "com.eteks.sweethome3d.viewcontroller.PhotosController.HomeStoredCamerasChangeListener";

}


/**
 * Creates a home door or window from an existing one.
 * @param {string} id           the ID of the object
 * @param {Object} doorOrWindow the door or window from which data are copied
 * @param {java.lang.String[]} copiedProperties the names of the additional properties which should be copied from the existing piece
 * or <code>null</code> if all properties should be copied.
 * @class
 * @extends HomePieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class HomeDoorOrWindow extends HomePieceOfFurniture implements DoorOrWindow {
    /*private*/ wallThickness: number;

    /*private*/ wallDistance: number;

    /*private*/ wallWidth: number;

    /*private*/ wallLeft: number;

    /*private*/ wallHeight: number;

    /*private*/ wallTop: number;

    /*private*/ wallCutOutOnBothSides: boolean;

    /*private*/ widthDepthDeformable: boolean;

    /*private*/ sashes: Sash[];

    /*private*/ cutOutShape: string;

    /*private*/ boundToWall: boolean;

    public constructor(id?: any, doorOrWindow?: any, copiedProperties?: any) {
        if (((typeof id === 'string') || id === null) && ((doorOrWindow != null && (doorOrWindow.constructor != null && doorOrWindow.constructor["__interfaces"] != null && doorOrWindow.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.DoorOrWindow") >= 0)) || doorOrWindow === null) && ((copiedProperties != null && copiedProperties instanceof <any>Array && (copiedProperties.length == 0 || copiedProperties[0] == null || (typeof copiedProperties[0] === 'string'))) || copiedProperties === null)) {
            let __args = arguments;
            super(id, doorOrWindow, copiedProperties);
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            if (this.boundToWall === undefined) { this.boundToWall = false; }
            this.wallThickness = doorOrWindow.getWallThickness();
            this.wallDistance = doorOrWindow.getWallDistance();
            this.wallWidth = 1;
            this.wallLeft = 0;
            this.wallHeight = 1;
            this.wallTop = 0;
            this.wallCutOutOnBothSides = doorOrWindow.isWallCutOutOnBothSides();
            this.widthDepthDeformable = doorOrWindow.isWidthDepthDeformable();
            this.sashes = doorOrWindow.getSashes();
            this.cutOutShape = doorOrWindow.getCutOutShape();
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.DoorOrWindow") >= 0)) || id === null) && ((doorOrWindow != null && doorOrWindow instanceof <any>Array && (doorOrWindow.length == 0 || doorOrWindow[0] == null || (typeof doorOrWindow[0] === 'string'))) || doorOrWindow === null) && copiedProperties === undefined) {
            let __args = arguments;
            let doorOrWindow: any = __args[0];
            let copiedProperties: any = __args[1];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("doorOrWindow");
                super(id, doorOrWindow, copiedProperties);
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallWidth === undefined) { this.wallWidth = 0; }
                if (this.wallLeft === undefined) { this.wallLeft = 0; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.wallTop === undefined) { this.wallTop = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                if (this.boundToWall === undefined) { this.boundToWall = false; }
                this.wallThickness = doorOrWindow.getWallThickness();
                this.wallDistance = doorOrWindow.getWallDistance();
                this.wallWidth = 1;
                this.wallLeft = 0;
                this.wallHeight = 1;
                this.wallTop = 0;
                this.wallCutOutOnBothSides = doorOrWindow.isWallCutOutOnBothSides();
                this.widthDepthDeformable = doorOrWindow.isWidthDepthDeformable();
                this.sashes = doorOrWindow.getSashes();
                this.cutOutShape = doorOrWindow.getCutOutShape();
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            if (this.boundToWall === undefined) { this.boundToWall = false; }
        } else if (((typeof id === 'string') || id === null) && ((doorOrWindow != null && (doorOrWindow.constructor != null && doorOrWindow.constructor["__interfaces"] != null && doorOrWindow.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.DoorOrWindow") >= 0)) || doorOrWindow === null) && copiedProperties === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                super(id, doorOrWindow, copiedProperties);
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallWidth === undefined) { this.wallWidth = 0; }
                if (this.wallLeft === undefined) { this.wallLeft = 0; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.wallTop === undefined) { this.wallTop = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                if (this.boundToWall === undefined) { this.boundToWall = false; }
                this.wallThickness = doorOrWindow.getWallThickness();
                this.wallDistance = doorOrWindow.getWallDistance();
                this.wallWidth = 1;
                this.wallLeft = 0;
                this.wallHeight = 1;
                this.wallTop = 0;
                this.wallCutOutOnBothSides = doorOrWindow.isWallCutOutOnBothSides();
                this.widthDepthDeformable = doorOrWindow.isWidthDepthDeformable();
                this.sashes = doorOrWindow.getSashes();
                this.cutOutShape = doorOrWindow.getCutOutShape();
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            if (this.boundToWall === undefined) { this.boundToWall = false; }
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.DoorOrWindow") >= 0)) || id === null) && doorOrWindow === undefined && copiedProperties === undefined) {
            let __args = arguments;
            let doorOrWindow: any = __args[0];
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("doorOrWindow");
                    super(id, doorOrWindow, copiedProperties);
                    if (this.wallThickness === undefined) { this.wallThickness = 0; }
                    if (this.wallDistance === undefined) { this.wallDistance = 0; }
                    if (this.wallWidth === undefined) { this.wallWidth = 0; }
                    if (this.wallLeft === undefined) { this.wallLeft = 0; }
                    if (this.wallHeight === undefined) { this.wallHeight = 0; }
                    if (this.wallTop === undefined) { this.wallTop = 0; }
                    if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                    if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                    if (this.sashes === undefined) { this.sashes = null; }
                    if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                    if (this.boundToWall === undefined) { this.boundToWall = false; }
                    this.wallThickness = doorOrWindow.getWallThickness();
                    this.wallDistance = doorOrWindow.getWallDistance();
                    this.wallWidth = 1;
                    this.wallLeft = 0;
                    this.wallHeight = 1;
                    this.wallTop = 0;
                    this.wallCutOutOnBothSides = doorOrWindow.isWallCutOutOnBothSides();
                    this.widthDepthDeformable = doorOrWindow.isWidthDepthDeformable();
                    this.sashes = doorOrWindow.getSashes();
                    this.cutOutShape = doorOrWindow.getCutOutShape();
                }
                if (this.wallThickness === undefined) { this.wallThickness = 0; }
                if (this.wallDistance === undefined) { this.wallDistance = 0; }
                if (this.wallWidth === undefined) { this.wallWidth = 0; }
                if (this.wallLeft === undefined) { this.wallLeft = 0; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.wallTop === undefined) { this.wallTop = 0; }
                if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
                if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
                if (this.sashes === undefined) { this.sashes = null; }
                if (this.cutOutShape === undefined) { this.cutOutShape = null; }
                if (this.boundToWall === undefined) { this.boundToWall = false; }
            }
            if (this.wallThickness === undefined) { this.wallThickness = 0; }
            if (this.wallDistance === undefined) { this.wallDistance = 0; }
            if (this.wallWidth === undefined) { this.wallWidth = 0; }
            if (this.wallLeft === undefined) { this.wallLeft = 0; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.wallTop === undefined) { this.wallTop = 0; }
            if (this.wallCutOutOnBothSides === undefined) { this.wallCutOutOnBothSides = false; }
            if (this.widthDepthDeformable === undefined) { this.widthDepthDeformable = false; }
            if (this.sashes === undefined) { this.sashes = null; }
            if (this.cutOutShape === undefined) { this.cutOutShape = null; }
            if (this.boundToWall === undefined) { this.boundToWall = false; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the thickness of the wall in which this door or window should be placed.
     * @return {number} a value in percentage of the depth of the door or the window.
     */
    public getWallThickness(): number {
        return this.wallThickness;
    }

    /**
     * Sets the thickness of the wall in which this door or window should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallThickness a value in percentage of the depth of the door or the window.
     */
    public setWallThickness(wallThickness: number) {
        if (wallThickness !== this.wallThickness) {
            const oldWallThickness: number = this.wallThickness;
            this.wallThickness = wallThickness;
            this.firePropertyChange(/* name */"WALL_THICKNESS", oldWallThickness, wallThickness);
        }
    }

    /**
     * Returns the distance between the back side of this door or window and the wall where it's located.
     * @return {number} a distance in percentage of the depth of the door or the window.
     */
    public getWallDistance(): number {
        return this.wallDistance;
    }

    /**
     * Sets the distance between the back side of this door or window and the wall where it's located.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallDistance a distance in percentage of the depth of the door or the window.
     */
    public setWallDistance(wallDistance: number) {
        if (wallDistance !== this.wallDistance) {
            const oldWallDistance: number = this.wallDistance;
            this.wallDistance = wallDistance;
            this.firePropertyChange(/* name */"WALL_DISTANCE", oldWallDistance, wallDistance);
        }
    }

    /**
     * Returns the width of the wall part in which this door or window should be placed.
     * @return {number} a value in percentage of the width of the door or the window.
     */
    public getWallWidth(): number {
        return this.wallWidth;
    }

    /**
     * Sets the width of the wall part in which this door or window should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallWidth a value in percentage of the width of the door or the window.
     */
    public setWallWidth(wallWidth: number) {
        if (wallWidth !== this.wallWidth) {
            const oldWallWidth: number = this.wallWidth;
            this.wallWidth = wallWidth;
            this.firePropertyChange(/* name */"WALL_WIDTH", oldWallWidth, wallWidth);
        }
    }

    /**
     * Returns the distance between the left side of this door or window and the wall part where it should be placed.
     * @return {number} a distance in percentage of the width of the door or the window.
     */
    public getWallLeft(): number {
        return this.wallLeft;
    }

    /**
     * Sets the distance between the left side of this door or window and the wall part where it should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallLeft a distance in percentage of the width of the door or the window.
     */
    public setWallLeft(wallLeft: number) {
        if (wallLeft !== this.wallLeft) {
            const oldWallLeft: number = this.wallLeft;
            this.wallLeft = wallLeft;
            this.firePropertyChange(/* name */"WALL_LEFT", oldWallLeft, wallLeft);
        }
    }

    /**
     * Returns the height of the wall part in which this door or window should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @return {number} a value in percentage of the height of the door or the window.
     */
    public getWallHeight(): number {
        return this.wallHeight;
    }

    /**
     * Sets the height of the wall part in which this door or window should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallHeight a value in percentage of the height of the door or the window.
     */
    public setWallHeight(wallHeight: number) {
        if (wallHeight !== this.wallHeight) {
            const oldWallHeight: number = this.wallHeight;
            this.wallHeight = wallHeight;
            this.firePropertyChange(/* name */"WALL_HEIGHT", oldWallHeight, wallHeight);
        }
    }

    /**
     * Returns the distance between the left side of this door or window and the wall part where it should be placed.
     * @return {number} a distance in percentage of the height of the door or the window.
     */
    public getWallTop(): number {
        return this.wallTop;
    }

    /**
     * Sets the distance between the top side of this door or window and the wall part where it should be placed.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {number} wallTop a distance in percentage of the height of the door or the window.
     */
    public setWallTop(wallTop: number) {
        if (wallTop !== this.wallTop) {
            const oldWallTop: number = this.wallTop;
            this.wallTop = wallTop;
            this.firePropertyChange(/* name */"WALL_TOP", oldWallTop, wallTop);
        }
    }

    /**
     * Returns a copy of the sashes attached to this door or window.
     * If no sash is defined an empty array is returned.
     * @return {com.eteks.sweethome3d.model.Sash[]}
     */
    public getSashes(): Sash[] {
        if (this.sashes.length === 0) {
            return this.sashes;
        } else {
            return /* clone */this.sashes.slice(0);
        }
    }

    /**
     * Sets the sashes attached to this door or window. Once this piece is updated,
     * listeners added to this piece will receive a change notification.
     * @param {com.eteks.sweethome3d.model.Sash[]} sashes sashes of this window.
     */
    public setSashes(sashes: Sash[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(sashes, this.sashes)) {
            const oldSashes: Sash[] = this.sashes.length === 0 ? this.sashes : /* clone */this.sashes.slice(0);
            this.sashes = sashes.length === 0 ? sashes : /* clone */sashes.slice(0);
            this.firePropertyChange(/* name */"SASHES", oldSashes, sashes);
        }
    }

    /**
     * Returns the shape used to cut out walls that intersect this door or window.
     * @return {string}
     */
    public getCutOutShape(): string {
        return this.cutOutShape;
    }

    /**
     * Sets the shape used to cut out walls that intersect this door or window.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {string} cutOutShape a SVG path element.
     */
    public setCutOutShape(cutOutShape: string) {
        if (cutOutShape !== this.cutOutShape && (cutOutShape == null || !(cutOutShape === this.cutOutShape))) {
            const oldCutOutShape: string = this.cutOutShape;
            this.cutOutShape = cutOutShape;
            this.firePropertyChange(/* name */"CUT_OUT_SHAPE", oldCutOutShape, cutOutShape);
        }
    }

    /**
     * Returns <code>true</code> if this door or window should cut out the both sides
     * of the walls it intersects, even if its front or back side are within the wall thickness.
     * @return {boolean}
     */
    public isWallCutOutOnBothSides(): boolean {
        return this.wallCutOutOnBothSides;
    }

    /**
     * Sets whether the width and depth of the new door or window may
     * be changed independently from each other.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {boolean} wallCutOutOnBothSides
     */
    public setWallCutOutOnBothSides(wallCutOutOnBothSides: boolean) {
        if (wallCutOutOnBothSides !== this.wallCutOutOnBothSides) {
            this.wallCutOutOnBothSides = wallCutOutOnBothSides;
            this.firePropertyChange(/* name */"WALL_CUT_OUT_ON_BOTH_SIDES", !wallCutOutOnBothSides, wallCutOutOnBothSides);
        }
    }

    /**
     * Returns <code>false</code> if the width and depth of this door or window may
     * not be changed independently from each other. When <code>false</code>, this door or window
     * will also make a hole in the wall when it's placed whatever its depth if its
     * {@link #isBoundToWall() bouldToWall} flag is <code>true</code>.
     * @return {boolean}
     */
    public isWidthDepthDeformable(): boolean {
        return this.widthDepthDeformable;
    }

    /**
     * Sets whether the width and depth of the new door or window may
     * be changed independently from each other.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {boolean} widthDepthDeformable
     */
    public setWidthDepthDeformable(widthDepthDeformable: boolean) {
        if (widthDepthDeformable !== this.widthDepthDeformable) {
            this.widthDepthDeformable = widthDepthDeformable;
            this.firePropertyChange(/* name */"WIDTH_DEPTH_DEFORMABLE", !widthDepthDeformable, widthDepthDeformable);
        }
    }

    /**
     * Returns <code>true</code> if the location and the size of this door or window
     * were bound to a wall, last time they were updated.
     * @return {boolean}
     */
    public isBoundToWall(): boolean {
        return this.boundToWall;
    }

    /**
     * Sets whether the location and the size of this door or window
     * were bound to a wall, last time they were updated.
     * Once this piece is updated, listeners added to this piece will receive a change notification.
     * @param {boolean} boundToWall
     */
    public setBoundToWall(boundToWall: boolean) {
        if (boundToWall !== this.boundToWall) {
            this.boundToWall = boundToWall;
            this.firePropertyChange(/* name */"BOUND_TO_WALL", !boundToWall, boundToWall);
        }
    }

    /**
     * Sets the abscissa of this door or window and
     * resets its {@link #isBoundToWall() boundToWall} flag if the abscissa changed.
     * @param {number} x
     */
    public setX(x: number) {
        if (this.getX() !== x) {
            this.boundToWall = false;
        }
        super.setX(x);
    }

    /**
     * Sets the ordinate of this door or window and
     * resets its {@link #isBoundToWall() boundToWall} flag if the ordinate changed.
     * @param {number} y
     */
    public setY(y: number) {
        if (this.getY() !== y) {
            this.boundToWall = false;
        }
        super.setY(y);
    }

    /**
     * Sets the angle of this door or window and
     * resets its {@link #isBoundToWall() boundToWall} flag if the angle changed.
     * @param {number} angle
     */
    public setAngle(angle: number) {
        if (this.getAngle() !== angle) {
            this.boundToWall = false;
        }
        super.setAngle(angle);
    }

    /**
     * Sets the depth of this door or window and
     * resets its {@link #isBoundToWall() boundToWall} flag if the depth changed.
     * @param {number} depth
     */
    public setDepth(depth: number) {
        if (this.getDepth() !== depth) {
            this.boundToWall = false;
        }
        super.setDepth(depth);
    }

    /**
     * Returns always <code>true</code>.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return true;
    }

    /**
     * Returns a copy of this door or window.
     * @return {HomeObject}
     */
    public duplicate(): HomeObject {
        const copy: HomeDoorOrWindow = <HomeDoorOrWindow>super.duplicate();
        copy.boundToWall = false;
        return copy;
    }
}
HomeDoorOrWindow["__class"] = "com.eteks.sweethome3d.model.HomeDoorOrWindow";
HomeDoorOrWindow["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.DoorOrWindow", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.Elevatable"];

HomeDoorOrWindow['__transients'] = ['shapeCache', 'propertyChangeSupport'];

/**
 * Creates a shelf unit from an existing one.
 * No additional properties will be copied.
 * @param {string} id    the ID of the shelfUnit
 * @param {Object} shelfUnit the shelfUnit from which data are copied
 * @param {java.lang.String[]} copiedProperties the names of the additional properties which should be copied from the existing piece
 * or <code>null</code> if all properties should be copied.
 * @class
 * @extends HomePieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class HomeShelfUnit extends HomePieceOfFurniture implements ShelfUnit {
    /*private*/ shelfElevations: number[];

    /*private*/ shelfBoxes: BoxBounds[];

    public constructor(id?: any, shelfUnit?: any, copiedProperties?: any) {
        if (((typeof id === 'string') || id === null) && ((shelfUnit != null && (shelfUnit.constructor != null && shelfUnit.constructor["__interfaces"] != null && shelfUnit.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.ShelfUnit") >= 0)) || shelfUnit === null) && ((copiedProperties != null && copiedProperties instanceof <any>Array && (copiedProperties.length == 0 || copiedProperties[0] == null || (typeof copiedProperties[0] === 'string'))) || copiedProperties === null)) {
            let __args = arguments;
            super(id, shelfUnit, copiedProperties);
            if (this.shelfElevations === undefined) { this.shelfElevations = null; }
            if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
            this.shelfElevations = shelfUnit.getShelfElevations();
            this.shelfBoxes = shelfUnit.getShelfBoxes();
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.ShelfUnit") >= 0)) || id === null) && ((shelfUnit != null && shelfUnit instanceof <any>Array && (shelfUnit.length == 0 || shelfUnit[0] == null || (typeof shelfUnit[0] === 'string'))) || shelfUnit === null) && copiedProperties === undefined) {
            let __args = arguments;
            let shelfUnit: any = __args[0];
            let copiedProperties: any = __args[1];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("shelfUnit");
                super(id, shelfUnit, copiedProperties);
                if (this.shelfElevations === undefined) { this.shelfElevations = null; }
                if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
                this.shelfElevations = shelfUnit.getShelfElevations();
                this.shelfBoxes = shelfUnit.getShelfBoxes();
            }
            if (this.shelfElevations === undefined) { this.shelfElevations = null; }
            if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
        } else if (((typeof id === 'string') || id === null) && ((shelfUnit != null && (shelfUnit.constructor != null && shelfUnit.constructor["__interfaces"] != null && shelfUnit.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.ShelfUnit") >= 0)) || shelfUnit === null) && copiedProperties === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                super(id, shelfUnit, copiedProperties);
                if (this.shelfElevations === undefined) { this.shelfElevations = null; }
                if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
                this.shelfElevations = shelfUnit.getShelfElevations();
                this.shelfBoxes = shelfUnit.getShelfBoxes();
            }
            if (this.shelfElevations === undefined) { this.shelfElevations = null; }
            if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.ShelfUnit") >= 0)) || id === null) && shelfUnit === undefined && copiedProperties === undefined) {
            let __args = arguments;
            let shelfUnit: any = __args[0];
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("shelfUnit");
                    super(id, shelfUnit, copiedProperties);
                    if (this.shelfElevations === undefined) { this.shelfElevations = null; }
                    if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
                    this.shelfElevations = shelfUnit.getShelfElevations();
                    this.shelfBoxes = shelfUnit.getShelfBoxes();
                }
                if (this.shelfElevations === undefined) { this.shelfElevations = null; }
                if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
            }
            if (this.shelfElevations === undefined) { this.shelfElevations = null; }
            if (this.shelfBoxes === undefined) { this.shelfBoxes = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the elevation(s) at which other objects can be placed on this shelf unit.
     * @return {float[]}
     */
    public getShelfElevations(): number[] {
        return this.shelfElevations != null ? /* clone */this.shelfElevations.slice(0) : null;
    }

    /**
     * Sets the elevation(s) at which other objects can be placed on this shelf unit.
     * Once this light is updated, listeners added to this light will receive a change notification.
     * @param {float[]} shelfElevations elevation of the shelves
     */
    public setShelfElevations(shelfElevations: number[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(shelfElevations, this.shelfElevations)) {
            const oldShelfElevations: number[] = this.shelfElevations.length === 0 ? this.shelfElevations : /* clone */this.shelfElevations.slice(0);
            this.shelfElevations = shelfElevations.length === 0 ? shelfElevations : /* clone */shelfElevations.slice(0);
            this.firePropertyChange(/* name */"SHELF_ELEVATIONS", oldShelfElevations, shelfElevations);
        }
    }

    /**
     * Returns the coordinates of the shelf box(es) in which other objects can be placed in this shelf unit.
     * @return {com.eteks.sweethome3d.model.BoxBounds[]}
     */
    public getShelfBoxes(): BoxBounds[] {
        return /* clone */this.shelfBoxes.slice(0);
    }

    /**
     * Sets the coordinates of the shelf box(es) in which other objects can be placed in this shelf.
     * Once this light is updated, listeners added to this light will receive a change notification.
     * @param shelfElevations elevation of the shelves
     * @param {com.eteks.sweethome3d.model.BoxBounds[]} shelfBoxes
     */
    public setShelfBoxes(shelfBoxes: BoxBounds[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(shelfBoxes, this.shelfBoxes)) {
            const oldShelfBoxes: BoxBounds[] = this.shelfBoxes.length === 0 ? this.shelfBoxes : /* clone */this.shelfBoxes.slice(0);
            this.shelfBoxes = shelfBoxes.length === 0 ? shelfBoxes : /* clone */shelfBoxes.slice(0);
            this.firePropertyChange(/* name */"SHELF_BOXES", oldShelfBoxes, shelfBoxes);
        }
    }

    /**
     * Returns a clone of this shelf unit.
     * @return {HomeShelfUnit}
     */
    public clone(): HomeShelfUnit {
        return <HomeShelfUnit>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }
}
HomeShelfUnit["__class"] = "com.eteks.sweethome3d.model.HomeShelfUnit";
HomeShelfUnit["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.ShelfUnit", "com.eteks.sweethome3d.model.Elevatable"];

HomeShelfUnit['__transients'] = ['shapeCache', 'propertyChangeSupport'];

/**
 * Creates a home light from an existing one.
 * No additional properties will be copied.
 * @param {string} id    the ID of the light
 * @param {Object} light the light from which data are copied
 * @param {java.lang.String[]} copiedProperties the names of the additional properties which should be copied from the existing piece
 * or <code>null</code> if all properties should be copied.
 * @class
 * @extends HomePieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class HomeLight extends HomePieceOfFurniture implements Light {
    /*private*/ lightSources: LightSource[];

    /*private*/ lightSourceMaterialNames: string[];

    /*private*/ power: number;

    public constructor(id?: any, light?: any, copiedProperties?: any) {
        if (((typeof id === 'string') || id === null) && ((light != null && (light.constructor != null && light.constructor["__interfaces"] != null && light.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Light") >= 0)) || light === null) && ((copiedProperties != null && copiedProperties instanceof <any>Array && (copiedProperties.length == 0 || copiedProperties[0] == null || (typeof copiedProperties[0] === 'string'))) || copiedProperties === null)) {
            let __args = arguments;
            super(id, light, copiedProperties);
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            if (this.power === undefined) { this.power = 0; }
            this.lightSources = light.getLightSources();
            this.lightSourceMaterialNames = light.getLightSourceMaterialNames();
            this.power = 0.5;
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Light") >= 0)) || id === null) && ((light != null && light instanceof <any>Array && (light.length == 0 || light[0] == null || (typeof light[0] === 'string'))) || light === null) && copiedProperties === undefined) {
            let __args = arguments;
            let light: any = __args[0];
            let copiedProperties: any = __args[1];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("light");
                super(id, light, copiedProperties);
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                if (this.power === undefined) { this.power = 0; }
                this.lightSources = light.getLightSources();
                this.lightSourceMaterialNames = light.getLightSourceMaterialNames();
                this.power = 0.5;
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            if (this.power === undefined) { this.power = 0; }
        } else if (((typeof id === 'string') || id === null) && ((light != null && (light.constructor != null && light.constructor["__interfaces"] != null && light.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Light") >= 0)) || light === null) && copiedProperties === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                super(id, light, copiedProperties);
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                if (this.power === undefined) { this.power = 0; }
                this.lightSources = light.getLightSources();
                this.lightSourceMaterialNames = light.getLightSourceMaterialNames();
                this.power = 0.5;
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            if (this.power === undefined) { this.power = 0; }
        } else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Light") >= 0)) || id === null) && light === undefined && copiedProperties === undefined) {
            let __args = arguments;
            let light: any = __args[0];
            {
                let __args = arguments;
                let copiedProperties: any = HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("light");
                    super(id, light, copiedProperties);
                    if (this.lightSources === undefined) { this.lightSources = null; }
                    if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                    if (this.power === undefined) { this.power = 0; }
                    this.lightSources = light.getLightSources();
                    this.lightSourceMaterialNames = light.getLightSourceMaterialNames();
                    this.power = 0.5;
                }
                if (this.lightSources === undefined) { this.lightSources = null; }
                if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
                if (this.power === undefined) { this.power = 0; }
            }
            if (this.lightSources === undefined) { this.lightSources = null; }
            if (this.lightSourceMaterialNames === undefined) { this.lightSourceMaterialNames = null; }
            if (this.power === undefined) { this.power = 0; }
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the sources managed by this light. Each light source point
     * is a percentage of the width, the depth and the height of this light.
     * with the abscissa origin at the left side of the piece,
     * the ordinate origin at the front side of the piece
     * and the elevation origin at the bottom side of the piece.
     * @return {com.eteks.sweethome3d.model.LightSource[]} a copy of light sources array.
     */
    public getLightSources(): LightSource[] {
        if (this.lightSources.length === 0) {
            return this.lightSources;
        } else {
            return /* clone */this.lightSources.slice(0);
        }
    }

    /**
     * Sets the sources managed by this light. Once this light is updated,
     * listeners added to this light will receive a change notification.
     * @param {com.eteks.sweethome3d.model.LightSource[]} lightSources sources of the light
     */
    public setLightSources(lightSources: LightSource[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(lightSources, this.lightSources)) {
            const oldLightSources: LightSource[] = this.lightSources.length === 0 ? this.lightSources : /* clone */this.lightSources.slice(0);
            this.lightSources = lightSources.length === 0 ? lightSources : /* clone */lightSources.slice(0);
            this.firePropertyChange(/* name */"LIGHT_SOURCES", oldLightSources, lightSources);
        }
    }

    /**
     * Returns the material names of the light sources in the 3D model managed by this light.
     * @return {java.lang.String[]} a copy of light source material names array.
     */
    public getLightSourceMaterialNames(): string[] {
        if (this.lightSourceMaterialNames.length === 0) {
            return this.lightSourceMaterialNames;
        } else {
            return /* clone */this.lightSourceMaterialNames.slice(0);
        }
    }

    /**
     * Sets the material names of the light sources in the 3D model managed by this light.
     * Once this light is updated, listeners added to this light will receive a change notification.
     * @param {java.lang.String[]} lightSourceMaterialNames material names of the light sources
     */
    public setLightSourceMaterialNames(lightSourceMaterialNames: string[]) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(lightSourceMaterialNames, this.lightSourceMaterialNames)) {
            const oldLightSourceMaterialNames: string[] = this.lightSourceMaterialNames.length === 0 ? this.lightSourceMaterialNames : /* clone */this.lightSourceMaterialNames.slice(0);
            this.lightSourceMaterialNames = lightSourceMaterialNames.length === 0 ? lightSourceMaterialNames : /* clone */lightSourceMaterialNames.slice(0);
            this.firePropertyChange(/* name */"LIGHT_SOURCE_MATERIAL_NAMES", oldLightSourceMaterialNames, lightSourceMaterialNames);
        }
    }

    /**
     * Returns the power of this light.
     * @return {number}
     */
    public getPower(): number {
        return this.power;
    }

    /**
     * Sets the power of this light. Once this light is updated,
     * listeners added to this light will receive a change notification.
     * @param {number} power power of the light
     */
    public setPower(power: number) {
        if (power !== this.power) {
            const oldPower: number = this.power;
            this.power = power;
            this.firePropertyChange(/* name */"POWER", oldPower, power);
        }
    }

    /**
     * Returns a clone of this light.
     * @return {HomeLight}
     */
    public clone(): HomeLight {
        return <HomeLight>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }
}
HomeLight["__class"] = "com.eteks.sweethome3d.model.HomeLight";
HomeLight["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.Elevatable", "com.eteks.sweethome3d.model.Light"];

HomeLight['__transients'] = ['shapeCache', 'propertyChangeSupport'];

/**
 * Creates a group from the given <code>furniture</code> list.
 * The level of each piece of furniture of the group will be reset to <code>null</code> and if they belong to levels
 * with different elevations, their elevation will be updated to be relative to the elevation of the lowest level.
 * @param {string} id
 * @param {HomePieceOfFurniture[]} furniture
 * @param {number} angle
 * @param {boolean} modelMirrored
 * @param {string} name
 * @class
 * @extends HomePieceOfFurniture
 * @author Emmanuel Puybaret
 */
export class HomeFurnitureGroup extends HomePieceOfFurniture {
    /*private*/ furniture: Array<HomePieceOfFurniture>;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable: boolean;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable: boolean;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable: boolean;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow: boolean;

    /*private*/ fixedWidth: number;

    /*private*/ fixedDepth: number;

    /*private*/ fixedHeight: number;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation: number;

    /*private*/ __com_eteks_sweethome3d_model_HomeFurnitureGroup_currency: string;

    /*private*/ furnitureListener: PropertyChangeListener;

    public constructor(id?: any, furniture?: any, angle?: any, modelMirrored?: any, name?: any) {
        if (((typeof id === 'string') || id === null) && ((furniture != null && (furniture instanceof Array)) || furniture === null) && ((typeof angle === 'number') || angle === null) && ((typeof modelMirrored === 'boolean') || modelMirrored === null) && ((typeof name === 'string') || name === null)) {
            let __args = arguments;
            super(id, /* get */furniture[0]);
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
            if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
            if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
            if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
            if (this.furnitureListener === undefined) { this.furnitureListener = null; }
            this.furniture = /* unmodifiableList */furniture.slice(0);
            this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = true;
            this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = true;
            this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = true;
            let movable: boolean = true;
            let visible: boolean = false;
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    movable = piece.isMovable() && movable;
                    visible = piece.isVisible() || visible;
                }
            }
            this.setName(name);
            this.setCatalogId(null);
            this.setDescription(null);
            this.setInformation(null);
            this.setCreator(null);
            this.setNameVisible(false);
            this.setNameXOffset(0);
            this.setNameYOffset(0);
            this.setNameAngle(0);
            this.setNameStyle(null);
            super.setIcon(null);
            super.setPlanIcon(null);
            super.setModel(null);
            super.setMovable(movable);
            super.setAngle(angle);
            super.setModelMirrored(modelMirrored);
            this.setVisible(visible);
            this.updateLocationAndSize(furniture, angle, true);
            this.addFurnitureListener();
        } else if (((id != null && (id instanceof Array)) || id === null) && ((typeof furniture === 'number') || furniture === null) && ((typeof angle === 'boolean') || angle === null) && ((typeof modelMirrored === 'string') || modelMirrored === null) && name === undefined) {
            let __args = arguments;
            let furniture: any = __args[0];
            let angle: any = __args[1];
            let modelMirrored: any = __args[2];
            let name: any = __args[3];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("furnitureGroup");
                super(id, /* get */furniture[0]);
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                if (this.furnitureListener === undefined) { this.furnitureListener = null; }
                this.furniture = /* unmodifiableList */furniture.slice(0);
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = true;
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = true;
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = true;
                let movable: boolean = true;
                let visible: boolean = false;
                for (let index = 0; index < furniture.length; index++) {
                    let piece = furniture[index];
                    {
                        movable = piece.isMovable() && movable;
                        visible = piece.isVisible() || visible;
                    }
                }
                this.setName(name);
                this.setCatalogId(null);
                this.setDescription(null);
                this.setInformation(null);
                this.setCreator(null);
                this.setNameVisible(false);
                this.setNameXOffset(0);
                this.setNameYOffset(0);
                this.setNameAngle(0);
                this.setNameStyle(null);
                super.setIcon(null);
                super.setPlanIcon(null);
                super.setModel(null);
                super.setMovable(movable);
                super.setAngle(angle);
                super.setModelMirrored(modelMirrored);
                this.setVisible(visible);
                this.updateLocationAndSize(furniture, angle, true);
                this.addFurnitureListener();
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
            if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
            if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
            if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
            if (this.furnitureListener === undefined) { this.furnitureListener = null; }
        } else if (((id != null && (id instanceof Array)) || id === null) && ((furniture != null && furniture instanceof <any>HomePieceOfFurniture) || furniture === null) && ((typeof angle === 'string') || angle === null) && modelMirrored === undefined && name === undefined) {
            let __args = arguments;
            let furniture: any = __args[0];
            let leadingPiece: any = __args[1];
            let name: any = __args[2];
            {
                let __args = arguments;
                let angle: any = leadingPiece.getAngle();
                let modelMirrored: any = false;
                {
                    let __args = arguments;
                    let id: any = HomeObject.createId("furnitureGroup");
                    super(id, /* get */furniture[0]);
                    if (this.furniture === undefined) { this.furniture = null; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                    if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                    if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                    if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                    if (this.furnitureListener === undefined) { this.furnitureListener = null; }
                    this.furniture = /* unmodifiableList */furniture.slice(0);
                    this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = true;
                    this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = true;
                    this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = true;
                    let movable: boolean = true;
                    let visible: boolean = false;
                    for (let index = 0; index < furniture.length; index++) {
                        let piece = furniture[index];
                        {
                            movable = piece.isMovable() && movable;
                            visible = piece.isVisible() || visible;
                        }
                    }
                    this.setName(name);
                    this.setCatalogId(null);
                    this.setDescription(null);
                    this.setInformation(null);
                    this.setCreator(null);
                    this.setNameVisible(false);
                    this.setNameXOffset(0);
                    this.setNameYOffset(0);
                    this.setNameAngle(0);
                    this.setNameStyle(null);
                    super.setIcon(null);
                    super.setPlanIcon(null);
                    super.setModel(null);
                    super.setMovable(movable);
                    super.setAngle(angle);
                    super.setModelMirrored(modelMirrored);
                    this.setVisible(visible);
                    this.updateLocationAndSize(furniture, angle, true);
                    this.addFurnitureListener();
                }
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                if (this.furnitureListener === undefined) { this.furnitureListener = null; }
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
            if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
            if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
            if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
            if (this.furnitureListener === undefined) { this.furnitureListener = null; }
        } else if (((id != null && (id instanceof Array)) || id === null) && ((typeof furniture === 'string') || furniture === null) && angle === undefined && modelMirrored === undefined && name === undefined) {
            let __args = arguments;
            let furniture: any = __args[0];
            let name: any = __args[1];
            {
                let __args = arguments;
                let leadingPiece: any = /* get */__args[0][0];
                {
                    let __args = arguments;
                    let angle: any = leadingPiece.getAngle();
                    let modelMirrored: any = false;
                    {
                        let __args = arguments;
                        let id: any = HomeObject.createId("furnitureGroup");
                        super(id, /* get */furniture[0]);
                        if (this.furniture === undefined) { this.furniture = null; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                        if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                        if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                        if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                        if (this.furnitureListener === undefined) { this.furnitureListener = null; }
                        this.furniture = /* unmodifiableList */furniture.slice(0);
                        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = true;
                        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = true;
                        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = true;
                        let movable: boolean = true;
                        let visible: boolean = false;
                        for (let index = 0; index < furniture.length; index++) {
                            let piece = furniture[index];
                            {
                                movable = piece.isMovable() && movable;
                                visible = piece.isVisible() || visible;
                            }
                        }
                        this.setName(name);
                        this.setCatalogId(null);
                        this.setDescription(null);
                        this.setInformation(null);
                        this.setCreator(null);
                        this.setNameVisible(false);
                        this.setNameXOffset(0);
                        this.setNameYOffset(0);
                        this.setNameAngle(0);
                        this.setNameStyle(null);
                        super.setIcon(null);
                        super.setPlanIcon(null);
                        super.setModel(null);
                        super.setMovable(movable);
                        super.setAngle(angle);
                        super.setModelMirrored(modelMirrored);
                        this.setVisible(visible);
                        this.updateLocationAndSize(furniture, angle, true);
                        this.addFurnitureListener();
                    }
                    if (this.furniture === undefined) { this.furniture = null; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                    if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                    if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                    if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                    if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                    if (this.furnitureListener === undefined) { this.furnitureListener = null; }
                }
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
                if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
                if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
                if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
                if (this.furnitureListener === undefined) { this.furnitureListener = null; }
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = false; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = false; }
            if (this.fixedWidth === undefined) { this.fixedWidth = 0; }
            if (this.fixedDepth === undefined) { this.fixedDepth = 0; }
            if (this.fixedHeight === undefined) { this.fixedHeight = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = 0; }
            if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency === undefined) { this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null; }
            if (this.furnitureListener === undefined) { this.furnitureListener = null; }
        } else throw new Error('invalid overload');
    }

    /**
     * Updates the location and size of this group from the furniture it contains.
     * @param {HomePieceOfFurniture[]} furniture
     * @param {number} angle
     * @param {boolean} init
     * @private
     */
    updateLocationAndSize(furniture: Array<HomePieceOfFurniture>, angle: number, init: boolean) {
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = true;
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = true;
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = true;
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = true;
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = /* get */furniture[0].getCurrency();
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable = piece.isResizable() && this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable;
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable = piece.isDeformable() && this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable;
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable = piece.isTexturable() && this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable;
                this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow = piece.isDoorOrWindow() && this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow;
                if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency != null) {
                    if (piece.getCurrency() == null || !(piece.getCurrency() === this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency)) {
                        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency = null;
                    }
                }
            }
        }
        let elevation: number = 3.4028235E38;
        if (init) {
            let minLevel: Level = null;
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    const level: Level = piece.getLevel();
                    if (level != null && (minLevel == null || level.getElevation() < minLevel.getElevation())) {
                        minLevel = level;
                    }
                }
            }
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    if (piece.getLevel() != null) {
                        elevation = Math.min(elevation, piece.getGroundElevation() - minLevel.getElevation());
                        piece.setElevation(piece.getGroundElevation() - minLevel.getElevation());
                        piece.setLevel(null);
                    } else {
                        elevation = Math.min(elevation, piece.getElevation());
                    }
                }
            }
        } else {
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    elevation = Math.min(elevation, piece.getElevation());
                }
            }
        }
        let height: number = 0;
        let dropOnTopElevation: number = -1;
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                height = Math.max(height, piece.getElevation() + piece.getHeightInPlan());
                if (piece.getDropOnTopElevation() >= 0) {
                    dropOnTopElevation = Math.max(dropOnTopElevation, piece.getElevation() + piece.getHeightInPlan() * piece.getDropOnTopElevation());
                }
            }
        }
        height -= elevation;
        dropOnTopElevation -= elevation;
        const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(-angle);
        let unrotatedBoundingRectangle: java.awt.geom.Rectangle2D = null;
        {
            let array = this.getFurnitureWithoutGroups(furniture);
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    const pieceShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
                    const points: number[][] = piece.getPoints();
                    pieceShape.moveTo(points[0][0], points[0][1]);
                    for (let i: number = 1; i < points.length; i++) {
                        {
                            pieceShape.lineTo(points[i][0], points[i][1]);
                        };
                    }
                    pieceShape.closePath();
                    if (unrotatedBoundingRectangle == null) {
                        unrotatedBoundingRectangle = pieceShape.createTransformedShape(rotation).getBounds2D();
                    } else {
                        unrotatedBoundingRectangle.add(pieceShape.createTransformedShape(rotation).getBounds2D());
                    }
                }
            }
        }
        const center: java.awt.geom.Point2D = new java.awt.geom.Point2D.Float(<number>unrotatedBoundingRectangle.getCenterX(), <number>unrotatedBoundingRectangle.getCenterY());
        rotation.setToRotation(angle);
        rotation.transform(center, center);
        if (this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable) {
            const width: number = <number>unrotatedBoundingRectangle.getWidth();
            super.setWidth(width);
            super.setWidthInPlan(width);
            const depth: number = <number>unrotatedBoundingRectangle.getHeight();
            super.setDepth(depth);
            super.setDepthInPlan(depth);
            super.setHeight(height);
            super.setHeightInPlan(height);
        } else {
            this.fixedWidth = <number>unrotatedBoundingRectangle.getWidth();
            this.fixedDepth = <number>unrotatedBoundingRectangle.getHeight();
            this.fixedHeight = height;
        }
        this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation = dropOnTopElevation / height;
        super.setX(<number>center.getX());
        super.setY(<number>center.getY());
        super.setElevation(elevation);
    }

    /**
     * Adds a listener to the furniture of this group that will update the size and location
     * of the group when its furniture is moved or resized.
     * @private
     */
    addFurnitureListener() {
        this.furnitureListener = new HomeFurnitureGroup.LocationAndSizeChangeListener(this);
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                piece.addPropertyChangeListener(this.furnitureListener);
            }
        }
    }

    /**
     * Returns all the pieces of the given <code>furniture</code> list.
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    getFurnitureWithoutGroups(furniture: Array<HomePieceOfFurniture>): Array<HomePieceOfFurniture> {
        const pieces: Array<HomePieceOfFurniture> = <any>([]);
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(pieces, this.getFurnitureWithoutGroups((<HomeFurnitureGroup>piece).getFurniture()));
                } else {
                    /* add */(pieces.push(piece) > 0);
                }
            }
        }
        return pieces;
    }

    /**
     * Returns the furniture of this group and of all its subgroups, including the possible child furniture groups.
     * @return {HomePieceOfFurniture[]}
     */
    public getAllFurniture(): Array<HomePieceOfFurniture> {
        const pieces: Array<HomePieceOfFurniture> = <any>(this.furniture.slice(0));
        {
            let array = this.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(pieces, (<HomeFurnitureGroup>piece).getAllFurniture());
                    }
                }
            }
        }
        return pieces;
    }

    /**
     * Returns a list of the furniture of this group.
     * @return {HomePieceOfFurniture[]}
     */
    public getFurniture(): Array<HomePieceOfFurniture> {
        return /* unmodifiableList */this.furniture.slice(0);
    }

    /**
     * Adds the <code>piece</code> in parameter at the given <code>index</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} index
     * @private
     */
    addPieceOfFurniture(piece: HomePieceOfFurniture, index: number) {
        this.furniture = <any>(this.furniture.slice(0));
        piece.setLevel(this.getLevel());
        /* add */this.furniture.splice(index, 0, piece);
        piece.addPropertyChangeListener(this.furnitureListener);
        this.updateLocationAndSize(this.furniture, this.getAngle(), false);
    }

    /**
     * Deletes the <code>piece</code> in parameter from this group.
     * @throws IllegalStateException if the last piece in this group is the one in parameter
     * @param {HomePieceOfFurniture} piece
     * @private
     */
    deletePieceOfFurniture(piece: HomePieceOfFurniture) {
        const index: number = this.furniture.indexOf(piece);
        if (index !== -1) {
            if (/* size */(<number>this.furniture.length) > 1) {
                piece.setLevel(null);
                piece.removePropertyChangeListener(this.furnitureListener);
                this.furniture = <any>(this.furniture.slice(0));
                /* remove */this.furniture.splice(index, 1)[0];
                this.updateLocationAndSize(this.furniture, this.getAngle(), false);
            } else {
                throw new IllegalStateException("Group can\'t be empty");
            }
        }
    }

    /**
     * Returns the catalog ID of this group.
     * @return {string}
     */
    public getCatalogId(): string {
        return super.getCatalogId();
    }

    /**
     * Returns the information associated with this group.
     * @return {string}
     */
    public getInformation(): string {
        return super.getInformation();
    }

    /**
     * Returns <code>true</code> if this group is movable.
     * @return {boolean}
     */
    public isMovable(): boolean {
        return super.isMovable();
    }

    /**
     * Sets whether this group is movable or not.
     * @param {boolean} movable
     */
    public setMovable(movable: boolean) {
        super.setMovable(movable);
    }

    /**
     * Returns <code>true</code> if all furniture of this group are doors or windows.
     * @return {boolean}
     */
    public isDoorOrWindow(): boolean {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_doorOrWindow;
    }

    /**
     * Returns <code>true</code> if all furniture of this group are resizable.
     * @return {boolean}
     */
    public isResizable(): boolean {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable;
    }

    /**
     * Returns <code>true</code> if all furniture of this group are deformable.
     * @return {boolean}
     */
    public isDeformable(): boolean {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_deformable;
    }

    /**
     * Returns <code>true</code> if all furniture of this group are texturable.
     * @return {boolean}
     */
    public isTexturable(): boolean {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_texturable;
    }

    /**
     * Returns <code>false</code>.
     * @return {boolean}
     */
    public isHorizontallyRotatable(): boolean {
        return false;
    }

    /**
     * Returns the width of this group.
     * @return {number}
     */
    public getWidth(): number {
        if (!this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable) {
            return this.fixedWidth;
        } else {
            return super.getWidth();
        }
    }

    /**
     * Returns the width of this group. As a group can't be rotated around an horizontal axis,
     * its width in the horizontal plan is equal to its width.
     * @return {number}
     */
    public getWidthInPlan(): number {
        return this.getWidth();
    }

    /**
     * Returns the depth of this group.
     * @return {number}
     */
    public getDepth(): number {
        if (!this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable) {
            return this.fixedDepth;
        } else {
            return super.getDepth();
        }
    }

    /**
     * Returns the depth of this group. As a group can't be rotated around an horizontal axis,
     * its depth in the horizontal plan is equal to its depth.
     * @return {number}
     */
    public getDepthInPlan(): number {
        return this.getDepth();
    }

    /**
     * Returns the height of this group.
     * @return {number}
     */
    public getHeight(): number {
        if (!this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_resizable) {
            return this.fixedHeight;
        } else {
            return super.getHeight();
        }
    }

    /**
     * Returns the height of this group. As a group can't be rotated around an horizontal axis,
     * its height in the horizontal plan is equal to its height.
     * @return {number}
     */
    public getHeightInPlan(): number {
        return this.getHeight();
    }

    /**
     * Returns <code>true</code> if this piece or a child of this group is rotated around an horizontal axis.
     * @return {boolean}
     */
    public isHorizontallyRotated(): boolean {
        if (super.isHorizontallyRotated()) {
            return true;
        } else {
            {
                let array = this.getFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        if (childPiece.isHorizontallyRotated()) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    }

    /**
     * Returns the elevation at which should be placed an object dropped on this group.
     * @return {number}
     */
    public getDropOnTopElevation(): number {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_dropOnTopElevation;
    }

    /**
     * Returns <code>null</code>.
     * @return {Object}
     */
    public getIcon(): Content {
        return null;
    }

    /**
     * @throws IllegalStateException
     * @param {Object} icon
     */
    public setIcon(icon: Content) {
        throw new IllegalStateException("Can\'t set icon of a group");
    }

    /**
     * Returns <code>null</code>.
     * @return {Object}
     */
    public getPlanIcon(): Content {
        return null;
    }

    /**
     * @throws IllegalStateException
     * @param {Object} planIcon
     */
    public setPlanIcon(planIcon: Content) {
        throw new IllegalStateException("Can\'t set plan icon of a group");
    }

    /**
     * Returns <code>null</code>.
     * @return {Object}
     */
    public getModel(): Content {
        return null;
    }

    /**
     * @throws IllegalStateException
     * @param {Object} model
     */
    public setModel(model: Content) {
        throw new IllegalStateException("Can\'t set model of a group");
    }

    /**
     * Returns <code>null</code>.
     * @return {number}
     */
    public getModelSize(): number {
        return null;
    }

    /**
     * @throws IllegalStateException
     * @param {number} modelSize
     */
    public setModelSize(modelSize: number) {
        throw new IllegalStateException("Can\'t set model size of a group");
    }

    /**
     * Returns an identity matrix.
     * @return {float[][]}
     */
    public getModelRotation(): number[][] {
        return PieceOfFurniture.IDENTITY_ROTATION_$LI$();
    }

    /**
     * @throws IllegalStateException
     * @param {float[][]} modelRotation
     */
    public setModelRotation(modelRotation: number[][]) {
        throw new IllegalStateException("Can\'t set model rotation of a group");
    }

    /**
     * Returns <code>true</code>.
     * @return {boolean}
     */
    public isModelCenteredAtOrigin(): boolean {
        return true;
    }

    /**
     * Returns 0.
     * @return {number}
     */
    public getModelFlags(): number {
        return 0;
    }

    /**
     * @throws IllegalStateException
     * @param {number} modelFlags
     */
    public setModelFlags(modelFlags: number) {
        throw new IllegalStateException("Can\'t set model flags attribute of a group");
    }

    /**
     * Returns <code>false</code>.
     * @return {boolean}
     */
    public isBackFaceShown(): boolean {
        return false;
    }

    /**
     * @throws IllegalStateException
     * @deprecated
     * @param {boolean} backFaceShown
     */
    public setBackFaceShown(backFaceShown: boolean) {
        throw new IllegalStateException("Can\'t set back face shown attribute of a group");
    }

    /**
     * Returns <code>null</code>.
     * @return {com.eteks.sweethome3d.model.Transformation[]}
     */
    public getModelTransformations(): Transformation[] {
        return null;
    }

    /**
     * Sets the transformations of this group.
     * @param {com.eteks.sweethome3d.model.Transformation[]} modelTransformations
     */
    public setModelTransformations(modelTransformations: Transformation[]) {
        if (this.isDeformable()) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.setModelTransformations(modelTransformations);
                }
            }
        }
    }

    /**
     * Returns 0.
     * @return {number}
     */
    public getPitch(): number {
        return 0;
    }

    /**
     * Returns 0.
     * @return {number}
     */
    public getRoll(): number {
        return 0;
    }

    /**
     * Returns <code>null</code>.
     * @return {string}
     */
    public getStaircaseCutOutShape(): string {
        return null;
    }

    /**
     * @throws IllegalStateException
     * @param {string} staircaseCutOutShape
     */
    public setStaircaseCutOutShape(staircaseCutOutShape: string) {
        throw new IllegalStateException("Can\'t set staircase cut out shape of a group");
    }

    /**
     * Returns the creator set for this group.
     * @return {string}
     */
    public getCreator(): string {
        return super.getCreator();
    }

    /**
     * Returns the price of the furniture of this group with a price.
     * @return {Big}
     */
    public getPrice(): Big {
        let price: Big = null;
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                if (piece.getPrice() != null) {
                    if (price == null) {
                        price = piece.getPrice();
                    } else {
                        price = /* add */price.plus(piece.getPrice());
                    }
                }
            }
        }
        if (price == null) {
            return super.getPrice();
        } else {
            return price;
        }
    }

    /**
     * Sets the price of this group.
     * @throws UnsupportedOperationException if the price of one of the pieces is set
     * @param {Big} price
     */
    public setPrice(price: Big) {
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                if (piece.getPrice() != null) {
                    throw new UnsupportedOperationException("Can\'t change the price of a group containing pieces with a price");
                }
            }
        }
        super.setPrice(price);
    }

    /**
     * Returns the VAT percentage of the furniture of this group
     * or <code>null</code> if one piece has no VAT percentage
     * or has a VAT percentage different from the other furniture.
     * @return {Big}
     */
    public getValueAddedTaxPercentage(): Big {
        const valueAddedTaxPercentage: Big = /* get */this.furniture[0].getValueAddedTaxPercentage();
        if (valueAddedTaxPercentage != null) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    const pieceValueAddedTaxPercentage: Big = piece.getValueAddedTaxPercentage();
                    if (pieceValueAddedTaxPercentage == null || !/* equals */((valueAddedTaxPercentage) != null ? pieceValueAddedTaxPercentage.eq(valueAddedTaxPercentage) : (pieceValueAddedTaxPercentage === (valueAddedTaxPercentage)))) {
                        return null;
                    }
                }
            }
        }
        return valueAddedTaxPercentage;
    }

    /**
     * Returns the currency of the furniture of this group
     * or <code>null</code> if one piece has no currency
     * or has a currency different from the other furniture.
     * @return {string}
     */
    public getCurrency(): string {
        return this.__com_eteks_sweethome3d_model_HomeFurnitureGroup_currency;
    }

    /**
     * Returns the VAT of the furniture of this group.
     * @return {Big}
     */
    public getValueAddedTax(): Big {
        let valueAddedTax: Big = null;
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                const pieceValueAddedTax: Big = piece.getValueAddedTax();
                if (pieceValueAddedTax != null) {
                    if (valueAddedTax == null) {
                        valueAddedTax = pieceValueAddedTax;
                    } else {
                        valueAddedTax = /* add */valueAddedTax.plus(pieceValueAddedTax);
                    }
                }
            }
        }
        return valueAddedTax;
    }

    /**
     * Returns the total price of the furniture of this group.
     * @return {Big}
     */
    public getPriceValueAddedTaxIncluded(): Big {
        let priceValueAddedTaxIncluded: Big = null;
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                if (piece.getPrice() != null) {
                    if (priceValueAddedTaxIncluded == null) {
                        priceValueAddedTaxIncluded = piece.getPriceValueAddedTaxIncluded();
                    } else {
                        priceValueAddedTaxIncluded = /* add */priceValueAddedTaxIncluded.plus(piece.getPriceValueAddedTaxIncluded());
                    }
                }
            }
        }
        return priceValueAddedTaxIncluded;
    }

    /**
     * Returns <code>null</code>.
     * @return {number}
     */
    public getColor(): number {
        return null;
    }

    /**
     * Sets the <code>color</code> of the furniture of this group.
     * @param {number} color
     */
    public setColor(color: number) {
        if (this.isTexturable()) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.setColor(color);
                }
            }
        }
    }

    /**
     * Returns <code>null</code>.
     * @return {HomeTexture}
     */
    public getTexture(): HomeTexture {
        return null;
    }

    /**
     * Sets the <code>texture</code> of the furniture of this group.
     * @param {HomeTexture} texture
     */
    public setTexture(texture: HomeTexture) {
        if (this.isTexturable()) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.setTexture(texture);
                }
            }
        }
    }

    /**
     * Returns <code>null</code>.
     * @return {com.eteks.sweethome3d.model.HomeMaterial[]}
     */
    public getModelMaterials(): HomeMaterial[] {
        return null;
    }

    /**
     * Sets the materials of the furniture of this group.
     * @param {com.eteks.sweethome3d.model.HomeMaterial[]} modelMaterials
     */
    public setModelMaterials(modelMaterials: HomeMaterial[]) {
        if (this.isTexturable()) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.setModelMaterials(modelMaterials);
                }
            }
        }
    }

    /**
     * Returns <code>null</code>.
     * @return {number}
     */
    public getShininess(): number {
        return null;
    }

    /**
     * Sets the shininess of the furniture of this group.
     * @param {number} shininess
     */
    public setShininess(shininess: number) {
        if (this.isTexturable()) {
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.setShininess(shininess);
                }
            }
        }
    }

    /**
     * Sets the <code>angle</code> of the furniture of this group.
     * @param {number} angle
     */
    public setAngle(angle: number) {
        if (angle !== this.getAngle()) {
            const angleDelta: number = angle - this.getAngle();
            const cosAngleDelta: number = Math.cos(angleDelta);
            const sinAngleDelta: number = Math.sin(angleDelta);
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setAngle(piece.getAngle() + angleDelta);
                    const newX: number = this.getX() + <number>((piece.getX() - this.getX()) * cosAngleDelta - (piece.getY() - this.getY()) * sinAngleDelta);
                    const newY: number = this.getY() + <number>((piece.getX() - this.getX()) * sinAngleDelta + (piece.getY() - this.getY()) * cosAngleDelta);
                    piece.setX(newX);
                    piece.setY(newY);
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setAngle(angle);
        }
    }

    /**
     * Sets the <code>abscissa</code> of this group and moves its furniture accordingly.
     * @param {number} x
     */
    public setX(x: number) {
        if (x !== this.getX()) {
            const dx: number = x - this.getX();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setX(piece.getX() + dx);
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setX(x);
        }
    }

    /**
     * Sets the <code>ordinate</code> of this group and moves its furniture accordingly.
     * @param {number} y
     */
    public setY(y: number) {
        if (y !== this.getY()) {
            const dy: number = y - this.getY();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setY(piece.getY() + dy);
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setY(y);
        }
    }

    /**
     * Sets the <code>width</code> of this group, then moves and resizes its furniture accordingly.
     * This method shouldn't be called on a group that contain furniture rotated around an horizontal axis.
     * @param {number} width
     */
    public setWidth(width: number) {
        if (width !== this.getWidth()) {
            const widthFactor: number = width / this.getWidth();
            const angle: number = this.getAngle();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    const angleDelta: number = piece.getAngle() - angle;
                    const pieceWidth: number = piece.getWidth();
                    const pieceDepth: number = piece.getDepth();
                    piece.setWidth(pieceWidth + pieceWidth * (widthFactor - 1) * Math.abs(<number>Math.cos(angleDelta)));
                    piece.setDepth(pieceDepth + pieceDepth * (widthFactor - 1) * Math.abs(<number>Math.sin(angleDelta)));
                    const cosAngle: number = Math.cos(angle);
                    const sinAngle: number = Math.sin(angle);
                    let newX: number = this.getX() + <number>((piece.getX() - this.getX()) * cosAngle + (piece.getY() - this.getY()) * sinAngle);
                    const newY: number = this.getY() + <number>((piece.getX() - this.getX()) * -sinAngle + (piece.getY() - this.getY()) * cosAngle);
                    newX = this.getX() + (newX - this.getX()) * widthFactor;
                    piece.setX(this.getX() + <number>((newX - this.getX()) * cosAngle - (newY - this.getY()) * sinAngle));
                    piece.setY(this.getY() + <number>((newX - this.getX()) * sinAngle + (newY - this.getY()) * cosAngle));
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setWidth(width);
        }
    }

    /**
     * Sets the <code>depth</code> of this group, then moves and resizes its furniture accordingly.
     * This method shouldn't be called on a group that contain furniture rotated around an horizontal axis.
     * @param {number} depth
     */
    public setDepth(depth: number) {
        if (depth !== this.getDepth()) {
            const depthFactor: number = depth / this.getDepth();
            const angle: number = this.getAngle();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    const angleDelta: number = piece.getAngle() - angle;
                    const pieceWidth: number = piece.getWidth();
                    const pieceDepth: number = piece.getDepth();
                    piece.setWidth(pieceWidth + pieceWidth * (depthFactor - 1) * Math.abs(<number>Math.sin(angleDelta)));
                    piece.setDepth(pieceDepth + pieceDepth * (depthFactor - 1) * Math.abs(<number>Math.cos(angleDelta)));
                    const cosAngle: number = Math.cos(angle);
                    const sinAngle: number = Math.sin(angle);
                    const newX: number = this.getX() + <number>((piece.getX() - this.getX()) * cosAngle + (piece.getY() - this.getY()) * sinAngle);
                    let newY: number = this.getY() + <number>((piece.getX() - this.getX()) * -sinAngle + (piece.getY() - this.getY()) * cosAngle);
                    newY = this.getY() + (newY - this.getY()) * depthFactor;
                    piece.setX(this.getX() + <number>((newX - this.getX()) * cosAngle - (newY - this.getY()) * sinAngle));
                    piece.setY(this.getY() + <number>((newX - this.getX()) * sinAngle + (newY - this.getY()) * cosAngle));
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setDepth(depth);
        }
    }

    /**
     * Sets the <code>height</code> of this group, then moves and resizes its furniture accordingly.
     * This method shouldn't be called on a group that contain furniture rotated around an horizontal axis.
     * @param {number} height
     */
    public setHeight(height: number) {
        if (height !== this.getHeight()) {
            const heightFactor: number = height / this.getHeight();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setHeight(piece.getHeight() * heightFactor);
                    piece.setElevation(this.getElevation() + (piece.getElevation() - this.getElevation()) * heightFactor);
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setHeight(height);
        }
    }

    /**
     * Scales this group and its children with the given <code>ratio</code>.
     * @param {number} scale
     */
    public scale(scale: number) {
        const angle: number = this.getAngle();
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                piece.removePropertyChangeListener(this.furnitureListener);
                piece.setWidth(piece.getWidth() * scale);
                piece.setDepth(piece.getDepth() * scale);
                piece.setHeight(piece.getHeight() * scale);
                const cosAngle: number = Math.cos(angle);
                const sinAngle: number = Math.sin(angle);
                let newX: number = this.getX() + <number>((piece.getX() - this.getX()) * cosAngle + (piece.getY() - this.getY()) * sinAngle);
                let newY: number = this.getY() + <number>((piece.getX() - this.getX()) * -sinAngle + (piece.getY() - this.getY()) * cosAngle);
                newX = this.getX() + (newX - this.getX()) * scale;
                newY = this.getY() + (newY - this.getY()) * scale;
                piece.setX(this.getX() + <number>((newX - this.getX()) * cosAngle - (newY - this.getY()) * sinAngle));
                piece.setY(this.getY() + <number>((newX - this.getX()) * sinAngle + (newY - this.getY()) * cosAngle));
                piece.setElevation(this.getElevation() + (piece.getElevation() - this.getElevation()) * scale);
                piece.addPropertyChangeListener(this.furnitureListener);
            }
        }
        super.setWidth(this.getWidth() * scale);
        super.setDepth(this.getDepth() * scale);
        super.setHeight(this.getHeight() * scale);
    }

    /**
     * Sets the <code>elevation</code> of this group, then moves its furniture accordingly.
     * @param {number} elevation
     */
    public setElevation(elevation: number) {
        if (elevation !== this.getElevation()) {
            const elevationDelta: number = elevation - this.getElevation();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setElevation(piece.getElevation() + elevationDelta);
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setElevation(elevation);
        }
    }

    /**
     * Sets whether the furniture of this group should be mirrored or not.
     * @param {boolean} modelMirrored
     */
    public setModelMirrored(modelMirrored: boolean) {
        if (modelMirrored !== this.isModelMirrored()) {
            const angle: number = this.getAngle();
            for (let index = 0; index < this.furniture.length; index++) {
                let piece = this.furniture[index];
                {
                    piece.removePropertyChangeListener(this.furnitureListener);
                    piece.setModelMirrored(!piece.isModelMirrored());
                    piece.setAngle(2 * angle - piece.getAngle());
                    const cosAngle: number = Math.cos(angle);
                    const sinAngle: number = Math.sin(angle);
                    let newX: number = this.getX() + <number>((piece.getX() - this.getX()) * cosAngle + (piece.getY() - this.getY()) * sinAngle);
                    const newY: number = this.getY() + <number>((piece.getX() - this.getX()) * -sinAngle + (piece.getY() - this.getY()) * cosAngle);
                    newX = this.getX() - (newX - this.getX());
                    piece.setX(this.getX() + <number>((newX - this.getX()) * cosAngle - (newY - this.getY()) * sinAngle));
                    piece.setY(this.getY() + <number>((newX - this.getX()) * sinAngle + (newY - this.getY()) * cosAngle));
                    piece.addPropertyChangeListener(this.furnitureListener);
                }
            }
            super.setModelMirrored(modelMirrored);
        }
    }

    /**
     * Sets whether the furniture of this group should be visible or not.
     * @param {boolean} visible
     */
    public setVisible(visible: boolean) {
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                piece.setVisible(visible);
            }
        }
        super.setVisible(visible);
    }

    /**
     * Set the level of this group and the furniture it contains.
     * @param {Level} level
     */
    public setLevel(level: Level) {
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                piece.setLevel(level);
            }
        }
        super.setLevel(level);
    }

    /**
     * Returns <code>true</code> if one of the pieces of this group intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                if (piece.intersectsRectangle(x0, y0, x1, y1)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns <code>true</code> if one of the pieces of this group contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                if (piece.containsPoint(x, y, margin)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a copy of this object and its children with new ids.
     * @return {HomeObject}
     */
    public duplicate(): HomeObject {
        const copy: HomeFurnitureGroup = <HomeFurnitureGroup>super.duplicate();
        const duplicatedFurniture: Array<HomePieceOfFurniture> = <any>([]);
        for (let index = 0; index < copy.furniture.length; index++) {
            let piece = copy.furniture[index];
            {
                piece.removePropertyChangeListener(copy.furnitureListener);
                const duplicatedPiece: HomePieceOfFurniture = <HomePieceOfFurniture>piece.duplicate();
                /* add */(duplicatedFurniture.push(duplicatedPiece) > 0);
                duplicatedPiece.addPropertyChangeListener(copy.furnitureListener);
            }
        }
        copy.furniture = /* unmodifiableList */duplicatedFurniture.slice(0);
        return copy;
    }

    /**
     * Returns a clone of this group with cloned furniture.
     * @return {HomeFurnitureGroup}
     */
    public clone(): HomeFurnitureGroup {
        const clone: HomeFurnitureGroup = <HomeFurnitureGroup>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
        clone.furniture = <any>([]);
        for (let index = 0; index < this.furniture.length; index++) {
            let piece = this.furniture[index];
            {
                /* add */(clone.furniture.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(piece)) > 0);
            }
        }
        clone.furniture = /* unmodifiableList */clone.furniture.slice(0);
        clone.addFurnitureListener();
        return clone;
    }
}
HomeFurnitureGroup["__class"] = "com.eteks.sweethome3d.model.HomeFurnitureGroup";
HomeFurnitureGroup["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable", "com.eteks.sweethome3d.model.PieceOfFurniture", "com.eteks.sweethome3d.model.Elevatable"];



export namespace HomeFurnitureGroup {

    /**
     * Properties listener that updates the size and location of this group.
     * This listener is bound to this group with a weak reference to avoid a strong link
     * of this group towards the furniture it contains.
     * @param {HomeFurnitureGroup} group
     * @class
     */
    export class LocationAndSizeChangeListener {
        group: HomeFurnitureGroup;

        public constructor(group: HomeFurnitureGroup) {
            if (this.group === undefined) { this.group = null; }
            this.group = <any>(group);
        }

        public propertyChange(ev: PropertyChangeEvent) {
            const group: HomeFurnitureGroup = /* get */this.group;
            if (group == null) {
                (<HomePieceOfFurniture>ev.getSource()).removePropertyChangeListener(this);
            } else if ((/* name */"X" === ev.getPropertyName()) || (/* name */"Y" === ev.getPropertyName()) || (/* name */"ELEVATION" === ev.getPropertyName()) || (/* name */"ANGLE" === ev.getPropertyName()) || (/* name */"WIDTH_IN_PLAN" === ev.getPropertyName()) || (/* name */"DEPTH_IN_PLAN" === ev.getPropertyName()) || (/* name */"HEIGHT_IN_PLAN" === ev.getPropertyName())) {
                group.updateLocationAndSize(group.getFurniture(), group.getAngle(), false);
            }
        }
    }
    LocationAndSizeChangeListener["__class"] = "com.eteks.sweethome3d.model.HomeFurnitureGroup.LocationAndSizeChangeListener";

}
HomeFurnitureGroup['__transients'] = ['furnitureListener', 'shapeCache', 'propertyChangeSupport'];

/**
 * Creates a home with no furniture and no walls.
 * @param {number} wallHeight default height for home walls
 * @class
 * @author Emmanuel Puybaret
 */
export class Home {
    /**
     * The current version of this home. Each time the field list is changed
     * in <code>Home</code> class or in one of the classes that it uses,
     * this number is increased.
     */
    public static CURRENT_VERSION: number = 7400;

    static HOME_TOP_CAMERA_ID: string = "camera-homeTopCamera";

    static HOME_OBSERVER_CAMERA_ID: string = "observerCamera-homeObserverCamera";

    static HOME_ENVIRONMENT_ID: string = "environment-homeEnvironment";

    static HOME_COMPASS_ID: string = "compass-homeCompass";

    static KEEP_BACKWARD_COMPATIBLITY: boolean = true;

    static LEVEL_ELEVATION_COMPARATOR: any; public static LEVEL_ELEVATION_COMPARATOR_$LI$(): any {
        if (Home.LEVEL_ELEVATION_COMPARATOR == null) {
            Home.LEVEL_ELEVATION_COMPARATOR = (level1: Level, level2: Level) => {
                const elevationComparison: number = /* compare */(level1.getElevation() - level2.getElevation());
                if (elevationComparison !== 0) {
                    return elevationComparison;
                } else {
                    return level1.getElevationIndex() - level2.getElevationIndex();
                }
            };
        } return Home.LEVEL_ELEVATION_COMPARATOR;
    }

    /*private*/ furniture: Array<HomePieceOfFurniture>;

    /*private*/ furnitureChangeSupport: CollectionChangeSupport<HomePieceOfFurniture>;

    /*private*/ selectedItems: Array<Selectable>;

    /*private*/ selectionListeners: Array<SelectionListener>;

    /*private*/ allLevelsSelection: boolean;

    /*private*/ levels: Array<Level>;

    /*private*/ selectedLevel: Level;

    /*private*/ levelsChangeSupport: CollectionChangeSupport<Level>;

    /*private*/ walls: Array<Wall>;

    /*private*/ wallsChangeSupport: CollectionChangeSupport<Wall>;

    /*private*/ rooms: Array<Room>;

    /*private*/ roomsChangeSupport: CollectionChangeSupport<Room>;

    /*private*/ polylines: Array<Polyline>;

    /*private*/ polylinesChangeSupport: CollectionChangeSupport<Polyline>;

    /*private*/ dimensionLines: Array<DimensionLine>;

    /*private*/ dimensionLinesChangeSupport: CollectionChangeSupport<DimensionLine>;

    /*private*/ labels: Array<Label>;

    /*private*/ labelsChangeSupport: CollectionChangeSupport<Label>;

    /*private*/ camera: Camera;

    /*private*/ name: string;

    /*private*/ wallHeight: number;

    /*private*/ modified: boolean;

    /*private*/ recovered: boolean;

    /*private*/ repaired: boolean;

    /*private*/ backgroundImage: BackgroundImage;

    /*private*/ observerCamera: ObserverCamera;

    /*private*/ topCamera: Camera;

    /*private*/ storedCameras: Array<Camera>;

    /*private*/ environment: HomeEnvironment;

    /*private*/ print: HomePrint;

    /*private*/ furnitureSortedPropertyName: string;

    /*private*/ furnitureVisiblePropertyNames: Array<string>;

    /*private*/ furnitureDescendingSorted: boolean;

    /*private*/ visualProperties: any;

    /*private*/ properties: any;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ version: number;

    /*private*/ basePlanLocked: boolean;

    /*private*/ compass: Compass;

    /*private*/ furnitureAdditionalProperties: Array<ObjectProperty>;

    /*private*/ skyColor: number;

    /*private*/ groundColor: number;

    /*private*/ groundTexture: HomeTexture;

    /*private*/ lightColor: number;

    /*private*/ wallsAlpha: number;

    /*private*/ furnitureSortedProperty: any;

    /*private*/ furnitureVisibleProperties: Array<any>;

    /*private*/ furnitureWithDoorsAndWindows: Array<HomePieceOfFurniture>;

    /*private*/ furnitureWithGroups: Array<HomePieceOfFurniture>;

    public constructor(furniture?: any, wallHeight?: any) {
        if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((typeof wallHeight === 'number') || wallHeight === null)) {
            let __args = arguments;
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.levels === undefined) { this.levels = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
            if (this.walls === undefined) { this.walls = null; }
            if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
            if (this.camera === undefined) { this.camera = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.modified === undefined) { this.modified = false; }
            if (this.recovered === undefined) { this.recovered = false; }
            if (this.repaired === undefined) { this.repaired = false; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.storedCameras === undefined) { this.storedCameras = null; }
            if (this.environment === undefined) { this.environment = null; }
            if (this.print === undefined) { this.print = null; }
            if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
            if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
            if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
            if (this.visualProperties === undefined) { this.visualProperties = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.version === undefined) { this.version = 0; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
            if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
            if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
            if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
            this.furniture = <any>(furniture.slice(0));
            this.walls = <any>([]);
            this.wallHeight = wallHeight;
            this.furnitureVisibleProperties = /* asList */["NAME", "WIDTH", "DEPTH", "HEIGHT", "VISIBLE"].slice(0);
            this.furnitureVisiblePropertyNames = <any>([]);
            for (let index = 0; index < this.furnitureVisibleProperties.length; index++) {
                let property = this.furnitureVisibleProperties[index];
                {
                    /* add */(this.furnitureVisiblePropertyNames.push(/* name */property) > 0);
                }
            }
            this.init(true);
            this.addModelListeners();
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && wallHeight === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let wallHeight: any = 250;
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
                if (this.selectedItems === undefined) { this.selectedItems = null; }
                if (this.selectionListeners === undefined) { this.selectionListeners = null; }
                if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
                if (this.levels === undefined) { this.levels = null; }
                if (this.selectedLevel === undefined) { this.selectedLevel = null; }
                if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
                if (this.walls === undefined) { this.walls = null; }
                if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
                if (this.rooms === undefined) { this.rooms = null; }
                if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
                if (this.polylines === undefined) { this.polylines = null; }
                if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
                if (this.dimensionLines === undefined) { this.dimensionLines = null; }
                if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
                if (this.labels === undefined) { this.labels = null; }
                if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
                if (this.camera === undefined) { this.camera = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.modified === undefined) { this.modified = false; }
                if (this.recovered === undefined) { this.recovered = false; }
                if (this.repaired === undefined) { this.repaired = false; }
                if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                if (this.observerCamera === undefined) { this.observerCamera = null; }
                if (this.topCamera === undefined) { this.topCamera = null; }
                if (this.storedCameras === undefined) { this.storedCameras = null; }
                if (this.environment === undefined) { this.environment = null; }
                if (this.print === undefined) { this.print = null; }
                if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
                if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
                if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
                if (this.visualProperties === undefined) { this.visualProperties = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.version === undefined) { this.version = 0; }
                if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
                if (this.compass === undefined) { this.compass = null; }
                if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
                if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
                if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
                if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
                this.furniture = <any>(furniture.slice(0));
                this.walls = <any>([]);
                this.wallHeight = wallHeight;
                this.furnitureVisibleProperties = /* asList */["NAME", "WIDTH", "DEPTH", "HEIGHT", "VISIBLE"].slice(0);
                this.furnitureVisiblePropertyNames = <any>([]);
                for (let index = 0; index < this.furnitureVisibleProperties.length; index++) {
                    let property = this.furnitureVisibleProperties[index];
                    {
                        /* add */(this.furnitureVisiblePropertyNames.push(/* name */property) > 0);
                    }
                }
                this.init(true);
                this.addModelListeners();
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.levels === undefined) { this.levels = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
            if (this.walls === undefined) { this.walls = null; }
            if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
            if (this.camera === undefined) { this.camera = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.modified === undefined) { this.modified = false; }
            if (this.recovered === undefined) { this.recovered = false; }
            if (this.repaired === undefined) { this.repaired = false; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.storedCameras === undefined) { this.storedCameras = null; }
            if (this.environment === undefined) { this.environment = null; }
            if (this.print === undefined) { this.print = null; }
            if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
            if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
            if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
            if (this.visualProperties === undefined) { this.visualProperties = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.version === undefined) { this.version = 0; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
            if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
            if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
            if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
        } else if (((furniture != null && furniture instanceof <any>Home) || furniture === null) && wallHeight === undefined) {
            let __args = arguments;
            let home: any = __args[0];
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.levels === undefined) { this.levels = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
            if (this.walls === undefined) { this.walls = null; }
            if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
            if (this.camera === undefined) { this.camera = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.modified === undefined) { this.modified = false; }
            if (this.recovered === undefined) { this.recovered = false; }
            if (this.repaired === undefined) { this.repaired = false; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.storedCameras === undefined) { this.storedCameras = null; }
            if (this.environment === undefined) { this.environment = null; }
            if (this.print === undefined) { this.print = null; }
            if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
            if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
            if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
            if (this.visualProperties === undefined) { this.visualProperties = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.version === undefined) { this.version = 0; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
            if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
            if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
            if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
            this.wallHeight = home.getWallHeight();
            Home.copyHomeData(home, this);
            Home.initListenersSupport(this);
            this.addModelListeners();
        } else if (((typeof furniture === 'number') || furniture === null) && wallHeight === undefined) {
            let __args = arguments;
            let wallHeight: any = __args[0];
            {
                let __args = arguments;
                let furniture: any = [];
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
                if (this.selectedItems === undefined) { this.selectedItems = null; }
                if (this.selectionListeners === undefined) { this.selectionListeners = null; }
                if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
                if (this.levels === undefined) { this.levels = null; }
                if (this.selectedLevel === undefined) { this.selectedLevel = null; }
                if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
                if (this.walls === undefined) { this.walls = null; }
                if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
                if (this.rooms === undefined) { this.rooms = null; }
                if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
                if (this.polylines === undefined) { this.polylines = null; }
                if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
                if (this.dimensionLines === undefined) { this.dimensionLines = null; }
                if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
                if (this.labels === undefined) { this.labels = null; }
                if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
                if (this.camera === undefined) { this.camera = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.modified === undefined) { this.modified = false; }
                if (this.recovered === undefined) { this.recovered = false; }
                if (this.repaired === undefined) { this.repaired = false; }
                if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                if (this.observerCamera === undefined) { this.observerCamera = null; }
                if (this.topCamera === undefined) { this.topCamera = null; }
                if (this.storedCameras === undefined) { this.storedCameras = null; }
                if (this.environment === undefined) { this.environment = null; }
                if (this.print === undefined) { this.print = null; }
                if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
                if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
                if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
                if (this.visualProperties === undefined) { this.visualProperties = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.version === undefined) { this.version = 0; }
                if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
                if (this.compass === undefined) { this.compass = null; }
                if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
                if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
                if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
                if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
                this.furniture = <any>(furniture.slice(0));
                this.walls = <any>([]);
                this.wallHeight = wallHeight;
                this.furnitureVisibleProperties = /* asList */["NAME", "WIDTH", "DEPTH", "HEIGHT", "VISIBLE"].slice(0);
                this.furnitureVisiblePropertyNames = <any>([]);
                for (let index = 0; index < this.furnitureVisibleProperties.length; index++) {
                    let property = this.furnitureVisibleProperties[index];
                    {
                        /* add */(this.furnitureVisiblePropertyNames.push(/* name */property) > 0);
                    }
                }
                this.init(true);
                this.addModelListeners();
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.levels === undefined) { this.levels = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
            if (this.walls === undefined) { this.walls = null; }
            if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
            if (this.camera === undefined) { this.camera = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.modified === undefined) { this.modified = false; }
            if (this.recovered === undefined) { this.recovered = false; }
            if (this.repaired === undefined) { this.repaired = false; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.storedCameras === undefined) { this.storedCameras = null; }
            if (this.environment === undefined) { this.environment = null; }
            if (this.print === undefined) { this.print = null; }
            if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
            if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
            if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
            if (this.visualProperties === undefined) { this.visualProperties = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.version === undefined) { this.version = 0; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
            if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
            if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
            if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
        } else if (furniture === undefined && wallHeight === undefined) {
            let __args = arguments;
            {
                let __args = arguments;
                let wallHeight: any = 250;
                {
                    let __args = arguments;
                    let furniture: any = [];
                    if (this.furniture === undefined) { this.furniture = null; }
                    if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
                    if (this.selectedItems === undefined) { this.selectedItems = null; }
                    if (this.selectionListeners === undefined) { this.selectionListeners = null; }
                    if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
                    if (this.levels === undefined) { this.levels = null; }
                    if (this.selectedLevel === undefined) { this.selectedLevel = null; }
                    if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
                    if (this.walls === undefined) { this.walls = null; }
                    if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
                    if (this.rooms === undefined) { this.rooms = null; }
                    if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
                    if (this.polylines === undefined) { this.polylines = null; }
                    if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
                    if (this.dimensionLines === undefined) { this.dimensionLines = null; }
                    if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
                    if (this.labels === undefined) { this.labels = null; }
                    if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
                    if (this.camera === undefined) { this.camera = null; }
                    if (this.name === undefined) { this.name = null; }
                    if (this.wallHeight === undefined) { this.wallHeight = 0; }
                    if (this.modified === undefined) { this.modified = false; }
                    if (this.recovered === undefined) { this.recovered = false; }
                    if (this.repaired === undefined) { this.repaired = false; }
                    if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                    if (this.observerCamera === undefined) { this.observerCamera = null; }
                    if (this.topCamera === undefined) { this.topCamera = null; }
                    if (this.storedCameras === undefined) { this.storedCameras = null; }
                    if (this.environment === undefined) { this.environment = null; }
                    if (this.print === undefined) { this.print = null; }
                    if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
                    if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
                    if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
                    if (this.visualProperties === undefined) { this.visualProperties = null; }
                    if (this.properties === undefined) { this.properties = null; }
                    if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                    if (this.version === undefined) { this.version = 0; }
                    if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
                    if (this.compass === undefined) { this.compass = null; }
                    if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
                    if (this.skyColor === undefined) { this.skyColor = 0; }
                    if (this.groundColor === undefined) { this.groundColor = 0; }
                    if (this.groundTexture === undefined) { this.groundTexture = null; }
                    if (this.lightColor === undefined) { this.lightColor = 0; }
                    if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                    if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
                    if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
                    if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
                    if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
                    this.furniture = <any>(furniture.slice(0));
                    this.walls = <any>([]);
                    this.wallHeight = wallHeight;
                    this.furnitureVisibleProperties = /* asList */["NAME", "WIDTH", "DEPTH", "HEIGHT", "VISIBLE"].slice(0);
                    this.furnitureVisiblePropertyNames = <any>([]);
                    for (let index = 0; index < this.furnitureVisibleProperties.length; index++) {
                        let property = this.furnitureVisibleProperties[index];
                        {
                            /* add */(this.furnitureVisiblePropertyNames.push(/* name */property) > 0);
                        }
                    }
                    this.init(true);
                    this.addModelListeners();
                }
                if (this.furniture === undefined) { this.furniture = null; }
                if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
                if (this.selectedItems === undefined) { this.selectedItems = null; }
                if (this.selectionListeners === undefined) { this.selectionListeners = null; }
                if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
                if (this.levels === undefined) { this.levels = null; }
                if (this.selectedLevel === undefined) { this.selectedLevel = null; }
                if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
                if (this.walls === undefined) { this.walls = null; }
                if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
                if (this.rooms === undefined) { this.rooms = null; }
                if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
                if (this.polylines === undefined) { this.polylines = null; }
                if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
                if (this.dimensionLines === undefined) { this.dimensionLines = null; }
                if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
                if (this.labels === undefined) { this.labels = null; }
                if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
                if (this.camera === undefined) { this.camera = null; }
                if (this.name === undefined) { this.name = null; }
                if (this.wallHeight === undefined) { this.wallHeight = 0; }
                if (this.modified === undefined) { this.modified = false; }
                if (this.recovered === undefined) { this.recovered = false; }
                if (this.repaired === undefined) { this.repaired = false; }
                if (this.backgroundImage === undefined) { this.backgroundImage = null; }
                if (this.observerCamera === undefined) { this.observerCamera = null; }
                if (this.topCamera === undefined) { this.topCamera = null; }
                if (this.storedCameras === undefined) { this.storedCameras = null; }
                if (this.environment === undefined) { this.environment = null; }
                if (this.print === undefined) { this.print = null; }
                if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
                if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
                if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
                if (this.visualProperties === undefined) { this.visualProperties = null; }
                if (this.properties === undefined) { this.properties = null; }
                if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
                if (this.version === undefined) { this.version = 0; }
                if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
                if (this.compass === undefined) { this.compass = null; }
                if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
                if (this.skyColor === undefined) { this.skyColor = 0; }
                if (this.groundColor === undefined) { this.groundColor = 0; }
                if (this.groundTexture === undefined) { this.groundTexture = null; }
                if (this.lightColor === undefined) { this.lightColor = 0; }
                if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
                if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
                if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
                if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
                if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
            }
            if (this.furniture === undefined) { this.furniture = null; }
            if (this.furnitureChangeSupport === undefined) { this.furnitureChangeSupport = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.selectionListeners === undefined) { this.selectionListeners = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.levels === undefined) { this.levels = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.levelsChangeSupport === undefined) { this.levelsChangeSupport = null; }
            if (this.walls === undefined) { this.walls = null; }
            if (this.wallsChangeSupport === undefined) { this.wallsChangeSupport = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsChangeSupport === undefined) { this.roomsChangeSupport = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesChangeSupport === undefined) { this.polylinesChangeSupport = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesChangeSupport === undefined) { this.dimensionLinesChangeSupport = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsChangeSupport === undefined) { this.labelsChangeSupport = null; }
            if (this.camera === undefined) { this.camera = null; }
            if (this.name === undefined) { this.name = null; }
            if (this.wallHeight === undefined) { this.wallHeight = 0; }
            if (this.modified === undefined) { this.modified = false; }
            if (this.recovered === undefined) { this.recovered = false; }
            if (this.repaired === undefined) { this.repaired = false; }
            if (this.backgroundImage === undefined) { this.backgroundImage = null; }
            if (this.observerCamera === undefined) { this.observerCamera = null; }
            if (this.topCamera === undefined) { this.topCamera = null; }
            if (this.storedCameras === undefined) { this.storedCameras = null; }
            if (this.environment === undefined) { this.environment = null; }
            if (this.print === undefined) { this.print = null; }
            if (this.furnitureSortedPropertyName === undefined) { this.furnitureSortedPropertyName = null; }
            if (this.furnitureVisiblePropertyNames === undefined) { this.furnitureVisiblePropertyNames = null; }
            if (this.furnitureDescendingSorted === undefined) { this.furnitureDescendingSorted = false; }
            if (this.visualProperties === undefined) { this.visualProperties = null; }
            if (this.properties === undefined) { this.properties = null; }
            if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
            if (this.version === undefined) { this.version = 0; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.furnitureAdditionalProperties === undefined) { this.furnitureAdditionalProperties = null; }
            if (this.skyColor === undefined) { this.skyColor = 0; }
            if (this.groundColor === undefined) { this.groundColor = 0; }
            if (this.groundTexture === undefined) { this.groundTexture = null; }
            if (this.lightColor === undefined) { this.lightColor = 0; }
            if (this.wallsAlpha === undefined) { this.wallsAlpha = 0; }
            if (this.furnitureSortedProperty === undefined) { this.furnitureSortedProperty = null; }
            if (this.furnitureVisibleProperties === undefined) { this.furnitureVisibleProperties = null; }
            if (this.furnitureWithDoorsAndWindows === undefined) { this.furnitureWithDoorsAndWindows = null; }
            if (this.furnitureWithGroups === undefined) { this.furnitureWithGroups = null; }
        } else throw new Error('invalid overload');
    }

    moveVisualProperty(visualPropertyName: string) {
        if (/* containsKey */this.visualProperties.hasOwnProperty(visualPropertyName)) {
            const value: any = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.visualProperties, visualPropertyName);
            /* put */(this.properties[visualPropertyName] = value != null ? /* valueOf */String(value).toString() : null);
            /* remove */(map => { let deleted = this.visualProperties[visualPropertyName]; delete this.visualProperties[visualPropertyName]; return deleted; })(this.visualProperties);
        }
    }

    init(newHome: boolean) {
        this.selectedItems = <any>([]);
        Home.initListenersSupport(this);
        if (this.furnitureVisibleProperties == null) {
            this.furnitureVisibleProperties = /* asList */["NAME", "WIDTH", "DEPTH", "HEIGHT", "COLOR", "MOVABLE", "DOOR_OR_WINDOW", "VISIBLE"].slice(0);
        }
        this.topCamera = new Camera(Home.HOME_TOP_CAMERA_ID, 50, 1050, 1010, <number>Math.PI, <number>Math.PI / 4, <number>Math.PI * 63 / 180);
        this.observerCamera = new ObserverCamera(Home.HOME_OBSERVER_CAMERA_ID, 50, 50, 170, 7 * <number>Math.PI / 4, <number>Math.PI / 16, <number>Math.PI * 63 / 180);
        this.storedCameras = /* emptyList */[];
        this.environment = new HomeEnvironment(Home.HOME_ENVIRONMENT_ID);
        this.rooms = <any>([]);
        this.polylines = <any>([]);
        this.dimensionLines = <any>([]);
        this.labels = <any>([]);
        this.compass = new Compass(Home.HOME_COMPASS_ID, -100, 50, 100);
        this.levels = <any>([]);
        this.compass.setVisible(newHome);
        this.visualProperties = <any>({});
        this.properties = <any>({});
        this.furnitureAdditionalProperties = <any>([]);
        this.version = Home.CURRENT_VERSION;
    }

    static initListenersSupport(home: Home) {
        home.furnitureChangeSupport = <any>(new CollectionChangeSupport<HomePieceOfFurniture>(home));
        home.selectionListeners = <any>([]);
        home.levelsChangeSupport = <any>(new CollectionChangeSupport<Level>(home));
        home.wallsChangeSupport = <any>(new CollectionChangeSupport<Wall>(home));
        home.roomsChangeSupport = <any>(new CollectionChangeSupport<Room>(home));
        home.polylinesChangeSupport = <any>(new CollectionChangeSupport<Polyline>(home));
        home.dimensionLinesChangeSupport = <any>(new CollectionChangeSupport<DimensionLine>(home));
        home.labelsChangeSupport = <any>(new CollectionChangeSupport<Label>(home));
        home.propertyChangeSupport = new PropertyChangeSupport(home);
    }

    /**
     * Adds listeners to model.
     * @private
     */
    addModelListeners() {
        const levelElevationChangeListener: PropertyChangeListener = new Home.Home$0(this);
        for (let index = 0; index < this.levels.length; index++) {
            let level = this.levels[index];
            {
                level.addPropertyChangeListener(levelElevationChangeListener);
            }
        }
        this.addLevelsListener((ev: CollectionEvent<Level>) => {
            switch ((ev.getType())) {
                case CollectionEvent.Type.ADD:
                    ev.getItem().addPropertyChangeListener(levelElevationChangeListener);
                    break;
                case CollectionEvent.Type.DELETE:
                    ev.getItem().removePropertyChangeListener(levelElevationChangeListener);
                    break;
            }
        });
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is compatible
     * with the first set of sortable properties that existed in <code>HomePieceOfFurniture</code> class.
     * @param {string} property
     * @return {boolean}
     * @private
     */
    isFurnitureSortedPropertyBackwardCompatible(property: any): boolean {
        if (property != null) {
            switch ((property)) {
                case "NAME":
                case "WIDTH":
                case "DEPTH":
                case "HEIGHT":
                case "MOVABLE":
                case "DOOR_OR_WINDOW":
                case "COLOR":
                case "VISIBLE":
                case "X":
                case "Y":
                case "ELEVATION":
                case "ANGLE":
                    return true;
                default:
                    return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Returns all the pieces of the given <code>furnitureGroup</code>.
     * @param {HomeFurnitureGroup} furnitureGroup
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    getGroupFurniture(furnitureGroup: HomeFurnitureGroup): Array<HomePieceOfFurniture> {
        const groupFurniture: Array<HomePieceOfFurniture> = <any>([]);
        {
            let array = furnitureGroup.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(groupFurniture, this.getGroupFurniture(<HomeFurnitureGroup>piece));
                    } else {
                        /* add */(groupFurniture.push(piece) > 0);
                    }
                }
            }
        }
        return groupFurniture;
    }

    /**
     * Adds the level <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addLevelsListener(listener: CollectionListener<Level>) {
        this.levelsChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the level <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeLevelsListener(listener: CollectionListener<Level>) {
        this.levelsChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the levels of this home.
     * @return {Level[]}
     */
    public getLevels(): Array<Level> {
        return /* unmodifiableList */this.levels.slice(0);
    }

    /**
     * Adds the given <code>level</code> to the list of levels of this home.
     * Once the <code>level</code> is added, level listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Level} level  the level to add
     */
    public addLevel(level: Level) {
        if (level.getElevationIndex() < 0) {
            let elevationIndex: number = 0;
            for (let index = 0; index < this.levels.length; index++) {
                let homeLevel = this.levels[index];
                {
                    if (homeLevel.getElevation() === level.getElevation()) {
                        elevationIndex = homeLevel.getElevationIndex() + 1;
                    } else if (homeLevel.getElevation() > level.getElevation()) {
                        break;
                    }
                }
            }
            level.setElevationIndex(elevationIndex);
        }
        this.levels = <any>(this.levels.slice(0));
        const index: number = /* binarySearch */((l, key, c) => { let comp: any = c; if (typeof c != 'function') { comp = (a, b) => c.compare(a, b); } let low = 0; let high = l.length - 1; while (low <= high) { let mid = (low + high) >>> 1; let midVal = l[mid]; let cmp = comp(midVal, key); if (cmp < 0) low = mid + 1; else if (cmp > 0) high = mid - 1; else return mid; } return -(low + 1); })(this.levels, level, Home.LEVEL_ELEVATION_COMPARATOR_$LI$());
        let levelIndex: number;
        if (index >= 0) {
            levelIndex = index;
        } else {
            levelIndex = -(index + 1);
        }
        /* add */this.levels.splice(levelIndex, 0, level);
        this.levelsChangeSupport.fireCollectionChanged(level, levelIndex, CollectionEvent.Type.ADD);
    }

    /**
     * Removes the given <code>level</code> from the set of levels of this home
     * and all the furniture, walls, rooms, dimension lines and labels that belong to this level.
     * Once the <code>level</code> is removed, level listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {Level} level  the level to remove
     */
    public deleteLevel(level: Level) {
        const index: number = this.levels.indexOf(level);
        if (index !== -1) {
            for (let index1 = 0; index1 < this.furniture.length; index1++) {
                let piece = this.furniture[index1];
                {
                    if (piece.getLevel() === level) {
                        this.deletePieceOfFurniture(piece);
                    }
                }
            }
            for (let index1 = 0; index1 < this.rooms.length; index1++) {
                let room = this.rooms[index1];
                {
                    if (room.getLevel() === level) {
                        this.deleteRoom(room);
                    }
                }
            }
            for (let index1 = 0; index1 < this.walls.length; index1++) {
                let wall = this.walls[index1];
                {
                    if (wall.getLevel() === level) {
                        this.deleteWall(wall);
                    }
                }
            }
            for (let index1 = 0; index1 < this.polylines.length; index1++) {
                let polyline = this.polylines[index1];
                {
                    if (polyline.getLevel() === level) {
                        this.deletePolyline(polyline);
                    }
                }
            }
            for (let index1 = 0; index1 < this.dimensionLines.length; index1++) {
                let dimensionLine = this.dimensionLines[index1];
                {
                    if (dimensionLine.getLevel() === level) {
                        this.deleteDimensionLine(dimensionLine);
                    }
                }
            }
            for (let index1 = 0; index1 < this.labels.length; index1++) {
                let label = this.labels[index1];
                {
                    if (label.getLevel() === level) {
                        this.deleteLabel(label);
                    }
                }
            }
            if (this.selectedLevel === level) {
                if (/* size */(<number>this.levels.length) === 1) {
                    this.setSelectedLevel(null);
                    this.setAllLevelsSelection(false);
                } else {
                    this.setSelectedLevel(/* get */this.levels[index >= 1 ? index - 1 : index + 1]);
                }
            }
            if (this.print != null && this.print.getPrintedLevels() != null) {
                const printedLevels: Array<Level> = <any>(this.print.getPrintedLevels().slice(0));
                if (/* remove */(a => { let index = a.indexOf(level); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(printedLevels)) {
                    this.print = new HomePrint(this.print.getPaperOrientation(), this.print.getPaperWidth(), this.print.getPaperHeight(), this.print.getPaperTopMargin(), this.print.getPaperLeftMargin(), this.print.getPaperBottomMargin(), this.print.getPaperRightMargin(), this.print.isFurniturePrinted(), this.print.isPlanPrinted(), printedLevels, this.print.isView3DPrinted(), this.print.getPlanScale(), this.print.getHeaderFormat(), this.print.getFooterFormat());
                }
            }
            this.levels = <any>(this.levels.slice(0));
            /* remove */this.levels.splice(index, 1)[0];
            this.levelsChangeSupport.fireCollectionChanged(level, index, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Returns the selected level in home or <code>null</code> if home has no level.
     * @return {Level}
     */
    public getSelectedLevel(): Level {
        return this.selectedLevel;
    }

    /**
     * Sets the selected level in home and notifies listeners of the change.
     * @param {Level} selectedLevel  the level to select
     */
    public setSelectedLevel(selectedLevel: Level) {
        if (selectedLevel !== this.selectedLevel) {
            const oldSelectedLevel: Level = this.selectedLevel;
            this.selectedLevel = selectedLevel;
            this.propertyChangeSupport.firePropertyChange(/* name */"SELECTED_LEVEL", oldSelectedLevel, selectedLevel);
        }
    }

    /**
     * Returns <code>true</code> if the selected items in this home are from all levels.
     * @return {boolean}
     */
    public isAllLevelsSelection(): boolean {
        return this.allLevelsSelection;
    }

    /**
     * Sets whether the selected items in this home are from all levels, and notifies listeners of the change.
     * @param {boolean} selectionAtAllLevels
     */
    public setAllLevelsSelection(selectionAtAllLevels: boolean) {
        if (selectionAtAllLevels !== this.allLevelsSelection) {
            this.allLevelsSelection = selectionAtAllLevels;
            this.propertyChangeSupport.firePropertyChange(/* name */"ALL_LEVELS_SELECTION", !selectionAtAllLevels, selectionAtAllLevels);
        }
    }

    /**
     * Adds the furniture <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addFurnitureListener(listener: CollectionListener<HomePieceOfFurniture>) {
        this.furnitureChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the furniture <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeFurnitureListener(listener: CollectionListener<HomePieceOfFurniture>) {
        this.furnitureChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a list of the furniture managed by this home.
     * This furniture in this list is always sorted in the index order they were added to home.
     * @return {HomePieceOfFurniture[]}
     */
    public getFurniture(): Array<HomePieceOfFurniture> {
        return /* unmodifiableList */this.furniture.slice(0);
    }

    public addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece: HomePieceOfFurniture) {
        this.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(piece, /* size */(<number>this.furniture.length));
    }

    public addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(piece: HomePieceOfFurniture, index: number) {
        this.furniture = <any>(this.furniture.slice(0));
        piece.setLevel(this.selectedLevel);
        /* add */this.furniture.splice(index, 0, piece);
        this.furnitureChangeSupport.fireCollectionChanged(piece, index, CollectionEvent.Type.ADD);
    }

    /**
     * Adds the <code>piece</code> in parameter at a given <code>index</code>.
     * Once the <code>piece</code> is added, furniture listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification.
     * @param {HomePieceOfFurniture} piece  the piece to add
     * @param {number} index  the index at which the piece will be added
     */
    public addPieceOfFurniture(piece?: any, index?: any) {
        if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && ((typeof index === 'number') || index === null)) {
            return <any>this.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$int(piece, index);
        } else if (((piece != null && piece instanceof <any>HomePieceOfFurniture) || piece === null) && index === undefined) {
            return <any>this.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
        } else throw new Error('invalid overload');
    }

    /**
     * Adds the <code>piece</code> in parameter at the <code>index</code> in the given <code>group</code>.
     * Once the <code>piece</code> is added, furniture listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification with an event {@link CollectionEvent#getIndex() index} equal to -1.
     * @param {HomePieceOfFurniture} piece  the piece to add
     * @param {HomeFurnitureGroup} group  the group to which the piece will be added
     * @param {number} index  the index at which the piece will be added
     */
    public addPieceOfFurnitureToGroup(piece: HomePieceOfFurniture, group: HomeFurnitureGroup, index: number) {
        piece.setLevel(this.selectedLevel);
        group.addPieceOfFurniture(piece, index);
        this.furnitureChangeSupport.fireCollectionChanged(piece, CollectionEvent.Type.ADD);
    }

    /**
     * Deletes the <code>piece</code> in parameter from this home.
     * Once the <code>piece</code> is deleted, furniture listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification. If the removed <code>piece</code> belongs to a group, the
     * {@link CollectionEvent#getIndex() index} of the event will be -1.
     * @param {HomePieceOfFurniture} piece  the piece to remove
     */
    public deletePieceOfFurniture(piece: HomePieceOfFurniture) {
        this.deselectItem(piece);
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            {
                let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                for (let index = 0; index < array.length; index++) {
                    let groupPiece = array[index];
                    {
                        this.deselectItem(groupPiece);
                    }
                }
            }
        }
        const index: number = this.furniture.indexOf(piece);
        const group: HomeFurnitureGroup = index === -1 ? this.getPieceOfFurnitureGroup(piece, null, this.furniture) : null;
        if (index !== -1 || group != null) {
            piece.setLevel(null);
            this.furniture = <any>(this.furniture.slice(0));
            if (group != null) {
                group.deletePieceOfFurniture(piece);
                this.furnitureChangeSupport.fireCollectionChanged(piece, CollectionEvent.Type.DELETE);
            } else {
                /* remove */this.furniture.splice(index, 1)[0];
                this.furnitureChangeSupport.fireCollectionChanged(piece, index, CollectionEvent.Type.DELETE);
            }
        }
    }

    /**
     * Returns the furniture group that contains the given <code>piece</code> or <code>null</code>
     * if it can't be found.
     * @param {HomePieceOfFurniture} piece
     * @param {HomeFurnitureGroup} furnitureGroup
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomeFurnitureGroup}
     * @private
     */
    getPieceOfFurnitureGroup(piece: HomePieceOfFurniture, furnitureGroup: HomeFurnitureGroup, furniture: Array<HomePieceOfFurniture>): HomeFurnitureGroup {
        for (let index = 0; index < furniture.length; index++) {
            let homePiece = furniture[index];
            {
                if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(homePiece, piece))) {
                    return furnitureGroup;
                } else if (homePiece != null && homePiece instanceof <any>HomeFurnitureGroup) {
                    const group: HomeFurnitureGroup = this.getPieceOfFurnitureGroup(piece, <HomeFurnitureGroup>homePiece, (<HomeFurnitureGroup>homePiece).getFurniture());
                    if (group != null) {
                        return group;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Adds the selection <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addSelectionListener(listener: SelectionListener) {
        /* add */(this.selectionListeners.push(listener) > 0);
    }

    /**
     * Removes the selection <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeSelectionListener(listener: SelectionListener) {
        /* remove */(a => { let index = a.indexOf(listener); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.selectionListeners);
    }

    /**
     * Returns a list of the selected items in home.
     * @return {*[]}
     */
    public getSelectedItems(): Array<Selectable> {
        return /* unmodifiableList */this.selectedItems.slice(0);
    }

    /**
     * Returns <code>true</code> if the given <code>item</code> is selected in this home
     * @param {Object} item a selectable item.
     * @return {boolean}
     */
    public isItemSelected(item: Selectable): boolean {
        return /* contains */(this.selectedItems.indexOf(<any>(item)) >= 0);
    }

    /**
     * Sets the selected items in home and notifies listeners selection change.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} selectedItems the list of selected items
     */
    public setSelectedItems(selectedItems: Array<any>) {
        const oldSelectedItems: Array<Selectable> = /* unmodifiableList */this.selectedItems.slice(0);
        this.selectedItems = <any>(selectedItems.slice(0));
        if (!/* isEmpty */(this.selectionListeners.length == 0)) {
            const selectionEvent: SelectionEvent = new SelectionEvent(this, oldSelectedItems, this.getSelectedItems());
            const listeners: SelectionListener[] = /* toArray */this.selectionListeners.slice(0);
            for (let index = 0; index < listeners.length; index++) {
                let listener = listeners[index];
                {
                    listener.selectionChanged(selectionEvent);
                }
            }
        }
    }

    /**
     * Deselects <code>item</code> if it's selected and notifies listeners selection change.
     * @param {Object} item  the item to remove from selected items
     */
    public deselectItem(item: Selectable) {
        const pieceSelectionIndex: number = this.selectedItems.indexOf(item);
        if (pieceSelectionIndex !== -1) {
            const selectedItems: Array<Selectable> = <any>(this.getSelectedItems().slice(0));
            /* remove */selectedItems.splice(pieceSelectionIndex, 1)[0];
            this.setSelectedItems(selectedItems);
        }
    }

    /**
     * Adds the room <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addRoomsListener(listener: CollectionListener<Room>) {
        this.roomsChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the room <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeRoomsListener(listener: CollectionListener<Room>) {
        this.roomsChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the rooms of this home.
     * @return {Room[]}
     */
    public getRooms(): Array<Room> {
        return /* unmodifiableList */this.rooms.slice(0);
    }

    public addRoom$com_eteks_sweethome3d_model_Room(room: Room) {
        this.addRoom$com_eteks_sweethome3d_model_Room$int(room, /* size */(<number>this.rooms.length));
    }

    public addRoom$com_eteks_sweethome3d_model_Room$int(room: Room, index: number) {
        this.rooms = <any>(this.rooms.slice(0));
        /* add */this.rooms.splice(index, 0, room);
        room.setLevel(this.selectedLevel);
        this.roomsChangeSupport.fireCollectionChanged(room, index, CollectionEvent.Type.ADD);
    }

    /**
     * Adds the <code>room</code> in parameter at a given <code>index</code>.
     * Once the <code>room</code> is added, room listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Room} room   the room to add
     * @param {number} index  the index at which the room will be added
     */
    public addRoom(room?: any, index?: any) {
        if (((room != null && room instanceof <any>Room) || room === null) && ((typeof index === 'number') || index === null)) {
            return <any>this.addRoom$com_eteks_sweethome3d_model_Room$int(room, index);
        } else if (((room != null && room instanceof <any>Room) || room === null) && index === undefined) {
            return <any>this.addRoom$com_eteks_sweethome3d_model_Room(room);
        } else throw new Error('invalid overload');
    }

    /**
     * Removes the given <code>room</code> from the set of rooms of this home.
     * Once the <code>room</code> is removed, room listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {Room} room  the room to remove
     */
    public deleteRoom(room: Room) {
        this.deselectItem(room);
        const index: number = this.rooms.indexOf(room);
        if (index !== -1) {
            room.setLevel(null);
            this.rooms = <any>(this.rooms.slice(0));
            /* remove */this.rooms.splice(index, 1)[0];
            this.roomsChangeSupport.fireCollectionChanged(room, index, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Adds the wall <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addWallsListener(listener: CollectionListener<Wall>) {
        this.wallsChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the wall <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeWallsListener(listener: CollectionListener<Wall>) {
        this.wallsChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the walls of this home.
     * @return {Wall[]}
     */
    public getWalls(): Array<Wall> {
        return /* unmodifiableCollection */this.walls.slice(0);
    }

    /**
     * Adds the given <code>wall</code> to the set of walls of this home.
     * Once the <code>wall</code> is added, wall listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Wall} wall  the wall to add
     */
    public addWall(wall: Wall) {
        this.walls = <any>(this.walls.slice(0));
        /* add */(this.walls.push(wall) > 0);
        wall.setLevel(this.selectedLevel);
        this.wallsChangeSupport.fireCollectionChanged(wall, CollectionEvent.Type.ADD);
    }

    /**
     * Removes the given <code>wall</code> from the set of walls of this home.
     * Once the <code>wall</code> is removed, wall listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * If any wall is attached to <code>wall</code> they will be detached from it.
     * @param {Wall} wall  the wall to remove
     */
    public deleteWall(wall: Wall) {
        this.deselectItem(wall);
        {
            let array = this.getWalls();
            for (let index = 0; index < array.length; index++) {
                let otherWall = array[index];
                {
                    if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(wall, otherWall.getWallAtStart()))) {
                        otherWall.setWallAtStart(null);
                    } else if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(wall, otherWall.getWallAtEnd()))) {
                        otherWall.setWallAtEnd(null);
                    }
                }
            }
        }
        const index: number = this.walls.indexOf(wall);
        if (index !== -1) {
            wall.setLevel(null);
            this.walls = <any>(this.walls.slice(0));
            /* remove */this.walls.splice(index, 1)[0];
            this.wallsChangeSupport.fireCollectionChanged(wall, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Adds the polyline <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addPolylinesListener(listener: CollectionListener<Polyline>) {
        this.polylinesChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the polyline <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removePolylinesListener(listener: CollectionListener<Polyline>) {
        this.polylinesChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the polylines of this home.
     * @return {Polyline[]}
     */
    public getPolylines(): Array<Polyline> {
        return /* unmodifiableList */this.polylines.slice(0);
    }

    public addPolyline$com_eteks_sweethome3d_model_Polyline(polyline: Polyline) {
        this.addPolyline$com_eteks_sweethome3d_model_Polyline$int(polyline, /* size */(<number>this.polylines.length));
    }

    public addPolyline$com_eteks_sweethome3d_model_Polyline$int(polyline: Polyline, index: number) {
        this.polylines = <any>(this.polylines.slice(0));
        /* add */this.polylines.splice(index, 0, polyline);
        polyline.setLevel(this.selectedLevel);
        this.polylinesChangeSupport.fireCollectionChanged(polyline, CollectionEvent.Type.ADD);
    }

    /**
     * Adds a <code>polyline</code> at a given <code>index</code> of the set of polylines of this home.
     * Once the <code>polyline</code> is added, polyline listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Polyline} polyline  the polyline to add
     * @param {number} index  the index at which the polyline will be added
     */
    public addPolyline(polyline?: any, index?: any) {
        if (((polyline != null && polyline instanceof <any>Polyline) || polyline === null) && ((typeof index === 'number') || index === null)) {
            return <any>this.addPolyline$com_eteks_sweethome3d_model_Polyline$int(polyline, index);
        } else if (((polyline != null && polyline instanceof <any>Polyline) || polyline === null) && index === undefined) {
            return <any>this.addPolyline$com_eteks_sweethome3d_model_Polyline(polyline);
        } else throw new Error('invalid overload');
    }

    /**
     * Removes a given <code>polyline</code> from the set of polylines of this home.
     * Once the <code>polyline</code> is removed, polyline listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {Polyline} polyline  the polyline to remove
     */
    public deletePolyline(polyline: Polyline) {
        this.deselectItem(polyline);
        const index: number = this.polylines.indexOf(polyline);
        if (index !== -1) {
            polyline.setLevel(null);
            this.polylines = <any>(this.polylines.slice(0));
            /* remove */this.polylines.splice(index, 1)[0];
            this.polylinesChangeSupport.fireCollectionChanged(polyline, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Adds the dimension line <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addDimensionLinesListener(listener: CollectionListener<DimensionLine>) {
        this.dimensionLinesChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the dimension line <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeDimensionLinesListener(listener: CollectionListener<DimensionLine>) {
        this.dimensionLinesChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the dimension lines of this home.
     * @return {DimensionLine[]}
     */
    public getDimensionLines(): Array<DimensionLine> {
        return /* unmodifiableCollection */this.dimensionLines.slice(0);
    }

    /**
     * Adds the given dimension line to the set of dimension lines of this home.
     * Once <code>dimensionLine</code> is added, dimension line listeners added
     * to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {DimensionLine} dimensionLine  the dimension line to add
     */
    public addDimensionLine(dimensionLine: DimensionLine) {
        this.dimensionLines = <any>(this.dimensionLines.slice(0));
        /* add */(this.dimensionLines.push(dimensionLine) > 0);
        dimensionLine.setLevel(this.selectedLevel);
        this.dimensionLinesChangeSupport.fireCollectionChanged(dimensionLine, CollectionEvent.Type.ADD);
    }

    /**
     * Removes the given dimension line from the set of dimension lines of this home.
     * Once <code>dimensionLine</code> is removed, dimension line listeners added
     * to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {DimensionLine} dimensionLine  the dimension line to remove
     */
    public deleteDimensionLine(dimensionLine: DimensionLine) {
        this.deselectItem(dimensionLine);
        const index: number = this.dimensionLines.indexOf(dimensionLine);
        if (index !== -1) {
            dimensionLine.setLevel(null);
            this.dimensionLines = <any>(this.dimensionLines.slice(0));
            /* remove */this.dimensionLines.splice(index, 1)[0];
            this.dimensionLinesChangeSupport.fireCollectionChanged(dimensionLine, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Adds the label <code>listener</code> in parameter to this home.
     * @param {Object} listener the listener to add
     */
    public addLabelsListener(listener: CollectionListener<Label>) {
        this.labelsChangeSupport.addCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Removes the label <code>listener</code> in parameter from this home.
     * @param {Object} listener the listener to remove
     */
    public removeLabelsListener(listener: CollectionListener<Label>) {
        this.labelsChangeSupport.removeCollectionListener(<any>(((funcInst: any) => { if (typeof funcInst == 'function') { return funcInst } return (ev) => (funcInst['collectionChanged'] ? funcInst['collectionChanged'] : funcInst).call(funcInst, ev) })(listener)));
    }

    /**
     * Returns a collection of the labels of this home.
     * @return {Label[]}
     */
    public getLabels(): Array<Label> {
        return /* unmodifiableCollection */this.labels.slice(0);
    }

    /**
     * Adds the given label to the set of labels of this home.
     * Once <code>label</code> is added, label listeners added
     * to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#ADD}.
     * @param {Label} label  the label to add
     */
    public addLabel(label: Label) {
        this.labels = <any>(this.labels.slice(0));
        /* add */(this.labels.push(label) > 0);
        label.setLevel(this.selectedLevel);
        this.labelsChangeSupport.fireCollectionChanged(label, CollectionEvent.Type.ADD);
    }

    /**
     * Removes the given label from the set of labels of this home.
     * Once <code>label</code> is removed, label listeners added to this home will receive a
     * {@link CollectionListener#collectionChanged(CollectionEvent) collectionChanged}
     * notification, with an {@link CollectionEvent#getType() event type}
     * equal to {@link CollectionEvent.Type#DELETE}.
     * @param {Label} label  the label to remove
     */
    public deleteLabel(label: Label) {
        this.deselectItem(label);
        const index: number = this.labels.indexOf(label);
        if (index !== -1) {
            label.setLevel(null);
            this.labels = <any>(this.labels.slice(0));
            /* remove */this.labels.splice(index, 1)[0];
            this.labelsChangeSupport.fireCollectionChanged(label, CollectionEvent.Type.DELETE);
        }
    }

    /**
     * Returns all the selectable and viewable items in this home, except the observer camera.
     * @return {*[]} a list containing viewable walls, rooms, furniture, dimension lines, polylines, labels and compass.
     */
    public getSelectableViewableItems(): Array<Selectable> {
        const items: Array<Selectable> = <any>([]);
        this.addViewableItems<any>(this.walls, items);
        this.addViewableItems<any>(this.rooms, items);
        this.addViewableItems<any>(this.dimensionLines, items);
        this.addViewableItems<any>(this.polylines, items);
        this.addViewableItems<any>(this.labels, items);
        {
            let array = this.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isViewable())) {
                        /* add */(items.push(piece) > 0);
                    }
                }
            }
        }
        if (this.compass.isVisible()) {
            /* add */(items.push(this.compass) > 0);
        }
        return items;
    }

    /**
     * Adds the viewable items to the set of selectable viewable items.
     * @param {*[]} items
     * @param {*[]} selectableViewableItems
     * @private
     */
    addViewableItems<T extends Selectable>(items: Array<T>, selectableViewableItems: Array<Selectable>) {
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) {
                    const elevatableItem: Elevatable = <any>item;
                    if (elevatableItem.getLevel() == null || elevatableItem.getLevel().isViewable()) {
                        /* add */(selectableViewableItems.push(item) > 0);
                    }
                }
            }
        }
    }

    /**
     * Returns all the mutable objects handled by this home.
     * @return {HomeObject[]} a list containing environment, compass, levels, walls, rooms, furniture and their possible children,
     * polylines, dimension lines, labels and cameras.
     */
    public getHomeObjects(): Array<HomeObject> {
        const homeItems: Array<HomeObject> = <any>([]);
        /* add */(homeItems.push(this.environment) > 0);
        /* add */(homeItems.push(this.compass) > 0);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.levels);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.walls);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.rooms);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.dimensionLines);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.polylines);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.labels);
        {
            let array = this.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    /* add */(homeItems.push(piece) > 0);
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, (<HomeFurnitureGroup>piece).getAllFurniture());
                    }
                }
            }
        }
        /* add */(homeItems.push(this.topCamera) > 0);
        /* add */(homeItems.push(this.observerCamera) > 0);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.storedCameras);
        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(homeItems, this.environment.getVideoCameraPath());
        return homeItems;
    }

    /**
     * Returns <code>true</code> if this home doesn't contain any item i.e.
     * no piece of furniture, no wall, no room, no dimension line and no label.
     * @return {boolean}
     */
    public isEmpty(): boolean {
        return /* isEmpty */(this.furniture.length == 0) && /* isEmpty */(this.walls.length == 0) && /* isEmpty */(this.rooms.length == 0) && /* isEmpty */(this.dimensionLines.length == 0) && /* isEmpty */(this.polylines.length == 0) && /* isEmpty */(this.labels.length == 0);
    }

    /**
     * Returns the wall height of this home.
     * @return {number}
     */
    public getWallHeight(): number {
        return this.wallHeight;
    }

    /**
     * Returns the name of this home.
     * @return {string}
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Sets the name of this home and fires a <code>PropertyChangeEvent</code>.
     * @param {string} name  the new name of this home
     */
    public setName(name: string) {
        if (name !== this.name && (name == null || !(name === this.name))) {
            const oldName: string = this.name;
            this.name = name;
            this.propertyChangeSupport.firePropertyChange(/* name */"NAME", oldName, name);
        }
    }

    /**
     * Returns whether the state of this home is modified or not.
     * @return {boolean}
     */
    public isModified(): boolean {
        return this.modified;
    }

    /**
     * Sets the modified state of this home and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} modified
     */
    public setModified(modified: boolean) {
        if (modified !== this.modified) {
            this.modified = modified;
            this.propertyChangeSupport.firePropertyChange(/* name */"MODIFIED", !modified, modified);
        }
    }

    /**
     * Returns whether this home was recovered or not.
     * @return {boolean}
     */
    public isRecovered(): boolean {
        return this.recovered;
    }

    /**
     * Sets whether this home was recovered or not and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} recovered
     */
    public setRecovered(recovered: boolean) {
        if (recovered !== this.recovered) {
            this.recovered = recovered;
            this.propertyChangeSupport.firePropertyChange(/* name */"RECOVERED", !recovered, recovered);
        }
    }

    /**
     * Returns whether this home was repaired or not.
     * @return {boolean}
     */
    public isRepaired(): boolean {
        return this.repaired;
    }

    /**
     * Sets whether this home is repaired or not and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} repaired
     */
    public setRepaired(repaired: boolean) {
        if (repaired !== this.repaired) {
            this.repaired = repaired;
            this.propertyChangeSupport.firePropertyChange(/* name */"REPAIRED", !repaired, repaired);
        }
    }

    /**
     * Returns the furniture property name on which home is sorted or <code>null</code> if
     * home furniture isn't sorted.
     * @return {string}
     */
    public getFurnitureSortedPropertyName(): string {
        return this.furnitureSortedPropertyName;
    }

    /**
     * Sets the furniture property name on which this home should be sorted
     * and fires a <code>PropertyChangeEvent</code>.
     * @param {string} furnitureSortedPropertyName the name of the property
     */
    public setFurnitureSortedPropertyName(furnitureSortedPropertyName: string) {
        if (furnitureSortedPropertyName !== this.furnitureSortedPropertyName && (furnitureSortedPropertyName == null || !(furnitureSortedPropertyName === this.furnitureSortedPropertyName))) {
            const oldFurnitureSortedPropertyName: string = this.furnitureSortedPropertyName;
            this.furnitureSortedPropertyName = furnitureSortedPropertyName;
            try {
                this.furnitureSortedProperty = furnitureSortedPropertyName != null ? /* valueOf */furnitureSortedPropertyName : null;
            } catch (ex) {
                this.furnitureSortedProperty = null;
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_SORTED_PROPERTY", oldFurnitureSortedPropertyName, furnitureSortedPropertyName);
        }
    }

    /**
     * Returns the furniture property on which home is sorted or <code>null</code> if
     * home furniture isn't sorted.
     * @deprecated {@link #getFurnitureSortedProperty()} and {@link #setFurnitureSortedProperty(HomePieceOfFurniture.SortableProperty)}
     * should be replaced by calls to {@link #getFurnitureSortedPropertyName()} and {@link #setFurnitureSortedPropertyName(String)}
     * to allow sorting on additional properties.
     * @return {string}
     */
    public getFurnitureSortedProperty(): any {
        return this.furnitureSortedProperty;
    }

    /**
     * Sets the furniture property on which this home should be sorted
     * and fires a <code>PropertyChangeEvent</code>.
     * @param {string} furnitureSortedProperty the new property
     * @deprecated {@link #getFurnitureSortedProperty()} and {@link #setFurnitureSortedProperty(HomePieceOfFurniture.SortableProperty)}
     * should be replaced by calls to {@link #getFurnitureSortedPropertyName()} and {@link #setFurnitureSortedPropertyName(String)}
     * to allow sorting on additional properties.
     */
    public setFurnitureSortedProperty(furnitureSortedProperty: any) {
        if (furnitureSortedProperty !== this.furnitureSortedProperty && (furnitureSortedProperty == null || !/* equals */(furnitureSortedProperty == this.furnitureSortedProperty))) {
            const oldFurnitureSortedProperty: any = this.furnitureSortedProperty;
            this.furnitureSortedProperty = furnitureSortedProperty;
            this.furnitureSortedPropertyName = furnitureSortedProperty != null ? /* name */furnitureSortedProperty : null;
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_SORTED_PROPERTY", oldFurnitureSortedProperty, furnitureSortedProperty);
        }
    }

    /**
     * Returns whether furniture is sorted in ascending or descending order.
     * @return {boolean}
     */
    public isFurnitureDescendingSorted(): boolean {
        return this.furnitureDescendingSorted;
    }

    /**
     * Sets the furniture sort order on which home should be sorted
     * and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} furnitureDescendingSorted
     */
    public setFurnitureDescendingSorted(furnitureDescendingSorted: boolean) {
        if (furnitureDescendingSorted !== this.furnitureDescendingSorted) {
            this.furnitureDescendingSorted = furnitureDescendingSorted;
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_DESCENDING_SORTED", !furnitureDescendingSorted, furnitureDescendingSorted);
        }
    }

    /**
     * Returns a list of the furniture property names that are visible.
     * @return {string[]}
     */
    public getFurnitureVisiblePropertyNames(): Array<string> {
        if (this.furnitureVisiblePropertyNames == null) {
            return /* emptyList */[];
        } else {
            return /* unmodifiableList */this.furnitureVisiblePropertyNames.slice(0);
        }
    }

    /**
     * Sets the furniture property names that are visible and the order in which they are visible,
     * then fires a <code>PropertyChangeEvent</code>.
     * @param {string[]} furnitureVisiblePropertyNames  the property names to display
     */
    public setFurnitureVisiblePropertyNames(furnitureVisiblePropertyNames: Array<string>) {
        if (furnitureVisiblePropertyNames !== this.furnitureVisiblePropertyNames && (furnitureVisiblePropertyNames == null || !/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(furnitureVisiblePropertyNames, this.furnitureVisiblePropertyNames))) {
            const oldFurnitureVisiblePropertyNames: Array<string> = this.furnitureVisiblePropertyNames;
            this.furnitureVisiblePropertyNames = <any>(furnitureVisiblePropertyNames.slice(0));
            this.furnitureVisibleProperties = <any>([]);
            for (let index = 0; index < furnitureVisiblePropertyNames.length; index++) {
                let propertyName = furnitureVisiblePropertyNames[index];
                {
                    try {
                        /* add */(this.furnitureVisibleProperties.push(/* valueOf */propertyName) > 0);
                    } catch (ex) {
                    }
                }
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_VISIBLE_PROPERTIES", /* unmodifiableList */oldFurnitureVisiblePropertyNames.slice(0), /* unmodifiableList */furnitureVisiblePropertyNames.slice(0));
        }
    }

    /**
     * Returns a list of the furniture properties that are visible.
     * @deprecated {@link #getFurnitureVisibleProperties()} and {@link #setFurnitureVisibleProperties(List<HomePieceOfFurniture.SortableProperty>)}
     * should be replaced by calls to {@link #getFurnitureVisiblePropertyNames()} and {@link #setFurnitureSortedPropertyName(List<String>)}
     * to allow displaying additional properties.
     * @return {string[]}
     */
    public getFurnitureVisibleProperties(): Array<any> {
        if (this.furnitureVisibleProperties == null) {
            return /* emptyList */[];
        } else {
            return /* unmodifiableList */this.furnitureVisibleProperties.slice(0);
        }
    }

    /**
     * Sets the furniture properties that are visible and the order in which they are visible,
     * then fires a <code>PropertyChangeEvent</code>.
     * @param {string[]} furnitureVisibleProperties  the properties to display
     * @deprecated {@link #getFurnitureVisibleProperties()} and {@link #setFurnitureVisibleProperties(List<HomePieceOfFurniture.SortableProperty>)}
     * should be replaced by calls to {@link #getFurnitureVisiblePropertyNames()} and {@link #setFurnitureSortedPropertyName(List<String>)}
     * to allow displaying additional properties.
     */
    public setFurnitureVisibleProperties(furnitureVisibleProperties: Array<any>) {
        if (furnitureVisibleProperties !== this.furnitureVisibleProperties && (furnitureVisibleProperties == null || !/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(furnitureVisibleProperties, this.furnitureVisibleProperties))) {
            const oldFurnitureVisibleProperties: Array<any> = this.furnitureVisibleProperties;
            this.furnitureVisibleProperties = <any>(furnitureVisibleProperties.slice(0));
            this.furnitureVisiblePropertyNames = <any>([]);
            for (let index = 0; index < furnitureVisibleProperties.length; index++) {
                let property = furnitureVisibleProperties[index];
                {
                    /* add */(this.furnitureVisiblePropertyNames.push(/* name */property) > 0);
                }
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_VISIBLE_PROPERTIES", /* unmodifiableList */oldFurnitureVisibleProperties.slice(0), /* unmodifiableList */furnitureVisibleProperties.slice(0));
        }
    }

    /**
     * Returns the list of furniture additional properties which should be handled in the user interface.
     * @return {ObjectProperty[]}
     */
    public getFurnitureAdditionalProperties(): Array<ObjectProperty> {
        return /* unmodifiableList */this.furnitureAdditionalProperties.slice(0);
    }

    /**
     * Sets the list of furniture additional properties which should be handled in the user interface.
     * @param {ObjectProperty[]} furnitureAdditionalProperties
     */
    public setFurnitureAdditionalProperties(furnitureAdditionalProperties: Array<ObjectProperty>) {
        if (furnitureAdditionalProperties !== this.furnitureAdditionalProperties && (furnitureAdditionalProperties == null || !/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(furnitureAdditionalProperties, this.furnitureAdditionalProperties))) {
            const oldFurnitureAdditionalProperties: Array<ObjectProperty> = this.furnitureAdditionalProperties;
            this.furnitureAdditionalProperties = <any>(furnitureAdditionalProperties.slice(0));
            const furnitureVisiblePropertyNames: Array<string> = <any>(this.getFurnitureVisiblePropertyNames().slice(0));
            for (let i: number = /* size */(<number>furnitureVisiblePropertyNames.length) - 1; i >= 0; i--) {
                {
                    try {
                    /* valueOf *//* get */furnitureVisiblePropertyNames[i];
                    } catch (ex) {
                        if (!/* contains */(furnitureAdditionalProperties.indexOf(<any>(new ObjectProperty(/* get */furnitureVisiblePropertyNames[i]))) >= 0)) {
                        /* remove */furnitureVisiblePropertyNames.splice(i, 1)[0];
                        }
                    }
                };
            }
            this.setFurnitureVisiblePropertyNames(furnitureVisiblePropertyNames);
            if (this.getFurnitureSortedPropertyName() != null && !/* contains */(furnitureAdditionalProperties.indexOf(<any>(new ObjectProperty(this.getFurnitureSortedPropertyName()))) >= 0)) {
                this.setFurnitureSortedPropertyName(null);
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"FURNITURE_ADDITIONAL_PROPERTIES", /* unmodifiableList */oldFurnitureAdditionalProperties.slice(0), /* unmodifiableList */furnitureAdditionalProperties.slice(0));
        }
    }

    /**
     * Returns the plan background image of this home.
     * @return {BackgroundImage}
     */
    public getBackgroundImage(): BackgroundImage {
        return this.backgroundImage;
    }

    /**
     * Sets the plan background image of this home and fires a <code>PropertyChangeEvent</code>.
     * @param {BackgroundImage} backgroundImage  the new background image
     */
    public setBackgroundImage(backgroundImage: BackgroundImage) {
        if (backgroundImage !== this.backgroundImage) {
            const oldBackgroundImage: BackgroundImage = this.backgroundImage;
            this.backgroundImage = backgroundImage;
            this.propertyChangeSupport.firePropertyChange(/* name */"BACKGROUND_IMAGE", oldBackgroundImage, backgroundImage);
        }
    }

    /**
     * Returns the camera used to display this home from a top point of view.
     * @return {Camera}
     */
    public getTopCamera(): Camera {
        return this.topCamera;
    }

    /**
     * Returns the camera used to display this home from an observer point of view.
     * @return {ObserverCamera}
     */
    public getObserverCamera(): ObserverCamera {
        return this.observerCamera;
    }

    /**
     * Sets the camera used to display this home and fires a <code>PropertyChangeEvent</code>.
     * @param {Camera} camera  the camera to use
     */
    public setCamera(camera: Camera) {
        if (camera !== this.camera) {
            const oldCamera: Camera = this.camera;
            this.camera = camera;
            this.propertyChangeSupport.firePropertyChange(/* name */"CAMERA", oldCamera, camera);
        }
    }

    /**
     * Returns the camera used to display this home.
     * @return {Camera}
     */
    public getCamera(): Camera {
        if (this.camera == null) {
            this.camera = this.getTopCamera();
        }
        return this.camera;
    }

    /**
     * Sets the cameras stored by this home and fires a <code>PropertyChangeEvent</code>.
     * The list given as parameter is cloned but not the camera instances it contains.
     * @param {Camera[]} storedCameras  the new list of cameras
     */
    public setStoredCameras(storedCameras: Array<Camera>) {
        if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(this.storedCameras, storedCameras)) {
            const oldStoredCameras: Array<Camera> = this.storedCameras;
            if (storedCameras == null) {
                this.storedCameras = /* emptyList */[];
            } else {
                this.storedCameras = <any>(storedCameras.slice(0));
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"STORED_CAMERAS", /* unmodifiableList */oldStoredCameras.slice(0), /* unmodifiableList */storedCameras.slice(0));
        }
    }

    /**
     * Returns a list of the cameras stored by this home.
     * @return {Camera[]}
     */
    public getStoredCameras(): Array<Camera> {
        return /* unmodifiableList */this.storedCameras.slice(0);
    }

    /**
     * Returns the environment attributes of this home.
     * @return {HomeEnvironment}
     */
    public getEnvironment(): HomeEnvironment {
        return this.environment;
    }

    /**
     * Returns the compass associated to this home.
     * @return {Compass}
     */
    public getCompass(): Compass {
        return this.compass;
    }

    /**
     * Returns the print attributes of this home.
     * @return {HomePrint}
     */
    public getPrint(): HomePrint {
        return this.print;
    }

    /**
     * Sets the print attributes of this home and fires a <code>PropertyChangeEvent</code>.
     * @param {HomePrint} print  the new print attributes
     */
    public setPrint(print: HomePrint) {
        if (print !== this.print) {
            const oldPrint: HomePrint = this.print;
            this.print = print;
            this.propertyChangeSupport.firePropertyChange(/* name */"PRINT", oldPrint, print);
        }
        this.print = print;
    }

    /**
     * Returns the value of the visual property <code>name</code> associated with this home.
     * @deprecated {@link #getVisualProperty(String)} and {@link #setVisualProperty(String, Object)}
     * should be replaced by calls to {@link #getProperty(String)} and {@link #setProperty(String, String)}
     * to ensure they can be easily saved and read. Future file format might not save visual properties anymore.
     * @param {string} name
     * @return {Object}
     */
    public getVisualProperty(name: string): any {
        return /* get */((m, k) => m[k] === undefined ? null : m[k])(this.visualProperties, name);
    }

    /**
     * Sets a visual property associated with this home.
     * @deprecated {@link #getVisualProperty(String)} and {@link #setVisualProperty(String, Object)}
     * should be replaced by calls to {@link #getProperty(String)} and {@link #setProperty(String, String)}
     * to ensure they can be easily saved and read. Future file format might not save visual properties anymore.
     * @param {string} name
     * @param {Object} value
     */
    public setVisualProperty(name: string, value: any) {
        /* put */(this.visualProperties[name] = value);
    }

    /**
     * Returns the value of the property <code>name</code> associated with this home.
     * @return {string} the value of the property or <code>null</code> if it doesn't exist.
     * @param {string} name
     */
    public getProperty(name: string): string {
        return /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
    }

    /**
     * Returns the numeric value of the property <code>name</code> associated with this home.
     * @return {number} an instance of {@link Long}, {@link Double} or <code>null</code> if the property
     * doesn't exist or can't be parsed.
     * @param {string} name
     */
    public getNumericProperty(name: string): number {
        const value: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
        if (value != null) {
            try {
                return new Number(value).valueOf();
            } catch (ex) {
                try {
                    return new Number(value).valueOf();
                } catch (ex1) {
                }
            }
        }
        return null;
    }

    /**
     * Sets a property associated with this home. Once the property is updated,
     * listeners added to this home will receive a change event of
     * {@link PropertyChangeEvent} class.<br>
     * To avoid any issue with existing or future properties of Sweet Home 3D classes,
     * do not use property names written with only upper case letters.
     * @param {string} name   the name of the property to set
     * @param {string} value  the new value of the property
     */
    public setProperty(name: string, value: string) {
        const oldValue: string = /* get */((m, k) => m[k] === undefined ? null : m[k])(this.properties, name);
        if (value == null) {
            if (oldValue != null) {
                /* remove */(map => { let deleted = this.properties[name]; delete this.properties[name]; return deleted; })(this.properties);
                this.propertyChangeSupport.firePropertyChange(name, oldValue, null);
            }
        } else {
            /* put */(this.properties[name] = value);
            this.propertyChangeSupport.firePropertyChange(name, oldValue, value);
        }
    }

    /**
     * Returns the property names.
     * @return {string[]} a collection of all the names of the properties set with {@link #setProperty(String, String) setProperty}
     */
    public getPropertyNames(): Array<string> {
        return /* keySet */Object.keys(this.properties);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this home for a specific property name.
     * Properties set with {@link #setProperty(String, String) setProperty} will be notified with
     * an event of {@link PropertyChangeEvent} class which property name will be equal to the property,
     * whereas changes on properties of {@link Property} enum will be notified with an event where
     * the property name will be equal to the value returned by {@link Property#name()} call.
     * @param {string} propertyName
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(propertyName: string, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(propertyName, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this object.
     * @param {string} propertyName
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(propertyName: string, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(propertyName, listener);
    }

    /**
     * Returns <code>true</code> if the home objects belonging to the base plan
     * (generally walls, rooms, dimension lines and texts) are locked.
     * @return {boolean}
     */
    public isBasePlanLocked(): boolean {
        return this.basePlanLocked;
    }

    /**
     * Sets whether home objects belonging to the base plan (generally walls, rooms,
     * dimension lines and texts) are locked and fires a <code>PropertyChangeEvent</code>.
     * @param {boolean} basePlanLocked
     */
    public setBasePlanLocked(basePlanLocked: boolean) {
        if (basePlanLocked !== this.basePlanLocked) {
            this.basePlanLocked = basePlanLocked;
            this.propertyChangeSupport.firePropertyChange(/* name */"BASE_PLAN_LOCKED", !basePlanLocked, basePlanLocked);
        }
    }

    /**
     * Returns the version of this home, the last time it was serialized or
     * or {@link #CURRENT_VERSION} if it is not serialized yet or
     * was serialized with Sweet Home 3D 0.x.
     * Version is useful to know with which Sweet Home 3D version this home was saved
     * and warn user that he may lose information if he saves with
     * current application a home created by a more recent version.
     * @return {number}
     */
    public getVersion(): number {
        return this.version;
    }

    /**
     * Sets the version of this home.
     * @return {void} version  the new version
     * @param {number} version
     */
    public setVersion(version: number) {
        this.version = version;
    }

    /**
     * Returns a clone of this home and the objects it contains.
     * Listeners bound to this home aren't added to the returned home.
     * @return {Home}
     */
    public clone(): Home {
        try {
            const clone: Home = <Home>/* clone *//* clone */((o: any) => { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; })(this);
            Home.copyHomeData(this, clone);
            Home.initListenersSupport(clone);
            clone.addModelListeners();
            return clone;
        } catch (ex) {
            throw new IllegalStateException("Super class isn\'t cloneable");
        }
    }

    /**
     * Copies all data of a <code>source</code> home to a <code>destination</code> home.
     * @param {Home} source
     * @param {Home} destination
     * @private
     */
    static copyHomeData(source: Home, destination: Home) {
        destination.allLevelsSelection = source.allLevelsSelection;
        destination.name = source.name;
        destination.modified = source.modified;
        destination.recovered = source.recovered;
        destination.repaired = source.repaired;
        destination.backgroundImage = source.backgroundImage;
        destination.furnitureDescendingSorted = source.furnitureDescendingSorted;
        destination.version = source.version;
        destination.basePlanLocked = source.basePlanLocked;
        destination.skyColor = source.skyColor;
        destination.groundColor = source.groundColor;
        destination.lightColor = source.lightColor;
        destination.wallsAlpha = source.wallsAlpha;
        destination.furnitureSortedProperty = source.furnitureSortedProperty;
        destination.selectedItems = <any>([]);
        destination.furniture = Home.cloneSelectableItems<any>(source.furniture, source.selectedItems, destination.selectedItems);
        destination.rooms = Home.cloneSelectableItems<any>(source.rooms, source.selectedItems, destination.selectedItems);
        destination.dimensionLines = Home.cloneSelectableItems<any>(source.dimensionLines, source.selectedItems, destination.selectedItems);
        destination.polylines = Home.cloneSelectableItems<any>(source.polylines, source.selectedItems, destination.selectedItems);
        destination.labels = Home.cloneSelectableItems<any>(source.labels, source.selectedItems, destination.selectedItems);
        destination.walls = /* clone */Wall.clone(source.walls);
        for (let i: number = 0; i < /* size */(<number>source.walls.length); i++) {
            {
                const wall: Wall = /* get */source.walls[i];
                if (/* contains */(source.selectedItems.indexOf(<any>(wall)) >= 0)) {
                /* add */(destination.selectedItems.push(/* get */destination.walls[i]) > 0);
                }
            };
        }
        destination.levels = <any>([]);
        if (/* size */(<number>source.levels.length) > 0) {
            for (let index = 0; index < source.levels.length; index++) {
                let level = source.levels[index];
                {
                    /* add */(destination.levels.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(level)) > 0);
                }
            }
            for (let i: number = 0; i < /* size */(<number>source.furniture.length); i++) {
                {
                    const pieceLevel: Level = /* get */source.furniture[i].getLevel();
                    if (pieceLevel != null) {
                    /* get */destination.furniture[i].setLevel(/* get */destination.levels[source.levels.indexOf(pieceLevel)]);
                    }
                };
            }
            for (let i: number = 0; i < /* size */(<number>source.rooms.length); i++) {
                {
                    const roomLevel: Level = /* get */source.rooms[i].getLevel();
                    if (roomLevel != null) {
                    /* get */destination.rooms[i].setLevel(/* get */destination.levels[source.levels.indexOf(roomLevel)]);
                    }
                };
            }
            for (let i: number = 0; i < /* size */(<number>source.dimensionLines.length); i++) {
                {
                    const dimensionLineLevel: Level = /* get */source.dimensionLines[i].getLevel();
                    if (dimensionLineLevel != null) {
                    /* get */destination.dimensionLines[i].setLevel(/* get */destination.levels[source.levels.indexOf(dimensionLineLevel)]);
                    }
                };
            }
            for (let i: number = 0; i < /* size */(<number>source.polylines.length); i++) {
                {
                    const polylineLevel: Level = /* get */source.polylines[i].getLevel();
                    if (polylineLevel != null) {
                    /* get */destination.polylines[i].setLevel(/* get */destination.levels[source.levels.indexOf(polylineLevel)]);
                    }
                };
            }
            for (let i: number = 0; i < /* size */(<number>source.labels.length); i++) {
                {
                    const labelLevel: Level = /* get */source.labels[i].getLevel();
                    if (labelLevel != null) {
                    /* get */destination.labels[i].setLevel(/* get */destination.levels[source.levels.indexOf(labelLevel)]);
                    }
                };
            }
            for (let i: number = 0; i < /* size */(<number>source.walls.length); i++) {
                {
                    const wallLevel: Level = /* get */source.walls[i].getLevel();
                    if (wallLevel != null) {
                    /* get */destination.walls[i].setLevel(/* get */destination.levels[source.levels.indexOf(wallLevel)]);
                    }
                };
            }
            if (source.selectedLevel != null) {
                destination.selectedLevel = /* get */destination.levels[source.levels.indexOf(source.selectedLevel)];
            }
        }
        if (source.print != null && source.print.getPrintedLevels() != null) {
            const printedLevels: Array<Level> = <any>(source.print.getPrintedLevels().slice(0));
            for (let i: number = 0; i < /* size */(<number>printedLevels.length); i++) {
                {
                /* set */(printedLevels[i] = /* get */destination.levels[source.levels.indexOf(/* get */printedLevels[i])]);
                };
            }
            destination.print = new HomePrint(source.print.getPaperOrientation(), source.print.getPaperWidth(), source.print.getPaperHeight(), source.print.getPaperTopMargin(), source.print.getPaperLeftMargin(), source.print.getPaperBottomMargin(), source.print.getPaperRightMargin(), source.print.isFurniturePrinted(), source.print.isPlanPrinted(), printedLevels, source.print.isView3DPrinted(), source.print.getPlanScale(), source.print.getHeaderFormat(), source.print.getFooterFormat());
        } else {
            destination.print = source.print;
        }
        destination.observerCamera = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(source.observerCamera);
        destination.topCamera = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(source.topCamera);
        if (source.camera === source.observerCamera) {
            destination.camera = destination.observerCamera;
            if (/* contains */(source.selectedItems.indexOf(<any>(source.observerCamera)) >= 0)) {
                /* add */(destination.selectedItems.push(destination.observerCamera) > 0);
            }
        } else {
            destination.camera = destination.topCamera;
        }
        destination.storedCameras = <any>([]);
        for (let index = 0; index < source.storedCameras.length; index++) {
            let camera = source.storedCameras[index];
            {
                /* add */(destination.storedCameras.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(camera)) > 0);
            }
        }
        destination.environment = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(source.environment);
        destination.compass = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(source.compass);
        destination.furnitureVisibleProperties = <any>(source.furnitureVisibleProperties.slice(0));
        destination.furnitureVisiblePropertyNames = <any>(source.furnitureVisiblePropertyNames.slice(0));
        destination.visualProperties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(source.visualProperties));
        destination.properties = <any>(((o) => { let r = {}; for (let p in o) r[p] = o[p]; return r; })(source.properties));
    }

    /**
     * Returns the list of cloned items in <code>source</code>.
     * If a cloned item is selected its clone will be selected too (ie added to
     * <code>destinationSelectedItems</code>).
     * @param {*[]} source
     * @param {*[]} sourceSelectedItems
     * @param {*[]} destinationSelectedItems
     * @return {*[]}
     * @private
     */
    static cloneSelectableItems<T extends Selectable>(source: Array<T>, sourceSelectedItems: Array<Selectable>, destinationSelectedItems: Array<Selectable>): Array<T> {
        const destination: Array<T> = <any>([]);
        for (let index = 0; index < source.length; index++) {
            let item = source[index];
            {
                const clone: T = <T><any>/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(item);
                /* add */(destination.push(clone) > 0);
                if (/* contains */(sourceSelectedItems.indexOf(<any>(item)) >= 0)) {
                    /* add */(destinationSelectedItems.push(clone) > 0);
                } else if (item != null && item instanceof <any>HomeFurnitureGroup) {
                    const sourceFurnitureGroup: Array<HomePieceOfFurniture> = (<any>item).getAllFurniture();
                    let destinationFurnitureGroup: Array<HomePieceOfFurniture> = null;
                    for (let i: number = 0, n: number = /* size */(<number>sourceFurnitureGroup.length); i < n; i++) {
                        {
                            const piece: HomePieceOfFurniture = /* get */sourceFurnitureGroup[i];
                            if (/* contains */(sourceSelectedItems.indexOf(<any>(piece)) >= 0)) {
                                if (destinationFurnitureGroup == null) {
                                    destinationFurnitureGroup = (<any>clone).getAllFurniture();
                                }
                            /* add */(destinationSelectedItems.push(/* get */destinationFurnitureGroup[i]) > 0);
                            }
                        };
                    }
                }
            }
        }
        return destination;
    }

    /**
     * Returns a deep copy of home selectable <code>items</code>.
     * Duplicated items are at the same index as their original and use different ids.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items to duplicate
     * @return {*[]}
     */
    public static duplicate(items: Array<any>): Array<Selectable> {
        const list: Array<Selectable> = <any>([]);
        const duplicatedWalls: Array<Wall> = Wall.duplicate(Home.getWallsSubList(items));
        let wallIndex: number = 0;
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (item != null && item instanceof <any>Wall) {
                    /* add */(list.push(/* get */duplicatedWalls[wallIndex++]) > 0);
                } else if (item != null && item instanceof <any>HomeObject) {
                    /* add */(list.push(<Selectable><any>(<HomeObject><any>item).duplicate()) > 0);
                } else {
                    /* add */(list.push(/* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(item)) > 0);
                }
            }
        }
        return list;
    }

    /**
     * Returns a sub list of <code>items</code> that contains only home furniture.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {HomePieceOfFurniture[]}
     */
    public static getFurnitureSubList(items: Array<any>): Array<HomePieceOfFurniture> {
        return Home.getSubList<any>(items, HomePieceOfFurniture);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only walls.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {Wall[]}
     */
    public static getWallsSubList(items: Array<any>): Array<Wall> {
        return Home.getSubList<any>(items, Wall);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only rooms.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {Room[]}
     */
    public static getRoomsSubList(items: Array<any>): Array<Room> {
        return Home.getSubList<any>(items, Room);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only labels.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {Polyline[]}
     */
    public static getPolylinesSubList(items: Array<any>): Array<Polyline> {
        return Home.getSubList<any>(items, Polyline);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only dimension lines.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {DimensionLine[]}
     */
    public static getDimensionLinesSubList(items: Array<any>): Array<DimensionLine> {
        return Home.getSubList<any>(items, DimensionLine);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only labels.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items  the items among which the search is done
     * @return {Label[]}
     */
    public static getLabelsSubList(items: Array<any>): Array<Label> {
        return Home.getSubList<any>(items, Label);
    }

    /**
     * Returns a sub list of <code>items</code> that contains only instances of <code>subListClass</code>.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items         the items among which the search is done
     * @param {Object} subListClass  the class of the searched items
     * @return {*[]}
     */
    public static getSubList<T>(items: Array<any>, subListClass: any): Array<T> {
        const subList: Array<T> = <any>([]);
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (/* isInstance */((c: any, o: any) => { if (typeof c === 'string') return (o.constructor && o.constructor["__interfaces"] && o.constructor["__interfaces"].indexOf(c) >= 0) || (o["__interfaces"] && o["__interfaces"].indexOf(c) >= 0); else if (typeof c === 'function') return (o instanceof c) || (o.constructor && o.constructor === c); })(subListClass, item)) {
                    /* add */(subList.push(<T><any>item) > 0);
                }
            }
        }
        return subList;
    }
}
Home["__class"] = "com.eteks.sweethome3d.model.Home";


export namespace Home {

    export class Home$0 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if ((/* name */"ELEVATION" === ev.getPropertyName()) || (/* name */"ELEVATION_INDEX" === ev.getPropertyName())) {
                this.__parent.levels = <any>(this.__parent.levels.slice(0));
                /* sort */((l, c) => { if ((<any>c).compare) l.sort((e1, e2) => (<any>c).compare(e1, e2)); else l.sort(<any>c); })(this.__parent.levels, Home.LEVEL_ELEVATION_COMPARATOR_$LI$());
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}
Home['__transients'] = ['furnitureChangeSupport', 'selectedItems', 'selectionListeners', 'allLevelsSelection', 'levelsChangeSupport', 'wallsChangeSupport', 'roomsChangeSupport', 'polylinesChangeSupport', 'dimensionLinesChangeSupport', 'labelsChangeSupport', 'modified', 'recovered', 'repaired', 'propertyChangeSupport', 'furnitureAdditionalProperties'];

/**
 * Creates a camera at given location and angle.
 * @param {string} id
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {number} yaw
 * @param {number} pitch
 * @param {number} fieldOfView
 * @class
 * @extends Camera
 * @author Emmanuel Puybaret
 */
export class ObserverCamera extends Camera implements Selectable {
    /*private*/ fixedSize: boolean;

    /*private*/ planScale: number;

    /*private*/ shapeCache: java.awt.Shape;

    /*private*/ rectangleShapeCache: java.awt.Shape;

    public constructor(id?: any, x?: any, y?: any, z?: any, yaw?: any, pitch?: any, fieldOfView?: any) {
        if (((typeof id === 'string') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && ((typeof fieldOfView === 'number') || fieldOfView === null)) {
            let __args = arguments;
            super(id, x, y, z, yaw, pitch, fieldOfView);
            if (this.fixedSize === undefined) { this.fixedSize = false; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.rectangleShapeCache === undefined) { this.rectangleShapeCache = null; }
            this.planScale = 1;
        } else if (((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && ((typeof yaw === 'number') || yaw === null) && ((typeof pitch === 'number') || pitch === null) && fieldOfView === undefined) {
            let __args = arguments;
            let x: any = __args[0];
            let y: any = __args[1];
            let z: any = __args[2];
            let yaw: any = __args[3];
            let pitch: any = __args[4];
            let fieldOfView: any = __args[5];
            {
                let __args = arguments;
                let id: any = HomeObject.createId("observerCamera");
                super(id, x, y, z, yaw, pitch, fieldOfView);
                if (this.fixedSize === undefined) { this.fixedSize = false; }
                if (this.shapeCache === undefined) { this.shapeCache = null; }
                if (this.rectangleShapeCache === undefined) { this.rectangleShapeCache = null; }
                this.planScale = 1;
            }
            if (this.fixedSize === undefined) { this.fixedSize = false; }
            if (this.shapeCache === undefined) { this.shapeCache = null; }
            if (this.rectangleShapeCache === undefined) { this.rectangleShapeCache = null; }
            this.planScale = 1;
        } else throw new Error('invalid overload');
    }

    /**
     * Sets whether camera size should depends on its elevation and will notify listeners
     * bound to size properties of the size change.
     * @param {boolean} fixedSize
     */
    public setFixedSize(fixedSize: boolean) {
        if (this.fixedSize !== fixedSize) {
            const oldWidth: number = this.getWidth();
            const oldDepth: number = this.getDepth();
            const oldHeight: number = this.getHeight();
            this.fixedSize = fixedSize;
            this.shapeCache = null;
            this.rectangleShapeCache = null;
            this.firePropertyChange(/* name */"WIDTH", oldWidth, this.getWidth());
            this.firePropertyChange(/* name */"DEPTH", oldDepth, this.getDepth());
            this.firePropertyChange(/* name */"HEIGHT", oldHeight, this.getHeight());
        }
    }

    /**
     * Returns <code>true</code> if the camera size doesn't change according to its elevation.
     * @return {boolean}
     */
    public isFixedSize(): boolean {
        return this.fixedSize;
    }

    /**
     * Sets the scale used to paint this camera and will notify listeners
     * bound to size properties of the size change.
     * @param {number} scale
     */
    public setPlanScale(scale: number) {
        if (this.planScale !== scale) {
            const oldWidth: number = this.getWidth();
            const oldDepth: number = this.getDepth();
            const oldHeight: number = this.getHeight();
            this.planScale = scale;
            this.shapeCache = null;
            this.rectangleShapeCache = null;
            this.firePropertyChange(/* name */"WIDTH", oldWidth, this.getWidth());
            this.firePropertyChange(/* name */"DEPTH", oldDepth, this.getDepth());
            this.firePropertyChange(/* name */"HEIGHT", oldHeight, this.getHeight());
        }
    }

    /**
     * Returns the scale used to paint this camera in the plan.
     * @return {number}
     */
    public getPlanScale(): number {
        return this.planScale;
    }

    /**
     * Sets the yaw angle in radians of this camera.
     * @param {number} yaw
     */
    public setYaw(yaw: number) {
        super.setYaw(yaw);
        this.shapeCache = null;
        this.rectangleShapeCache = null;
    }

    /**
     * Sets the abscissa of this camera.
     * @param {number} x
     */
    public setX(x: number) {
        super.setX(x);
        this.shapeCache = null;
        this.rectangleShapeCache = null;
    }

    /**
     * Sets the ordinate of this camera.
     * @param {number} y
     */
    public setY(y: number) {
        super.setY(y);
        this.shapeCache = null;
        this.rectangleShapeCache = null;
    }

    /**
     * Sets the elevation of this camera.
     * @param {number} z
     */
    public setZ(z: number) {
        const oldWidth: number = this.getWidth();
        const oldDepth: number = this.getDepth();
        const oldHeight: number = this.getHeight();
        super.setZ(z);
        this.shapeCache = null;
        this.rectangleShapeCache = null;
        this.firePropertyChange(/* name */"WIDTH", oldWidth, this.getWidth());
        this.firePropertyChange(/* name */"DEPTH", oldDepth, this.getDepth());
        this.firePropertyChange(/* name */"HEIGHT", oldHeight, this.getHeight());
    }

    /**
     * Returns the width of this observer camera according to
     * human proportions with an eyes elevation at z.
     * @return {number}
     */
    public getWidth(): number {
        if (this.fixedSize || this.planScale > 1) {
            return 46.6 * this.planScale;
        } else {
            const width: number = this.getZ() * 4 / 14;
            return Math.min(Math.max(width, 20), 62.5) * this.planScale;
        }
    }

    /**
     * Returns the depth of this observer camera according to
     * human proportions with an eyes elevation at z.
     * @return {number}
     */
    public getDepth(): number {
        if (this.fixedSize || this.planScale > 1) {
            return 18.6 * this.planScale;
        } else {
            const depth: number = this.getZ() * 8 / 70;
            return Math.min(Math.max(depth, 8), 25) * this.planScale;
        }
    }

    /**
     * Returns the height of this observer camera according to
     * human proportions with an eyes elevation at z.
     * @return {number}
     */
    public getHeight(): number {
        if (this.fixedSize || this.planScale > 1) {
            return 175.0 * this.planScale;
        } else {
            return this.getZ() * 15 / 14 * this.planScale;
        }
    }

    /**
     * Returns the points of each corner of the rectangle surrounding this camera.
     * @return {float[][]} an array of the 4 (x,y) coordinates of the camera corners.
     */
    public getPoints(): number[][] {
        const cameraPoints: number[][] = <any>(function (dims) { let allocate = function (dims) { if (dims.length === 0) { return 0; } else { let array = []; for (let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; } }; return allocate(dims); })([4, 2]);
        const it: java.awt.geom.PathIterator = this.getRectangleShape().getPathIterator(null);
        for (let i: number = 0; i < cameraPoints.length; i++) {
            {
                it.currentSegment(cameraPoints[i]);
                it.next();
            };
        }
        return cameraPoints;
    }

    /**
     * Returns <code>true</code> if this camera intersects
     * with the horizontal rectangle which opposite corners are at points
     * (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {boolean}
     */
    public intersectsRectangle(x0: number, y0: number, x1: number, y1: number): boolean {
        const rectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x0, y0, 0, 0);
        rectangle.add(x1, y1);
        return this.getShape().intersects(rectangle);
    }

    /**
     * Returns <code>true</code> if this camera contains
     * the point at (<code>x</code>, <code>y</code>)
     * with a given <code>margin</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     */
    public containsPoint(x: number, y: number, margin: number): boolean {
        if (margin === 0) {
            return this.getShape().contains(x, y);
        } else {
            return this.getShape().intersects(x - margin, y - margin, 2 * margin, 2 * margin);
        }
    }

    /**
     * Returns the ellipse shape matching this camera.
     * @return {Object}
     * @private
     */
    getShape(): java.awt.Shape {
        if (this.shapeCache == null) {
            if (this.planScale <= 1) {
                const cameraEllipse: java.awt.geom.Ellipse2D = new java.awt.geom.Ellipse2D.Float(this.getX() - this.getWidth() / 2, this.getY() - this.getDepth() / 2, this.getWidth(), this.getDepth());
                const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(this.getYaw(), this.getX(), this.getY());
                const it: java.awt.geom.PathIterator = cameraEllipse.getPathIterator(rotation);
                const pieceShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
                pieceShape.append(it, false);
                this.shapeCache = pieceShape;
            } else {
                this.shapeCache = this.getRectangleShape();
            }
        }
        return this.shapeCache;
    }

    /**
     * Returns the rectangle shape matching this camera.
     * @return {Object}
     * @private
     */
    getRectangleShape(): java.awt.Shape {
        if (this.rectangleShapeCache == null) {
            const cameraRectangle: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(this.getX() - this.getWidth() / 2, this.getY() - this.getDepth() / 2, this.getWidth(), this.getDepth());
            const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(this.getYaw(), this.getX(), this.getY());
            const it: java.awt.geom.PathIterator = cameraRectangle.getPathIterator(rotation);
            const cameraRectangleShape: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            cameraRectangleShape.append(it, false);
            this.rectangleShapeCache = cameraRectangleShape;
        }
        return this.rectangleShapeCache;
    }

    /**
     * Moves this camera of (<code>dx</code>, <code>dy</code>) units.
     * @param {number} dx
     * @param {number} dy
     */
    public move(dx: number, dy: number) {
        this.setX(this.getX() + dx);
        this.setY(this.getY() + dy);
    }

    /**
     * Returns a clone of this camera.
     * @return {ObserverCamera}
     */
    public clone(): ObserverCamera {
        return <ObserverCamera>/* clone *//* clone */((o: any) => { if (super.clone != undefined) { return super.clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
    }
}
ObserverCamera["__class"] = "com.eteks.sweethome3d.model.ObserverCamera";
ObserverCamera["__interfaces"] = ["com.eteks.sweethome3d.model.Selectable"];

ObserverCamera['__transients'] = ['planScale', 'shapeCache', 'rectangleShapeCache', 'lens', 'propertyChangeSupport'];

/**
 * Creates the controller of plan view.
 * @param {Home} home        the home plan edited by this controller and its view
 * @param {UserPreferences} preferences the preferences of the application
 * @param {Object} viewFactory a factory able to create the plan view managed by this controller
 * @param {Object} contentManager a content manager used to import furniture
 * @param {javax.swing.undo.UndoableEditSupport} undoSupport undo support to post changes on plan by this controller
 * @class
 * @extends FurnitureController
 * @author Emmanuel Puybaret
 */
export class PlanController extends FurnitureController implements Controller {
    static SCALE_VISUAL_PROPERTY: string = "com.eteks.sweethome3d.SweetHome3D.PlanScale";

    static PIXEL_MARGIN: number = 4;

    static INDICATOR_PIXEL_MARGIN: number = 5;

    static WALL_ENDS_PIXEL_MARGIN: number = 2;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_PlanController_home: Home;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_PlanController_preferences: any;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory: ViewFactory;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_PlanController_contentManager: ContentManager;

    /*private*/ __com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport: javax.swing.undo.UndoableEditSupport;

    /*private*/ propertyChangeSupport: PropertyChangeSupport;

    /*private*/ planView: PlanView;

    /*private*/ selectionListener: SelectionListener;

    /*private*/ wallChangeListener: PropertyChangeListener;

    /*private*/ furnitureSizeChangeListener: PropertyChangeListener;

    /*private*/ selectionState: PlanController.ControllerState;

    /*private*/ rectangleSelectionState: PlanController.ControllerState;

    /*private*/ selectionMoveState: PlanController.ControllerState;

    /*private*/ panningState: PlanController.ControllerState;

    /*private*/ dragAndDropState: PlanController.ControllerState;

    /*private*/ wallCreationState: PlanController.ControllerState;

    /*private*/ wallDrawingState: PlanController.ControllerState;

    /*private*/ wallResizeState: PlanController.ControllerState;

    /*private*/ wallArcExtentState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureRotationState: PlanController.ControllerState;

    /*private*/ pieceOfFurniturePitchRotationState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureRollRotationState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureElevationState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureHeightState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureResizeState: PlanController.ControllerState;

    /*private*/ lightPowerModificationState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureNameOffsetState: PlanController.ControllerState;

    /*private*/ pieceOfFurnitureNameRotationState: PlanController.ControllerState;

    /*private*/ cameraYawRotationState: PlanController.ControllerState;

    /*private*/ cameraPitchRotationState: PlanController.ControllerState;

    /*private*/ cameraElevationState: PlanController.ControllerState;

    /*private*/ dimensionLineCreationState: PlanController.ControllerState;

    /*private*/ dimensionLineDrawingState: PlanController.ControllerState;

    /*private*/ dimensionLineResizeState: PlanController.ControllerState;

    /*private*/ dimensionLineOffsetState: PlanController.ControllerState;

    /*private*/ dimensionLinePitchRotationState: PlanController.ControllerState;

    /*private*/ dimensionLineHeightState: PlanController.ControllerState;

    /*private*/ dimensionLineElevationState: PlanController.ControllerState;

    /*private*/ roomCreationState: PlanController.ControllerState;

    /*private*/ roomDrawingState: PlanController.ControllerState;

    /*private*/ roomResizeState: PlanController.ControllerState;

    /*private*/ roomAreaOffsetState: PlanController.ControllerState;

    /*private*/ roomAreaRotationState: PlanController.ControllerState;

    /*private*/ roomNameOffsetState: PlanController.ControllerState;

    /*private*/ roomNameRotationState: PlanController.ControllerState;

    /*private*/ polylineCreationState: PlanController.ControllerState;

    /*private*/ polylineDrawingState: PlanController.ControllerState;

    /*private*/ polylineResizeState: PlanController.ControllerState;

    /*private*/ labelCreationState: PlanController.ControllerState;

    /*private*/ labelRotationState: PlanController.ControllerState;

    /*private*/ labelElevationState: PlanController.ControllerState;

    /*private*/ compassRotationState: PlanController.ControllerState;

    /*private*/ compassResizeState: PlanController.ControllerState;

    /*private*/ state: PlanController.ControllerState;

    /*private*/ previousState: PlanController.ControllerState;

    /*private*/ xLastMousePress: number;

    /*private*/ yLastMousePress: number;

    /*private*/ shiftDownLastMousePress: boolean;

    /*private*/ alignmentActivatedLastMousePress: boolean;

    /*private*/ duplicationActivatedLastMousePress: boolean;

    /*private*/ magnetismToggledLastMousePress: boolean;

    /*private*/ pointerTypeLastMousePress: View.PointerType;

    /*private*/ xLastMouseMove: number;

    /*private*/ yLastMouseMove: number;

    /*private*/ wallsAreaCache: java.awt.geom.Area;

    /*private*/ wallsIncludingBaseboardsAreaCache: java.awt.geom.Area;

    /*private*/ insideWallsAreaCache: java.awt.geom.Area;

    /*private*/ roomPathsCache: Array<java.awt.geom.GeneralPath>;

    /*private*/ furnitureSidesCache: any;

    /*private*/ draggedItems: Array<Selectable>;

    /*private*/ feedbackDisplayed: boolean;

    public constructor(home: Home, preferences: any, viewFactory: ViewFactory, contentManager: ContentManager, undoSupport: javax.swing.undo.UndoableEditSupport) {
        super(home, preferences, viewFactory, contentManager, undoSupport);
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_home === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PlanController_home = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager = null; }
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport === undefined) { this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport = null; }
        if (this.propertyChangeSupport === undefined) { this.propertyChangeSupport = null; }
        if (this.planView === undefined) { this.planView = null; }
        if (this.selectionListener === undefined) { this.selectionListener = null; }
        if (this.wallChangeListener === undefined) { this.wallChangeListener = null; }
        if (this.furnitureSizeChangeListener === undefined) { this.furnitureSizeChangeListener = null; }
        if (this.selectionState === undefined) { this.selectionState = null; }
        if (this.rectangleSelectionState === undefined) { this.rectangleSelectionState = null; }
        if (this.selectionMoveState === undefined) { this.selectionMoveState = null; }
        if (this.panningState === undefined) { this.panningState = null; }
        if (this.dragAndDropState === undefined) { this.dragAndDropState = null; }
        if (this.wallCreationState === undefined) { this.wallCreationState = null; }
        if (this.wallDrawingState === undefined) { this.wallDrawingState = null; }
        if (this.wallResizeState === undefined) { this.wallResizeState = null; }
        if (this.wallArcExtentState === undefined) { this.wallArcExtentState = null; }
        if (this.pieceOfFurnitureRotationState === undefined) { this.pieceOfFurnitureRotationState = null; }
        if (this.pieceOfFurniturePitchRotationState === undefined) { this.pieceOfFurniturePitchRotationState = null; }
        if (this.pieceOfFurnitureRollRotationState === undefined) { this.pieceOfFurnitureRollRotationState = null; }
        if (this.pieceOfFurnitureElevationState === undefined) { this.pieceOfFurnitureElevationState = null; }
        if (this.pieceOfFurnitureHeightState === undefined) { this.pieceOfFurnitureHeightState = null; }
        if (this.pieceOfFurnitureResizeState === undefined) { this.pieceOfFurnitureResizeState = null; }
        if (this.lightPowerModificationState === undefined) { this.lightPowerModificationState = null; }
        if (this.pieceOfFurnitureNameOffsetState === undefined) { this.pieceOfFurnitureNameOffsetState = null; }
        if (this.pieceOfFurnitureNameRotationState === undefined) { this.pieceOfFurnitureNameRotationState = null; }
        if (this.cameraYawRotationState === undefined) { this.cameraYawRotationState = null; }
        if (this.cameraPitchRotationState === undefined) { this.cameraPitchRotationState = null; }
        if (this.cameraElevationState === undefined) { this.cameraElevationState = null; }
        if (this.dimensionLineCreationState === undefined) { this.dimensionLineCreationState = null; }
        if (this.dimensionLineDrawingState === undefined) { this.dimensionLineDrawingState = null; }
        if (this.dimensionLineResizeState === undefined) { this.dimensionLineResizeState = null; }
        if (this.dimensionLineOffsetState === undefined) { this.dimensionLineOffsetState = null; }
        if (this.dimensionLinePitchRotationState === undefined) { this.dimensionLinePitchRotationState = null; }
        if (this.dimensionLineHeightState === undefined) { this.dimensionLineHeightState = null; }
        if (this.dimensionLineElevationState === undefined) { this.dimensionLineElevationState = null; }
        if (this.roomCreationState === undefined) { this.roomCreationState = null; }
        if (this.roomDrawingState === undefined) { this.roomDrawingState = null; }
        if (this.roomResizeState === undefined) { this.roomResizeState = null; }
        if (this.roomAreaOffsetState === undefined) { this.roomAreaOffsetState = null; }
        if (this.roomAreaRotationState === undefined) { this.roomAreaRotationState = null; }
        if (this.roomNameOffsetState === undefined) { this.roomNameOffsetState = null; }
        if (this.roomNameRotationState === undefined) { this.roomNameRotationState = null; }
        if (this.polylineCreationState === undefined) { this.polylineCreationState = null; }
        if (this.polylineDrawingState === undefined) { this.polylineDrawingState = null; }
        if (this.polylineResizeState === undefined) { this.polylineResizeState = null; }
        if (this.labelCreationState === undefined) { this.labelCreationState = null; }
        if (this.labelRotationState === undefined) { this.labelRotationState = null; }
        if (this.labelElevationState === undefined) { this.labelElevationState = null; }
        if (this.compassRotationState === undefined) { this.compassRotationState = null; }
        if (this.compassResizeState === undefined) { this.compassResizeState = null; }
        if (this.state === undefined) { this.state = null; }
        if (this.previousState === undefined) { this.previousState = null; }
        if (this.xLastMousePress === undefined) { this.xLastMousePress = 0; }
        if (this.yLastMousePress === undefined) { this.yLastMousePress = 0; }
        if (this.shiftDownLastMousePress === undefined) { this.shiftDownLastMousePress = false; }
        if (this.alignmentActivatedLastMousePress === undefined) { this.alignmentActivatedLastMousePress = false; }
        if (this.duplicationActivatedLastMousePress === undefined) { this.duplicationActivatedLastMousePress = false; }
        if (this.magnetismToggledLastMousePress === undefined) { this.magnetismToggledLastMousePress = false; }
        if (this.pointerTypeLastMousePress === undefined) { this.pointerTypeLastMousePress = null; }
        if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
        if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
        if (this.wallsAreaCache === undefined) { this.wallsAreaCache = null; }
        if (this.wallsIncludingBaseboardsAreaCache === undefined) { this.wallsIncludingBaseboardsAreaCache = null; }
        if (this.insideWallsAreaCache === undefined) { this.insideWallsAreaCache = null; }
        if (this.roomPathsCache === undefined) { this.roomPathsCache = null; }
        if (this.furnitureSidesCache === undefined) { this.furnitureSidesCache = null; }
        if (this.draggedItems === undefined) { this.draggedItems = null; }
        this.feedbackDisplayed = true;
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home = home;
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences = preferences;
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory = viewFactory;
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager = contentManager;
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport = undoSupport;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        this.furnitureSidesCache = <any>({});
        this.selectionState = new PlanController.SelectionState(this);
        this.selectionMoveState = new PlanController.SelectionMoveState(this);
        this.rectangleSelectionState = new PlanController.RectangleSelectionState(this);
        this.panningState = new PlanController.PanningState(this);
        this.dragAndDropState = new PlanController.DragAndDropState(this);
        this.wallCreationState = new PlanController.WallCreationState(this);
        this.wallDrawingState = new PlanController.WallDrawingState(this);
        this.wallResizeState = new PlanController.WallResizeState(this);
        this.wallArcExtentState = new PlanController.WallArcExtentState(this);
        this.pieceOfFurnitureRotationState = new PlanController.PieceOfFurnitureRotationState(this);
        this.pieceOfFurniturePitchRotationState = new PlanController.PieceOfFurniturePitchRotationState(this);
        this.pieceOfFurnitureRollRotationState = new PlanController.PieceOfFurnitureRollRotationState(this);
        this.pieceOfFurnitureElevationState = new PlanController.PieceOfFurnitureElevationState(this);
        this.pieceOfFurnitureHeightState = new PlanController.PieceOfFurnitureHeightState(this);
        this.pieceOfFurnitureResizeState = new PlanController.PieceOfFurnitureResizeState(this);
        this.lightPowerModificationState = new PlanController.LightPowerModificationState(this);
        this.pieceOfFurnitureNameOffsetState = new PlanController.PieceOfFurnitureNameOffsetState(this);
        this.pieceOfFurnitureNameRotationState = new PlanController.PieceOfFurnitureNameRotationState(this);
        this.cameraYawRotationState = new PlanController.CameraYawRotationState(this);
        this.cameraPitchRotationState = new PlanController.CameraPitchRotationState(this);
        this.cameraElevationState = new PlanController.CameraElevationState(this);
        this.dimensionLineCreationState = new PlanController.DimensionLineCreationState(this);
        this.dimensionLineDrawingState = new PlanController.DimensionLineDrawingState(this);
        this.dimensionLineResizeState = new PlanController.DimensionLineResizeState(this);
        this.dimensionLineOffsetState = new PlanController.DimensionLineOffsetState(this);
        this.dimensionLinePitchRotationState = new PlanController.DimensionLinePitchRotationState(this);
        this.dimensionLineHeightState = new PlanController.DimensionLineHeightState(this);
        this.dimensionLineElevationState = new PlanController.DimensionLineElevationState(this);
        this.roomCreationState = new PlanController.RoomCreationState(this);
        this.roomDrawingState = new PlanController.RoomDrawingState(this);
        this.roomResizeState = new PlanController.RoomResizeState(this);
        this.roomAreaOffsetState = new PlanController.RoomAreaOffsetState(this);
        this.roomAreaRotationState = new PlanController.RoomAreaRotationState(this);
        this.roomNameOffsetState = new PlanController.RoomNameOffsetState(this);
        this.roomNameRotationState = new PlanController.RoomNameRotationState(this);
        this.polylineCreationState = new PlanController.PolylineCreationState(this);
        this.polylineDrawingState = new PlanController.PolylineDrawingState(this);
        this.polylineResizeState = new PlanController.PolylineResizeState(this);
        this.labelCreationState = new PlanController.LabelCreationState(this);
        this.labelRotationState = new PlanController.LabelRotationState(this);
        this.labelElevationState = new PlanController.LabelElevationState(this);
        this.compassRotationState = new PlanController.CompassRotationState(this);
        this.compassResizeState = new PlanController.CompassResizeState(this);
        this.setState(this.selectionState);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_addModelListeners();
        const scale: number = home.getNumericProperty(PlanController.SCALE_VISUAL_PROPERTY);
        if (scale != null) {
            this.setScale(/* floatValue */scale);
        }
    }

    /**
     * Returns the view associated with this controller.
     * @return {Object}
     */
    public getView(): PlanView {
        if (this.planView == null) {
            this.planView = this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory.createPlanView(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this);
        }
        return this.planView;
    }

    /**
     * Changes current state of controller.
     * @param {PlanController.ControllerState} state
     */
    setState(state: PlanController.ControllerState) {
        let oldMode: PlanController.Mode = null;
        let oldModificationState: boolean = false;
        let oldBasePlanModificationState: boolean = false;
        if (this.state != null) {
            oldMode = this.state.getMode();
            oldModificationState = this.state.isModificationState();
            oldBasePlanModificationState = this.state.isBasePlanModificationState();
            this.state.exit();
        }
        this.previousState = this.state;
        this.state = state;
        this.state.enter();
        if (oldMode !== state.getMode()) {
            this.propertyChangeSupport.firePropertyChange(/* name */"MODE", oldMode, state.getMode());
        }
        if (oldModificationState !== state.isModificationState()) {
            this.propertyChangeSupport.firePropertyChange(/* name */"MODIFICATION_STATE", oldModificationState, !oldModificationState);
        }
        if (oldBasePlanModificationState !== state.isBasePlanModificationState()) {
            this.propertyChangeSupport.firePropertyChange(/* name */"BASE_PLAN_MODIFICATION_STATE", oldBasePlanModificationState, !oldBasePlanModificationState);
        }
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public addPropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.addPropertyChangeListener(/* name */property, listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     * @param {string} property
     * @param {PropertyChangeListener} listener
     */
    public removePropertyChangeListener(property: any, listener: PropertyChangeListener) {
        this.propertyChangeSupport.removePropertyChangeListener(/* name */property, listener);
    }

    /**
     * Returns the active mode of this controller.
     * @return {PlanController.Mode}
     */
    public getMode(): PlanController.Mode {
        return this.state.getMode();
    }

    /**
     * Sets the active mode of this controller and fires a <code>PropertyChangeEvent</code>.
     * @param {PlanController.Mode} mode
     */
    public setMode(mode: PlanController.Mode) {
        const oldMode: PlanController.Mode = this.state.getMode();
        if (mode !== oldMode) {
            this.state.setMode(mode);
            this.propertyChangeSupport.firePropertyChange(/* name */"MODE", oldMode, mode);
        }
    }

    /**
     * Returns <code>true</code> if the interactions in the current mode may modify
     * the state of a home.
     * @return {boolean}
     */
    public isModificationState(): boolean {
        return this.state.isModificationState();
    }

    /**
     * Returns <code>true</code> if the interactions in the current mode may modify
     * the base plan of a home.
     * @return {boolean}
     */
    public isBasePlanModificationState(): boolean {
        return this.state.isBasePlanModificationState();
    }

    /**
     * Deletes the selection in home.
     */
    public deleteSelection() {
        this.state.deleteSelection();
    }

    /**
     * Escapes of current action.
     */
    public escape() {
        this.state.escape();
    }

    /**
     * Moves the selection of (<code>dx</code>,<code>dy</code>) in home.
     * @param {number} dx
     * @param {number} dy
     */
    public moveSelection(dx: number, dy: number) {
        this.state.moveSelection(dx, dy);
    }

    /**
     * Toggles temporary magnetism feature of user preferences.
     * @param {boolean} magnetismToggled if <code>true</code> then magnetism feature is toggled.
     */
    public toggleMagnetism(magnetismToggled: boolean) {
        this.state.toggleMagnetism(magnetismToggled);
    }

    /**
     * Activates or deactivates alignment feature.
     * @param {boolean} alignmentActivated if <code>true</code> then alignment is active.
     */
    public setAlignmentActivated(alignmentActivated: boolean) {
        this.state.setAlignmentActivated(alignmentActivated);
    }

    /**
     * Activates or deactivates duplication feature.
     * @param {boolean} duplicationActivated if <code>true</code> then duplication is active.
     */
    public setDuplicationActivated(duplicationActivated: boolean) {
        this.state.setDuplicationActivated(duplicationActivated);
    }

    /**
     * Activates or deactivates edition.
     * @param {boolean} editionActivated if <code>true</code> then edition is active
     */
    public setEditionActivated(editionActivated: boolean) {
        this.state.setEditionActivated(editionActivated);
    }

    /**
     * Updates an editable property with the entered <code>value</code>.
     * @param {string} editableProperty
     * @param {Object} value
     */
    public updateEditableProperty(editableProperty: any, value: any) {
        this.state.updateEditableProperty(editableProperty, value);
    }

    public pressMouse$float$float$int$boolean$boolean(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
        this.pressMouse$float$float$int$boolean$boolean$boolean$boolean(x, y, clickCount, shiftDown, shiftDown, duplicationActivated, shiftDown);
    }

    public pressMouse$float$float$int$boolean$boolean$boolean$boolean(x: number, y: number, clickCount: number, shiftDown: boolean, alignmentActivated: boolean, duplicationActivated: boolean, magnetismToggled: boolean) {
        this.pressMouse$float$float$int$boolean$boolean$boolean$boolean$com_eteks_sweethome3d_viewcontroller_View_PointerType(x, y, clickCount, shiftDown, alignmentActivated, duplicationActivated, magnetismToggled, null);
    }

    public pressMouse$float$float$int$boolean$boolean$boolean$boolean$com_eteks_sweethome3d_viewcontroller_View_PointerType(x: number, y: number, clickCount: number, shiftDown: boolean, alignmentActivated: boolean, duplicationActivated: boolean, magnetismToggled: boolean, pointerType: View.PointerType) {
        this.xLastMousePress = x;
        this.yLastMousePress = y;
        this.xLastMouseMove = x;
        this.yLastMouseMove = y;
        this.shiftDownLastMousePress = shiftDown;
        this.alignmentActivatedLastMousePress = alignmentActivated;
        this.duplicationActivatedLastMousePress = duplicationActivated;
        this.magnetismToggledLastMousePress = magnetismToggled;
        this.pointerTypeLastMousePress = pointerType;
        this.state.pressMouse(x, y, clickCount, shiftDown, duplicationActivated);
    }

    /**
     * Processes a mouse button pressed event.
     * @param {number} x
     * @param {number} y
     * @param {number} clickCount
     * @param {boolean} shiftDown
     * @param {boolean} alignmentActivated
     * @param {boolean} duplicationActivated
     * @param {boolean} magnetismToggled
     * @param {View.PointerType} pointerType
     */
    public pressMouse(x?: any, y?: any, clickCount?: any, shiftDown?: any, alignmentActivated?: any, duplicationActivated?: any, magnetismToggled?: any, pointerType?: any) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof shiftDown === 'boolean') || shiftDown === null) && ((typeof alignmentActivated === 'boolean') || alignmentActivated === null) && ((typeof duplicationActivated === 'boolean') || duplicationActivated === null) && ((typeof magnetismToggled === 'boolean') || magnetismToggled === null) && ((typeof pointerType === 'number') || pointerType === null)) {
            return <any>this.pressMouse$float$float$int$boolean$boolean$boolean$boolean$com_eteks_sweethome3d_viewcontroller_View_PointerType(x, y, clickCount, shiftDown, alignmentActivated, duplicationActivated, magnetismToggled, pointerType);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof shiftDown === 'boolean') || shiftDown === null) && ((typeof alignmentActivated === 'boolean') || alignmentActivated === null) && ((typeof duplicationActivated === 'boolean') || duplicationActivated === null) && ((typeof magnetismToggled === 'boolean') || magnetismToggled === null) && pointerType === undefined) {
            return <any>this.pressMouse$float$float$int$boolean$boolean$boolean$boolean(x, y, clickCount, shiftDown, alignmentActivated, duplicationActivated, magnetismToggled);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof shiftDown === 'boolean') || shiftDown === null) && ((typeof alignmentActivated === 'boolean') || alignmentActivated === null) && duplicationActivated === undefined && magnetismToggled === undefined && pointerType === undefined) {
            return <any>this.pressMouse$float$float$int$boolean$boolean(x, y, clickCount, shiftDown, alignmentActivated);
        } else throw new Error('invalid overload');
    }

    /**
     * Processes a mouse button released event.
     * @param {number} x
     * @param {number} y
     */
    public releaseMouse(x: number, y: number) {
        this.state.releaseMouse(x, y);
    }

    /**
     * Processes a mouse button moved event.
     * @param {number} x
     * @param {number} y
     */
    public moveMouse(x: number, y: number) {
        this.xLastMouseMove = x;
        this.yLastMouseMove = y;
        this.state.moveMouse(x, y);
    }

    /**
     * Processes a zoom event.
     * @param {number} factor
     */
    public zoom(factor: number) {
        this.state.zoom(factor);
    }

    /**
     * Sets whether requested feedback should be displayed in the view or not.
     * @param {boolean} displayed
     */
    public setFeedbackDisplayed(displayed: boolean) {
        this.feedbackDisplayed = displayed;
        this.getView().deleteFeedback();
    }

    /**
     * Returns <code>true</code> if this view accepts to display requested feedback.
     * @return {boolean}
     */
    public isFeedbackDisplayed(): boolean {
        return this.feedbackDisplayed;
    }

    /**
     * Returns the selection state.
     * @return {PlanController.ControllerState}
     */
    getSelectionState(): PlanController.ControllerState {
        return this.selectionState;
    }

    /**
     * Returns the selection move state.
     * @return {PlanController.ControllerState}
     */
    getSelectionMoveState(): PlanController.ControllerState {
        return this.selectionMoveState;
    }

    /**
     * Returns the rectangle selection state.
     * @return {PlanController.ControllerState}
     */
    getRectangleSelectionState(): PlanController.ControllerState {
        return this.rectangleSelectionState;
    }

    /**
     * Returns the panning state.
     * @return {PlanController.ControllerState}
     */
    getPanningState(): PlanController.ControllerState {
        return this.panningState;
    }

    /**
     * Returns the drag and drop state.
     * @return {PlanController.ControllerState}
     */
    getDragAndDropState(): PlanController.ControllerState {
        return this.dragAndDropState;
    }

    /**
     * Returns the wall creation state.
     * @return {PlanController.ControllerState}
     */
    getWallCreationState(): PlanController.ControllerState {
        return this.wallCreationState;
    }

    /**
     * Returns the wall drawing state.
     * @return {PlanController.ControllerState}
     */
    getWallDrawingState(): PlanController.ControllerState {
        return this.wallDrawingState;
    }

    /**
     * Returns the wall resize state.
     * @return {PlanController.ControllerState}
     */
    getWallResizeState(): PlanController.ControllerState {
        return this.wallResizeState;
    }

    /**
     * Returns the wall arc extent state.
     * @return {PlanController.ControllerState}
     */
    getWallArcExtentState(): PlanController.ControllerState {
        return this.wallArcExtentState;
    }

    /**
     * Returns the piece rotation state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureRotationState(): PlanController.ControllerState {
        return this.pieceOfFurnitureRotationState;
    }

    /**
     * Returns the piece pitch rotation state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurniturePitchRotationState(): PlanController.ControllerState {
        return this.pieceOfFurniturePitchRotationState;
    }

    /**
     * Returns the piece roll rotation state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureRollRotationState(): PlanController.ControllerState {
        return this.pieceOfFurnitureRollRotationState;
    }

    /**
     * Returns the piece elevation state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureElevationState(): PlanController.ControllerState {
        return this.pieceOfFurnitureElevationState;
    }

    /**
     * Returns the piece height state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureHeightState(): PlanController.ControllerState {
        return this.pieceOfFurnitureHeightState;
    }

    /**
     * Returns the piece resize state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureResizeState(): PlanController.ControllerState {
        return this.pieceOfFurnitureResizeState;
    }

    /**
     * Returns the light power modification state.
     * @return {PlanController.ControllerState}
     */
    getLightPowerModificationState(): PlanController.ControllerState {
        return this.lightPowerModificationState;
    }

    /**
     * Returns the piece name offset state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureNameOffsetState(): PlanController.ControllerState {
        return this.pieceOfFurnitureNameOffsetState;
    }

    /**
     * Returns the piece name rotation state.
     * @return {PlanController.ControllerState}
     */
    getPieceOfFurnitureNameRotationState(): PlanController.ControllerState {
        return this.pieceOfFurnitureNameRotationState;
    }

    /**
     * Returns the camera yaw rotation state.
     * @return {PlanController.ControllerState}
     */
    getCameraYawRotationState(): PlanController.ControllerState {
        return this.cameraYawRotationState;
    }

    /**
     * Returns the camera pitch rotation state.
     * @return {PlanController.ControllerState}
     */
    getCameraPitchRotationState(): PlanController.ControllerState {
        return this.cameraPitchRotationState;
    }

    /**
     * Returns the camera elevation state.
     * @return {PlanController.ControllerState}
     */
    getCameraElevationState(): PlanController.ControllerState {
        return this.cameraElevationState;
    }

    /**
     * Returns the dimension line creation state.
     * @return {PlanController.ControllerState}
     */
    getDimensionLineCreationState(): PlanController.ControllerState {
        return this.dimensionLineCreationState;
    }

    /**
     * Returns the dimension line drawing state.
     * @return {PlanController.ControllerState}
     */
    getDimensionLineDrawingState(): PlanController.ControllerState {
        return this.dimensionLineDrawingState;
    }

    /**
     * Returns the dimension line resize state.
     * @return {PlanController.ControllerState}
     */
    getDimensionLineResizeState(): PlanController.ControllerState {
        return this.dimensionLineResizeState;
    }

    /**
     * Returns the dimension line offset state.
     * @return {PlanController.ControllerState}
     */
    getDimensionLineOffsetState(): PlanController.ControllerState {
        return this.dimensionLineOffsetState;
    }

    /**
     * Returns the dimension line rotation state.
     * @return {PlanController.ControllerState}
     */
    public getDimensionLinePitchRotationState(): PlanController.ControllerState {
        return this.dimensionLinePitchRotationState;
    }

    /**
     * Returns the dimension line height state.
     * @return {PlanController.ControllerState}
     * @private
     */
    getDimensionLineHeightState(): PlanController.ControllerState {
        return this.dimensionLineHeightState;
    }

    /**
     * Returns the dimension line elevation state.
     * @return {PlanController.ControllerState}
     */
    public getDimensionLineElevationState(): PlanController.ControllerState {
        return this.dimensionLineElevationState;
    }

    /**
     * Returns the room creation state.
     * @return {PlanController.ControllerState}
     */
    getRoomCreationState(): PlanController.ControllerState {
        return this.roomCreationState;
    }

    /**
     * Returns the room drawing state.
     * @return {PlanController.ControllerState}
     */
    getRoomDrawingState(): PlanController.ControllerState {
        return this.roomDrawingState;
    }

    /**
     * Returns the room resize state.
     * @return {PlanController.ControllerState}
     */
    getRoomResizeState(): PlanController.ControllerState {
        return this.roomResizeState;
    }

    /**
     * Returns the room area offset state.
     * @return {PlanController.ControllerState}
     */
    getRoomAreaOffsetState(): PlanController.ControllerState {
        return this.roomAreaOffsetState;
    }

    /**
     * Returns the room area rotation state.
     * @return {PlanController.ControllerState}
     */
    getRoomAreaRotationState(): PlanController.ControllerState {
        return this.roomAreaRotationState;
    }

    /**
     * Returns the room name offset state.
     * @return {PlanController.ControllerState}
     */
    getRoomNameOffsetState(): PlanController.ControllerState {
        return this.roomNameOffsetState;
    }

    /**
     * Returns the room name rotation state.
     * @return {PlanController.ControllerState}
     */
    getRoomNameRotationState(): PlanController.ControllerState {
        return this.roomNameRotationState;
    }

    /**
     * Returns the polyline creation state.
     * @return {PlanController.ControllerState}
     */
    getPolylineCreationState(): PlanController.ControllerState {
        return this.polylineCreationState;
    }

    /**
     * Returns the polyline drawing state.
     * @return {PlanController.ControllerState}
     */
    getPolylineDrawingState(): PlanController.ControllerState {
        return this.polylineDrawingState;
    }

    /**
     * Returns the polyline resize state.
     * @return {PlanController.ControllerState}
     */
    getPolylineResizeState(): PlanController.ControllerState {
        return this.polylineResizeState;
    }

    /**
     * Returns the label creation state.
     * @return {PlanController.ControllerState}
     */
    getLabelCreationState(): PlanController.ControllerState {
        return this.labelCreationState;
    }

    /**
     * Returns the label rotation state.
     * @return {PlanController.ControllerState}
     */
    getLabelRotationState(): PlanController.ControllerState {
        return this.labelRotationState;
    }

    /**
     * Returns the label elevation state.
     * @return {PlanController.ControllerState}
     */
    getLabelElevationState(): PlanController.ControllerState {
        return this.labelElevationState;
    }

    /**
     * Returns the compass rotation state.
     * @return {PlanController.ControllerState}
     */
    getCompassRotationState(): PlanController.ControllerState {
        return this.compassRotationState;
    }

    /**
     * Returns the compass resize state.
     * @return {PlanController.ControllerState}
     */
    getCompassResizeState(): PlanController.ControllerState {
        return this.compassResizeState;
    }

    /**
     * Returns the abscissa of mouse position at last mouse press.
     * @return {number}
     */
    getXLastMousePress(): number {
        return this.xLastMousePress;
    }

    /**
     * Returns the ordinate of mouse position at last mouse press.
     * @return {number}
     */
    getYLastMousePress(): number {
        return this.yLastMousePress;
    }

    /**
     * Returns <code>true</code> if shift key was down at last mouse press.
     * @return {boolean}
     */
    wasShiftDownLastMousePress(): boolean {
        return this.shiftDownLastMousePress;
    }

    /**
     * Returns <code>true</code> if magnetism was toggled at last mouse press.
     * @return {boolean}
     */
    wasMagnetismToggledLastMousePress(): boolean {
        return this.magnetismToggledLastMousePress;
    }

    /**
     * Returns <code>true</code> if alignment was activated at last mouse press.
     * @return {boolean}
     */
    wasAlignmentActivatedLastMousePress(): boolean {
        return this.alignmentActivatedLastMousePress;
    }

    /**
     * Returns <code>true</code> if duplication was activated at last mouse press.
     * @return {boolean}
     */
    wasDuplicationActivatedLastMousePress(): boolean {
        return this.duplicationActivatedLastMousePress;
    }

    /**
     * Returns the pointer type used at the last mouse press.
     * @return {View.PointerType}
     */
    getPointerTypeLastMousePress(): View.PointerType {
        return this.pointerTypeLastMousePress;
    }

    /**
     * Returns the abscissa of mouse position at last mouse move.
     * @return {number}
     */
    getXLastMouseMove(): number {
        return this.xLastMouseMove;
    }

    /**
     * Returns the ordinate of mouse position at last mouse move.
     * @return {number}
     */
    getYLastMouseMove(): number {
        return this.yLastMouseMove;
    }

    /**
     * Controls the modification of the item selected in plan.
     */
    public modifySelectedItem() {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1) {
            const item: Selectable = /* get */selectedItems[0];
            if (item != null && item instanceof <any>HomePieceOfFurniture) {
                this.modifySelectedFurniture();
            } else if (item != null && item instanceof <any>Wall) {
                this.modifySelectedWalls();
            } else if (item != null && item instanceof <any>Room) {
                this.modifySelectedRooms();
            } else if (item != null && item instanceof <any>Polyline) {
                this.modifySelectedPolylines();
            } else if (item != null && item instanceof <any>DimensionLine) {
                this.modifySelectedDimensionLines();
            } else if (item != null && item instanceof <any>Label) {
                this.modifySelectedLabels();
            } else if (item != null && item instanceof <any>Compass) {
                this.modifyCompass();
            } else if (item != null && item instanceof <any>ObserverCamera) {
                this.modifyObserverCamera();
            }
        }
    }

    /**
     * Controls the modification of selected walls.
     */
    public modifySelectedWalls() {
        if (!/* isEmpty */(Home.getWallsSubList(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()).length == 0)) {
            new WallController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    /**
     * Locks home base plan.
     */
    public lockBasePlan() {
        if (!this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked()) {
            const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            const selection: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            const oldSelection: Selectable[] = /* toArray */selection.slice(0);
            const newSelection: Array<Selectable> = this.getItemsNotPartOfBasePlan(selection);
            const newSelectedItems: Selectable[] = /* toArray */newSelection.slice(0);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(true);
            this.selectItems$java_util_List$boolean(newSelection, allLevelsSelection);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LockingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, allLevelsSelection, newSelectedItems));
        }
    }

    /**
     * Returns <code>true</code> it the given <code>item</code> belongs
     * to the base plan.
     * @param {Object} item
     * @return {boolean}
     */
    isItemPartOfBasePlan(item: Selectable): boolean {
        if (item != null && item instanceof <any>HomePieceOfFurniture) {
            return this.isPieceOfFurniturePartOfBasePlan(<HomePieceOfFurniture><any>item);
        } else {
            return !(item != null && item instanceof <any>ObserverCamera);
        }
    }

    /**
     * Returns the items among the given list that are not part of the base plan.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @return {*[]}
     * @private
     */
    getItemsNotPartOfBasePlan(items: Array<any>): Array<Selectable> {
        const itemsNotPartOfBasePlan: Array<Selectable> = <any>([]);
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (!this.isItemPartOfBasePlan(item)) {
                    /* add */(itemsNotPartOfBasePlan.push(item) > 0);
                }
            }
        }
        return itemsNotPartOfBasePlan;
    }

    /**
     * Unlocks home base plan.
     */
    public unlockBasePlan() {
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked()) {
            const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            const selection: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            const selectedItems: Selectable[] = /* toArray */selection.slice(0);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(false);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(false);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.UnlockingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, selectedItems, allLevelsSelection));
        }
    }

    /**
     * Returns <code>true</code> if the given <code>item</code> may be moved
     * in the plan. Default implementation returns <code>true</code>.
     * @param {Object} item
     * @return {boolean}
     */
    isItemMovable(item: Selectable): boolean {
        if (item != null && item instanceof <any>HomePieceOfFurniture) {
            return this.isPieceOfFurnitureMovable(<HomePieceOfFurniture><any>item);
        } else {
            return true;
        }
    }

    /**
     * Returns <code>true</code> if the given <code>item</code> may be resized.
     * Default implementation returns <code>false</code> if the given <code>item</code>
     * is a non resizable piece of furniture.
     * @param {Object} item
     * @return {boolean}
     */
    isItemResizable(item: Selectable): boolean {
        if (item != null && item instanceof <any>HomePieceOfFurniture) {
            return (<HomePieceOfFurniture><any>item).isResizable();
        } else {
            return true;
        }
    }

    /**
     * Returns <code>true</code> if the given <code>item</code> may be deleted.
     * Default implementation returns <code>true</code> except if the given <code>item</code>
     * is a camera or a compass or if the given <code>item</code> isn't a
     * {@linkplain #isPieceOfFurnitureDeletable(HomePieceOfFurniture) deletable piece of furniture}.
     * @param {Object} item
     * @return {boolean}
     */
    isItemDeletable(item: Selectable): boolean {
        if (item != null && item instanceof <any>HomePieceOfFurniture) {
            return this.isPieceOfFurnitureDeletable(<HomePieceOfFurniture><any>item);
        } else {
            return !((item != null && item instanceof <any>Compass) || (item != null && item instanceof <any>Camera));
        }
    }

    /**
     * Flips horizontally selected objects.
     */
    public flipHorizontally() {
        this.flipSelectedItems(true);
    }

    /**
     * Flips vertically selected objects.
     */
    public flipVertically() {
        this.flipSelectedItems(false);
    }

    flipSelectedItems(horizontally: boolean) {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (!/* isEmpty */(selectedItems.length == 0)) {
            const flippedItems: Selectable[] = /* toArray */selectedItems.slice(0);
            const itemTextBaseOffsets: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(flippedItems.length);
            for (let i: number = 0; i < itemTextBaseOffsets.length; i++) {
                {
                    if (flippedItems[i] != null && flippedItems[i] instanceof <any>HomeFurnitureGroup) {
                        const group: HomeFurnitureGroup = <HomeFurnitureGroup><any>flippedItems[i];
                        const furniture: Array<HomePieceOfFurniture> = group.getAllFurniture();
                        itemTextBaseOffsets[i] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>furniture.length) + 1);
                        itemTextBaseOffsets[i][0] = this.getTextBaseOffset(group.getName(), group.getNameStyle(), (<any>group.constructor));
                        for (let j: number = 0; j < /* size */(<number>furniture.length); j++) {
                            {
                                const piece: HomePieceOfFurniture = /* get */furniture[j];
                                itemTextBaseOffsets[i][j + 1] = this.getTextBaseOffset(piece.getName(), piece.getNameStyle(), (<any>piece.constructor));
                            };
                        }
                    } else if (flippedItems[i] != null && flippedItems[i] instanceof <any>HomePieceOfFurniture) {
                        const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>flippedItems[i];
                        itemTextBaseOffsets[i] = [this.getTextBaseOffset(piece.getName(), piece.getNameStyle(), (<any>piece.constructor))];
                    } else if (flippedItems[i] != null && flippedItems[i] instanceof <any>Room) {
                        const room: Room = <Room><any>flippedItems[i];
                        itemTextBaseOffsets[i] = [this.getTextBaseOffset(room.getName(), room.getNameStyle(), (<any>room.constructor)), this.getTextBaseOffset(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()), room.getAreaStyle(), (<any>room.constructor))];
                    }
                };
            }
            this.doFlipItems(flippedItems, itemTextBaseOffsets, horizontally);
            this.selectAndShowItems$java_util_List$boolean(selectedItems, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.FlippingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection(), /* toArray */selectedItems.slice(0), itemTextBaseOffsets, horizontally));
        }
    }

    /**
     * Flips the <code>items</code>.
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {float[][]} itemTextBaseOffsets
     * @param {boolean} horizontalFlip
     * @private
     */
    doFlipItems(items: Selectable[], itemTextBaseOffsets: number[][], horizontalFlip: boolean) {
        let minX: number = 3.4028235E38;
        let minY: number = 3.4028235E38;
        let maxX: number = -3.4028235E38;
        let maxY: number = -3.4028235E38;
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (!(item != null && item instanceof <any>ObserverCamera)) {
                    {
                        let array = item.getPoints();
                        for (let index1 = 0; index1 < array.length; index1++) {
                            let point = array[index1];
                            {
                                minX = Math.min(minX, point[0]);
                                minY = Math.min(minY, point[1]);
                                maxX = Math.max(maxX, point[0]);
                                maxY = Math.max(maxY, point[1]);
                            }
                        }
                    }
                }
            }
        }
        const symmetryX: number = (minX + maxX) / 2;
        const symmetryY: number = (minY + maxY) / 2;
        const flippedItems: Array<Selectable> = /* asList */items.slice(0);
        for (let i: number = 0; i < items.length; i++) {
            {
                this.flipItem(items[i], itemTextBaseOffsets[i], 0, horizontalFlip ? symmetryX : symmetryY, horizontalFlip, flippedItems);
            };
        }
    }

    /**
     * Flips the given <code>item</code> with the given axis coordinate.
     * @param {Object} item the item to flip
     * @param {float[]} itemTextBaseOffsets base offset for the texts of the item
     * @param {number} offsetIndex  index to get the first text base offset of item
     * @param {number} axisCoordinate the coordinate of the symmetry axis
     * @param {boolean} horizontalFlip if <code>true</code> the item should be flipped horizontally otherwise vertically
     * @param {*[]} flippedItems list of all the items that must be flipped
     */
    flipItem(item: Selectable, itemTextBaseOffsets: number[], offsetIndex: number, axisCoordinate: number, horizontalFlip: boolean, flippedItems: Array<Selectable>) {
        if (item != null && item instanceof <any>HomePieceOfFurniture) {
            const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
            if (horizontalFlip) {
                piece.setX(axisCoordinate * 2 - piece.getX());
                piece.setAngle(-piece.getAngle());
                PlanController.flipPieceOfFurnitureName(piece, itemTextBaseOffsets[0], horizontalFlip);
            } else {
                piece.setY(axisCoordinate * 2 - piece.getY());
                piece.setAngle(<number>Math.PI - piece.getAngle());
                PlanController.flipPieceOfFurnitureName(piece, itemTextBaseOffsets[0], horizontalFlip);
            }
            if (piece.isHorizontallyRotatable()) {
                piece.setRoll(-piece.getRoll());
            }
            if (piece.isResizable()) {
                piece.setModelMirrored(!piece.isModelMirrored());
            }
            if (item != null && item instanceof <any>HomeFurnitureGroup) {
                const furniture: Array<HomePieceOfFurniture> = (<HomeFurnitureGroup><any>item).getAllFurniture();
                for (let i: number = 0; i < /* size */(<number>furniture.length); i++) {
                    {
                        PlanController.flipPieceOfFurnitureName(/* get */furniture[i], itemTextBaseOffsets[i + 1], horizontalFlip);
                    };
                }
            }
        } else if (item != null && item instanceof <any>Wall) {
            const wall: Wall = <Wall><any>item;
            if (horizontalFlip) {
                wall.setXStart(axisCoordinate * 2 - wall.getXStart());
                const wallAtStart: Wall = wall.getWallAtStart();
                if (wallAtStart != null && !/* contains */(flippedItems.indexOf(<any>(wallAtStart)) >= 0)) {
                    if (wallAtStart.getWallAtStart() === wall) {
                        wallAtStart.setXStart(axisCoordinate * 2 - wallAtStart.getXStart());
                    } else {
                        wallAtStart.setXEnd(axisCoordinate * 2 - wallAtStart.getXEnd());
                    }
                }
                wall.setXEnd(axisCoordinate * 2 - wall.getXEnd());
                const wallAtEnd: Wall = wall.getWallAtEnd();
                if (wallAtEnd != null && !/* contains */(flippedItems.indexOf(<any>(wallAtEnd)) >= 0)) {
                    if (wallAtEnd.getWallAtStart() === wall) {
                        wallAtEnd.setXStart(axisCoordinate * 2 - wallAtEnd.getXStart());
                    } else {
                        wallAtEnd.setXEnd(axisCoordinate * 2 - wallAtEnd.getXEnd());
                    }
                }
            } else {
                wall.setYStart(axisCoordinate * 2 - wall.getYStart());
                const wallAtStart: Wall = wall.getWallAtStart();
                if (wallAtStart != null && !/* contains */(flippedItems.indexOf(<any>(wallAtStart)) >= 0)) {
                    if (wallAtStart.getWallAtStart() === wall) {
                        wallAtStart.setYStart(axisCoordinate * 2 - wallAtStart.getYStart());
                    } else {
                        wallAtStart.setYEnd(axisCoordinate * 2 - wallAtStart.getYEnd());
                    }
                }
                wall.setYEnd(axisCoordinate * 2 - wall.getYEnd());
                const wallAtEnd: Wall = wall.getWallAtEnd();
                if (wallAtEnd != null && !/* contains */(flippedItems.indexOf(<any>(wallAtEnd)) >= 0)) {
                    if (wallAtEnd.getWallAtStart() === wall) {
                        wallAtEnd.setYStart(axisCoordinate * 2 - wallAtEnd.getYStart());
                    } else {
                        wallAtEnd.setYEnd(axisCoordinate * 2 - wallAtEnd.getYEnd());
                    }
                }
            }
            const arcExtent: number = wall.getArcExtent();
            if (arcExtent != null) {
                wall.setArcExtent(-arcExtent);
            }
            PlanController.reverseWallSidesStyle(wall);
        } else if (item != null && item instanceof <any>Room) {
            const room: Room = <Room><any>item;
            const points: number[][] = room.getPoints();
            for (let index = 0; index < points.length; index++) {
                let point = points[index];
                {
                    if (horizontalFlip) {
                        point[0] = axisCoordinate * 2 - point[0];
                    } else {
                        point[1] = axisCoordinate * 2 - point[1];
                    }
                }
            }
            room.setPoints(points);
            const nameStyle: TextStyle = room.getNameStyle();
            const areaStyle: TextStyle = room.getAreaStyle();
            if (horizontalFlip) {
                room.setNameXOffset(-room.getNameXOffset());
                room.setAreaXOffset(-room.getAreaXOffset());
                if (nameStyle != null) {
                    if (nameStyle.getAlignment() === TextStyle.Alignment.LEFT) {
                        room.setNameStyle(nameStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.RIGHT));
                    } else if (nameStyle.getAlignment() === TextStyle.Alignment.RIGHT) {
                        room.setNameStyle(nameStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.LEFT));
                    }
                }
                if (areaStyle != null) {
                    if (areaStyle.getAlignment() === TextStyle.Alignment.LEFT) {
                        room.setAreaStyle(areaStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.RIGHT));
                    } else if (areaStyle.getAlignment() === TextStyle.Alignment.RIGHT) {
                        room.setAreaStyle(areaStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.LEFT));
                    }
                }
            } else {
                room.setNameYOffset(-room.getNameYOffset());
                let baseOffset: number = itemTextBaseOffsets[0];
                room.setNameXOffset(room.getNameXOffset() - baseOffset * <number>Math.sin(room.getNameAngle()));
                room.setNameYOffset(room.getNameYOffset() - baseOffset * <number>Math.cos(room.getNameAngle()));
                room.setAreaYOffset(-room.getAreaYOffset());
                baseOffset = itemTextBaseOffsets[1];
                room.setAreaXOffset(room.getAreaXOffset() - baseOffset * <number>Math.sin(room.getAreaAngle()));
                room.setAreaYOffset(room.getAreaYOffset() - baseOffset * <number>Math.cos(room.getAreaAngle()));
            }
            room.setNameAngle(-room.getNameAngle());
            room.setAreaAngle(-room.getAreaAngle());
        } else if (item != null && item instanceof <any>Polyline) {
            const polyline: Polyline = <Polyline><any>item;
            const points: number[][] = polyline.getPoints();
            for (let index = 0; index < points.length; index++) {
                let point = points[index];
                {
                    if (horizontalFlip) {
                        point[0] = axisCoordinate * 2 - point[0];
                    } else {
                        point[1] = axisCoordinate * 2 - point[1];
                    }
                }
            }
            polyline.setPoints(points);
        } else if (item != null && item instanceof <any>DimensionLine) {
            const dimensionLine: DimensionLine = <DimensionLine><any>item;
            if (dimensionLine.isElevationDimensionLine()) {
                if (horizontalFlip) {
                    dimensionLine.setXStart(axisCoordinate * 2 - dimensionLine.getXStart());
                    dimensionLine.setXEnd(dimensionLine.getXStart());
                    dimensionLine.setPitch(<number>Math.PI - dimensionLine.getPitch());
                } else {
                    dimensionLine.setYStart(axisCoordinate * 2 - dimensionLine.getYStart());
                    dimensionLine.setYEnd(dimensionLine.getYStart());
                    dimensionLine.setPitch(-dimensionLine.getPitch());
                }
                dimensionLine.setOffset(-dimensionLine.getOffset());
            } else {
                if (horizontalFlip) {
                    const xStart: number = dimensionLine.getXStart();
                    dimensionLine.setXStart(axisCoordinate * 2 - dimensionLine.getXEnd());
                    dimensionLine.setXEnd(axisCoordinate * 2 - xStart);
                    const yStart: number = dimensionLine.getYStart();
                    dimensionLine.setYStart(dimensionLine.getYEnd());
                    dimensionLine.setYEnd(yStart);
                } else {
                    dimensionLine.setYStart(axisCoordinate * 2 - dimensionLine.getYStart());
                    dimensionLine.setYEnd(axisCoordinate * 2 - dimensionLine.getYEnd());
                    dimensionLine.setOffset(-dimensionLine.getOffset());
                }
            }
        } else if (item != null && item instanceof <any>Label) {
            const label: Label = <Label><any>item;
            if (horizontalFlip) {
                label.setX(axisCoordinate * 2 - label.getX());
                label.setAngle(-label.getAngle());
            } else {
                label.setY(axisCoordinate * 2 - label.getY());
                if (label.getPitch() != null) {
                    label.setAngle(<number>Math.PI - label.getAngle());
                } else {
                    label.setAngle(-label.getAngle());
                }
            }
            const style: TextStyle = label.getStyle();
            if (style != null) {
                if (style.getAlignment() === TextStyle.Alignment.LEFT) {
                    label.setStyle(style.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.RIGHT));
                } else if (style.getAlignment() === TextStyle.Alignment.RIGHT) {
                    label.setStyle(style.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.LEFT));
                }
            }
        } else if (item != null && item instanceof <any>Compass) {
            const compass: Compass = <Compass><any>item;
            if (horizontalFlip) {
                compass.setX(axisCoordinate * 2 - compass.getX());
                compass.setNorthDirection(-compass.getNorthDirection());
            } else {
                compass.setY(axisCoordinate * 2 - compass.getY());
                compass.setNorthDirection(<number>Math.PI - compass.getNorthDirection());
            }
        }
    }

    /**
     * Flips the name of the given <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} nameBaseOffset
     * @param {boolean} horizontalFlip
     * @private
     */
    static flipPieceOfFurnitureName(piece: HomePieceOfFurniture, nameBaseOffset: number, horizontalFlip: boolean) {
        if (horizontalFlip) {
            piece.setNameXOffset(-piece.getNameXOffset());
            const nameStyle: TextStyle = piece.getNameStyle();
            if (nameStyle != null) {
                if (nameStyle.getAlignment() === TextStyle.Alignment.LEFT) {
                    piece.setNameStyle(nameStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.RIGHT));
                } else if (nameStyle.getAlignment() === TextStyle.Alignment.RIGHT) {
                    piece.setNameStyle(nameStyle.deriveStyle$com_eteks_sweethome3d_model_TextStyle_Alignment(TextStyle.Alignment.LEFT));
                }
            }
        } else {
            piece.setNameYOffset(-piece.getNameYOffset());
            if (piece.getNameXOffset() !== 0 || piece.getNameYOffset() !== 0) {
                piece.setNameXOffset(piece.getNameXOffset() - nameBaseOffset * <number>Math.sin(piece.getNameAngle()));
                piece.setNameYOffset(piece.getNameYOffset() - nameBaseOffset * <number>Math.cos(piece.getNameAngle()));
            }
            piece.setNameAngle(-piece.getNameAngle());
        }
    }

    /**
     * Returns the offset between the vertical middle of the text and its base.
     * @param {string} text
     * @param {TextStyle} textStyle
     * @param {Object} itemClass
     * @return {number}
     * @private
     */
    getTextBaseOffset(text: string, textStyle: TextStyle, itemClass: any): number {
        if (textStyle == null) {
            textStyle = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getDefaultTextStyle(itemClass);
        }
        const textBounds: number[][] = this.getView().getTextBounds(text != null ? text : "Ag", textStyle, 0, 0, 0);
        return (textBounds[textBounds.length - 1][1] + textBounds[0][1]) / 2;
    }

    /**
     * Controls how selected walls are joined.
     */
    public joinSelectedWalls() {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const selectedWalls: Array<Wall> = Home.getWallsSubList(selectedItems);
        const walls: Wall[] = [null, null];
        for (let index = 0; index < selectedWalls.length; index++) {
            let wall = selectedWalls[index];
            {
                if ((wall.getArcExtent() == null || wall.getArcExtent() === 0.0) && (wall.getWallAtStart() == null || wall.getWallAtEnd() == null)) {
                    if (walls[0] == null) {
                        walls[0] = wall;
                    } else {
                        walls[1] = wall;
                        break;
                    }
                }
            }
        }
        if (walls[1] == null) {
            /* sort */((l, c) => { if ((<any>c).compare) l.sort((e1, e2) => (<any>c).compare(e1, e2)); else l.sort(<any>c); })(selectedWalls, new PlanController.PlanController$0(this, walls));
            if (walls[0] !== /* get */selectedWalls[1]) {
                walls[1] = /* get */selectedWalls[1];
            }
        }
        if (walls[1] != null) {
            const firstWallAngle: number = Math.atan2(walls[0].getYEnd() - walls[0].getYStart(), walls[0].getXEnd() - walls[0].getXStart());
            const secondWallAngle: number = Math.atan2(walls[1].getYEnd() - walls[1].getYStart(), walls[1].getXEnd() - walls[1].getXStart());
            const wallsAngle: number = Math.abs(firstWallAngle - secondWallAngle) % Math.PI;
            const parallel: boolean = wallsAngle <= Math.PI / 360 || (Math.PI - wallsAngle) <= Math.PI / 360;
            let joinPoint: number[] = null;
            if (!parallel) {
                joinPoint = PlanController.computeIntersection$float$float$float$float$float$float$float$float(walls[0].getXStart(), walls[0].getYStart(), walls[0].getXEnd(), walls[0].getYEnd(), walls[1].getXStart(), walls[1].getYStart(), walls[1].getXEnd(), walls[1].getYEnd());
            } else if (java.awt.geom.Line2D.ptLineDistSq(walls[1].getXStart(), walls[1].getYStart(), walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXStart(), walls[0].getYStart()) < 0.01 && java.awt.geom.Line2D.ptLineDistSq(walls[1].getXStart(), walls[1].getYStart(), walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXEnd(), walls[0].getYEnd()) < 0.01) {
                if ((walls[1].getWallAtStart() == null) !== (walls[1].getWallAtEnd() == null)) {
                    if (walls[1].getWallAtStart() == null) {
                        joinPoint = [walls[1].getXStart(), walls[1].getYStart()];
                    } else {
                        joinPoint = [walls[1].getXEnd(), walls[1].getYEnd()];
                    }
                } else if (walls[1].getWallAtStart() == null && walls[1].getWallAtEnd() == null) {
                    const wallStartDistanceToSegment: number = java.awt.geom.Line2D.ptSegDistSq(walls[1].getXStart(), walls[1].getYStart(), walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXStart(), walls[0].getYStart());
                    const wallEndDistanceToSegment: number = java.awt.geom.Line2D.ptSegDistSq(walls[1].getXStart(), walls[1].getYStart(), walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXEnd(), walls[0].getYEnd());
                    if (wallStartDistanceToSegment > 0.01 && wallEndDistanceToSegment > 0.01) {
                        if (walls[0].getWallAtEnd() != null || walls[0].getWallAtStart() == null && wallStartDistanceToSegment <= wallEndDistanceToSegment) {
                            if (java.awt.geom.Point2D.distanceSq(walls[1].getXStart(), walls[1].getYStart(), walls[0].getXStart(), walls[0].getYStart()) < java.awt.geom.Point2D.distanceSq(walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXStart(), walls[0].getYStart())) {
                                joinPoint = [walls[1].getXStart(), walls[1].getYStart()];
                            } else {
                                joinPoint = [walls[1].getXEnd(), walls[1].getYEnd()];
                            }
                        } else {
                            if (java.awt.geom.Point2D.distanceSq(walls[1].getXStart(), walls[1].getYStart(), walls[0].getXEnd(), walls[0].getYEnd()) < java.awt.geom.Point2D.distanceSq(walls[1].getXEnd(), walls[1].getYEnd(), walls[0].getXEnd(), walls[0].getYEnd())) {
                                joinPoint = [walls[1].getXStart(), walls[1].getYStart()];
                            } else {
                                joinPoint = [walls[1].getXEnd(), walls[1].getYEnd()];
                            }
                        }
                    }
                }
            }
            if (joinPoint != null) {
                const joinedWalls: PlanController.JoinedWall[] = PlanController.JoinedWall.getJoinedWalls(/* asList */[walls[0], walls[1]]);
                this.doJoinWalls(joinedWalls, joinPoint);
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallsJoiningUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection(), joinedWalls, joinPoint));
            }
        }
    }

    /**
     * Joins two walls at the given point.
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedWalls
     * @param {float[]} joinPoint
     * @private
     */
    doJoinWalls(joinedWalls: PlanController.JoinedWall[], joinPoint: number[]) {
        const walls: Wall[] = [joinedWalls[0].getWall(), joinedWalls[1].getWall()];
        let connected: boolean = false;
        for (let i: number = 0; i < 2; i++) {
            {
                let joinAtEnd: boolean = walls[i].getWallAtEnd() == null;
                let joinAtStart: boolean = walls[i].getWallAtStart() == null;
                if (joinAtStart && joinAtEnd) {
                    if (java.awt.geom.Point2D.distanceSq(walls[i].getXStart(), walls[i].getYStart(), joinPoint[0], joinPoint[1]) < java.awt.geom.Point2D.distanceSq(walls[i].getXEnd(), walls[i].getYEnd(), joinPoint[0], joinPoint[1])) {
                        joinAtEnd = false;
                    } else {
                        joinAtStart = false;
                    }
                }
                if (joinAtEnd) {
                    walls[i].setXEnd(joinPoint[0]);
                    walls[i].setYEnd(joinPoint[1]);
                } else if (joinAtStart) {
                    walls[i].setXStart(joinPoint[0]);
                    walls[i].setYStart(joinPoint[1]);
                }
                if (connected || walls[(i + 1) % 2].getWallAtStart() == null || walls[(i + 1) % 2].getWallAtEnd() == null) {
                    if (joinAtEnd) {
                        walls[i].setWallAtEnd(walls[(i + 1) % 2]);
                        connected = true;
                    } else if (joinAtStart) {
                        walls[i].setWallAtStart(walls[(i + 1) % 2]);
                        connected = true;
                    }
                }
            };
        }
        if (connected) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(/* asList */[walls[0], walls[1]]);
        } else {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(/* asList */[walls[0]]);
        }
    }

    /**
     * Controls the direction reverse of selected walls.
     */
    public reverseSelectedWallsDirection() {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const selectedWalls: Array<Wall> = Home.getWallsSubList(selectedItems);
        if (!/* isEmpty */(selectedWalls.length == 0)) {
            const reversedWalls: Wall[] = /* toArray */selectedWalls.slice(0);
            this.doReverseWallsDirection(reversedWalls);
            this.selectAndShowItems$java_util_List$boolean(/* asList */reversedWalls.slice(0), false);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallsDirectionReversingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection(), reversedWalls));
        }
    }

    /**
     * Reverses the <code>walls</code> direction.
     * @param {com.eteks.sweethome3d.model.Wall[]} walls
     * @private
     */
    doReverseWallsDirection(walls: Wall[]) {
        for (let index = 0; index < walls.length; index++) {
            let wall = walls[index];
            {
                const xStart: number = wall.getXStart();
                const yStart: number = wall.getYStart();
                const xEnd: number = wall.getXEnd();
                const yEnd: number = wall.getYEnd();
                wall.setXStart(xEnd);
                wall.setYStart(yEnd);
                wall.setXEnd(xStart);
                wall.setYEnd(yStart);
                if (wall.getArcExtent() != null) {
                    wall.setArcExtent(-wall.getArcExtent());
                }
                const wallAtStart: Wall = wall.getWallAtStart();
                const joinedAtEndOfWallAtStart: boolean = wallAtStart != null && wallAtStart.getWallAtEnd() === wall;
                const joinedAtStartOfWallAtStart: boolean = wallAtStart != null && wallAtStart.getWallAtStart() === wall;
                const wallAtEnd: Wall = wall.getWallAtEnd();
                const joinedAtEndOfWallAtEnd: boolean = wallAtEnd != null && wallAtEnd.getWallAtEnd() === wall;
                const joinedAtStartOfWallAtEnd: boolean = wallAtEnd != null && wallAtEnd.getWallAtStart() === wall;
                wall.setWallAtStart(wallAtEnd);
                wall.setWallAtEnd(wallAtStart);
                if (joinedAtEndOfWallAtStart) {
                    wallAtStart.setWallAtEnd(wall);
                } else if (joinedAtStartOfWallAtStart) {
                    wallAtStart.setWallAtStart(wall);
                }
                if (joinedAtEndOfWallAtEnd) {
                    wallAtEnd.setWallAtEnd(wall);
                } else if (joinedAtStartOfWallAtEnd) {
                    wallAtEnd.setWallAtStart(wall);
                }
                const heightAtEnd: number = wall.getHeightAtEnd();
                if (heightAtEnd != null) {
                    const height: number = wall.getHeight();
                    wall.setHeight(heightAtEnd);
                    wall.setHeightAtEnd(height);
                }
                PlanController.reverseWallSidesStyle(wall);
            }
        }
    }

    /**
     * Exchanges the style of wall sides.
     * @param {Wall} wall
     * @private
     */
    static reverseWallSidesStyle(wall: Wall) {
        const rightSideColor: number = wall.getRightSideColor();
        const rightSideTexture: HomeTexture = wall.getRightSideTexture();
        const leftSideShininess: number = wall.getLeftSideShininess();
        const leftSideBaseboard: Baseboard = wall.getLeftSideBaseboard();
        const leftSideColor: number = wall.getLeftSideColor();
        const leftSideTexture: HomeTexture = wall.getLeftSideTexture();
        const rightSideShininess: number = wall.getRightSideShininess();
        const rightSideBaseboard: Baseboard = wall.getRightSideBaseboard();
        wall.setLeftSideColor(rightSideColor);
        wall.setLeftSideTexture(rightSideTexture);
        wall.setLeftSideShininess(rightSideShininess);
        wall.setLeftSideBaseboard(rightSideBaseboard);
        wall.setRightSideColor(leftSideColor);
        wall.setRightSideTexture(leftSideTexture);
        wall.setRightSideShininess(leftSideShininess);
        wall.setRightSideBaseboard(leftSideBaseboard);
    }

    /**
     * Controls the split of the selected wall in two joined walls of equal length.
     */
    public splitSelectedWall() {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const selectedWalls: Array<Wall> = Home.getWallsSubList(selectedItems);
        if (/* size */(<number>selectedWalls.length) === 1) {
            const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            const basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            const splitWall: Wall = /* get */selectedWalls[0];
            const splitJoinedWall: PlanController.JoinedWall = new PlanController.JoinedWall(splitWall);
            const xStart: number = splitWall.getXStart();
            const yStart: number = splitWall.getYStart();
            const xEnd: number = splitWall.getXEnd();
            const yEnd: number = splitWall.getYEnd();
            const xMiddle: number = (xStart + xEnd) / 2;
            const yMiddle: number = (yStart + yEnd) / 2;
            const wallAtStart: Wall = splitWall.getWallAtStart();
            const joinedAtEndOfWallAtStart: boolean = wallAtStart != null && wallAtStart.getWallAtEnd() === splitWall;
            const joinedAtStartOfWallAtStart: boolean = wallAtStart != null && wallAtStart.getWallAtStart() === splitWall;
            const wallAtEnd: Wall = splitWall.getWallAtEnd();
            const joinedAtEndOfWallAtEnd: boolean = wallAtEnd != null && wallAtEnd.getWallAtEnd() === splitWall;
            const joinedAtStartOfWallAtEnd: boolean = wallAtEnd != null && wallAtEnd.getWallAtStart() === splitWall;
            const firstWall: Wall = <Wall>splitWall.duplicate();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(firstWall);
            firstWall.setLevel(splitWall.getLevel());
            const secondWall: Wall = <Wall>splitWall.duplicate();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(secondWall);
            secondWall.setLevel(splitWall.getLevel());
            firstWall.setXEnd(xMiddle);
            firstWall.setYEnd(yMiddle);
            secondWall.setXStart(xMiddle);
            secondWall.setYStart(yMiddle);
            if (splitWall.getHeightAtEnd() != null) {
                const heightAtMiddle: number = (splitWall.getHeight() + splitWall.getHeightAtEnd()) / 2;
                firstWall.setHeightAtEnd(heightAtMiddle);
                secondWall.setHeight(heightAtMiddle);
            }
            firstWall.setWallAtEnd(secondWall);
            secondWall.setWallAtStart(firstWall);
            firstWall.setWallAtStart(wallAtStart);
            if (joinedAtEndOfWallAtStart) {
                wallAtStart.setWallAtEnd(firstWall);
            } else if (joinedAtStartOfWallAtStart) {
                wallAtStart.setWallAtStart(firstWall);
            }
            secondWall.setWallAtEnd(wallAtEnd);
            if (joinedAtStartOfWallAtEnd) {
                wallAtEnd.setWallAtStart(secondWall);
            } else if (joinedAtEndOfWallAtEnd) {
                wallAtEnd.setWallAtEnd(secondWall);
            }
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteWall(splitWall);
            this.selectAndShowItems$java_util_List$boolean(/* asList */[firstWall].slice(0), false);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallSplittingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), basePlanLocked, allLevelsSelection, splitJoinedWall, new PlanController.JoinedWall(firstWall), new PlanController.JoinedWall(secondWall), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked()));
        }
    }

    /**
     * Controls the modification of the selected rooms.
     */
    public modifySelectedRooms() {
        if (!/* isEmpty */(Home.getRoomsSubList(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()).length == 0)) {
            new RoomController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    createDimensionLine$float$float(x: number, y: number) {
        new DimensionLineController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, x, y, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
    }

    /**
     * Creates a new label using its controller.
     * @param {number} x
     * @param {number} y
     */
    createLabel(x: number, y: number) {
        new LabelController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, x, y, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
    }

    /**
     * Controls the modification of the selected labels.
     */
    public modifySelectedLabels() {
        if (!/* isEmpty */(Home.getLabelsSubList(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()).length == 0)) {
            new LabelController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    /**
     * Controls the modification of the selected polylines.
     */
    public modifySelectedPolylines() {
        if (!/* isEmpty */(Home.getPolylinesSubList(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()).length == 0)) {
            new PolylineController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_contentManager, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    /**
     * Controls the modification of the selected labels.
     */
    public modifySelectedDimensionLines() {
        if (!/* isEmpty */(Home.getDimensionLinesSubList(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()).length == 0)) {
            new DimensionLineController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    /**
     * Controls the modification of the compass.
     */
    public modifyCompass() {
        new CompassController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
    }

    /**
     * Controls the modification of the observer camera.
     */
    public modifyObserverCamera() {
        new ObserverCameraController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory).displayView(this.getView());
    }

    /**
     * Toggles bold style of texts in selected items.
     */
    public toggleBoldStyle() {
        let selectionBoldStyle: boolean = null;
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    let bold: boolean;
                    if (item != null && item instanceof <any>Label) {
                        bold = this.getItemTextStyle(item, (<Label><any>item).getStyle()).isBold();
                    } else if ((item != null && item instanceof <any>HomePieceOfFurniture) && (<HomePieceOfFurniture><any>item).isVisible()) {
                        bold = this.getItemTextStyle(item, (<HomePieceOfFurniture><any>item).getNameStyle()).isBold();
                    } else if (item != null && item instanceof <any>Room) {
                        const room: Room = <Room><any>item;
                        bold = this.getItemTextStyle(room, room.getNameStyle()).isBold();
                        if (bold !== this.getItemTextStyle(room, room.getAreaStyle()).isBold()) {
                            bold = null;
                        }
                    } else if (item != null && item instanceof <any>DimensionLine) {
                        bold = this.getItemTextStyle(item, (<DimensionLine><any>item).getLengthStyle()).isBold();
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !(selectionBoldStyle === bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
            }
        }
        if (selectionBoldStyle == null) {
            selectionBoldStyle = true;
        } else {
            selectionBoldStyle = !selectionBoldStyle;
        }
        const itemsWithText: Array<Selectable> = <any>([]);
        const oldTextStyles: Array<TextStyle> = <any>([]);
        const textStyles: Array<TextStyle> = <any>([]);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>Label) {
                        const label: Label = <Label><any>item;
                        /* add */(itemsWithText.push(label) > 0);
                        const oldTextStyle: TextStyle = this.getItemTextStyle(label, label.getStyle());
                        /* add */(oldTextStyles.push(oldTextStyle) > 0);
                        /* add */(textStyles.push(oldTextStyle.deriveBoldStyle(selectionBoldStyle)) > 0);
                    } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                        if (piece.isVisible()) {
                            /* add */(itemsWithText.push(piece) > 0);
                            const oldNameStyle: TextStyle = this.getItemTextStyle(piece, piece.getNameStyle());
                            /* add */(oldTextStyles.push(oldNameStyle) > 0);
                            /* add */(textStyles.push(oldNameStyle.deriveBoldStyle(selectionBoldStyle)) > 0);
                        }
                    } else if (item != null && item instanceof <any>Room) {
                        const room: Room = <Room><any>item;
                        /* add */(itemsWithText.push(room) > 0);
                        const oldNameStyle: TextStyle = this.getItemTextStyle(room, room.getNameStyle());
                        /* add */(oldTextStyles.push(oldNameStyle) > 0);
                        /* add */(textStyles.push(oldNameStyle.deriveBoldStyle(selectionBoldStyle)) > 0);
                        const oldAreaStyle: TextStyle = this.getItemTextStyle(room, room.getAreaStyle());
                        /* add */(oldTextStyles.push(oldAreaStyle) > 0);
                        /* add */(textStyles.push(oldAreaStyle.deriveBoldStyle(selectionBoldStyle)) > 0);
                    } else if (item != null && item instanceof <any>DimensionLine) {
                        const dimensionLine: DimensionLine = <DimensionLine><any>item;
                        /* add */(itemsWithText.push(dimensionLine) > 0);
                        const oldLengthStyle: TextStyle = this.getItemTextStyle(dimensionLine, dimensionLine.getLengthStyle());
                        /* add */(oldTextStyles.push(oldLengthStyle) > 0);
                        /* add */(textStyles.push(oldLengthStyle.deriveBoldStyle(selectionBoldStyle)) > 0);
                    }
                }
            }
        }
        this.modifyTextStyle(/* toArray */itemsWithText.slice(0), /* toArray */oldTextStyles.slice(0), /* toArray */textStyles.slice(0));
    }

    /**
     * Returns <code>textStyle</code> if not null or the default text style.
     * @param {Object} item
     * @param {TextStyle} textStyle
     * @return {TextStyle}
     * @private
     */
    getItemTextStyle(item: Selectable, textStyle: TextStyle): TextStyle {
        if (textStyle == null) {
            textStyle = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getDefaultTextStyle((<any>item.constructor));
        }
        return textStyle;
    }

    /**
     * Toggles italic style of texts in selected items.
     */
    public toggleItalicStyle() {
        let selectionItalicStyle: boolean = null;
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    let italic: boolean;
                    if (item != null && item instanceof <any>Label) {
                        italic = this.getItemTextStyle(item, (<Label><any>item).getStyle()).isItalic();
                    } else if ((item != null && item instanceof <any>HomePieceOfFurniture) && (<HomePieceOfFurniture><any>item).isVisible()) {
                        italic = this.getItemTextStyle(item, (<HomePieceOfFurniture><any>item).getNameStyle()).isItalic();
                    } else if (item != null && item instanceof <any>Room) {
                        const room: Room = <Room><any>item;
                        italic = this.getItemTextStyle(room, room.getNameStyle()).isItalic();
                        if (italic !== this.getItemTextStyle(room, room.getAreaStyle()).isItalic()) {
                            italic = null;
                        }
                    } else if (item != null && item instanceof <any>DimensionLine) {
                        italic = this.getItemTextStyle(item, (<DimensionLine><any>item).getLengthStyle()).isItalic();
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !(selectionItalicStyle === italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
            }
        }
        if (selectionItalicStyle == null) {
            selectionItalicStyle = true;
        } else {
            selectionItalicStyle = !selectionItalicStyle;
        }
        const itemsWithText: Array<Selectable> = <any>([]);
        const oldTextStyles: Array<TextStyle> = <any>([]);
        const textStyles: Array<TextStyle> = <any>([]);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>Label) {
                        const label: Label = <Label><any>item;
                        /* add */(itemsWithText.push(label) > 0);
                        const oldTextStyle: TextStyle = this.getItemTextStyle(label, label.getStyle());
                        /* add */(oldTextStyles.push(oldTextStyle) > 0);
                        /* add */(textStyles.push(oldTextStyle.deriveItalicStyle(selectionItalicStyle)) > 0);
                    } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                        if (piece.isVisible()) {
                            /* add */(itemsWithText.push(piece) > 0);
                            const oldNameStyle: TextStyle = this.getItemTextStyle(piece, piece.getNameStyle());
                            /* add */(oldTextStyles.push(oldNameStyle) > 0);
                            /* add */(textStyles.push(oldNameStyle.deriveItalicStyle(selectionItalicStyle)) > 0);
                        }
                    } else if (item != null && item instanceof <any>Room) {
                        const room: Room = <Room><any>item;
                        /* add */(itemsWithText.push(room) > 0);
                        const oldNameStyle: TextStyle = this.getItemTextStyle(room, room.getNameStyle());
                        /* add */(oldTextStyles.push(oldNameStyle) > 0);
                        /* add */(textStyles.push(oldNameStyle.deriveItalicStyle(selectionItalicStyle)) > 0);
                        const oldAreaStyle: TextStyle = this.getItemTextStyle(room, room.getAreaStyle());
                        /* add */(oldTextStyles.push(oldAreaStyle) > 0);
                        /* add */(textStyles.push(oldAreaStyle.deriveItalicStyle(selectionItalicStyle)) > 0);
                    } else if (item != null && item instanceof <any>DimensionLine) {
                        const dimensionLine: DimensionLine = <DimensionLine><any>item;
                        /* add */(itemsWithText.push(dimensionLine) > 0);
                        const oldLengthStyle: TextStyle = this.getItemTextStyle(dimensionLine, dimensionLine.getLengthStyle());
                        /* add */(oldTextStyles.push(oldLengthStyle) > 0);
                        /* add */(textStyles.push(oldLengthStyle.deriveItalicStyle(selectionItalicStyle)) > 0);
                    }
                }
            }
        }
        this.modifyTextStyle(/* toArray */itemsWithText.slice(0), /* toArray */oldTextStyles.slice(0), /* toArray */textStyles.slice(0));
    }

    /**
     * Increase the size of texts in selected items.
     */
    public increaseTextSize() {
        this.applyFactorToTextSize(1.1);
    }

    /**
     * Decrease the size of texts in selected items.
     */
    public decreaseTextSize() {
        this.applyFactorToTextSize(1 / 1.1);
    }

    /**
     * Applies a factor to the font size of the texts of the selected items in home.
     * @param {number} factor
     * @private
     */
    applyFactorToTextSize(factor: number) {
        const itemsWithText: Array<Selectable> = <any>([]);
        const oldTextStyles: Array<TextStyle> = <any>([]);
        const textStyles: Array<TextStyle> = <any>([]);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>Label) {
                        const label: Label = <Label><any>item;
                        /* add */(itemsWithText.push(label) > 0);
                        const oldLabelStyle: TextStyle = this.getItemTextStyle(item, label.getStyle());
                        /* add */(oldTextStyles.push(oldLabelStyle) > 0);
                        /* add */(textStyles.push(oldLabelStyle.deriveStyle$float(Math.round(oldLabelStyle.getFontSize() * factor))) > 0);
                    } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                        if (piece.isVisible()) {
                            /* add */(itemsWithText.push(piece) > 0);
                            const oldNameStyle: TextStyle = this.getItemTextStyle(piece, piece.getNameStyle());
                            /* add */(oldTextStyles.push(oldNameStyle) > 0);
                            /* add */(textStyles.push(oldNameStyle.deriveStyle$float(Math.round(oldNameStyle.getFontSize() * factor))) > 0);
                        }
                    } else if (item != null && item instanceof <any>Room) {
                        const room: Room = <Room><any>item;
                        /* add */(itemsWithText.push(room) > 0);
                        const oldNameStyle: TextStyle = this.getItemTextStyle(room, room.getNameStyle());
                        /* add */(oldTextStyles.push(oldNameStyle) > 0);
                        /* add */(textStyles.push(oldNameStyle.deriveStyle$float(Math.round(oldNameStyle.getFontSize() * factor))) > 0);
                        const oldAreaStyle: TextStyle = this.getItemTextStyle(room, room.getAreaStyle());
                        /* add */(oldTextStyles.push(oldAreaStyle) > 0);
                        /* add */(textStyles.push(oldAreaStyle.deriveStyle$float(Math.round(oldAreaStyle.getFontSize() * factor))) > 0);
                    } else if (item != null && item instanceof <any>DimensionLine) {
                        const dimensionLine: DimensionLine = <DimensionLine><any>item;
                        /* add */(itemsWithText.push(dimensionLine) > 0);
                        const oldLengthStyle: TextStyle = this.getItemTextStyle(dimensionLine, dimensionLine.getLengthStyle());
                        /* add */(oldTextStyles.push(oldLengthStyle) > 0);
                        /* add */(textStyles.push(oldLengthStyle.deriveStyle$float(Math.round(oldLengthStyle.getFontSize() * factor))) > 0);
                    }
                }
            }
        }
        this.modifyTextStyle(/* toArray */itemsWithText.slice(0), /* toArray */oldTextStyles.slice(0), /* toArray */textStyles.slice(0));
    }

    /**
     * Changes the style of items and posts an undoable change style operation.
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {com.eteks.sweethome3d.model.TextStyle[]} oldStyles
     * @param {com.eteks.sweethome3d.model.TextStyle[]} styles
     * @private
     */
    modifyTextStyle(items: Selectable[], oldStyles: TextStyle[], styles: TextStyle[]) {
        const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
        const oldSelectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
        PlanController.doModifyTextStyle(items, styles);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.TextStyleModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, allLevelsSelection, oldStyles, items, styles));
    }

    /**
     * Changes the style of items.
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {com.eteks.sweethome3d.model.TextStyle[]} styles
     * @private
     */
    static doModifyTextStyle(items: Selectable[], styles: TextStyle[]) {
        let styleIndex: number = 0;
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (item != null && item instanceof <any>Label) {
                    (<Label><any>item).setStyle(styles[styleIndex++]);
                } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                    const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                    if (piece.isVisible()) {
                        piece.setNameStyle(styles[styleIndex++]);
                    }
                } else if (item != null && item instanceof <any>Room) {
                    const room: Room = <Room><any>item;
                    room.setNameStyle(styles[styleIndex++]);
                    room.setAreaStyle(styles[styleIndex++]);
                } else if (item != null && item instanceof <any>DimensionLine) {
                    (<DimensionLine><any>item).setLengthStyle(styles[styleIndex++]);
                }
            }
        }
    }

    /**
     * Returns the minimum scale of the plan view.
     * @return {number}
     */
    public getMinimumScale(): number {
        return 0.01;
    }

    /**
     * Returns the maximum scale of the plan view.
     * @return {number}
     */
    public getMaximumScale(): number {
        return 10.0;
    }

    /**
     * Returns the scale in plan view.
     * @return {number}
     */
    public getScale(): number {
        return this.getView().getScale();
    }

    /**
     * Controls the scale in plan view and and fires a <code>PropertyChangeEvent</code>.
     * @param {number} scale
     */
    public setScale(scale: number) {
        scale = Math.max(this.getMinimumScale(), Math.min(scale, this.getMaximumScale()));
        if (scale !== this.getView().getScale()) {
            const oldScale: number = this.getView().getScale();
            /* clear */(<any>this.furnitureSidesCache).entries = [];
            if (this.getView() != null) {
                const x: number = this.getView().convertXModelToScreen(this.getXLastMouseMove());
                const y: number = this.getView().convertXModelToScreen(this.getYLastMouseMove());
                this.getView().setScale(scale);
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera().setPlanScale(scale < 0.4 ? 0.4 / scale : 1.0);
                this.moveMouse(this.getView().convertXPixelToModel(x), this.getView().convertYPixelToModel(y));
            }
            this.propertyChangeSupport.firePropertyChange(/* name */"SCALE", oldScale, scale);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setProperty(PlanController.SCALE_VISUAL_PROPERTY, /* valueOf */String(scale).toString());
        }
    }

    /**
     * Sets the selected level in home.
     * @param {Level} level
     */
    public setSelectedLevel(level: Level) {
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedLevel(level);
    }

    /**
     * Selects all visible items in the selected level of home.
     */
    public selectAll() {
        const all: Array<Selectable> = this.getVisibleItemsAtSelectedLevel();
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked()) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(this.getItemsNotPartOfBasePlan(all));
        } else {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(all);
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(false);
    }

    /**
     * Returns the viewable and selectable home items at the selected level, except camera.
     * @return {*[]}
     * @private
     */
    getVisibleItemsAtSelectedLevel(): Array<Selectable> {
        const selectableItems: Array<Selectable> = <any>([]);
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectableViewableItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item != null && item instanceof <any>HomePieceOfFurniture) {
                        if (this.isPieceOfFurnitureVisibleAtSelectedLevel(<HomePieceOfFurniture><any>item)) {
                            /* add */(selectableItems.push(item) > 0);
                        }
                    } else if (!(item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) || (<Elevatable><any>item).isAtLevel(selectedLevel)) {
                        /* add */(selectableItems.push(item) > 0);
                    }
                }
            }
        }
        return selectableItems;
    }

    /**
     * Selects all visible items in all levels of home.
     */
    public selectAllAtAllLevels() {
        let allItems: Array<Selectable> = <any>(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectableViewableItems().slice(0));
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked()) {
            allItems = this.getItemsNotPartOfBasePlan(allItems);
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(allItems);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(true);
    }

    /**
     * Returns the visible (fully or partially) rooms at the selected level in home.
     * @return {Room[]}
     * @private
     */
    getDetectableRoomsAtSelectedLevel(): Array<Room> {
        const rooms: Array<Room> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const levels: Array<Level> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
        if (selectedLevel == null || /* size */(<number>levels.length) <= 1) {
            return rooms;
        } else {
            const visibleRooms: Array<Room> = <any>([]);
            const selectedLevelIndex: number = levels.indexOf(selectedLevel);
            const level0: boolean = /* get */levels[0] === selectedLevel || /* get */levels[selectedLevelIndex - 1].getElevation() === selectedLevel.getElevation();
            const otherLevel: Level = /* get */levels[level0 && selectedLevelIndex < /* size */(<number>levels.length) - 1 ? selectedLevelIndex + 1 : selectedLevelIndex - 1];
            for (let index = 0; index < rooms.length; index++) {
                let room = rooms[index];
                {
                    if (room.isAtLevel(selectedLevel) || otherLevel != null && room.isAtLevel(otherLevel) && (level0 && room.isFloorVisible() || !level0 && room.isCeilingVisible())) {
                        /* add */(visibleRooms.push(room) > 0);
                    }
                }
            }
            return visibleRooms;
        }
    }

    /**
     * Returns the visible (fully or partially) walls at the selected level in home.
     * @return {Wall[]}
     * @private
     */
    getDetectableWallsAtSelectedLevel(): Array<Wall> {
        const walls: Array<Wall> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const levels: Array<Level> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
        if (selectedLevel == null || /* size */(<number>levels.length) <= 1) {
            return walls;
        } else {
            const visibleWalls: Array<Wall> = <any>([]);
            const selectedLevelIndex: number = levels.indexOf(selectedLevel);
            const level0: boolean = /* get */levels[0] === selectedLevel || /* get */levels[selectedLevelIndex - 1].getElevation() === selectedLevel.getElevation();
            const otherLevel: Level = /* get */levels[level0 && selectedLevelIndex < /* size */(<number>levels.length) - 1 ? selectedLevelIndex + 1 : selectedLevelIndex - 1];
            for (let index = 0; index < walls.length; index++) {
                let wall = walls[index];
                {
                    if (wall.isAtLevel(selectedLevel) || otherLevel != null && wall.isAtLevel(otherLevel)) {
                        /* add */(visibleWalls.push(wall) > 0);
                    }
                }
            }
            return visibleWalls;
        }
    }

    /**
     * Returns the horizontal ruler of the plan view.
     * @return {Object}
     */
    public getHorizontalRulerView(): View {
        return this.getView().getHorizontalRuler();
    }

    /**
     * Returns the vertical ruler of the plan view.
     * @return {Object}
     */
    public getVerticalRulerView(): View {
        return this.getView().getVerticalRuler();
    }

    __com_eteks_sweethome3d_viewcontroller_PlanController_addModelListeners() {
        this.selectionListener = new PlanController.PlanController$1(this);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addSelectionListener(this.selectionListener);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera().addPropertyChangeListener(new PlanController.PlanController$2(this));
        this.wallChangeListener = new PlanController.PlanController$3(this);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    wall.addPropertyChangeListener(this.wallChangeListener);
                }
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWallsListener((ev: CollectionEvent<Wall>) => {
            if (ev.getType() === CollectionEvent.Type.ADD) {
                ev.getItem().addPropertyChangeListener(this.wallChangeListener);
            } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                ev.getItem().removePropertyChangeListener(this.wallChangeListener);
            }
            this.resetAreaCache();
        });
        const furnitureChangeListener: PropertyChangeListener = new PlanController.PlanController$4(this);
        this.furnitureSizeChangeListener = new PlanController.PlanController$5(this);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    piece.addPropertyChangeListener(furnitureChangeListener);
                    piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        {
                            let array1 = (<HomeFurnitureGroup>piece).getAllFurniture();
                            for (let index1 = 0; index1 < array1.length; index1++) {
                                let childPiece = array1[index1];
                                {
                                    childPiece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                                }
                            }
                        }
                    }
                }
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addFurnitureListener((ev: CollectionEvent<HomePieceOfFurniture>) => {
            const piece: HomePieceOfFurniture = ev.getItem();
            if (ev.getType() === CollectionEvent.Type.ADD) {
                piece.addPropertyChangeListener(furnitureChangeListener);
                piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                            }
                        }
                    }
                }
            } else if (ev.getType() === CollectionEvent.Type.DELETE) {
                piece.removePropertyChangeListener(furnitureChangeListener);
                /* remove */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries.splice(i, 1)[0]; } })(<any>this.furnitureSidesCache, piece);
                piece.removePropertyChangeListener(this.furnitureSizeChangeListener);
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.removePropertyChangeListener(this.furnitureSizeChangeListener);
                            }
                        }
                    }
                }
            }
        });
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPropertyChangeListener("SELECTED_LEVEL", new PlanController.PlanController$6(this));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera().setFixedSize(/* size */(<number>this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels().length) >= 2);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addLevelsListener((ev: CollectionEvent<Level>) => {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera().setFixedSize(/* size */(<number>this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels().length) >= 2);
        });
    }

    /**
     * Returns the selection listener add to the controlled home.
     * @return {Object}
     * @private
     */
    getSelectionListener(): SelectionListener {
        return this.selectionListener;
    }

    resetAreaCache() {
        this.wallsAreaCache = null;
        this.wallsIncludingBaseboardsAreaCache = null;
        this.insideWallsAreaCache = null;
        this.roomPathsCache = null;
    }

    /**
     * Displays in plan view the feedback of <code>draggedItems</code>,
     * during a drag and drop operation initiated from outside of plan view.
     * @param {*[]} draggedItems
     * @param {number} x
     * @param {number} y
     */
    public startDraggedItems(draggedItems: Array<Selectable>, x: number, y: number) {
        this.draggedItems = draggedItems;
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) {
            {
                let array = Home.getFurnitureSubList(draggedItems);
                for (let index = 0; index < array.length; index++) {
                    let piece = array[index];
                    {
                        if (piece.isResizable()) {
                            piece.setWidth(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(piece.getWidth(), 0.1));
                            piece.setWidthInPlan(piece.getWidth());
                            piece.setDepth(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(piece.getDepth(), 0.1));
                            piece.setDepthInPlan(piece.getDepth());
                            piece.setHeight(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(piece.getHeight(), 0.1));
                            piece.setHeightInPlan(piece.getHeight());
                        }
                        piece.setElevation(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(piece.getElevation(), 0.1));
                    }
                }
            }
        }
        if (this.isModificationState()) {
            this.escape();
        }
        this.setState(this.getDragAndDropState());
        this.moveMouse(x, y);
    }

    /**
     * Deletes in plan view the feedback of the dragged items.
     */
    public stopDraggedItems() {
        if (this.state !== this.getDragAndDropState()) {
            throw new IllegalStateException("Controller isn\'t in a drag and drop state");
        }
        this.draggedItems = null;
        this.setState(this.previousState);
    }

    /**
     * Attempts to modify <code>piece</code> location depending of its context.
     * If the <code>piece</code> is a door or a window and the point (<code>x</code>, <code>y</code>)
     * belongs to a wall, the piece will be resized, rotated and moved so
     * its opening depth is equal to wall thickness and its angle matches wall direction.
     * If the <code>piece</code> isn't a door or a window and the point (<code>x</code>, <code>y</code>)
     * belongs to a wall, the piece will be rotated and moved so
     * its back face lies along the closest wall side and its angle matches wall direction.
     * If the <code>piece</code> isn't a door or a window, its bounding box is included in
     * the one of an other object and its elevation is equal to zero, it will be elevated
     * to appear on the top of the latter.
     * @param {HomePieceOfFurniture} piece
     * @param {number} x
     * @param {number} y
     */
    adjustMagnetizedPieceOfFurniture(piece: HomePieceOfFurniture, x: number, y: number) {
        const pieceElevationAdjusted: boolean = this.adjustPieceOfFurnitureElevation(piece, false, 3.4028235E38) != null;
        const magnetWall: Wall = this.adjustPieceOfFurnitureOnWallAt(piece, x, y, true);
        let referencePiece: HomePieceOfFurniture = null;
        if (!pieceElevationAdjusted) {
            referencePiece = this.adjustPieceOfFurnitureSideBySideAt(piece, magnetWall == null, magnetWall);
        }
        if (referencePiece == null) {
            this.adjustPieceOfFurnitureInShelfBox(piece, magnetWall == null);
        }
    }

    /**
     * Attempts to move and resize <code>piece</code> depending on the wall under the
     * point (<code>x</code>, <code>y</code>) and returns that wall it it exists.
     * @see #adjustMagnetizedPieceOfFurniture(HomePieceOfFurniture, float, float)
     * @param {HomePieceOfFurniture} piece
     * @param {number} x
     * @param {number} y
     * @param {boolean} forceOrientation
     * @return {Wall}
     * @private
     */
    adjustPieceOfFurnitureOnWallAt(piece: HomePieceOfFurniture, x: number, y: number, forceOrientation: boolean): Wall {
        const margin: number = PlanController.PIXEL_MARGIN / this.getScale();
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const piecePoints: number[][] = piece.getPoints();
        const includeBaseboards: boolean = !piece.isDoorOrWindow() && piece.getElevation() === 0;
        const wallsArea: java.awt.geom.Area = this.getWallsArea(includeBaseboards);
        const walls: Array<Wall> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
        let referenceWall: Wall = null;
        let referenceWallArcExtent: number = null;
        if (forceOrientation || !piece.isDoorOrWindow()) {
            for (let index = 0; index < walls.length; index++) {
                let wall = walls[index];
                {
                    if (wall.isAtLevel(selectedLevel) && this.isLevelNullOrViewable(wall.getLevel()) && wall.containsPoint$float$float$boolean$float(x, y, includeBaseboards, 0) && wall.getStartPointToEndPointDistance() > 0) {
                        referenceWall = this.getReferenceWall(wall, x, y);
                        referenceWallArcExtent = wall.getArcExtent();
                        break;
                    }
                }
            }
            if (referenceWall == null) {
                for (let index = 0; index < walls.length; index++) {
                    let wall = walls[index];
                    {
                        if (wall.isAtLevel(selectedLevel) && this.isLevelNullOrViewable(wall.getLevel()) && wall.containsPoint$float$float$boolean$float(x, y, includeBaseboards, 0) && wall.getStartPointToEndPointDistance() > 0) {
                            referenceWall = this.getReferenceWall(wall, x, y);
                            referenceWallArcExtent = wall.getArcExtent();
                            break;
                        }
                    }
                }
            }
        }
        if (referenceWall == null) {
            const pieceAreaWithMargin: java.awt.geom.Area = new java.awt.geom.Area(this.getRotatedRectangle(piece.getX() - piece.getWidthInPlan() / 2 - margin, piece.getY() - piece.getDepthInPlan() / 2 - margin, piece.getWidthInPlan() + 2 * margin, piece.getDepthInPlan() + 2 * margin, piece.getAngle()));
            let intersectionWithReferenceWallSurface: number = 0;
            for (let index = 0; index < walls.length; index++) {
                let wall = walls[index];
                {
                    if (wall.isAtLevel(selectedLevel) && this.isLevelNullOrViewable(wall.getLevel()) && wall.getStartPointToEndPointDistance() > 0) {
                        const wallPoints: number[][] = wall.getPoints$boolean(includeBaseboards);
                        const wallAreaIntersection: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(wallPoints));
                        wallAreaIntersection.intersect(pieceAreaWithMargin);
                        if (!wallAreaIntersection.isEmpty()) {
                            const surface: number = this.getArea(wallAreaIntersection);
                            if (surface > intersectionWithReferenceWallSurface) {
                                intersectionWithReferenceWallSurface = surface;
                                if (forceOrientation) {
                                    referenceWall = this.getReferenceWall(wall, x, y);
                                    referenceWallArcExtent = wall.getArcExtent();
                                } else {
                                    const intersectionBounds: java.awt.geom.Rectangle2D = wallAreaIntersection.getBounds2D();
                                    referenceWall = this.getReferenceWall(wall, <number>intersectionBounds.getCenterX(), <number>intersectionBounds.getCenterY());
                                    referenceWallArcExtent = wall.getArcExtent();
                                }
                            }
                        }
                    }
                }
            }
        }
        if (referenceWall != null) {
            let xPiece: number = x;
            let yPiece: number = y;
            let pieceAngle: number = piece.getAngle();
            const halfWidth: number = piece.getWidthInPlan() / 2;
            let halfDepth: number = piece.getDepthInPlan() / 2;
            const wallAngle: number = Math.atan2(referenceWall.getYEnd() - referenceWall.getYStart(), referenceWall.getXEnd() - referenceWall.getXStart());
            const wallPoints: number[][] = referenceWall.getPoints$boolean(includeBaseboards);
            const magnetizedAtRight: boolean = wallAngle > -Math.PI / 2 && wallAngle <= Math.PI / 2;
            const cosWallAngle: number = Math.cos(wallAngle);
            const sinWallAngle: number = Math.sin(wallAngle);
            const distanceToLeftSide: number = wallPoints[0][0] !== wallPoints[0][1] || wallPoints[1][0] !== wallPoints[1][1] ? java.awt.geom.Line2D.ptLineDist(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], x, y) : java.awt.geom.Point2D.distance(wallPoints[0][0], wallPoints[0][1], x, y);
            const distanceToRightSide: number = wallPoints[2][0] !== wallPoints[2][1] || wallPoints[3][0] !== wallPoints[3][1] ? java.awt.geom.Line2D.ptLineDist(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], x, y) : java.awt.geom.Point2D.distance(wallPoints[2][0], wallPoints[2][1], x, y);
            const adjustOrientation: boolean = forceOrientation || piece.isDoorOrWindow() || referenceWall.containsPoint$float$float$boolean$float(x, y, includeBaseboards, margin);
            if (adjustOrientation) {
                const distanceToPieceLeftSide: number = java.awt.geom.Line2D.ptLineDist(piecePoints[0][0], piecePoints[0][1], piecePoints[3][0], piecePoints[3][1], x, y);
                const distanceToPieceRightSide: number = java.awt.geom.Line2D.ptLineDist(piecePoints[1][0], piecePoints[1][1], piecePoints[2][0], piecePoints[2][1], x, y);
                const distanceToPieceSide: number = pieceAngle > (3 * Math.PI / 2 + 1.0E-6) || pieceAngle < (Math.PI / 2 + 1.0E-6) ? distanceToPieceLeftSide : distanceToPieceRightSide;
                pieceAngle = <number>(distanceToRightSide < distanceToLeftSide ? wallAngle : wallAngle + Math.PI);
                if (piece.isDoorOrWindow()) {
                    const thicknessEpsilon: number = 7.5E-4;
                    let wallDistance: number;
                    if (referenceWallArcExtent == null || /* floatValue */referenceWallArcExtent === 0) {
                        wallDistance = thicknessEpsilon / 2;
                        if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                            const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                            if (piece.isResizable() && this.isItemResizable(piece) && doorOrWindow.isWidthDepthDeformable() && doorOrWindow.getModelTransformations() == null) {
                                piece.setDepth(thicknessEpsilon + referenceWall.getThickness() / doorOrWindow.getWallThickness());
                                piece.setDepthInPlan(piece.getDepth());
                                halfDepth = piece.getDepth() / 2;
                                wallDistance += piece.getDepth() * doorOrWindow.getWallDistance();
                            } else {
                                wallDistance += piece.getDepth() * (doorOrWindow.getWallDistance() + doorOrWindow.getWallThickness()) - referenceWall.getThickness();
                            }
                        }
                    } else {
                        wallDistance = -referenceWall.getThickness() / 2;
                        if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                            const doorOrWindow: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                            wallDistance += piece.getDepth() * (doorOrWindow.getWallDistance() + doorOrWindow.getWallThickness() / 2);
                        }
                    }
                    if (distanceToRightSide < distanceToLeftSide) {
                        xPiece += sinWallAngle * ((distanceToLeftSide + wallDistance) - halfDepth);
                        yPiece += cosWallAngle * (-(distanceToLeftSide + wallDistance) + halfDepth);
                    } else {
                        xPiece += sinWallAngle * (-(distanceToRightSide + wallDistance) + halfDepth);
                        yPiece += cosWallAngle * ((distanceToRightSide + wallDistance) - halfDepth);
                    }
                    if (magnetizedAtRight) {
                        xPiece += cosWallAngle * (halfWidth - distanceToPieceSide);
                        yPiece += sinWallAngle * (halfWidth - distanceToPieceSide);
                    } else {
                        xPiece += -cosWallAngle * (halfWidth - distanceToPieceSide);
                        yPiece += -sinWallAngle * (halfWidth - distanceToPieceSide);
                    }
                } else {
                    if (distanceToRightSide < distanceToLeftSide) {
                        const pointIndicator: number = java.awt.geom.Line2D.relativeCCW(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], x, y);
                        xPiece += pointIndicator * sinWallAngle * distanceToRightSide - sinWallAngle * halfDepth;
                        yPiece += -pointIndicator * cosWallAngle * distanceToRightSide + cosWallAngle * halfDepth;
                    } else {
                        const pointIndicator: number = java.awt.geom.Line2D.relativeCCW(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], x, y);
                        xPiece += -pointIndicator * sinWallAngle * distanceToLeftSide + sinWallAngle * halfDepth;
                        yPiece += pointIndicator * cosWallAngle * distanceToLeftSide - cosWallAngle * halfDepth;
                    }
                    if (magnetizedAtRight) {
                        xPiece += cosWallAngle * (halfWidth - distanceToPieceSide);
                        yPiece += sinWallAngle * (halfWidth - distanceToPieceSide);
                    } else {
                        xPiece += -cosWallAngle * (halfWidth - distanceToPieceSide);
                        yPiece += -sinWallAngle * (halfWidth - distanceToPieceSide);
                    }
                }
            } else {
                const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(referenceWall.getXStart(), referenceWall.getYStart(), referenceWall.getXEnd(), referenceWall.getYEnd());
                const pieceBoundingBox: java.awt.Shape = this.getRotatedRectangle(0, 0, piece.getWidthInPlan(), piece.getDepthInPlan(), <number>(pieceAngle - wallAngle));
                const rotatedBoundingBoxDepth: number = pieceBoundingBox.getBounds2D().getHeight();
                const relativeCCWToPieceCenterSignum: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(centerLine.relativeCCW(piece.getX(), piece.getY()));
                const relativeCCWToPointSignum: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(centerLine.relativeCCW(x, y));
                let distance: number = relativeCCWToPieceCenterSignum * (-referenceWall.getThickness() / 2 + centerLine.ptLineDist(piece.getX(), piece.getY()) - rotatedBoundingBoxDepth / 2);
                if (includeBaseboards) {
                    if (relativeCCWToPieceCenterSignum > 0 && referenceWall.getLeftSideBaseboard() != null) {
                        distance -= relativeCCWToPieceCenterSignum * referenceWall.getLeftSideBaseboard().getThickness();
                    } else if (relativeCCWToPieceCenterSignum < 0 && referenceWall.getRightSideBaseboard() != null) {
                        distance -= relativeCCWToPieceCenterSignum * referenceWall.getRightSideBaseboard().getThickness();
                    }
                }
                if (relativeCCWToPointSignum !== relativeCCWToPieceCenterSignum) {
                    distance -= relativeCCWToPointSignum * (rotatedBoundingBoxDepth + referenceWall.getThickness());
                    if (referenceWall.getLeftSideBaseboard() != null) {
                        distance -= relativeCCWToPointSignum * referenceWall.getLeftSideBaseboard().getThickness();
                    }
                    if (referenceWall.getRightSideBaseboard() != null) {
                        distance -= relativeCCWToPointSignum * referenceWall.getRightSideBaseboard().getThickness();
                    }
                }
                xPiece = piece.getX() + <number>(-distance * sinWallAngle);
                yPiece = piece.getY() + <number>(distance * cosWallAngle);
            }
            if (!piece.isDoorOrWindow() && (referenceWall.getArcExtent() == null || !adjustOrientation || java.awt.geom.Line2D.relativeCCW(referenceWall.getXStart(), referenceWall.getYStart(), referenceWall.getXEnd(), referenceWall.getYEnd(), x, y) > 0)) {
                const wallsAreaIntersection: java.awt.geom.Area = new java.awt.geom.Area(wallsArea);
                const adjustedPieceArea: java.awt.geom.Area = new java.awt.geom.Area(this.getRotatedRectangle(xPiece - halfWidth, yPiece - halfDepth, piece.getWidthInPlan(), piece.getDepthInPlan(), pieceAngle));
                wallsAreaIntersection.subtract(new java.awt.geom.Area(this.getPath$float_A_A(wallPoints)));
                wallsAreaIntersection.intersect(adjustedPieceArea);
                if (!wallsAreaIntersection.isEmpty()) {
                    const closestWallIntersectionPath: java.awt.geom.GeneralPath = this.getClosestPath(this.getAreaPaths(wallsAreaIntersection), x, y);
                    if (closestWallIntersectionPath != null) {
                        adjustedPieceArea.subtract(wallsArea);
                        if (adjustedPieceArea.isEmpty()) {
                            return null;
                        } else {
                            const adjustedPieceAreaPaths: Array<java.awt.geom.GeneralPath> = this.getAreaPaths(adjustedPieceArea);
                            const angleDifference: number = (wallAngle - pieceAngle + 2 * Math.PI) % Math.PI;
                            if (angleDifference < 1.0E-5 || Math.PI - angleDifference < 1.0E-5 || /* size */(<number>adjustedPieceAreaPaths.length) < 2) {
                                const adjustedPiecePathInArea: java.awt.geom.GeneralPath = this.getClosestPath(adjustedPieceAreaPaths, x, y);
                                const adjustingArea: java.awt.geom.Area = new java.awt.geom.Area(closestWallIntersectionPath);
                                for (let index = 0; index < adjustedPieceAreaPaths.length; index++) {
                                    let path = adjustedPieceAreaPaths[index];
                                    {
                                        if (path !== adjustedPiecePathInArea) {
                                            adjustingArea.add(new java.awt.geom.Area(path));
                                        }
                                    }
                                }
                                const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(-wallAngle);
                                const adjustingAreaBounds: java.awt.geom.Rectangle2D = adjustingArea.createTransformedArea(rotation).getBounds2D();
                                const adjustedPiecePathInAreaBounds: java.awt.geom.Rectangle2D = adjustedPiecePathInArea.createTransformedShape(rotation).getBounds2D();
                                if (!adjustingAreaBounds.contains(adjustedPiecePathInAreaBounds)) {
                                    const adjustLeftBorder: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(adjustedPiecePathInAreaBounds.getCenterX() - adjustingAreaBounds.getCenterX());
                                    xPiece += adjustingAreaBounds.getWidth() * cosWallAngle * adjustLeftBorder;
                                    yPiece += adjustingAreaBounds.getWidth() * sinWallAngle * adjustLeftBorder;
                                }
                            }
                        }
                    }
                }
            }
            piece.setAngle(pieceAngle);
            piece.setX(xPiece);
            piece.setY(yPiece);
            if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>piece).setBoundToWall(referenceWallArcExtent == null || /* floatValue */referenceWallArcExtent === 0);
            }
            return referenceWall;
        }
        return null;
    }

    /**
     * Returns <code>true</code> is the given <code>level</code> is viewable.
     * @param {Level} level
     * @return {boolean}
     * @private
     */
    isLevelNullOrViewable(level: Level): boolean {
        return level == null || level.isViewable();
    }

    /**
     * Returns <code>wall</code> or a small wall part at the angle formed by the line joining wall center to
     * (<code>x</code>, <code>y</code>) point if the given <code>wall</code> is round.
     * @param {Wall} wall
     * @param {number} x
     * @param {number} y
     * @return {Wall}
     * @private
     */
    getReferenceWall(wall: Wall, x: number, y: number): Wall {
        const arcExtent: number = wall.getArcExtent();
        if (arcExtent == null || /* floatValue */arcExtent === 0) {
            return wall;
        } else {
            const angle: number = Math.atan2(wall.getYArcCircleCenter() - y, x - wall.getXArcCircleCenter());
            const radius: number = java.awt.geom.Point2D.distance(wall.getXArcCircleCenter(), wall.getYArcCircleCenter(), wall.getXStart(), wall.getYStart());
            const epsilonAngle: number = 0.001;
            const wallPart: Wall = new Wall(<number>(wall.getXArcCircleCenter() + Math.cos(angle + epsilonAngle) * radius), <number>(wall.getYArcCircleCenter() - Math.sin(angle + epsilonAngle) * radius), <number>(wall.getXArcCircleCenter() + Math.cos(angle - epsilonAngle) * radius), <number>(wall.getYArcCircleCenter() - Math.sin(angle - epsilonAngle) * radius), wall.getThickness(), 0);
            wallPart.setLeftSideBaseboard(wall.getLeftSideBaseboard());
            wallPart.setRightSideBaseboard(wall.getRightSideBaseboard());
            return wallPart;
        }
    }

    /**
     * Returns the closest path among <code>paths</code> ones to the given point.
     * @param {java.awt.geom.GeneralPath[]} paths
     * @param {number} x
     * @param {number} y
     * @return {java.awt.geom.GeneralPath}
     * @private
     */
    getClosestPath(paths: Array<java.awt.geom.GeneralPath>, x: number, y: number): java.awt.geom.GeneralPath {
        let closestPath: java.awt.geom.GeneralPath = null;
        let closestPathDistance: number = 1.7976931348623157E308;
        for (let index = 0; index < paths.length; index++) {
            let path = paths[index];
            {
                const pathPoints: number[][] = this.getPathPoints(path, true);
                for (let i: number = 0; i < pathPoints.length; i++) {
                    {
                        const distanceToPath: number = java.awt.geom.Line2D.ptSegDistSq(pathPoints[i][0], pathPoints[i][1], pathPoints[(i + 1) % pathPoints.length][0], pathPoints[(i + 1) % pathPoints.length][1], x, y);
                        if (distanceToPath < closestPathDistance) {
                            closestPathDistance = distanceToPath;
                            closestPath = path;
                        }
                    };
                }
            }
        }
        return closestPath;
    }

    /**
     * Returns the dimension lines that indicates how is placed a given <code>piece</code>
     * along a <code>wall</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {Wall} wall
     * @return {DimensionLine[]}
     * @private
     */
    getDimensionLinesAlongWall(piece: HomePieceOfFurniture, wall: Wall): Array<DimensionLine> {
        const piecePoints: number[][] = piece.getPoints();
        const angle: number = piece.getAngle();
        const wallPoints: number[][] = wall.getPoints$();
        let pieceLeftPoint: number[];
        let pieceRightPoint: number[];
        const piecePoint: number[] = piece.isDoorOrWindow() ? piecePoints[3] : piecePoints[0];
        if (java.awt.geom.Line2D.ptLineDistSq(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], piecePoint[0], piecePoint[1]) <= java.awt.geom.Line2D.ptLineDistSq(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], piecePoint[0], piecePoint[1])) {
            pieceLeftPoint = PlanController.computeIntersection$float_A$float_A$float_A$float_A(wallPoints[0], wallPoints[1], piecePoints[0], piecePoints[3]);
            pieceRightPoint = PlanController.computeIntersection$float_A$float_A$float_A$float_A(wallPoints[0], wallPoints[1], piecePoints[1], piecePoints[2]);
        } else {
            pieceLeftPoint = PlanController.computeIntersection$float_A$float_A$float_A$float_A(wallPoints[2], wallPoints[3], piecePoints[0], piecePoints[3]);
            pieceRightPoint = PlanController.computeIntersection$float_A$float_A$float_A$float_A(wallPoints[2], wallPoints[3], piecePoints[1], piecePoints[2]);
        }
        const dimensionLines: Array<DimensionLine> = <any>([]);
        let wallEndPointJoinedToPieceLeftPoint: number[] = null;
        let wallEndPointJoinedToPieceRightPoint: number[] = null;
        const roomPaths: Array<java.awt.geom.GeneralPath> = this.getRoomPathsFromWalls();
        for (let i: number = 0; i < /* size */(<number>roomPaths.length) && wallEndPointJoinedToPieceLeftPoint == null && wallEndPointJoinedToPieceRightPoint == null; i++) {
            {
                const roomPoints: number[][] = this.getPathPoints(/* get */roomPaths[i], true);
                for (let j: number = 0; j < roomPoints.length; j++) {
                    {
                        const startPoint: number[] = roomPoints[j];
                        const endPoint: number[] = roomPoints[(j + 1) % roomPoints.length];
                        const deltaX: number = endPoint[0] - startPoint[0];
                        const deltaY: number = endPoint[1] - startPoint[1];
                        const segmentAngle: number = Math.abs(deltaX) < 1.0E-5 ? Math.PI / 2 : (Math.abs(deltaY) < 1.0E-5 ? 0 : Math.atan2(deltaY, deltaX));
                        const angleDifference: number = (segmentAngle - angle + 2 * Math.PI) % Math.PI;
                        if (angleDifference < 1.0E-5 || Math.PI - angleDifference < 1.0E-5) {
                            const segmentContainsLeftPoint: boolean = java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], pieceLeftPoint[0], pieceLeftPoint[1]) < 1.0E-4;
                            const segmentContainsRightPoint: boolean = java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], pieceRightPoint[0], pieceRightPoint[1]) < 1.0E-4;
                            if (segmentContainsLeftPoint || segmentContainsRightPoint) {
                                if (segmentContainsLeftPoint) {
                                    const startPointToLeftPointDistance: number = java.awt.geom.Point2D.distanceSq(startPoint[0], startPoint[1], pieceLeftPoint[0], pieceLeftPoint[1]);
                                    const startPointToRightPointDistance: number = java.awt.geom.Point2D.distanceSq(startPoint[0], startPoint[1], pieceRightPoint[0], pieceRightPoint[1]);
                                    if (startPointToLeftPointDistance < startPointToRightPointDistance || !segmentContainsRightPoint) {
                                        wallEndPointJoinedToPieceLeftPoint = /* clone */startPoint.slice(0);
                                    } else {
                                        wallEndPointJoinedToPieceLeftPoint = /* clone */endPoint.slice(0);
                                    }
                                }
                                if (segmentContainsRightPoint) {
                                    const endPointToLeftPointDistance: number = java.awt.geom.Point2D.distanceSq(endPoint[0], endPoint[1], pieceLeftPoint[0], pieceLeftPoint[1]);
                                    const endPointToRightPointDistance: number = java.awt.geom.Point2D.distanceSq(endPoint[0], endPoint[1], pieceRightPoint[0], pieceRightPoint[1]);
                                    if (endPointToLeftPointDistance < endPointToRightPointDistance && segmentContainsLeftPoint) {
                                        wallEndPointJoinedToPieceRightPoint = /* clone */startPoint.slice(0);
                                    } else {
                                        wallEndPointJoinedToPieceRightPoint = /* clone */endPoint.slice(0);
                                    }
                                }
                                break;
                            }
                        }
                    };
                }
            };
        }
        const pieceFrontSideAlongWallSide: boolean = !piece.isDoorOrWindow() && java.awt.geom.Line2D.ptLineDistSq(wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd(), piecePoint[0], piecePoint[1]) > java.awt.geom.Line2D.ptLineDistSq(wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd(), piecePoints[3][0], piecePoints[3][1]);
        if (wallEndPointJoinedToPieceLeftPoint != null) {
            let offset: number;
            if (pieceFrontSideAlongWallSide) {
                offset = -<number>java.awt.geom.Point2D.distance(pieceLeftPoint[0], pieceLeftPoint[1], piecePoints[0][0], piecePoints[0][1]) - 10 / this.getView().getScale();
            } else {
                offset = <number>java.awt.geom.Point2D.distance(pieceLeftPoint[0], pieceLeftPoint[1], piecePoints[3][0], piecePoints[3][1]) + 10 / this.getView().getScale();
            }
            /* add */(dimensionLines.push(this.getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(wallEndPointJoinedToPieceLeftPoint, pieceLeftPoint, offset, 0, false)) > 0);
        }
        if (wallEndPointJoinedToPieceRightPoint != null) {
            let offset: number;
            if (pieceFrontSideAlongWallSide) {
                offset = -<number>java.awt.geom.Point2D.distance(pieceRightPoint[0], pieceRightPoint[1], piecePoints[1][0], piecePoints[1][1]) - 10 / this.getView().getScale();
            } else {
                offset = <number>java.awt.geom.Point2D.distance(pieceRightPoint[0], pieceRightPoint[1], piecePoints[2][0], piecePoints[2][1]) + 10 / this.getView().getScale();
            }
            /* add */(dimensionLines.push(this.getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(pieceRightPoint, wallEndPointJoinedToPieceRightPoint, offset, 0, false)) > 0);
        }
        for (let i: number = /* size */(<number>dimensionLines.length) - 1; i >= 0; i--) {
            {
                if (/* get */dimensionLines[i].getLength() < 0.01) {
                /* remove */dimensionLines.splice(i, 1)[0];
                }
            };
        }
        return dimensionLines;
    }

    static computeIntersection$float_A$float_A$float_A$float_A(point1: number[], point2: number[], point3: number[], point4: number[]): number[] {
        return PlanController.computeIntersection$float$float$float$float$float$float$float$float(point1[0], point1[1], point2[0], point2[1], point3[0], point3[1], point4[0], point4[1]);
    }

    public static computeIntersection$float$float$float$float$float$float$float$float(xPoint1: number, yPoint1: number, xPoint2: number, yPoint2: number, xPoint3: number, yPoint3: number, xPoint4: number, yPoint4: number): number[] {
        let x: number = xPoint2;
        let y: number = yPoint2;
        const alpha1: number = (yPoint2 - yPoint1) / (xPoint2 - xPoint1);
        const alpha2: number = (yPoint4 - yPoint3) / (xPoint4 - xPoint3);
        if (alpha1 !== alpha2) {
            if (Math.abs(alpha1) > 4000) {
                if (Math.abs(alpha2) < 4000) {
                    x = xPoint1;
                    const beta2: number = yPoint4 - alpha2 * xPoint4;
                    y = alpha2 * x + beta2;
                }
            } else if (Math.abs(alpha2) > 4000) {
                if (Math.abs(alpha1) < 4000) {
                    x = xPoint3;
                    const beta1: number = yPoint2 - alpha1 * xPoint2;
                    y = alpha1 * x + beta1;
                }
            } else {
                const sameSignum: boolean = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(alpha1) === /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(alpha2);
                if (Math.abs(alpha1 - alpha2) > 1.0E-5 && (!sameSignum || (Math.abs(alpha1) > Math.abs(alpha2) ? alpha1 / alpha2 : alpha2 / alpha1) > 1.004)) {
                    const beta1: number = yPoint2 - alpha1 * xPoint2;
                    const beta2: number = yPoint4 - alpha2 * xPoint4;
                    x = (beta2 - beta1) / (alpha1 - alpha2);
                    y = alpha1 * x + beta1;
                }
            }
        }
        return [x, y];
    }

    /**
     * Returns the intersection point between the line joining the first two points and
     * the line joining the two last points.
     * @param {number} xPoint1
     * @param {number} yPoint1
     * @param {number} xPoint2
     * @param {number} yPoint2
     * @param {number} xPoint3
     * @param {number} yPoint3
     * @param {number} xPoint4
     * @param {number} yPoint4
     * @return {float[]}
     * @private
     */
    public static computeIntersection(xPoint1?: any, yPoint1?: any, xPoint2?: any, yPoint2?: any, xPoint3?: any, yPoint3?: any, xPoint4?: any, yPoint4?: any): number[] {
        if (((typeof xPoint1 === 'number') || xPoint1 === null) && ((typeof yPoint1 === 'number') || yPoint1 === null) && ((typeof xPoint2 === 'number') || xPoint2 === null) && ((typeof yPoint2 === 'number') || yPoint2 === null) && ((typeof xPoint3 === 'number') || xPoint3 === null) && ((typeof yPoint3 === 'number') || yPoint3 === null) && ((typeof xPoint4 === 'number') || xPoint4 === null) && ((typeof yPoint4 === 'number') || yPoint4 === null)) {
            return <any>PlanController.computeIntersection$float$float$float$float$float$float$float$float(xPoint1, yPoint1, xPoint2, yPoint2, xPoint3, yPoint3, xPoint4, yPoint4);
        } else if (((xPoint1 != null && xPoint1 instanceof <any>Array && (xPoint1.length == 0 || xPoint1[0] == null || (typeof xPoint1[0] === 'number'))) || xPoint1 === null) && ((yPoint1 != null && yPoint1 instanceof <any>Array && (yPoint1.length == 0 || yPoint1[0] == null || (typeof yPoint1[0] === 'number'))) || yPoint1 === null) && ((xPoint2 != null && xPoint2 instanceof <any>Array && (xPoint2.length == 0 || xPoint2[0] == null || (typeof xPoint2[0] === 'number'))) || xPoint2 === null) && ((yPoint2 != null && yPoint2 instanceof <any>Array && (yPoint2.length == 0 || yPoint2[0] == null || (typeof yPoint2[0] === 'number'))) || yPoint2 === null) && xPoint3 === undefined && yPoint3 === undefined && xPoint4 === undefined && yPoint4 === undefined) {
            return <any>PlanController.computeIntersection$float_A$float_A$float_A$float_A(xPoint1, yPoint1, xPoint2, yPoint2);
        } else throw new Error('invalid overload');
    }

    /**
     * Attempts to elevate <code>piece</code> depending on the shelf units which surrounds it or the highest piece that includes
     * its bounding box and returns that piece.
     * @see #adjustMagnetizedPieceOfFurniture(HomePieceOfFurniture, float, float)
     * @param {HomePieceOfFurniture} piece
     * @param {boolean} adjustOnlyNullElevation
     * @param {number} margin
     * @return {HomePieceOfFurniture}
     * @private
     */
    adjustPieceOfFurnitureElevation(piece: HomePieceOfFurniture, adjustOnlyNullElevation: boolean, margin: number): HomePieceOfFurniture {
        if (!adjustOnlyNullElevation || !piece.isDoorOrWindow() && piece.getElevation() === 0) {
            let distanceToClosestShelf: number = 3.4028235E38;
            const pieceElevation: number = piece.getElevation();
            let closestShelfElevation: number = pieceElevation;
            let surroundingFurniture: Array<HomePieceOfFurniture>;
            if (adjustOnlyNullElevation || piece.getElevation() === 0) {
                const highestSurroundingPiece: HomePieceOfFurniture = this.getHighestSurroundingPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
                if (highestSurroundingPiece != null) {
                    surroundingFurniture = /* asList */[highestSurroundingPiece];
                } else {
                    return null;
                }
            } else {
                surroundingFurniture = this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
                let containsShelfUnits: boolean = false;
                for (let index = 0; index < surroundingFurniture.length; index++) {
                    let surroundingPiece = surroundingFurniture[index];
                    {
                        if (surroundingPiece != null && surroundingPiece instanceof <any>HomeShelfUnit) {
                            containsShelfUnits = true;
                        }
                    }
                }
                if (!containsShelfUnits) {
                    return null;
                }
            }
            for (let index = 0; index < surroundingFurniture.length; index++) {
                let surroundingPiece = surroundingFurniture[index];
                {
                    let shelfElevations: number[] = [];
                    if (!adjustOnlyNullElevation && (surroundingPiece != null && surroundingPiece instanceof <any>HomeShelfUnit) && !surroundingPiece.isHorizontallyRotated()) {
                        const shelfUnit: HomeShelfUnit = <HomeShelfUnit>surroundingPiece;
                        const shelfBoxes: BoxBounds[] = shelfUnit.getShelfBoxes();
                        if (shelfBoxes.length > 0) {
                            shelfElevations = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(shelfBoxes.length);
                            for (let i: number = 0; i < shelfElevations.length; i++) {
                                {
                                    shelfElevations[i] = shelfBoxes[i].getZLower();
                                };
                            }
                        } else {
                            shelfElevations = shelfUnit.getShelfElevations();
                        }
                    }
                    if (shelfElevations.length === 0 || shelfElevations[0] !== 0 && piece.getElevation() === 0) {
                        shelfElevations = [surroundingPiece.getDropOnTopElevation()];
                    }
                    if (shelfElevations.length !== 0) {
                        for (let index1 = 0; index1 < shelfElevations.length; index1++) {
                            let shelfElevation = shelfElevations[index1];
                            {
                                let elevation: number = surroundingPiece.getElevation();
                                if (surroundingPiece.isHorizontallyRotated()) {
                                    elevation += surroundingPiece.getHeightInPlan();
                                } else {
                                    elevation += surroundingPiece.getHeight() * shelfElevation;
                                }
                                if (surroundingPiece.getLevel() != null) {
                                    elevation += surroundingPiece.getLevel().getElevation() - (piece.getLevel() != null ? piece.getLevel().getElevation() : this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel().getElevation());
                                }
                                const distanceToShelf: number = Math.abs(pieceElevation - elevation);
                                if (distanceToClosestShelf > distanceToShelf) {
                                    distanceToClosestShelf = distanceToShelf;
                                    closestShelfElevation = elevation;
                                }
                            }
                        }
                    }
                }
            }
            if (closestShelfElevation !== pieceElevation && Math.abs(closestShelfElevation - pieceElevation) < margin) {
                piece.setElevation(closestShelfElevation);
                return piece;
            }
        }
        return null;
    }

    /**
     * Attempts to align <code>piece</code> on the borders of home furniture at the same elevation
     * that intersects with it and returns that piece.
     * @see #adjustMagnetizedPieceOfFurniture(HomePieceOfFurniture, float, float)
     * @param {HomePieceOfFurniture} piece
     * @param {boolean} forceOrientation
     * @param {Wall} magnetWall
     * @return {HomePieceOfFurniture}
     * @private
     */
    adjustPieceOfFurnitureSideBySideAt(piece: HomePieceOfFurniture, forceOrientation: boolean, magnetWall: Wall): HomePieceOfFurniture {
        let piecePoints: number[][] = piece.getPoints();
        const pieceArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(piecePoints));
        const doorOrWindowBoundToWall: boolean = (piece != null && piece instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>piece).isBoundToWall();
        const pieceElevation: number = piece.getGroundElevation();
        const margin: number = 2 * PlanController.PIXEL_MARGIN / this.getScale();
        let referencePiece: HomePieceOfFurniture = null;
        let intersectionWithReferencePieceArea: java.awt.geom.Area = null;
        let intersectionWithReferencePieceSurface: number = 0;
        let referencePiecePoints: number[][] = null;
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let homePiece = array[index];
                {
                    const homePieceElevation: number = homePiece.getGroundElevation();
                    if (homePiece !== piece && this.isPieceOfFurnitureVisibleAtSelectedLevel(homePiece) && pieceElevation < homePieceElevation + homePiece.getHeightInPlan() && pieceElevation + piece.getHeightInPlan() > homePieceElevation && (!doorOrWindowBoundToWall || homePiece.isDoorOrWindow())) {
                        const points: number[][] = homePiece.getPoints();
                        let marginArea: java.awt.geom.Area;
                        if (doorOrWindowBoundToWall && homePiece.isDoorOrWindow()) {
                            marginArea = new java.awt.geom.Area(this.getPath$float_A_A(new Wall(points[1][0], points[1][1], points[2][0], points[2][1], margin, 0).getPoints$()));
                            marginArea.add(new java.awt.geom.Area(this.getPath$float_A_A(new Wall(points[3][0], points[3][1], points[0][0], points[0][1], margin, 0).getPoints$())));
                        } else {
                            marginArea = /* get */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries[i].value; } return null; })(<any>this.furnitureSidesCache, homePiece);
                            if (marginArea == null) {
                                const pieceSideWalls: Wall[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(points.length);
                                for (let i: number = 0; i < pieceSideWalls.length; i++) {
                                    {
                                        pieceSideWalls[i] = new Wall(points[i][0], points[i][1], points[(i + 1) % pieceSideWalls.length][0], points[(i + 1) % pieceSideWalls.length][1], margin, 0);
                                    };
                                }
                                for (let i: number = 0; i < pieceSideWalls.length; i++) {
                                    {
                                        pieceSideWalls[(i + 1) % pieceSideWalls.length].setWallAtStart(pieceSideWalls[i]);
                                        pieceSideWalls[i].setWallAtEnd(pieceSideWalls[(i + 1) % pieceSideWalls.length]);
                                    };
                                }
                                const pieceSidePoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(pieceSideWalls.length * 2 + 2);
                                let pieceSideWallPoints: number[][] = null;
                                for (let i: number = 0; i < pieceSideWalls.length; i++) {
                                    {
                                        pieceSideWallPoints = pieceSideWalls[i].getPoints$();
                                        pieceSidePoints[i] = pieceSideWallPoints[0];
                                        pieceSidePoints[pieceSidePoints.length - i - 1] = pieceSideWallPoints[3];
                                    };
                                }
                                pieceSidePoints[(pieceSidePoints.length / 2 | 0) - 1] = pieceSideWallPoints[1];
                                pieceSidePoints[(pieceSidePoints.length / 2 | 0)] = pieceSideWallPoints[2];
                                marginArea = new java.awt.geom.Area(this.getPath$float_A_A(pieceSidePoints));
                                /* put */((m, k, v) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { m.entries[i].value = v; return; } m.entries.push({ key: k, value: v, getKey: function () { return this.key }, getValue: function () { return this.value } }); })(<any>this.furnitureSidesCache, homePiece, marginArea);
                            }
                        }
                        const intersection: java.awt.geom.Area = new java.awt.geom.Area(marginArea);
                        intersection.intersect(pieceArea);
                        if (!intersection.isEmpty()) {
                            const exclusiveOr: java.awt.geom.Area = new java.awt.geom.Area(pieceArea);
                            exclusiveOr.exclusiveOr(intersection);
                            if (exclusiveOr.isSingular()) {
                                const insideArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(points));
                                insideArea.subtract(marginArea);
                                insideArea.intersect(pieceArea);
                                if (insideArea.isEmpty()) {
                                    const surface: number = this.getArea(intersection);
                                    if (surface > intersectionWithReferencePieceSurface) {
                                        intersectionWithReferencePieceSurface = surface;
                                        referencePiece = homePiece;
                                        referencePiecePoints = points;
                                        intersectionWithReferencePieceArea = intersection;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (referencePiece != null) {
            let alignedOnReferencePieceFrontOrBackSide: boolean;
            if (doorOrWindowBoundToWall && referencePiece.isDoorOrWindow()) {
                alignedOnReferencePieceFrontOrBackSide = false;
            } else {
                const referencePieceLargerBoundingBox: java.awt.geom.GeneralPath = this.getRotatedRectangle(referencePiece.getX() - referencePiece.getWidthInPlan(), referencePiece.getY() - referencePiece.getDepthInPlan(), referencePiece.getWidthInPlan() * 2, referencePiece.getDepthInPlan() * 2, referencePiece.getAngle());
                const pathPoints: number[][] = this.getPathPoints(referencePieceLargerBoundingBox, false);
                alignedOnReferencePieceFrontOrBackSide = this.isAreaLargerOnFrontOrBackSide(intersectionWithReferencePieceArea, pathPoints);
            }
            if (forceOrientation) {
                piece.setAngle(referencePiece.getAngle());
            }
            const pieceBoundingBox: java.awt.Shape = this.getRotatedRectangle(0, 0, piece.getWidthInPlan(), piece.getDepthInPlan(), piece.getAngle() - referencePiece.getAngle());
            let deltaX: number = 0;
            let deltaY: number = 0;
            if (!alignedOnReferencePieceFrontOrBackSide) {
                const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(referencePiece.getX(), referencePiece.getY(), (referencePiecePoints[0][0] + referencePiecePoints[1][0]) / 2, (referencePiecePoints[0][1] + referencePiecePoints[1][1]) / 2);
                const rotatedBoundingBoxWidth: number = pieceBoundingBox.getBounds2D().getWidth();
                const distance: number = centerLine.relativeCCW(piece.getX(), piece.getY()) * (-referencePiece.getWidthInPlan() / 2 + centerLine.ptLineDist(piece.getX(), piece.getY()) - rotatedBoundingBoxWidth / 2);
                deltaX = <number>(distance * Math.cos(referencePiece.getAngle()));
                deltaY = <number>(distance * Math.sin(referencePiece.getAngle()));
            } else {
                const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(referencePiece.getX(), referencePiece.getY(), (referencePiecePoints[2][0] + referencePiecePoints[1][0]) / 2, (referencePiecePoints[2][1] + referencePiecePoints[1][1]) / 2);
                const rotatedBoundingBoxDepth: number = pieceBoundingBox.getBounds2D().getHeight();
                const distance: number = centerLine.relativeCCW(piece.getX(), piece.getY()) * (-referencePiece.getDepthInPlan() / 2 + centerLine.ptLineDist(piece.getX(), piece.getY()) - rotatedBoundingBoxDepth / 2);
                deltaX = <number>(-distance * Math.sin(referencePiece.getAngle()));
                deltaY = <number>(distance * Math.cos(referencePiece.getAngle()));
                if (!this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_Wall$float$float(piece, magnetWall, deltaX, deltaY)) {
                    deltaX = deltaY = 0;
                }
            }
            if (!this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$float$float(piece, referencePiece, deltaX, deltaY)) {
                piece.move(deltaX, deltaY);
                return referencePiece;
            } else {
                if (forceOrientation) {
                    piecePoints = piece.getPoints();
                }
                const alignedOnPieceFrontOrBackSide: boolean = this.isAreaLargerOnFrontOrBackSide(intersectionWithReferencePieceArea, piecePoints);
                const referencePieceBoundingBox: java.awt.Shape = this.getRotatedRectangle(0, 0, referencePiece.getWidthInPlan(), referencePiece.getDepthInPlan(), referencePiece.getAngle() - piece.getAngle());
                if (!alignedOnPieceFrontOrBackSide) {
                    const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(piece.getX(), piece.getY(), (piecePoints[0][0] + piecePoints[1][0]) / 2, (piecePoints[0][1] + piecePoints[1][1]) / 2);
                    const rotatedBoundingBoxWidth: number = referencePieceBoundingBox.getBounds2D().getWidth();
                    const distance: number = centerLine.relativeCCW(referencePiece.getX(), referencePiece.getY()) * (-piece.getWidthInPlan() / 2 + centerLine.ptLineDist(referencePiece.getX(), referencePiece.getY()) - rotatedBoundingBoxWidth / 2);
                    deltaX = -<number>(distance * Math.cos(piece.getAngle()));
                    deltaY = -<number>(distance * Math.sin(piece.getAngle()));
                } else {
                    const centerLine: java.awt.geom.Line2D = new java.awt.geom.Line2D.Float(piece.getX(), piece.getY(), (piecePoints[2][0] + piecePoints[1][0]) / 2, (piecePoints[2][1] + piecePoints[1][1]) / 2);
                    const rotatedBoundingBoxDepth: number = referencePieceBoundingBox.getBounds2D().getHeight();
                    const distance: number = centerLine.relativeCCW(referencePiece.getX(), referencePiece.getY()) * (-piece.getDepthInPlan() / 2 + centerLine.ptLineDist(referencePiece.getX(), referencePiece.getY()) - rotatedBoundingBoxDepth / 2);
                    deltaX = -<number>(-distance * Math.sin(piece.getAngle()));
                    deltaY = -<number>(distance * Math.cos(piece.getAngle()));
                    if (!this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_Wall$float$float(piece, magnetWall, deltaX, deltaY)) {
                        deltaX = deltaY = 0;
                    }
                }
                if (!this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$float$float(piece, referencePiece, deltaX, deltaY)) {
                    piece.move(deltaX, deltaY);
                    return referencePiece;
                }
            }
        }
        return null;
    }

    /**
     * Attempts to keep <code>piece</code> in the shelf boxes it intersects with at the same elevation
     * and returns that shelf unit.
     * @see #adjustMagnetizedPieceOfFurniture(HomePieceOfFurniture, float, float)
     * @param {HomePieceOfFurniture} piece
     * @param {boolean} forceOrientation
     * @return {HomePieceOfFurniture}
     * @private
     */
    adjustPieceOfFurnitureInShelfBox(piece: HomePieceOfFurniture, forceOrientation: boolean): HomePieceOfFurniture {
        const pieceElevation: number = piece.getGroundElevation();
        let piecePoints: number[][] = piece.getPoints();
        let pieceArea: java.awt.geom.Area = null;
        let largestIntersectionSurface: number = 0;
        let intersectedShelfUnit: HomeShelfUnit = null;
        let largestShelfPoints: java.awt.geom.Point2D[] = null;
        const surroundingFurniture: Array<HomePieceOfFurniture> = this.getSurroundingFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(piece);
        let pieceSurface: number = 0;
        for (let index = 0; index < surroundingFurniture.length; index++) {
            let surroundingPiece = surroundingFurniture[index];
            {
                if ((surroundingPiece != null && surroundingPiece instanceof <any>HomeShelfUnit) && !surroundingPiece.isHorizontallyRotated()) {
                    const shelfUnit: HomeShelfUnit = <HomeShelfUnit>surroundingPiece;
                    const shelfUnitElevation: number = shelfUnit.getGroundElevation();
                    {
                        let array = shelfUnit.getShelfBoxes();
                        for (let index1 = 0; index1 < array.length; index1++) {
                            let shelfBox = array[index1];
                            {
                                if (Math.abs(shelfUnitElevation + shelfBox.getZLower() * shelfUnit.getHeight() - pieceElevation) < 0.1) {
                                    const shelfPoints: java.awt.geom.Point2D[] = [new java.awt.geom.Point2D.Float(shelfBox.getXLower() * shelfUnit.getWidth(), (1 - shelfBox.getYUpper()) * shelfUnit.getDepth()), new java.awt.geom.Point2D.Float(shelfBox.getXUpper() * shelfUnit.getWidth(), (1 - shelfBox.getYUpper()) * shelfUnit.getDepth()), new java.awt.geom.Point2D.Float(shelfBox.getXUpper() * shelfUnit.getWidth(), (1 - shelfBox.getYLower()) * shelfUnit.getDepth()), new java.awt.geom.Point2D.Float(shelfBox.getXLower() * shelfUnit.getWidth(), (1 - shelfBox.getYLower()) * shelfUnit.getDepth())];
                                    const transform: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getTranslateInstance(shelfUnit.getX() - shelfUnit.getWidth() / 2, shelfUnit.getY() - shelfUnit.getDepth() / 2);
                                    transform.concatenate(java.awt.geom.AffineTransform.getRotateInstance(shelfUnit.getAngle(), shelfUnit.getWidth() / 2, shelfUnit.getDepth() / 2));
                                    if (shelfUnit.isModelMirrored()) {
                                        transform.concatenate(new java.awt.geom.AffineTransform(-1, 0, 0, 1, shelfUnit.getWidth(), 0));
                                    }
                                    for (let i: number = 0; i < shelfPoints.length; i++) {
                                        {
                                            transform.transform(shelfPoints[i], shelfPoints[i]);
                                        };
                                    }
                                    const shelfPath: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
                                    shelfPath.moveTo(<number>shelfPoints[0].getX(), <number>shelfPoints[0].getY());
                                    shelfPath.lineTo(<number>shelfPoints[1].getX(), <number>shelfPoints[1].getY());
                                    shelfPath.lineTo(<number>shelfPoints[2].getX(), <number>shelfPoints[2].getY());
                                    shelfPath.lineTo(<number>shelfPoints[3].getX(), <number>shelfPoints[3].getY());
                                    shelfPath.closePath();
                                    const intersectionWithShelf: java.awt.geom.Area = new java.awt.geom.Area(shelfPath);
                                    if (pieceArea == null) {
                                        pieceArea = new java.awt.geom.Area(this.getPath$float_A_A(piecePoints));
                                    }
                                    intersectionWithShelf.intersect(pieceArea);
                                    if (!intersectionWithShelf.isEmpty()) {
                                        if (pieceSurface === 0) {
                                            pieceSurface = this.getArea(pieceArea);
                                        }
                                        const intersectionSurface: number = pieceSurface - this.getArea(intersectionWithShelf);
                                        intersectedShelfUnit = shelfUnit;
                                        if (Math.abs(intersectionSurface) > 0.01 && intersectionSurface < pieceSurface / 4 && largestIntersectionSurface < intersectionSurface) {
                                            largestIntersectionSurface = intersectionSurface;
                                            largestShelfPoints = shelfPoints;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (forceOrientation && intersectedShelfUnit != null) {
            piece.setAngle(intersectedShelfUnit.getAngle());
            piecePoints = piece.getPoints();
        }
        if (largestShelfPoints != null) {
            let widthDelta: number = 0;
            for (let i: number = 0; i < piecePoints.length; i++) {
                {
                    if (java.awt.geom.Line2D.relativeCCW(largestShelfPoints[0].getX(), largestShelfPoints[0].getY(), largestShelfPoints[3].getX(), largestShelfPoints[3].getY(), piecePoints[i][0], piecePoints[i][1]) === (intersectedShelfUnit.isModelMirrored() ? 1 : -1)) {
                        const distance: number = <number>java.awt.geom.Line2D.ptLineDistSq(largestShelfPoints[0].getX(), largestShelfPoints[0].getY(), largestShelfPoints[3].getX(), largestShelfPoints[3].getY(), piecePoints[i][0], piecePoints[i][1]);
                        if (distance > widthDelta) {
                            widthDelta = distance;
                        }
                    }
                };
            }
            if (widthDelta > 0) {
                widthDelta = <number>Math.sqrt(widthDelta) * (intersectedShelfUnit.isModelMirrored() ? -1 : 1);
                piece.move(widthDelta * <number>Math.cos(intersectedShelfUnit.getAngle()), widthDelta * <number>Math.sin(intersectedShelfUnit.getAngle()));
            } else {
                for (let i: number = 0; i < piecePoints.length; i++) {
                    {
                        if (java.awt.geom.Line2D.relativeCCW(largestShelfPoints[1].getX(), largestShelfPoints[1].getY(), largestShelfPoints[2].getX(), largestShelfPoints[2].getY(), piecePoints[i][0], piecePoints[i][1]) === (intersectedShelfUnit.isModelMirrored() ? -1 : 1)) {
                            const distance: number = <number>java.awt.geom.Line2D.ptLineDistSq(largestShelfPoints[1].getX(), largestShelfPoints[1].getY(), largestShelfPoints[2].getX(), largestShelfPoints[2].getY(), piecePoints[i][0], piecePoints[i][1]);
                            if (distance > widthDelta) {
                                widthDelta = distance;
                            }
                        }
                    };
                }
                if (widthDelta > 0) {
                    widthDelta = <number>Math.sqrt(widthDelta) * (intersectedShelfUnit.isModelMirrored() ? 1 : -1);
                    piece.move(widthDelta * <number>Math.cos(intersectedShelfUnit.getAngle()), widthDelta * <number>Math.sin(intersectedShelfUnit.getAngle()));
                }
            }
            let depthDelta: number = 0;
            for (let i: number = 0; i < piecePoints.length; i++) {
                {
                    if (java.awt.geom.Line2D.relativeCCW(largestShelfPoints[0].getX(), largestShelfPoints[0].getY(), largestShelfPoints[1].getX(), largestShelfPoints[1].getY(), piecePoints[i][0], piecePoints[i][1]) === (intersectedShelfUnit.isModelMirrored() ? -1 : 1)) {
                        const distance: number = <number>java.awt.geom.Line2D.ptLineDistSq(largestShelfPoints[0].getX(), largestShelfPoints[0].getY(), largestShelfPoints[1].getX(), largestShelfPoints[1].getY(), piecePoints[i][0], piecePoints[i][1]);
                        if (distance > depthDelta) {
                            depthDelta = distance;
                        }
                    }
                };
            }
            if (depthDelta > 0) {
                depthDelta = <number>Math.sqrt(depthDelta);
                piece.move(depthDelta * -<number>Math.sin(intersectedShelfUnit.getAngle()), depthDelta * <number>Math.cos(intersectedShelfUnit.getAngle()));
            } else {
                for (let i: number = 0; i < piecePoints.length; i++) {
                    {
                        if (java.awt.geom.Line2D.relativeCCW(largestShelfPoints[3].getX(), largestShelfPoints[3].getY(), largestShelfPoints[2].getX(), largestShelfPoints[2].getY(), piecePoints[i][0], piecePoints[i][1]) === (intersectedShelfUnit.isModelMirrored() ? 1 : -1)) {
                            const distance: number = <number>java.awt.geom.Line2D.ptLineDistSq(largestShelfPoints[3].getX(), largestShelfPoints[3].getY(), largestShelfPoints[2].getX(), largestShelfPoints[2].getY(), piecePoints[i][0], piecePoints[i][1]);
                            if (distance > depthDelta) {
                                depthDelta = distance;
                            }
                        }
                    };
                }
                if (depthDelta > 0) {
                    depthDelta = -<number>Math.sqrt(depthDelta);
                    piece.move(depthDelta * -<number>Math.sin(intersectedShelfUnit.getAngle()), depthDelta * <number>Math.cos(intersectedShelfUnit.getAngle()));
                }
            }
            return intersectedShelfUnit;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if the intersection between the given <code>area</code> and
     * the front or back sides of the rectangle defined by <code>piecePoints</code> is larger
     * than with the left and right sides of this rectangle.
     * @param {java.awt.geom.Area} area
     * @param {float[][]} piecePoints
     * @return {boolean}
     * @private
     */
    isAreaLargerOnFrontOrBackSide(area: java.awt.geom.Area, piecePoints: number[][]): boolean {
        const pieceFrontAndBackQuarters: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
        pieceFrontAndBackQuarters.moveTo(piecePoints[0][0], piecePoints[0][1]);
        pieceFrontAndBackQuarters.lineTo(piecePoints[2][0], piecePoints[2][1]);
        pieceFrontAndBackQuarters.lineTo(piecePoints[3][0], piecePoints[3][1]);
        pieceFrontAndBackQuarters.lineTo(piecePoints[1][0], piecePoints[1][1]);
        pieceFrontAndBackQuarters.closePath();
        const intersectionWithFrontOrBack: java.awt.geom.Area = new java.awt.geom.Area(area);
        intersectionWithFrontOrBack.intersect(new java.awt.geom.Area(pieceFrontAndBackQuarters));
        if (intersectionWithFrontOrBack.isEmpty()) {
            return false;
        } else {
            const pieceLeftAndRightQuarters: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
            pieceLeftAndRightQuarters.moveTo(piecePoints[0][0], piecePoints[0][1]);
            pieceLeftAndRightQuarters.lineTo(piecePoints[2][0], piecePoints[2][1]);
            pieceLeftAndRightQuarters.lineTo(piecePoints[1][0], piecePoints[1][1]);
            pieceLeftAndRightQuarters.lineTo(piecePoints[3][0], piecePoints[3][1]);
            pieceLeftAndRightQuarters.closePath();
            const intersectionWithLeftAndRight: java.awt.geom.Area = new java.awt.geom.Area(area);
            intersectionWithLeftAndRight.intersect(new java.awt.geom.Area(pieceLeftAndRightQuarters));
            return this.getArea(intersectionWithFrontOrBack) > this.getArea(intersectionWithLeftAndRight);
        }
    }

    /**
     * Returns the area of the given shape.
     * @param {java.awt.geom.Area} area
     * @return {number}
     * @private
     */
    getArea(area: java.awt.geom.Area): number {
        const pathPoints: number[][] = this.getPathPoints(this.getPath$java_awt_geom_Area(area), false);
        if (pathPoints.length > 1) {
            return new Room(pathPoints).getArea();
        } else {
            return 0;
        }
    }

    public isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$float$float(piece1: HomePieceOfFurniture, piece2: HomePieceOfFurniture, deltaX: number, deltaY: number): boolean {
        const intersection: java.awt.geom.Area = new java.awt.geom.Area(this.getRotatedRectangle(piece1.getX() - piece1.getWidthInPlan() / 2 + deltaX, piece1.getY() - piece1.getDepthInPlan() / 2 + deltaY, piece1.getWidthInPlan(), piece1.getDepth(), piece1.getAngle()));
        const epsilon: number = 0.01;
        intersection.intersect(new java.awt.geom.Area(this.getRotatedRectangle(piece2.getX() - piece2.getWidthInPlan() / 2 - epsilon, piece2.getY() - piece2.getDepthInPlan() / 2 - epsilon, piece2.getWidthInPlan() + 2 * epsilon, piece2.getDepthInPlan() + 2 * epsilon, piece2.getAngle())));
        return intersection.isEmpty();
    }

    /**
     * Returns <code>true</code> if the given pieces don't intersect once the first is moved from
     * (<code>deltaX</code>, <code>deltaY</code>) vector.
     * @param {HomePieceOfFurniture} piece1
     * @param {HomePieceOfFurniture} piece2
     * @param {number} deltaX
     * @param {number} deltaY
     * @return {boolean}
     * @private
     */
    public isIntersectionEmpty(piece1?: any, piece2?: any, deltaX?: any, deltaY?: any): boolean {
        if (((piece1 != null && piece1 instanceof <any>HomePieceOfFurniture) || piece1 === null) && ((piece2 != null && piece2 instanceof <any>HomePieceOfFurniture) || piece2 === null) && ((typeof deltaX === 'number') || deltaX === null) && ((typeof deltaY === 'number') || deltaY === null)) {
            return <any>this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture$float$float(piece1, piece2, deltaX, deltaY);
        } else if (((piece1 != null && piece1 instanceof <any>HomePieceOfFurniture) || piece1 === null) && ((piece2 != null && piece2 instanceof <any>Wall) || piece2 === null) && ((typeof deltaX === 'number') || deltaX === null) && ((typeof deltaY === 'number') || deltaY === null)) {
            return <any>this.isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_Wall$float$float(piece1, piece2, deltaX, deltaY);
        } else throw new Error('invalid overload');
    }

    isIntersectionEmpty$com_eteks_sweethome3d_model_HomePieceOfFurniture$com_eteks_sweethome3d_model_Wall$float$float(piece: HomePieceOfFurniture, wall: Wall, deltaX: number, deltaY: number): boolean {
        if (wall != null) {
            const wallAreaIntersection: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(wall.getPoints$()));
            wallAreaIntersection.intersect(new java.awt.geom.Area(this.getRotatedRectangle(piece.getX() - piece.getWidthInPlan() / 2 + deltaX, piece.getY() - piece.getDepthInPlan() / 2 + deltaY, piece.getWidthInPlan(), piece.getDepthInPlan(), piece.getAngle())));
            return this.getArea(wallAreaIntersection) < 1.0E-4;
        }
        return true;
    }

    /**
     * Returns the shape of the given rectangle rotated of a given <code>angle</code>.
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} angle
     * @return {java.awt.geom.GeneralPath}
     * @private
     */
    getRotatedRectangle(x: number, y: number, width: number, height: number, angle: number): java.awt.geom.GeneralPath {
        const referencePieceLargerBoundingBox: java.awt.geom.Rectangle2D = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
        const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(angle, x + width / 2, y + height / 2);
        const rotatedBoundingBox: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
        rotatedBoundingBox.append(referencePieceLargerBoundingBox.getPathIterator(rotation), false);
        return rotatedBoundingBox;
    }

    /**
     * Returns the dimension line that measures the side of a piece, the length of a room side
     * or the length of a wall side at (<code>x</code>, <code>y</code>) point,
     * or <code>null</code> if it doesn't exist.
     * @param {number} x
     * @param {number} y
     * @param {boolean} magnetismEnabled
     * @return {DimensionLine}
     * @private
     */
    getMeasuringDimensionLineAt(x: number, y: number, magnetismEnabled: boolean): DimensionLine {
        const margin: number = this.getSelectionMargin();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    if (this.isPieceOfFurnitureVisibleAtSelectedLevel(piece)) {
                        const dimensionLine: DimensionLine = this.getDimensionLineBetweenPointsAt(piece.getPoints(), x, y, margin, magnetismEnabled);
                        if (dimensionLine != null) {
                            return dimensionLine;
                        }
                    }
                }
            }
        }
        {
            let array = this.getRoomPathsFromWalls();
            for (let index = 0; index < array.length; index++) {
                let roomPath = array[index];
                {
                    if (roomPath.intersects(x - margin, y - margin, 2 * margin, 2 * margin)) {
                        const dimensionLine: DimensionLine = this.getDimensionLineBetweenPointsAt(this.getPathPoints(roomPath, true), x, y, margin, magnetismEnabled);
                        if (dimensionLine != null) {
                            return dimensionLine;
                        }
                    }
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
            for (let index = 0; index < array.length; index++) {
                let room = array[index];
                {
                    if (this.isLevelNullOrViewable(room.getLevel()) && room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel())) {
                        const dimensionLine: DimensionLine = this.getDimensionLineBetweenPointsAt(room.getPoints(), x, y, margin, magnetismEnabled);
                        if (dimensionLine != null) {
                            return dimensionLine;
                        }
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns the dimension line that measures the side of the given polygon at (<code>x</code>, <code>y</code>) point,
     * or <code>null</code> if it doesn't exist.
     * @param {float[][]} points
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @param {boolean} magnetismEnabled
     * @return {DimensionLine}
     * @private
     */
    getDimensionLineBetweenPointsAt(points: number[][], x: number, y: number, margin: number, magnetismEnabled: boolean): DimensionLine {
        for (let i: number = 0; i < points.length; i++) {
            {
                const nextPointIndex: number = (i + 1) % points.length;
                const distanceBetweenPointsSq: number = java.awt.geom.Point2D.distanceSq(points[i][0], points[i][1], points[nextPointIndex][0], points[nextPointIndex][1]);
                if (distanceBetweenPointsSq > 0.01 && java.awt.geom.Line2D.ptSegDistSq(points[i][0], points[i][1], points[nextPointIndex][0], points[nextPointIndex][1], x, y) <= margin * margin) {
                    return this.getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(points[i], points[nextPointIndex], 0, distanceBetweenPointsSq, magnetismEnabled);
                }
            };
        }
        return null;
    }

    getDimensionLineBetweenPoints$float_A$float_A$float$boolean(point1: number[], point2: number[], offset: number, magnetismEnabled: boolean): DimensionLine {
        return this.getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(point1, point2, offset, java.awt.geom.Point2D.distanceSq(point1[0], point1[1], point2[0], point2[1]), magnetismEnabled);
    }

    public getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(point1: number[], point2: number[], offset: number, distanceBetweenPointsSq: number, magnetismEnabled: boolean): DimensionLine {
        const angle: number = Math.atan2(point1[1] - point2[1], point2[0] - point1[0]);
        const reverse: boolean = angle <= -Math.PI / 2 || angle > Math.PI / 2;
        let xStart: number;
        let yStart: number;
        let xEnd: number;
        let yEnd: number;
        if (reverse) {
            xStart = point2[0];
            yStart = point2[1];
            xEnd = point1[0];
            yEnd = point1[1];
            offset = -offset;
        } else {
            xStart = point1[0];
            yStart = point1[1];
            xEnd = point2[0];
            yEnd = point2[1];
        }
        if (magnetismEnabled) {
            const magnetizedLength: number = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(<number>Math.sqrt(distanceBetweenPointsSq), this.getView().getPixelLength());
            if (reverse) {
                xEnd = point2[0] - <number>(magnetizedLength * Math.cos(angle));
                yEnd = point2[1] + <number>(magnetizedLength * Math.sin(angle));
            } else {
                xEnd = point1[0] + <number>(magnetizedLength * Math.cos(angle));
                yEnd = point1[1] - <number>(magnetizedLength * Math.sin(angle));
            }
        }
        return new DimensionLine(xStart, yStart, xEnd, yEnd, offset);
    }

    /**
     * Returns the dimension line between the given points.
     * @param {float[]} point1
     * @param {float[]} point2
     * @param {number} offset
     * @param {number} distanceBetweenPointsSq
     * @param {boolean} magnetismEnabled
     * @return {DimensionLine}
     * @private
     */
    public getDimensionLineBetweenPoints(point1?: any, point2?: any, offset?: any, distanceBetweenPointsSq?: any, magnetismEnabled?: any): DimensionLine {
        if (((point1 != null && point1 instanceof <any>Array && (point1.length == 0 || point1[0] == null || (typeof point1[0] === 'number'))) || point1 === null) && ((point2 != null && point2 instanceof <any>Array && (point2.length == 0 || point2[0] == null || (typeof point2[0] === 'number'))) || point2 === null) && ((typeof offset === 'number') || offset === null) && ((typeof distanceBetweenPointsSq === 'number') || distanceBetweenPointsSq === null) && ((typeof magnetismEnabled === 'boolean') || magnetismEnabled === null)) {
            return <any>this.getDimensionLineBetweenPoints$float_A$float_A$float$double$boolean(point1, point2, offset, distanceBetweenPointsSq, magnetismEnabled);
        } else if (((point1 != null && point1 instanceof <any>Array && (point1.length == 0 || point1[0] == null || (typeof point1[0] === 'number'))) || point1 === null) && ((point2 != null && point2 instanceof <any>Array && (point2.length == 0 || point2[0] == null || (typeof point2[0] === 'number'))) || point2 === null) && ((typeof offset === 'number') || offset === null) && ((typeof distanceBetweenPointsSq === 'boolean') || distanceBetweenPointsSq === null) && magnetismEnabled === undefined) {
            return <any>this.getDimensionLineBetweenPoints$float_A$float_A$float$boolean(point1, point2, offset, distanceBetweenPointsSq);
        } else throw new Error('invalid overload');
    }

    public addLevel$() {
        this.addLevel$boolean(false);
    }

    /**
     * Controls the creation of a new level at same elevation.
     */
    public addLevelAtSameElevation() {
        this.addLevel$boolean(true);
    }

    public addLevel$boolean(sameElevation: boolean) {
        const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
        const oldSelectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
        const oldSelectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const homeBackgroundImage: BackgroundImage = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getBackgroundImage();
        let levels: Array<Level> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
        const newWallHeight: number = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewWallHeight();
        const newFloorThickness: number = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewFloorThickness();
        let level0: Level;
        if (/* isEmpty */(levels.length == 0)) {
            const level0Name: string = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "levelName", 0);
            level0 = this.createLevel(level0Name, 0, newFloorThickness, newWallHeight);
            this.moveHomeItemsToLevel(level0);
            level0.setBackgroundImage(homeBackgroundImage);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBackgroundImage(null);
            levels = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
        } else {
            level0 = null;
        }
        const newLevelName: string = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "levelName", /* size */(<number>levels.length));
        let newLevel: Level;
        if (sameElevation) {
            const referencedLevel: Level = level0 != null ? level0 : this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            newLevel = this.createLevel(newLevelName, referencedLevel.getElevation(), referencedLevel.getFloorThickness(), referencedLevel.getHeight());
        } else {
            const newLevelElevation: number = /* get */levels[/* size */(<number>levels.length) - 1].getElevation() + newWallHeight + newFloorThickness;
            newLevel = this.createLevel(newLevelName, newLevelElevation, newFloorThickness, newWallHeight);
        }
        this.setSelectedLevel(newLevel);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LevelAdditionUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, allLevelsSelection, oldSelectedLevel, level0, homeBackgroundImage, newLevel));
    }

    /**
     * Controls the creation of a level.
     * @param {boolean} sameElevation
     * @private
     */
    public addLevel(sameElevation?: any) {
        if (((typeof sameElevation === 'boolean') || sameElevation === null)) {
            return <any>this.addLevel$boolean(sameElevation);
        } else if (sameElevation === undefined) {
            return <any>this.addLevel$();
        } else throw new Error('invalid overload');
    }

    /**
     * Returns a new level added to home.
     * @param {string} name
     * @param {number} elevation
     * @param {number} floorThickness
     * @param {number} height
     * @return {Level}
     */
    createLevel(name: string, elevation: number, floorThickness: number, height: number): Level {
        const newLevel: Level = new Level(name, elevation, floorThickness, height);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addLevel(newLevel);
        return newLevel;
    }

    /**
     * Moves to the given <code>level</code> all existing furniture, walls, rooms, dimension lines
     * and labels.
     * @param {Level} level
     * @private
     */
    moveHomeItemsToLevel(level: Level) {
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    piece.setLevel(level);
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    wall.setLevel(level);
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
            for (let index = 0; index < array.length; index++) {
                let room = array[index];
                {
                    room.setLevel(level);
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines();
            for (let index = 0; index < array.length; index++) {
                let polyline = array[index];
                {
                    polyline.setLevel(level);
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getDimensionLines();
            for (let index = 0; index < array.length; index++) {
                let dimensionLine = array[index];
                {
                    dimensionLine.setLevel(level);
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLabels();
            for (let index = 0; index < array.length; index++) {
                let label = array[index];
                {
                    label.setLevel(level);
                }
            }
        }
    }

    /**
     * Toggles the viewability of the selected level.
     */
    public toggleSelectedLevelViewability() {
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        selectedLevel.setViewable(!selectedLevel.isViewable());
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LevelViewabilityModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, selectedLevel));
    }

    /**
     * Makes the selected level the only viewable one.
     */
    public setSelectedLevelOnlyViewable() {
        const viewableLevels: Level[] = this.getLevels(true);
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const selectedLevelViewable: boolean = selectedLevel.isViewable();
        if (viewableLevels.length !== 1 || !selectedLevelViewable) {
            PlanController.setLevelsViewability(viewableLevels, false);
            selectedLevel.setViewable(true);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LevelsViewabilityModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, selectedLevel, selectedLevelViewable, viewableLevels));
        }
    }

    /**
     * Makes all levels viewable.
     */
    public setAllLevelsViewable() {
        const unviewableLevels: Level[] = this.getLevels(false);
        if (unviewableLevels.length > 0) {
            const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            PlanController.setLevelsViewability(unviewableLevels, true);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.AllLevelsViewabilityModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, selectedLevel, unviewableLevels));
        }
    }

    /**
     * Returns levels which are viewable or not according to parameter.
     * @param {boolean} viewable
     * @return {com.eteks.sweethome3d.model.Level[]}
     * @private
     */
    getLevels(viewable: boolean): Level[] {
        const levels: Array<Level> = <any>([]);
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
            for (let index = 0; index < array.length; index++) {
                let level = array[index];
                {
                    if (level.isViewable() === viewable) {
                        /* add */(levels.push(level) > 0);
                    }
                }
            }
        }
        return /* toArray */levels.slice(0);
    }

    static setLevelsViewability(levels: Level[], viewable: boolean) {
        for (let index = 0; index < levels.length; index++) {
            let level = levels[index];
            {
                level.setViewable(viewable);
            }
        }
    }

    public modifySelectedLevel() {
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel() != null) {
            new LevelController(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, this.__com_eteks_sweethome3d_viewcontroller_PlanController_viewFactory, this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport).displayView(this.getView());
        }
    }

    /**
     * Deletes the selected level and the items that belongs to it.
     */
    public deleteSelectedLevel() {
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.beginUpdate();
        const levelFurniture: Array<HomePieceOfFurniture> = <any>([]);
        const oldSelectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            for (let index = 0; index < array.length; index++) {
                let piece = array[index];
                {
                    if (piece.getLevel() === oldSelectedLevel) {
                        /* add */(levelFurniture.push(piece) > 0);
                    }
                }
            }
        }
        this.deleteFurniture(levelFurniture);
        const levelOtherItems: Array<Selectable> = <any>([]);
        this.addLevelItemsAtSelectedLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls(), levelOtherItems);
        this.addLevelItemsAtSelectedLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms(), levelOtherItems);
        this.addLevelItemsAtSelectedLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getDimensionLines(), levelOtherItems);
        this.addLevelItemsAtSelectedLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLabels(), levelOtherItems);
        this.postDeleteItems(levelOtherItems, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
        this.doDeleteItems(levelOtherItems);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteLevel(oldSelectedLevel);
        const levels: Array<Level> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
        let remainingLevel: Level;
        let remainingLevelElevation: number;
        let remainingLevelViewable: boolean;
        if (/* size */(<number>levels.length) === 1) {
            remainingLevel = /* get */levels[0];
            remainingLevelElevation = remainingLevel.getElevation();
            remainingLevelViewable = remainingLevel.isViewable();
            remainingLevel.setElevation(0);
            remainingLevel.setViewable(true);
        } else {
            remainingLevel = null;
            remainingLevelElevation = null;
            remainingLevelViewable = false;
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LevelDeletionUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelectedLevel, remainingLevel, remainingLevelElevation, remainingLevelViewable));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.endUpdate();
    }

    addLevelItemsAtSelectedLevel(items: Array<any>, levelItems: Array<Selectable>) {
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if ((item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) && (<Elevatable><any>item).getLevel() === selectedLevel) {
                    /* add */(levelItems.push(item) > 0);
                }
            }
        }
    }

    /**
     * Returns a new wall instance between (<code>xStart</code>,
     * <code>yStart</code>) and (<code>xEnd</code>, <code>yEnd</code>)
     * end points. The new wall is added to home and its start point is joined
     * to the start of <code>wallStartAtStart</code> or
     * the end of <code>wallEndAtStart</code>.
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {Wall} wallStartAtStart
     * @param {Wall} wallEndAtStart
     * @return {Wall}
     */
    createWall(xStart: number, yStart: number, xEnd: number, yEnd: number, wallStartAtStart: Wall, wallEndAtStart: Wall): Wall {
        const newWall: Wall = new Wall(xStart, yStart, xEnd, yEnd, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewWallThickness(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewWallHeight(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewWallPattern());
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(newWall);
        if (wallStartAtStart != null) {
            newWall.setWallAtStart(wallStartAtStart);
            wallStartAtStart.setWallAtStart(newWall);
        } else if (wallEndAtStart != null) {
            newWall.setWallAtStart(wallEndAtStart);
            wallEndAtStart.setWallAtEnd(newWall);
        }
        return newWall;
    }

    /**
     * Joins the end point of <code>wall</code> to the start of
     * <code>wallStartAtEnd</code> or the end of <code>wallEndAtEnd</code>.
     * @param {Wall} wall
     * @param {Wall} wallStartAtEnd
     * @param {Wall} wallEndAtEnd
     * @private
     */
    joinNewWallEndToWall(wall: Wall, wallStartAtEnd: Wall, wallEndAtEnd: Wall) {
        if (wallStartAtEnd != null) {
            wall.setWallAtEnd(wallStartAtEnd);
            wallStartAtEnd.setWallAtStart(wall);
            wall.setXEnd(wallStartAtEnd.getXStart());
            wall.setYEnd(wallStartAtEnd.getYStart());
        } else if (wallEndAtEnd != null) {
            wall.setWallAtEnd(wallEndAtEnd);
            wallEndAtEnd.setWallAtEnd(wall);
            wall.setXEnd(wallEndAtEnd.getXEnd());
            wall.setYEnd(wallEndAtEnd.getYEnd());
        }
    }

    /**
     * Returns the wall at (<code>x</code>, <code>y</code>) point,
     * which has a start point not joined to any wall.
     * @param {number} x
     * @param {number} y
     * @param {Wall} ignoredWall
     * @return {Wall}
     * @private
     */
    getWallStartAt(x: number, y: number, ignoredWall: Wall): Wall {
        const margin: number = PlanController.WALL_ENDS_PIXEL_MARGIN / this.getScale();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    if (wall !== ignoredWall && this.isLevelNullOrViewable(wall.getLevel()) && wall.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && wall.getWallAtStart() == null && wall.containsWallStartAt(x, y, margin)) {
                        return wall;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns the wall at (<code>x</code>, <code>y</code>) point,
     * which has a end point not joined to any wall.
     * @param {number} x
     * @param {number} y
     * @param {Wall} ignoredWall
     * @return {Wall}
     * @private
     */
    getWallEndAt(x: number, y: number, ignoredWall: Wall): Wall {
        const margin: number = PlanController.WALL_ENDS_PIXEL_MARGIN / this.getScale();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
            for (let index = 0; index < array.length; index++) {
                let wall = array[index];
                {
                    if (wall !== ignoredWall && this.isLevelNullOrViewable(wall.getLevel()) && wall.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && wall.getWallAtEnd() == null && wall.containsWallEndAt(x, y, margin)) {
                        return wall;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns the tolerance margin to handle an indicator.
     * @return {number}
     * @private
     */
    getIndicatorMargin(): number {
        let indicatorPixelMagin: number = PlanController.INDICATOR_PIXEL_MARGIN;
        if (this.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
            indicatorPixelMagin *= 3;
        }
        return indicatorPixelMagin / this.getScale();
    }

    /**
     * Returns the selected wall with a start point
     * at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Wall}
     * @private
     */
    getResizedWallStartAt(x: number, y: number): Wall {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Wall) && this.isItemResizable(/* get */selectedItems[0])) {
            const wall: Wall = <Wall><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (wall.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && wall.containsWallStartAt(x, y, margin)) {
                return wall;
            }
        }
        return null;
    }

    /**
     * Returns the selected wall with an end point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Wall}
     * @private
     */
    getResizedWallEndAt(x: number, y: number): Wall {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Wall) && this.isItemResizable(/* get */selectedItems[0])) {
            const wall: Wall = <Wall><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (wall.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && wall.containsWallEndAt(x, y, margin)) {
                return wall;
            }
        }
        return null;
    }

    /**
     * Returns the selected wall with a middle point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Wall}
     * @private
     */
    getArcExtentWallAt(x: number, y: number): Wall {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Wall) && this.isItemResizable(/* get */selectedItems[0])) {
            const wall: Wall = <Wall><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (wall.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && wall.isMiddlePointAt(x, y, margin)) {
                return wall;
            }
        }
        return null;
    }

    /**
     * Returns a new room instance with the given points.
     * The new room is added to home.
     * @param {float[][]} roomPoints
     * @return {Room}
     */
    createRoom(roomPoints: number[][]): Room {
        const newRoom: Room = new Room(roomPoints);
        newRoom.setFloorColor(this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewRoomFloorColor());
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addRoom$com_eteks_sweethome3d_model_Room(newRoom);
        return newRoom;
    }

    /**
     * Returns the points of the room matching the closed path that contains the point at the given
     * coordinates or <code>null</code> if there's no closed path at this point.
     * @param {number} x
     * @param {number} y
     * @return {float[][]}
     * @private
     */
    computeRoomPointsAt(x: number, y: number): number[][] {
        {
            let array = this.getRoomPathsFromWalls();
            for (let index = 0; index < array.length; index++) {
                let roomPath = array[index];
                {
                    if (roomPath.contains(x, y)) {
                        {
                            let array1 = this.getVisibleDoorsAndWindowsAtGround(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture());
                            for (let index1 = 0; index1 < array1.length; index1++) {
                                let piece = array1[index1];
                                {
                                    const doorPoints: number[][] = piece.getPoints();
                                    let intersectionCount: number = 0;
                                    for (let i: number = 0; i < doorPoints.length; i++) {
                                        {
                                            if (roomPath.contains(doorPoints[i][0], doorPoints[i][1])) {
                                                intersectionCount++;
                                            }
                                        };
                                    }
                                    if (doorPoints.length === 4) {
                                        const epsilon: number = 0.05;
                                        let doorStepPoints: number[][] = null;
                                        if ((piece != null && piece instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>piece).isWallCutOutOnBothSides()) {
                                            const door: HomeDoorOrWindow = <HomeDoorOrWindow>piece;
                                            const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
                                            const doorArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(doorPoints));
                                            const wallsDoorIntersection: java.awt.geom.Area = new java.awt.geom.Area();
                                            {
                                                let array2 = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
                                                for (let index2 = 0; index2 < array2.length; index2++) {
                                                    let wall = array2[index2];
                                                    {
                                                        if (wall.isAtLevel(selectedLevel) && door.isParallelToWall(wall)) {
                                                            const wallPath: java.awt.geom.GeneralPath = this.getPath$float_A_A(wall.getPoints$());
                                                            let intersectionArea: java.awt.geom.Area = new java.awt.geom.Area(wallPath);
                                                            intersectionArea.intersect(doorArea);
                                                            if (!intersectionArea.isEmpty()) {
                                                                const deeperDoor: HomePieceOfFurniture = /* clone *//* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for (let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(door);
                                                                deeperDoor.setDepthInPlan(deeperDoor.getDepth() + 4 * wall.getThickness());
                                                                intersectionArea = new java.awt.geom.Area(wallPath);
                                                                intersectionArea.intersect(new java.awt.geom.Area(this.getPath$float_A_A(deeperDoor.getPoints())));
                                                                wallsDoorIntersection.add(intersectionArea);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (!wallsDoorIntersection.isEmpty() && wallsDoorIntersection.isSingular()) {
                                                const intersectionPoints: number[][] = this.getPathPoints(this.getPath$java_awt_geom_Area(wallsDoorIntersection), true);
                                                if (intersectionPoints.length === 4) {
                                                    const doorMiddleY: number = door.getY() + door.getDepth() * (-0.5 + door.getWallDistance() + door.getWallThickness() / 2);
                                                    const halfWidth: number = door.getWidth() / 2;
                                                    const doorMiddlePoints: number[] = [door.getX() - halfWidth, doorMiddleY, door.getX() + halfWidth, doorMiddleY];
                                                    const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(door.getAngle(), door.getX(), door.getY());
                                                    rotation.transform(doorMiddlePoints, 0, doorMiddlePoints, 0, 2);
                                                    for (let i: number = 0; i < intersectionPoints.length - 1; i++) {
                                                        {
                                                            if (roomPath.intersects(intersectionPoints[i][0] - epsilon / 2, intersectionPoints[i][1] - epsilon / 2, epsilon, epsilon)) {
                                                                const inPoint1: number = i;
                                                                let outPoint1: number;
                                                                let outPoint2: number;
                                                                if (roomPath.intersects(intersectionPoints[i + 1][0] - epsilon / 2, intersectionPoints[i + 1][1] - epsilon / 2, epsilon, epsilon)) {
                                                                    outPoint2 = (i + 2) % 4;
                                                                    outPoint1 = (i + 3) % 4;
                                                                } else if (roomPath.intersects(intersectionPoints[(i + 3) % 4][0] - epsilon / 2, intersectionPoints[(i + 3) % 4][1] - epsilon / 2, epsilon, epsilon)) {
                                                                    outPoint1 = (i + 1) % 4;
                                                                    outPoint2 = (i + 2) % 4;
                                                                } else {
                                                                    break;
                                                                }
                                                                if (java.awt.geom.Point2D.distanceSq(intersectionPoints[inPoint1][0], intersectionPoints[inPoint1][1], doorMiddlePoints[0], doorMiddlePoints[1]) < java.awt.geom.Point2D.distanceSq(intersectionPoints[inPoint1][0], intersectionPoints[inPoint1][1], doorMiddlePoints[2], doorMiddlePoints[3])) {
                                                                    intersectionPoints[outPoint1][0] = doorMiddlePoints[0];
                                                                    intersectionPoints[outPoint1][1] = doorMiddlePoints[1];
                                                                    intersectionPoints[outPoint2][0] = doorMiddlePoints[2];
                                                                    intersectionPoints[outPoint2][1] = doorMiddlePoints[3];
                                                                } else {
                                                                    intersectionPoints[outPoint1][0] = doorMiddlePoints[2];
                                                                    intersectionPoints[outPoint1][1] = doorMiddlePoints[3];
                                                                    intersectionPoints[outPoint2][0] = doorMiddlePoints[0];
                                                                    intersectionPoints[outPoint2][1] = doorMiddlePoints[1];
                                                                }
                                                                doorStepPoints = intersectionPoints;
                                                                break;
                                                            }
                                                        };
                                                    }
                                                }
                                            }
                                        }
                                        if (doorStepPoints == null && intersectionCount === 2) {
                                            const wallsDoorIntersection: java.awt.geom.Area = new java.awt.geom.Area(this.getWallsArea(false));
                                            wallsDoorIntersection.intersect(new java.awt.geom.Area(this.getPath$float_A_A(doorPoints)));
                                            const intersectionPoints: number[][] = this.getPathPoints(this.getPath$java_awt_geom_Area(wallsDoorIntersection), false);
                                            if (intersectionPoints.length === 4) {
                                                for (let i: number = 0; i < intersectionPoints.length; i++) {
                                                    {
                                                        if (roomPath.intersects(intersectionPoints[i][0] - epsilon / 2, intersectionPoints[i][1] - epsilon / 2, epsilon, epsilon)) {
                                                            const inPoint1: number = i;
                                                            let inPoint2: number;
                                                            let outPoint1: number;
                                                            let outPoint2: number;
                                                            if (roomPath.intersects(intersectionPoints[i + 1][0] - epsilon / 2, intersectionPoints[i + 1][1] - epsilon / 2, epsilon, epsilon)) {
                                                                inPoint2 = i + 1;
                                                                outPoint2 = (i + 2) % 4;
                                                                outPoint1 = (i + 3) % 4;
                                                            } else {
                                                                outPoint1 = (i + 1) % 4;
                                                                outPoint2 = (i + 2) % 4;
                                                                inPoint2 = (i + 3) % 4;
                                                            }
                                                            intersectionPoints[outPoint1][0] = (intersectionPoints[outPoint1][0] + intersectionPoints[inPoint1][0]) / 2;
                                                            intersectionPoints[outPoint1][1] = (intersectionPoints[outPoint1][1] + intersectionPoints[inPoint1][1]) / 2;
                                                            intersectionPoints[outPoint2][0] = (intersectionPoints[outPoint2][0] + intersectionPoints[inPoint2][0]) / 2;
                                                            intersectionPoints[outPoint2][1] = (intersectionPoints[outPoint2][1] + intersectionPoints[inPoint2][1]) / 2;
                                                            doorStepPoints = intersectionPoints;
                                                            break;
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        if (doorStepPoints != null) {
                                            const path: java.awt.geom.GeneralPath = this.getPath$float_A_A(doorStepPoints);
                                            const bounds2D: java.awt.geom.Rectangle2D = path.getBounds2D();
                                            const transform: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getTranslateInstance(bounds2D.getCenterX(), bounds2D.getCenterY());
                                            const min: number = Math.min(bounds2D.getWidth(), bounds2D.getHeight());
                                            const scale: number = (min + epsilon) / min;
                                            transform.scale(scale, scale);
                                            transform.translate(-bounds2D.getCenterX(), -bounds2D.getCenterY());
                                            const doorStepPath: java.awt.Shape = path.createTransformedShape(transform);
                                            const halfDoorRoomUnion: java.awt.geom.Area = new java.awt.geom.Area(doorStepPath);
                                            halfDoorRoomUnion.add(new java.awt.geom.Area(roomPath));
                                            roomPath = this.getPath$java_awt_geom_Area(halfDoorRoomUnion);
                                        }
                                    }
                                }
                            }
                        }
                        return this.getPathPoints(roomPath, false);
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns all the visible doors and windows with a null elevation in the given <code>furniture</code>.
     * @param {HomePieceOfFurniture[]} furniture
     * @return {HomePieceOfFurniture[]}
     * @private
     */
    getVisibleDoorsAndWindowsAtGround(furniture: Array<HomePieceOfFurniture>): Array<HomePieceOfFurniture> {
        const doorsAndWindows: Array<HomePieceOfFurniture> = <any>([]);
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                if (this.isPieceOfFurnitureVisibleAtSelectedLevel(piece) && piece.getElevation() === 0) {
                    if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(doorsAndWindows, this.getVisibleDoorsAndWindowsAtGround((<HomeFurnitureGroup>piece).getFurniture()));
                    } else if (piece.isDoorOrWindow()) {
                        /* add */(doorsAndWindows.push(piece) > 0);
                    }
                }
            }
        }
        return doorsAndWindows;
    }

    /**
     * Returns the selected room with a point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Room}
     * @private
     */
    getResizedRoomAt(x: number, y: number): Room {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemResizable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && room.getPointIndexAt(x, y, margin) !== -1) {
                return room;
            }
        }
        return null;
    }

    /**
     * Returns the selected room with its name center point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Room}
     * @private
     */
    getRoomNameAt(x: number, y: number): Room {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemMovable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && room.getName() != null && room.getName().trim().length > 0 && room.isNameCenterPointAt(x, y, margin)) {
                return room;
            }
        }
        return null;
    }

    /**
     * Returns the selected room with its
     * name angle point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Room}
     * @private
     */
    getRoomRotatedNameAt(x: number, y: number): Room {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemMovable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && room.getName() != null && room.getName().trim().length > 0 && this.isTextAnglePointAt(room, room.getName(), room.getNameStyle(), room.getXCenter() + room.getNameXOffset(), room.getYCenter() + room.getNameYOffset(), room.getNameAngle(), x, y, margin)) {
                return room;
            }
        }
        return null;
    }

    /**
     * Returns the selected room with its area center point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Room}
     * @private
     */
    getRoomAreaAt(x: number, y: number): Room {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemMovable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && room.isAreaVisible() && room.isAreaCenterPointAt(x, y, margin)) {
                return room;
            }
        }
        return null;
    }

    /**
     * Returns the selected room with its
     * area angle point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Room}
     * @private
     */
    getRoomRotatedAreaAt(x: number, y: number): Room {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemMovable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (room.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && room.isAreaVisible()) {
                const area: number = room.getArea();
                if (area > 0.01) {
                    const areaText: string = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getAreaFormatWithUnit().format(area);
                    if (this.isTextAnglePointAt(room, areaText, room.getAreaStyle(), room.getXCenter() + room.getAreaXOffset(), room.getYCenter() + room.getAreaYOffset(), room.getAreaAngle(), x, y, margin)) {
                        return room;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns <code>true</code> if the given point can be removed from the <code>room</code>.
     * @param {Room} room
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    public isRoomPointDeletableAt(room: Room, x: number, y: number): boolean {
        return this.isItemResizable(room) && room.getPointIndexAt(x, y, this.getIndicatorMargin()) >= 0;
    }

    /**
     * Deletes the point of the selected room at the given coordinates and posts an undoable operation.
     * @param {number} x
     * @param {number} y
     */
    public deletePointFromSelectedRoom(x: number, y: number) {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemResizable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const index: number = room.getPointIndexAt(x, y, this.getIndicatorMargin());
            if (index >= 0) {
                const points: number[][] = room.getPoints();
                const point: number[] = points[index];
                const xPoint: number = point[0];
                const yPoint: number = point[1];
                room.removePoint(index);
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(/* asList */[room].slice(0));
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomPointDeletionUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), room, index, xPoint, yPoint));
            }
        }
    }

    /**
     * Returns <code>true</code> if the <code>room</code> can be recomputed at the given coordinates.
     * @param {Room} room
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    public isRoomPointsComputableAt(room: Room, x: number, y: number): boolean {
        if (this.isItemResizable(room) && room.containsPoint(x, y, 0)) {
            const roomPoints: number[][] = this.computeRoomPointsAt(x, y);
            return roomPoints != null && !/* deepEquals */(JSON.stringify(room.getPoints()) === JSON.stringify(roomPoints));
        }
        return false;
    }

    /**
     * Controls the recomputation of the points of the selected room at the given coordinates.
     * @param {number} x
     * @param {number} y
     */
    public recomputeSelectedRoomPoints(x: number, y: number) {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemResizable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const oldPoints: number[][] = room.getPoints();
            const newPoints: number[][] = this.computeRoomPointsAt(x, y);
            if (newPoints != null) {
                room.setPoints(newPoints);
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(/* asList */[room].slice(0));
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomPointsModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), room, oldPoints, newPoints));
            }
        }
    }

    /**
     * Adds a point to the selected room at the given coordinates and posts an undoable operation.
     * @param {number} x
     * @param {number} y
     */
    public addPointToSelectedRoom(x: number, y: number) {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Room) && this.isItemResizable(/* get */selectedItems[0])) {
            const room: Room = <Room><any>/* get */selectedItems[0];
            const points: number[][] = room.getPoints();
            let closestSegmentIndex: number = -1;
            let smallestDistance: number = 1.7976931348623157E308;
            for (let i: number = 0; i < points.length; i++) {
                {
                    const point: number[] = points[i];
                    const nextPoint: number[] = points[(i + 1) % points.length];
                    const distanceToSegment: number = java.awt.geom.Line2D.ptSegDistSq(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
                    if (smallestDistance > distanceToSegment) {
                        smallestDistance = distanceToSegment;
                        closestSegmentIndex = i;
                    }
                };
            }
            const index: number = closestSegmentIndex + 1;
            room.addPoint$float$float$int(x, y, index);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(/* asList */[room].slice(0));
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomPointAdditionUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */selectedItems.slice(0), room, index, x, y));
        }
    }

    public createDimensionLine$float$float$float$float$float(xStart: number, yStart: number, xEnd: number, yEnd: number, offset: number): DimensionLine {
        const newDimensionLine: DimensionLine = new DimensionLine(xStart, yStart, xEnd, yEnd, offset);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addDimensionLine(newDimensionLine);
        return newDimensionLine;
    }

    /**
     * Returns a new dimension instance joining (<code>xStart</code>,
     * <code>yStart</code>) and (<code>xEnd</code>, <code>yEnd</code>) points.
     * The new dimension line is added to home.
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {number} offset
     * @return {DimensionLine}
     */
    public createDimensionLine(xStart?: any, yStart?: any, xEnd?: any, yEnd?: any, offset?: any): any {
        if (((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof xEnd === 'number') || xEnd === null) && ((typeof yEnd === 'number') || yEnd === null) && ((typeof offset === 'number') || offset === null)) {
            return <any>this.createDimensionLine$float$float$float$float$float(xStart, yStart, xEnd, yEnd, offset);
        } else if (((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && xEnd === undefined && yEnd === undefined && offset === undefined) {
            return <any>this.createDimensionLine$float$float(xStart, yStart);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns the selected dimension line with an end extension line
     * at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getResizedDimensionLineStartAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemResizable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && dimensionLine.containsStartExtensionLinetAt(x, y, margin)) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns the selected dimension line with an end extension line
     * at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getResizedDimensionLineEndAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemResizable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && dimensionLine.containsEndExtensionLineAt(x, y, margin)) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns the selected dimension line with a point
     * at (<code>x</code>, <code>y</code>) at its middle.
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getOffsetDimensionLineAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemResizable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && (dimensionLine.isMiddlePointAt(x, y, margin) || dimensionLine.isTopPointAt(x, y, margin) && !dimensionLine.containsPoint(x, y, 0))) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to rotate the piece.
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getPitchRotatedDimensionLineAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemMovable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && dimensionLine.isElevationDimensionLine() && dimensionLine.isBottomPointAt(x, y, margin) && !dimensionLine.containsPoint(x, y, 0)) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to elevate the piece.
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getElevatedDimensionLineAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemMovable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && dimensionLine.isLeftPointAt(x, y, margin) && !dimensionLine.containsPoint(x, y, 0)) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to resize the height
     * of the piece.
     * @param {number} x
     * @param {number} y
     * @return {DimensionLine}
     * @private
     */
    getHeightResizedDimensionLineAt(x: number, y: number): DimensionLine {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>DimensionLine) && this.isItemResizable(/* get */selectedItems[0])) {
            const dimensionLine: DimensionLine = <DimensionLine><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (dimensionLine.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && dimensionLine.isRightPointAt(x, y, margin) && !dimensionLine.containsPoint(x, y, 0)) {
                return dimensionLine;
            }
        }
        return null;
    }

    /**
     * Returns a new polyline instance with the given points.
     * The new polyline is added to home.
     * @param {float[][]} polylinePoints
     * @return {Polyline}
     */
    createPolyline(polylinePoints: number[][]): Polyline {
        const newPolyline: Polyline = new Polyline(polylinePoints);
        const lengthUnit: any = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit();
        newPolyline.setThickness(lengthUnit.isMetric() ? 2 : LengthUnit.inchToCentimeter(1));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPolyline$com_eteks_sweethome3d_model_Polyline(newPolyline);
        return newPolyline;
    }

    /**
     * Returns the selected polyline with a point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Polyline}
     * @private
     */
    getResizedPolylineAt(x: number, y: number): Polyline {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Polyline) && this.isItemResizable(/* get */selectedItems[0])) {
            const polyline: Polyline = <Polyline><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (polyline.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && polyline.getPointIndexAt(x, y, margin) !== -1) {
                return polyline;
            }
        }
        return null;
    }

    /**
     * Returns the tolerance margin to select an item.
     * @return {number}
     * @private
     */
    getSelectionMargin(): number {
        let indicatorPixelMagin: number = PlanController.PIXEL_MARGIN;
        if (this.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
            indicatorPixelMagin *= 2;
        }
        return indicatorPixelMagin / this.getScale();
    }

    /**
     * Returns the selected item at (<code>x</code>, <code>y</code>) point.
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     * @private
     */
    isItemSelectedAt(x: number, y: number): boolean {
        const margin: number = this.getSelectionMargin();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if (item.containsPoint(x, y, margin)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public getSelectableItemAt$float$float(x: number, y: number): Selectable {
        return this.getSelectableItemAt$float$float$boolean(x, y, true);
    }

    public getSelectableItemAt$float$float$boolean(x: number, y: number, ignoreGroupsFurniture: boolean): Selectable {
        const selectableItems: Array<Selectable> = this.getSelectableItemsAt$float$float$boolean$boolean(x, y, true, ignoreGroupsFurniture);
        if (/* size */(<number>selectableItems.length) !== 0) {
            return /* get */selectableItems[0];
        } else {
            return null;
        }
    }

    /**
     * Returns the selectable item at (<code>x</code>, <code>y</code>) point.
     * @param {number} x
     * @param {number} y
     * @param {boolean} ignoreGroupsFurniture
     * @return {Object}
     * @private
     */
    public getSelectableItemAt(x?: any, y?: any, ignoreGroupsFurniture?: any): Selectable {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof ignoreGroupsFurniture === 'boolean') || ignoreGroupsFurniture === null)) {
            return <any>this.getSelectableItemAt$float$float$boolean(x, y, ignoreGroupsFurniture);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ignoreGroupsFurniture === undefined) {
            return <any>this.getSelectableItemAt$float$float(x, y);
        } else throw new Error('invalid overload');
    }

    public getSelectableItemsAt$float$float(x: number, y: number): Array<Selectable> {
        return this.getSelectableItemsAt$float$float$boolean$boolean(x, y, false, true);
    }

    public getSelectableItemsAt$float$float$boolean$boolean(x: number, y: number, stopAtFirstItem: boolean, ignoreGroupsFurniture: boolean): Array<Selectable> {
        const items: Array<Selectable> = <any>([]);
        const margin: number = this.getSelectionMargin();
        const textMargin: number = margin / 2;
        const camera: ObserverCamera = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera();
        if (camera != null && camera === this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getCamera() && camera.containsPoint(x, y, margin)) {
            /* add */(items.push(camera) > 0);
            if (stopAtFirstItem) {
                return items;
            }
        }
        const basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLabels();
            for (let index = 0; index < array.length; index++) {
                let label = array[index];
                {
                    if ((!basePlanLocked || !this.isItemPartOfBasePlan(label)) && this.isLevelNullOrViewable(label.getLevel()) && label.isAtLevel(selectedLevel) && (label.containsPoint(x, y, margin) || this.isItemTextAt(label, label.getText(), label.getStyle(), label.getX(), label.getY(), label.getAngle(), x, y, textMargin))) {
                        /* add */(items.push(label) > 0);
                        if (stopAtFirstItem) {
                            return items;
                        }
                    }
                }
            }
        }
        {
            let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getDimensionLines();
            for (let index = 0; index < array.length; index++) {
                let dimensionLine = array[index];
                {
                    if ((!basePlanLocked || !this.isItemPartOfBasePlan(dimensionLine)) && this.isLevelNullOrViewable(dimensionLine.getLevel()) && dimensionLine.isAtLevel(selectedLevel) && dimensionLine.containsPoint(x, y, margin)) {
                        /* add */(items.push(dimensionLine) > 0);
                        if (stopAtFirstItem) {
                            return items;
                        }
                    }
                }
            }
        }
        const polylines: Array<Polyline> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines();
        for (let i: number = /* size */(<number>polylines.length) - 1; i >= 0; i--) {
            {
                const polyline: Polyline = /* get */polylines[i];
                if ((!basePlanLocked || !this.isItemPartOfBasePlan(polyline)) && this.isLevelNullOrViewable(polyline.getLevel()) && polyline.isAtLevel(selectedLevel) && polyline.containsPoint(x, y, margin)) {
                /* add */(items.push(polyline) > 0);
                    if (stopAtFirstItem) {
                        return items;
                    }
                }
            };
        }
        const furniture: Array<HomePieceOfFurniture> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
        const foundFurniture: Array<HomePieceOfFurniture> = <any>([]);
        let foundPiece: HomePieceOfFurniture = null;
        for (let i: number = /* size */(<number>furniture.length) - 1; i >= 0; i--) {
            {
                const piece: HomePieceOfFurniture = /* get */furniture[i];
                if ((!basePlanLocked || !this.isItemPartOfBasePlan(piece)) && this.isPieceOfFurnitureVisibleAtSelectedLevel(piece)) {
                    if (piece.containsPoint(x, y, margin)) {
                    /* add */(foundFurniture.push(piece) > 0);
                        if (foundPiece == null || piece.getGroundElevation() > foundPiece.getGroundElevation()) {
                            foundPiece = piece;
                        }
                    } else if (foundPiece == null) {
                        const pieceName: string = piece.getName();
                        if (pieceName != null && piece.isNameVisible() && this.isItemTextAt(piece, pieceName, piece.getNameStyle(), piece.getX() + piece.getNameXOffset(), piece.getY() + piece.getNameYOffset(), piece.getNameAngle(), x, y, textMargin)) {
                        /* add */(foundFurniture.push(piece) > 0);
                            foundPiece = piece;
                        }
                    }
                }
            };
        }
        if (foundPiece == null && basePlanLocked) {
            {
                let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
                for (let index = 0; index < array.length; index++) {
                    let item = array[index];
                    {
                        if (item != null && item instanceof <any>HomePieceOfFurniture) {
                            const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>item;
                            if (!this.isItemPartOfBasePlan(piece) && this.isPieceOfFurnitureVisibleAtSelectedLevel(piece) && (piece.containsPoint(x, y, margin) || piece.getName() != null && piece.isNameVisible() && this.isItemTextAt(piece, piece.getName(), piece.getNameStyle(), piece.getX() + piece.getNameXOffset(), piece.getY() + piece.getNameYOffset(), piece.getNameAngle(), x, y, textMargin))) {
                                /* add */(foundFurniture.push(piece) > 0);
                                foundPiece = piece;
                                if (stopAtFirstItem) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (foundPiece != null && stopAtFirstItem) {
            if (!ignoreGroupsFurniture && (foundPiece != null && foundPiece instanceof <any>HomeFurnitureGroup)) {
                const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
                if (/* size */(<number>selectedItems.length) >= 1) {
                    if ((/* size */(<number>selectedItems.length) === 1 && /* get */selectedItems[0] === foundPiece) || /* containsAll */((a, r) => { for (let i = 0; i < r.length; i++) { if (a.indexOf(<any>r[i]) < 0) return false; } return true; })((<HomeFurnitureGroup>foundPiece).getAllFurniture(), selectedItems)) {
                        for (let index = 0; index < selectedItems.length; index++) {
                            let selectedItem = selectedItems[index];
                            {
                                if (selectedItem != null && selectedItem instanceof <any>HomeFurnitureGroup) {
                                    const groupFurniture: Array<HomePieceOfFurniture> = (<HomeFurnitureGroup><any>selectedItem).getFurniture();
                                    for (let i: number = /* size */(<number>groupFurniture.length) - 1; i >= 0; i--) {
                                        {
                                            const piece: HomePieceOfFurniture = /* get */groupFurniture[i];
                                            if ((!basePlanLocked || !this.isItemPartOfBasePlan(piece)) && !/* contains */(selectedItems.indexOf(<any>(piece)) >= 0) && piece.containsPoint(x, y, margin)) {
                                                return /* asList */[piece].slice(0);
                                            }
                                        };
                                    }
                                }
                            }
                        }
                        for (let index = 0; index < selectedItems.length; index++) {
                            let selectedItem = selectedItems[index];
                            {
                                if (selectedItem != null && selectedItem instanceof <any>HomePieceOfFurniture) {
                                    const groupFurniture: Array<HomePieceOfFurniture> = this.getFurnitureInSameGroup(<HomePieceOfFurniture><any>selectedItem);
                                    for (let i: number = /* size */(<number>groupFurniture.length) - 1; i >= 0; i--) {
                                        {
                                            const piece: HomePieceOfFurniture = /* get */groupFurniture[i];
                                            if ((!basePlanLocked || !this.isItemPartOfBasePlan(piece)) && piece.containsPoint(x, y, margin)) {
                                                return /* asList */[piece].slice(0);
                                            }
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return /* asList */[foundPiece].slice(0);
        } else {
            /* sort */((l, c) => { if ((<any>c).compare) l.sort((e1, e2) => (<any>c).compare(e1, e2)); else l.sort(<any>c); })(foundFurniture, new PlanController.PlanController$7(this));
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(items, foundFurniture);
            {
                let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        if ((!basePlanLocked || !this.isItemPartOfBasePlan(wall)) && this.isLevelNullOrViewable(wall.getLevel()) && wall.isAtLevel(selectedLevel) && wall.containsPoint$float$float$float(x, y, margin)) {
                            /* add */(items.push(wall) > 0);
                            if (stopAtFirstItem) {
                                return items;
                            }
                        }
                    }
                }
            }
            const rooms: Array<Room> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
            let foundRoom: Room = null;
            for (let i: number = /* size */(<number>rooms.length) - 1; i >= 0; i--) {
                {
                    const room: Room = /* get */rooms[i];
                    if ((!basePlanLocked || !this.isItemPartOfBasePlan(room)) && this.isLevelNullOrViewable(room.getLevel()) && room.isAtLevel(selectedLevel)) {
                        if (room.containsPoint(x, y, margin)) {
                        /* add */(items.push(room) > 0);
                            if (foundRoom == null || room.isCeilingVisible() && !foundRoom.isCeilingVisible()) {
                                foundRoom = room;
                            }
                        } else {
                            const roomName: string = room.getName();
                            if (roomName != null && this.isItemTextAt(room, roomName, room.getNameStyle(), room.getXCenter() + room.getNameXOffset(), room.getYCenter() + room.getNameYOffset(), room.getNameAngle(), x, y, textMargin)) {
                            /* add */(items.push(room) > 0);
                                foundRoom = room;
                            }
                            if (room.isAreaVisible()) {
                                const areaText: string = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea());
                                if (this.isItemTextAt(room, areaText, room.getAreaStyle(), room.getXCenter() + room.getAreaXOffset(), room.getYCenter() + room.getAreaYOffset(), room.getAreaAngle(), x, y, textMargin)) {
                                /* add */(items.push(room) > 0);
                                    foundRoom = room;
                                }
                            }
                        }
                    }
                };
            }
            if (foundRoom != null && stopAtFirstItem) {
                return /* asList */[foundRoom].slice(0);
            } else {
                const compass: Compass = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getCompass();
                if ((!basePlanLocked || !this.isItemPartOfBasePlan(compass)) && compass.containsPoint(x, y, textMargin)) {
                    /* add */(items.push(compass) > 0);
                }
                return items;
            }
        }
    }

    /**
     * Returns the selectable items at (<code>x</code>, <code>y</code>) point.
     * @param {number} x
     * @param {number} y
     * @param {boolean} stopAtFirstItem
     * @param {boolean} ignoreGroupsFurniture
     * @return {*[]}
     * @private
     */
    public getSelectableItemsAt(x?: any, y?: any, stopAtFirstItem?: any, ignoreGroupsFurniture?: any): Array<Selectable> {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof stopAtFirstItem === 'boolean') || stopAtFirstItem === null) && ((typeof ignoreGroupsFurniture === 'boolean') || ignoreGroupsFurniture === null)) {
            return <any>this.getSelectableItemsAt$float$float$boolean$boolean(x, y, stopAtFirstItem, ignoreGroupsFurniture);
        } else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && stopAtFirstItem === undefined && ignoreGroupsFurniture === undefined) {
            return <any>this.getSelectableItemsAt$float$float(x, y);
        } else throw new Error('invalid overload');
    }

    /**
     * Returns <code>true</code> if the <code>text</code> of an <code>item</code> displayed
     * at the point (<code>xText</code>, <code>yText</code>) contains the point (<code>x</code>, <code>y</code>).
     * @param {Object} item
     * @param {string} text
     * @param {TextStyle} textStyle
     * @param {number} xText
     * @param {number} yText
     * @param {number} textAngle
     * @param {number} x
     * @param {number} y
     * @param {number} textMargin
     * @return {boolean}
     * @private
     */
    isItemTextAt(item: Selectable, text: string, textStyle: TextStyle, xText: number, yText: number, textAngle: number, x: number, y: number, textMargin: number): boolean {
        if (textStyle == null) {
            textStyle = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getDefaultTextStyle((<any>item.constructor));
        }
        const textBounds: number[][] = this.getView().getTextBounds(text, textStyle, xText, yText, textAngle);
        return this.getPath$float_A_A(textBounds).intersects(x - textMargin, y - textMargin, 2 * textMargin, 2 * textMargin);
    }

    /**
     * Returns the items that intersects with the rectangle of (<code>x0</code>,
     * <code>y0</code>), (<code>x1</code>, <code>y1</code>) opposite corners.
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @return {*[]}
     */
    getSelectableItemsIntersectingRectangle(x0: number, y0: number, x1: number, y1: number): Array<Selectable> {
        const items: Array<Selectable> = <any>([]);
        const basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
        {
            let array = this.getVisibleItemsAtSelectedLevel();
            for (let index = 0; index < array.length; index++) {
                let item = array[index];
                {
                    if ((!basePlanLocked || !this.isItemPartOfBasePlan(item)) && item.intersectsRectangle(x0, y0, x1, y1)) {
                        /* add */(items.push(item) > 0);
                    }
                }
            }
        }
        const camera: ObserverCamera = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getObserverCamera();
        if (camera != null && camera.intersectsRectangle(x0, y0, x1, y1)) {
            /* add */(items.push(camera) > 0);
        }
        return items;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to rotate the piece.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getRotatedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isTopLeftPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to elevate the piece.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getElevatedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isTopRightPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to resize the height
     * of the piece.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getHeightResizedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedResizablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (!selectedPiece.isHorizontallyRotated() && selectedPiece.isBottomLeftPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to rotate the piece
     * around the pitch axis.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getPitchRotatedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null && this.getView().isFurnitureSizeInPlanSupported()) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.getPitch() !== 0 && selectedPiece.isBottomLeftPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to rotate the piece
     * around the roll axis.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getRollRotatedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null && this.getView().isFurnitureSizeInPlanSupported()) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.getRoll() !== 0 && selectedPiece.isBottomLeftPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with a point
     * at (<code>x</code>, <code>y</code>) that can be used to resize
     * the width and the depth of the piece.
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getWidthAndDepthResizedPieceOfFurnitureAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedResizablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isBottomRightPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected item if selection contains one selected movable piece of furniture.
     * @return {HomePieceOfFurniture}
     * @private
     */
    getSelectedMovablePieceOfFurniture(): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedPieceOfFurniture();
        if (selectedPiece != null && this.isItemMovable(selectedPiece)) {
            return selectedPiece;
        }
        return null;
    }

    /**
     * Returns the selected item if selection contains one selected resizable piece of furniture.
     * @return {HomePieceOfFurniture}
     * @private
     */
    getSelectedResizablePieceOfFurniture(): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedPieceOfFurniture();
        if (selectedPiece != null && selectedPiece.isResizable() && this.isItemResizable(selectedPiece)) {
            return selectedPiece;
        }
        return null;
    }

    /**
     * Returns the selected item if selection contains one selected piece of furniture.
     * @return {HomePieceOfFurniture}
     * @private
     */
    getSelectedPieceOfFurniture(): HomePieceOfFurniture {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>HomePieceOfFurniture)) {
            const piece: HomePieceOfFurniture = <HomePieceOfFurniture><any>/* get */selectedItems[0];
            if (this.isPieceOfFurnitureVisibleAtSelectedLevel(piece)) {
                return piece;
            }
        }
        return null;
    }

    /**
     * Returns the selected light with a point at (<code>x</code>, <code>y</code>)
     * that can be used to resize the power of the light.
     * @param {number} x
     * @param {number} y
     * @return {HomeLight}
     * @private
     */
    getModifiedLightPowerAt(x: number, y: number): HomeLight {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedPieceOfFurniture();
        if (selectedPiece != null && selectedPiece instanceof <any>HomeLight) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isBottomLeftPointAt(x, y, margin) && !selectedPiece.containsPoint(x, y, 0)) {
                return <HomeLight>selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with its
     * name center point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getPieceOfFurnitureNameAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isNameVisible() && selectedPiece.getName().trim().length > 0 && selectedPiece.isNameCenterPointAt(x, y, margin)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns the selected piece of furniture with its
     * name angle point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {HomePieceOfFurniture}
     * @private
     */
    getPieceOfFurnitureRotatedNameAt(x: number, y: number): HomePieceOfFurniture {
        const selectedPiece: HomePieceOfFurniture = this.getSelectedMovablePieceOfFurniture();
        if (selectedPiece != null) {
            const margin: number = this.getIndicatorMargin();
            if (selectedPiece.isNameVisible() && selectedPiece.getName().trim().length > 0 && this.isTextAnglePointAt(selectedPiece, selectedPiece.getName(), selectedPiece.getNameStyle(), selectedPiece.getX() + selectedPiece.getNameXOffset(), selectedPiece.getY() + selectedPiece.getNameYOffset(), selectedPiece.getNameAngle(), x, y, margin)) {
                return selectedPiece;
            }
        }
        return null;
    }

    /**
     * Returns <code>true</code> if the angle indicator of the <code>text</code> of an <code>item</code> displayed
     * at the point (<code>xText</code>, <code>yText</code>) is equal to the point (<code>x</code>, <code>y</code>).
     * @param {Object} item
     * @param {string} text
     * @param {TextStyle} textStyle
     * @param {number} xText
     * @param {number} yText
     * @param {number} textAngle
     * @param {number} x
     * @param {number} y
     * @param {number} margin
     * @return {boolean}
     * @private
     */
    isTextAnglePointAt(item: Selectable, text: string, textStyle: TextStyle, xText: number, yText: number, textAngle: number, x: number, y: number, margin: number): boolean {
        if (textStyle == null) {
            textStyle = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getDefaultTextStyle((<any>item.constructor));
        }
        const textBounds: number[][] = this.getView().getTextBounds(text, textStyle, xText, yText, textAngle);
        let anglePointX: number;
        let anglePointY: number;
        if (textStyle.getAlignment() === TextStyle.Alignment.LEFT) {
            anglePointX = textBounds[0][0];
            anglePointY = textBounds[0][1];
        } else if (textStyle.getAlignment() === TextStyle.Alignment.RIGHT) {
            anglePointX = textBounds[1][0];
            anglePointY = textBounds[1][1];
        } else {
            anglePointX = (textBounds[0][0] + textBounds[1][0]) / 2;
            anglePointY = (textBounds[0][1] + textBounds[1][1]) / 2;
        }
        return Math.abs(x - anglePointX) <= margin && Math.abs(y - anglePointY) <= margin;
    }

    /**
     * Returns the selected label with its angle point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Label}
     * @private
     */
    getRotatedLabelAt(x: number, y: number): Label {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Label) && this.isItemMovable(/* get */selectedItems[0])) {
            const label: Label = <Label><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            if (label.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && this.isTextAnglePointAt(label, label.getText(), label.getStyle(), label.getX(), label.getY(), label.getAngle(), x, y, margin)) {
                return label;
            }
        }
        return null;
    }

    /**
     * Returns the selected label with its elevation point at (<code>x</code>, <code>y</code>).
     * @param {number} x
     * @param {number} y
     * @return {Label}
     * @private
     */
    getElevatedLabelAt(x: number, y: number): Label {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Label)) {
            const label: Label = <Label><any>/* get */selectedItems[0];
            if (label.getPitch() != null && this.isItemMovable(label)) {
                const margin: number = this.getIndicatorMargin();
                if (label.isAtLevel(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel())) {
                    let style: TextStyle = label.getStyle();
                    if (style == null) {
                        style = this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getDefaultTextStyle((<any>label.constructor));
                    }
                    const textBounds: number[][] = this.getView().getTextBounds(label.getText(), this.getItemTextStyle(label, label.getStyle()), label.getX(), label.getY(), label.getAngle());
                    let pointX: number;
                    let pointY: number;
                    if (style.getAlignment() === TextStyle.Alignment.LEFT) {
                        pointX = textBounds[3][0];
                        pointY = textBounds[3][1];
                    } else if (style.getAlignment() === TextStyle.Alignment.RIGHT) {
                        pointX = textBounds[2][0];
                        pointY = textBounds[2][1];
                    } else {
                        pointX = (textBounds[2][0] + textBounds[3][0]) / 2;
                        pointY = (textBounds[2][1] + textBounds[3][1]) / 2;
                    }
                    if (Math.abs(x - pointX) <= margin && Math.abs(y - pointY) <= margin) {
                        return label;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns the selected camera with a point at (<code>x</code>, <code>y</code>)
     * that can be used to change the camera yaw angle.
     * @param {number} x
     * @param {number} y
     * @return {Camera}
     * @private
     */
    getYawRotatedCameraAt(x: number, y: number): Camera {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Camera) && this.isItemResizable(/* get */selectedItems[0])) {
            const camera: ObserverCamera = <ObserverCamera><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            const cameraPoints: number[][] = camera.getPoints();
            const xMiddleFirstAndLastPoint: number = (cameraPoints[0][0] + cameraPoints[3][0]) / 2;
            const yMiddleFirstAndLastPoint: number = (cameraPoints[0][1] + cameraPoints[3][1]) / 2;
            if (Math.abs(x - xMiddleFirstAndLastPoint) <= margin && Math.abs(y - yMiddleFirstAndLastPoint) <= margin && !camera.containsPoint(x, y, 0)) {
                return camera;
            }
        }
        return null;
    }

    /**
     * Returns the selected camera with a point at (<code>x</code>, <code>y</code>)
     * that can be used to change the camera pitch angle.
     * @param {number} x
     * @param {number} y
     * @return {Camera}
     * @private
     */
    getPitchRotatedCameraAt(x: number, y: number): Camera {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Camera) && this.isItemResizable(/* get */selectedItems[0])) {
            const camera: ObserverCamera = <ObserverCamera><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            const cameraPoints: number[][] = camera.getPoints();
            const xMiddleFirstAndLastPoint: number = (cameraPoints[1][0] + cameraPoints[2][0]) / 2;
            const yMiddleFirstAndLastPoint: number = (cameraPoints[1][1] + cameraPoints[2][1]) / 2;
            if (Math.abs(x - xMiddleFirstAndLastPoint) <= margin && Math.abs(y - yMiddleFirstAndLastPoint) <= margin && !camera.containsPoint(x, y, 0)) {
                return camera;
            }
        }
        return null;
    }

    /**
     * Returns the selected camera with a point at (<code>x</code>, <code>y</code>)
     * that can be used to change the camera elevation.
     * @param {number} x
     * @param {number} y
     * @return {Camera}
     * @private
     */
    getElevatedCameraAt(x: number, y: number): Camera {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Camera) && this.isItemResizable(/* get */selectedItems[0])) {
            const camera: ObserverCamera = <ObserverCamera><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            const cameraPoints: number[][] = camera.getPoints();
            const xMiddleFirstAndSecondPoint: number = (cameraPoints[0][0] + cameraPoints[1][0]) / 2;
            const yMiddleFirstAndSecondPoint: number = (cameraPoints[0][1] + cameraPoints[1][1]) / 2;
            if (Math.abs(x - xMiddleFirstAndSecondPoint) <= margin && Math.abs(y - yMiddleFirstAndSecondPoint) <= margin && !camera.containsPoint(x, y, 0)) {
                return camera;
            }
        }
        return null;
    }

    /**
     * Returns the selected compass with a point
     * at (<code>x</code>, <code>y</code>) that can be used to rotate it.
     * @param {number} x
     * @param {number} y
     * @return {Compass}
     * @private
     */
    getRotatedCompassAt(x: number, y: number): Compass {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Compass) && this.isItemMovable(/* get */selectedItems[0])) {
            const compass: Compass = <Compass><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            const compassPoints: number[][] = compass.getPoints();
            const xMiddleThirdAndFourthPoint: number = (compassPoints[2][0] + compassPoints[3][0]) / 2;
            const yMiddleThirdAndFourthPoint: number = (compassPoints[2][1] + compassPoints[3][1]) / 2;
            if (Math.abs(x - xMiddleThirdAndFourthPoint) <= margin && Math.abs(y - yMiddleThirdAndFourthPoint) <= margin && !compass.containsPoint(x, y, 0)) {
                return compass;
            }
        }
        return null;
    }

    /**
     * Returns the selected compass with a point
     * at (<code>x</code>, <code>y</code>) that can be used to resize it.
     * @param {number} x
     * @param {number} y
     * @return {Compass}
     * @private
     */
    getResizedCompassAt(x: number, y: number): Compass {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        if (/* size */(<number>selectedItems.length) === 1 && (/* get */selectedItems[0] != null && /* get */selectedItems[0] instanceof <any>Compass) && this.isItemMovable(/* get */selectedItems[0])) {
            const compass: Compass = <Compass><any>/* get */selectedItems[0];
            const margin: number = this.getIndicatorMargin();
            const compassPoints: number[][] = compass.getPoints();
            const xMiddleSecondAndThirdPoint: number = (compassPoints[1][0] + compassPoints[2][0]) / 2;
            const yMiddleSecondAndThirdPoint: number = (compassPoints[1][1] + compassPoints[2][1]) / 2;
            if (Math.abs(x - xMiddleSecondAndThirdPoint) <= margin && Math.abs(y - yMiddleSecondAndThirdPoint) <= margin && !compass.containsPoint(x, y, 0)) {
                return compass;
            }
        }
        return null;
    }

    /**
     * Deletes <code>items</code> in plan and record it as an undoable operation.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     */
    public deleteItems(items: Array<any>) {
        const deletedItems: Array<Selectable> = <any>([]);
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (this.isItemDeletable(item)) {
                    /* add */(deletedItems.push(item) > 0);
                }
            }
        }
        if (!/* isEmpty */(deletedItems.length == 0)) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.beginUpdate();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.removeSelectionListener(this.selectionListener);
            const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            const selectedItems: Array<Selectable> = <any>(items.slice(0));
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.ItemsDeletionStartUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, allLevelsSelection, /* toArray */selectedItems.slice(0)));
            this.deleteFurniture(Home.getFurnitureSubList(deletedItems));
            const deletedOtherItems: Array<Selectable> = <any>(Home.getWallsSubList(deletedItems).slice(0));
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(deletedOtherItems, Home.getRoomsSubList(deletedItems));
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(deletedOtherItems, Home.getDimensionLinesSubList(deletedItems));
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(deletedOtherItems, Home.getPolylinesSubList(deletedItems));
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(deletedOtherItems, Home.getLabelsSubList(deletedItems));
            this.postDeleteItems(deletedOtherItems, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
            this.doDeleteItems(deletedOtherItems);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addSelectionListener(this.selectionListener);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.ItemsDeletionEndUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home));
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.endUpdate();
        }
    }

    /**
     * Posts an undoable delete items operation about <code>deletedItems</code>.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} deletedItems
     * @param {boolean} basePlanLocked
     * @param {boolean} allLevelsSelection
     * @private
     */
    postDeleteItems(deletedItems: Array<any>, basePlanLocked: boolean, allLevelsSelection: boolean) {
        const deletedWalls: Array<Wall> = Home.getWallsSubList(deletedItems);
        const joinedDeletedWalls: PlanController.JoinedWall[] = PlanController.JoinedWall.getJoinedWalls(deletedWalls);
        const deletedRooms: Array<Room> = Home.getRoomsSubList(deletedItems);
        const homeRooms: Array<Room> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
        const sortedMap: any = <any>({});
        for (let index = 0; index < deletedRooms.length; index++) {
            let room = deletedRooms[index];
            {
                /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedMap, homeRooms.indexOf(room), room);
            }
        }
        const rooms: Room[] = /* toArray */((a1, a2) => { if (a1.length >= a2.length) { a1.length = 0; a1.push.apply(a1, a2); return a1; } else { return a2.slice(0); } })((s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */((m) => { if (m.entries == null) m.entries = []; return m.entries.length; })(<any>sortedMap)), /* values */((m) => { let r = []; if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) r.push(m.entries[i].value); return r; })(<any>sortedMap));
        const roomsIndices: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(rooms.length);
        const roomsLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(rooms.length);
        let i: number = 0;
        {
            let array = /* keySet */((m) => { let r = []; if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) r.push(m.entries[i].key); return r; })(<any>sortedMap);
            for (let loopIndex = 0; loopIndex < array.length; loopIndex++) {
                let index = array[loopIndex];
                {
                    roomsIndices[i] = index;
                    roomsLevels[i] = rooms[i].getLevel();
                    i++;
                }
            }
        }
        const deletedDimensionLines: Array<DimensionLine> = Home.getDimensionLinesSubList(deletedItems);
        const dimensionLines: DimensionLine[] = /* toArray */deletedDimensionLines.slice(0);
        const dimensionLinesLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(dimensionLines.length);
        for (i = 0; i < dimensionLines.length; i++) {
            {
                dimensionLinesLevels[i] = dimensionLines[i].getLevel();
            };
        }
        const deletedPolylines: Array<Polyline> = Home.getPolylinesSubList(deletedItems);
        const homePolylines: Array<Polyline> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines();
        const sortedPolylinesMap: any = <any>({});
        for (let index = 0; index < deletedPolylines.length; index++) {
            let polyline = deletedPolylines[index];
            {
                /* put */(function (m, k, v) { if (m.entries == null) m.entries = []; for (var i = 0; i < m.entries.length; i++)  if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { var pv = m.entries[i].value; m.entries[i].value = v; return pv; } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); m.entries.sort(function (e1, e2) { return (e1.key.compareTo != null) ? e1.key.compareTo(e2) : (e1.key - e2.key); }); return null; })(sortedPolylinesMap, homePolylines.indexOf(polyline), polyline);
            }
        }
        const polylines: Polyline[] = /* toArray */((a1, a2) => { if (a1.length >= a2.length) { a1.length = 0; a1.push.apply(a1, a2); return a1; } else { return a2.slice(0); } })((s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */((m) => { if (m.entries == null) m.entries = []; return m.entries.length; })(<any>sortedPolylinesMap)), /* values */((m) => { let r = []; if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) r.push(m.entries[i].value); return r; })(<any>sortedPolylinesMap));
        const polylinesIndices: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(polylines.length);
        const polylinesLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(polylines.length);
        i = 0;
        {
            let array = /* keySet */((m) => { let r = []; if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) r.push(m.entries[i].key); return r; })(<any>sortedPolylinesMap);
            for (let loopIndex = 0; loopIndex < array.length; loopIndex++) {
                let index = array[loopIndex];
                {
                    polylinesIndices[i] = index;
                    polylinesLevels[i] = polylines[i].getLevel();
                    i++;
                }
            }
        }
        const deletedLabels: Array<Label> = Home.getLabelsSubList(deletedItems);
        const labels: Label[] = /* toArray */deletedLabels.slice(0);
        const labelsLevels: Level[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(labels.length);
        for (i = 0; i < labels.length; i++) {
            {
                labelsLevels[i] = labels[i].getLevel();
            };
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.ItemsDeletionUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, basePlanLocked, allLevelsSelection, /* toArray */deletedItems.slice(0), joinedDeletedWalls, rooms, roomsIndices, roomsLevels, dimensionLines, dimensionLinesLevels, polylines, polylinesIndices, polylinesLevels, labels, labelsLevels));
    }

    /**
     * Deletes <code>items</code> from home.
     * @param {*[]} items
     * @private
     */
    doDeleteItems(items: Array<Selectable>) {
        let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (item != null && item instanceof <any>Wall) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteWall(<Wall><any>item);
                } else if (item != null && item instanceof <any>DimensionLine) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteDimensionLine(<DimensionLine><any>item);
                } else if (item != null && item instanceof <any>Room) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteRoom(<Room><any>item);
                } else if (item != null && item instanceof <any>Polyline) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deletePolyline(<Polyline><any>item);
                } else if (item != null && item instanceof <any>Label) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteLabel(<Label><any>item);
                } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                    this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deletePieceOfFurniture(<HomePieceOfFurniture><any>item);
                }
                basePlanLocked = !this.isItemPartOfBasePlan(item) && basePlanLocked;
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(false);
    }

    /**
     * Moves and shows selected items in plan component of (<code>dx</code>,
     * <code>dy</code>) units and record it as undoable operation.
     * @param {number} dx
     * @param {number} dy
     * @private
     */
    moveAndShowSelectedItems(dx: number, dy: number) {
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        const movedItems: Array<Selectable> = <any>([]);
        for (let index = 0; index < selectedItems.length; index++) {
            let item = selectedItems[index];
            {
                if (this.isItemMovable(item)) {
                    /* add */(movedItems.push(item) > 0);
                }
            }
        }
        if (!/* isEmpty */(movedItems.length == 0)) {
            this.moveItems(movedItems, dx, dy);
            this.selectAndShowItems$java_util_List$boolean(movedItems, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
            if (/* size */(<number>movedItems.length) !== 1 || !(/* get */movedItems[0] != null && /* get */movedItems[0] instanceof <any>Camera)) {
                this.postItemsMove(movedItems, selectedItems, dx, dy);
            }
        }
    }

    /**
     * Moves <code>items</code> of (<code>dx</code>, <code>dy</code>) units.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @param {number} dx
     * @param {number} dy
     */
    public moveItems(items: Array<any>, dx: number, dy: number) {
        for (let index = 0; index < items.length; index++) {
            let item = items[index];
            {
                if (item != null && item instanceof <any>Wall) {
                    const wall: Wall = <Wall><any>item;
                    wall.removePropertyChangeListener(this.wallChangeListener);
                    PlanController.moveWallStartPoint(wall, wall.getXStart() + dx, wall.getYStart() + dy, !/* contains */(items.indexOf(<any>(wall.getWallAtStart())) >= 0));
                    PlanController.moveWallEndPoint(wall, wall.getXEnd() + dx, wall.getYEnd() + dy, !/* contains */(items.indexOf(<any>(wall.getWallAtEnd())) >= 0));
                    this.resetAreaCache();
                    wall.addPropertyChangeListener(this.wallChangeListener);
                } else {
                    let boundToWall: boolean = false;
                    if (item != null && item instanceof <any>HomeDoorOrWindow) {
                        boundToWall = (<HomeDoorOrWindow><any>item).isBoundToWall();
                    }
                    item.move(dx, dy);
                    if (boundToWall) {
                        const itemArea: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(item.getPoints()));
                        itemArea.intersect(this.getWallsArea(true));
                        (<HomeDoorOrWindow><any>item).setBoundToWall(!itemArea.isEmpty());
                    }
                }
            }
        }
    }

    /**
     * Moves <code>wall</code> start point to (<code>xStart</code>, <code>yStart</code>)
     * and the wall point joined to its start point if <code>moveWallAtStart</code> is true.
     * @param {Wall} wall
     * @param {number} xStart
     * @param {number} yStart
     * @param {boolean} moveWallAtStart
     * @private
     */
    static moveWallStartPoint(wall: Wall, xStart: number, yStart: number, moveWallAtStart: boolean) {
        const oldXStart: number = wall.getXStart();
        const oldYStart: number = wall.getYStart();
        wall.setXStart(xStart);
        wall.setYStart(yStart);
        const wallAtStart: Wall = wall.getWallAtStart();
        if (wallAtStart != null && moveWallAtStart) {
            if (wallAtStart.getWallAtStart() === wall && (wallAtStart.getWallAtEnd() !== wall || (wallAtStart.getXStart() === oldXStart && wallAtStart.getYStart() === oldYStart))) {
                wallAtStart.setXStart(xStart);
                wallAtStart.setYStart(yStart);
            } else if (wallAtStart.getWallAtEnd() === wall && (wallAtStart.getWallAtStart() !== wall || (wallAtStart.getXEnd() === oldXStart && wallAtStart.getYEnd() === oldYStart))) {
                wallAtStart.setXEnd(xStart);
                wallAtStart.setYEnd(yStart);
            }
        }
    }

    /**
     * Moves <code>wall</code> end point to (<code>xEnd</code>, <code>yEnd</code>)
     * and the wall point joined to its end if <code>moveWallAtEnd</code> is true.
     * @param {Wall} wall
     * @param {number} xEnd
     * @param {number} yEnd
     * @param {boolean} moveWallAtEnd
     * @private
     */
    static moveWallEndPoint(wall: Wall, xEnd: number, yEnd: number, moveWallAtEnd: boolean) {
        const oldXEnd: number = wall.getXEnd();
        const oldYEnd: number = wall.getYEnd();
        wall.setXEnd(xEnd);
        wall.setYEnd(yEnd);
        const wallAtEnd: Wall = wall.getWallAtEnd();
        if (wallAtEnd != null && moveWallAtEnd) {
            if (wallAtEnd.getWallAtStart() === wall && (wallAtEnd.getWallAtEnd() !== wall || (wallAtEnd.getXStart() === oldXEnd && wallAtEnd.getYStart() === oldYEnd))) {
                wallAtEnd.setXStart(xEnd);
                wallAtEnd.setYStart(yEnd);
            } else if (wallAtEnd.getWallAtEnd() === wall && (wallAtEnd.getWallAtStart() !== wall || (wallAtEnd.getXEnd() === oldXEnd && wallAtEnd.getYEnd() === oldYEnd))) {
                wallAtEnd.setXEnd(xEnd);
                wallAtEnd.setYEnd(yEnd);
            }
        }
    }

    /**
     * Moves <code>wall</code> start point to (<code>x</code>, <code>y</code>)
     * if <code>editingStartPoint</code> is true or <code>wall</code> end point
     * to (<code>x</code>, <code>y</code>) if <code>editingStartPoint</code> is false.
     * @param {Wall} wall
     * @param {number} x
     * @param {number} y
     * @param {boolean} startPoint
     * @private
     */
    static moveWallPoint(wall: Wall, x: number, y: number, startPoint: boolean) {
        if (startPoint) {
            PlanController.moveWallStartPoint(wall, x, y, true);
        } else {
            PlanController.moveWallEndPoint(wall, x, y, true);
        }
    }

    /**
     * Moves <code>room</code> point at the given index to (<code>x</code>, <code>y</code>).
     * @param {Room} room
     * @param {number} x
     * @param {number} y
     * @param {number} pointIndex
     * @private
     */
    static moveRoomPoint(room: Room, x: number, y: number, pointIndex: number) {
        room.setPoint(x, y, pointIndex);
    }

    /**
     * Moves <code>dimensionLine</code> start point to (<code>x</code>, <code>y</code>)
     * if <code>editingStartPoint</code> is true or <code>dimensionLine</code> end point
     * to (<code>x</code>, <code>y</code>) if <code>editingStartPoint</code> is false.
     * @param {DimensionLine} dimensionLine
     * @param {number} x
     * @param {number} y
     * @param {boolean} startPoint
     * @private
     */
    static moveDimensionLinePoint(dimensionLine: DimensionLine, x: number, y: number, startPoint: boolean) {
        if (startPoint) {
            dimensionLine.setXStart(x);
            dimensionLine.setYStart(y);
        } else {
            dimensionLine.setXEnd(x);
            dimensionLine.setYEnd(y);
        }
    }

    /**
     * Swaps start and end points of the given dimension line.
     * @param {DimensionLine} dimensionLine
     * @private
     */
    static reverseDimensionLine(dimensionLine: DimensionLine) {
        const swappedX: number = dimensionLine.getXStart();
        const swappedY: number = dimensionLine.getYStart();
        dimensionLine.setXStart(dimensionLine.getXEnd());
        dimensionLine.setYStart(dimensionLine.getYEnd());
        dimensionLine.setXEnd(swappedX);
        dimensionLine.setYEnd(swappedY);
        dimensionLine.setOffset(-dimensionLine.getOffset());
    }

    selectAndShowItems$java_util_List(items: Array<any>) {
        this.selectAndShowItems$java_util_List$boolean(items, false);
    }

    public selectAndShowItems$java_util_List$boolean(items: Array<any>, allLevelsSelection: boolean) {
        this.selectItems$java_util_List$boolean(items, allLevelsSelection);
        this.selectLevelFromSelectedItems();
        this.getView().makeSelectionVisible();
    }

    /**
     * Selects <code>items</code> and make them visible at screen.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @param {boolean} allLevelsSelection
     * @private
     */
    public selectAndShowItems(items?: any, allLevelsSelection?: any) {
        if (((items != null && (items instanceof Array)) || items === null) && ((typeof allLevelsSelection === 'boolean') || allLevelsSelection === null)) {
            return <any>this.selectAndShowItems$java_util_List$boolean(items, allLevelsSelection);
        } else if (((items != null && (items instanceof Array)) || items === null) && allLevelsSelection === undefined) {
            return <any>this.selectAndShowItems$java_util_List(items);
        } else throw new Error('invalid overload');
    }

    selectItems$java_util_List(items: Array<any>) {
        this.selectItems$java_util_List$boolean(items, false);
    }

    public selectItems$java_util_List$boolean(items: Array<any>, allLevelsSelection: boolean) {
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.removeSelectionListener(this.selectionListener);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(items);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addSelectionListener(this.selectionListener);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(allLevelsSelection);
    }

    /**
     * Selects <code>items</code>.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     * @param {boolean} allLevelsSelection
     * @private
     */
    public selectItems(items?: any, allLevelsSelection?: any) {
        if (((items != null && (items instanceof Array)) || items === null) && ((typeof allLevelsSelection === 'boolean') || allLevelsSelection === null)) {
            return <any>this.selectItems$java_util_List$boolean(items, allLevelsSelection);
        } else if (((items != null && (items instanceof Array)) || items === null) && allLevelsSelection === undefined) {
            return <any>this.selectItems$java_util_List(items);
        } else throw new Error('invalid overload');
    }

    /**
     * Selects the given <code>item</code>.
     * @param {Object} item
     */
    public selectItem(item: Selectable) {
        this.selectItems$java_util_List(/* asList */[item].slice(0));
    }

    /**
     * Toggles the selection of the given <code>item</code>.
     * @param {Object} item
     */
    public toggleItemSelection(item: Selectable) {
        const selectedItems: Array<Selectable> = <any>(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems().slice(0));
        if (/* contains */(selectedItems.indexOf(<any>(item)) >= 0)) {
            /* remove */(a => { let index = a.indexOf(item); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems);
        } else {
            /* add */(selectedItems.push(item) > 0);
        }
        this.selectItems$java_util_List$boolean(selectedItems, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    /**
     * Deselects all walls in plan.
     * @private
     */
    deselectAll() {
        const emptyList: Array<Selectable> = /* emptyList */[];
        this.selectItems$java_util_List(emptyList);
    }

    /**
     * Adds <code>items</code> to home and post an undoable operation.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} items
     */
    public addItems(items: Array<any>) {
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.beginUpdate();
        this.addFurniture$java_util_List(Home.getFurnitureSubList(items));
        this.addWalls(Home.getWallsSubList(items));
        this.addRooms(Home.getRoomsSubList(items));
        this.addPolylines(Home.getPolylinesSubList(items));
        this.addDimensionLines(Home.getDimensionLinesSubList(items));
        this.addLabels(Home.getLabelsSubList(items));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setSelectedItems(items);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.ItemsAdditionEndUndoableEdit(this.__com_eteks_sweethome3d_viewcontroller_PlanController_home, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */items.slice(0)));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.endUpdate();
    }

    public addFurniture(furniture?: any, furnitureLevels?: any, group?: any, beforePiece?: any) {
        if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((furnitureLevels != null && furnitureLevels instanceof <any>Array && (furnitureLevels.length == 0 || furnitureLevels[0] == null || (furnitureLevels[0] != null && furnitureLevels[0] instanceof <any>Level))) || furnitureLevels === null) && ((group != null && group instanceof <any>HomeFurnitureGroup) || group === null) && ((beforePiece != null && beforePiece instanceof <any>HomePieceOfFurniture) || beforePiece === null)) {
            super.addFurniture(furniture, furnitureLevels, group, beforePiece);
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && ((furnitureLevels != null && furnitureLevels instanceof <any>HomePieceOfFurniture) || furnitureLevels === null) && group === undefined && beforePiece === undefined) {
            return <any>this.addFurniture$java_util_List$com_eteks_sweethome3d_model_HomePieceOfFurniture(furniture, furnitureLevels);
        } else if (((furniture != null && (furniture instanceof Array)) || furniture === null) && furnitureLevels === undefined && group === undefined && beforePiece === undefined) {
            return <any>this.addFurniture$java_util_List(furniture);
        } else throw new Error('invalid overload');
    }

    public addFurniture$java_util_List(furniture: Array<HomePieceOfFurniture>) {
        super.addFurniture$java_util_List(furniture);
        if (this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) {
            const wallsArea: java.awt.geom.Area = this.getWallsArea(false);
            for (let index = 0; index < furniture.length; index++) {
                let piece = furniture[index];
                {
                    if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                        const piecePoints: number[][] = piece.getPoints();
                        const pieceAreaIntersection: java.awt.geom.Area = new java.awt.geom.Area(this.getPath$float_A_A(piecePoints));
                        pieceAreaIntersection.intersect(wallsArea);
                        if (!pieceAreaIntersection.isEmpty() && new Room(piecePoints).getArea() / this.getArea(pieceAreaIntersection) > 0.999) {
                            (<HomeDoorOrWindow>piece).setBoundToWall(true);
                        }
                    }
                }
            }
        }
    }

    /**
     * Adds <code>walls</code> to home and post an undoable new wall operation.
     * @param {Wall[]} walls
     */
    public addWalls(walls: Array<Wall>) {
        for (let index = 0; index < walls.length; index++) {
            let wall = walls[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(wall);
            }
        }
        this.postCreateWalls(walls, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    /**
     * Posts an undoable new wall operation, about <code>newWalls</code>.
     * @param {Wall[]} newWalls
     * @param {*[]} oldSelectedItems
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @private
     */
    postCreateWalls(newWalls: Array<Wall>, oldSelectedItems: Array<Selectable>, oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean) {
        if (/* size */(<number>newWalls.length) > 0) {
            let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            if (basePlanLocked) {
                for (let index = 0; index < newWalls.length; index++) {
                    let wall = newWalls[index];
                    {
                        basePlanLocked = !this.isItemPartOfBasePlan(wall) && basePlanLocked;
                    }
                }
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            const joinedNewWalls: PlanController.JoinedWall[] = PlanController.JoinedWall.getJoinedWalls(newWalls);
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallsCreationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, oldBasePlanLocked, oldAllLevelsSelection, joinedNewWalls, newBasePlanLocked));
        }
    }

    /**
     * Adds the walls in <code>joinedWalls</code> to plan component, joins
     * them to other walls if necessary.
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedWalls
     * @param {boolean} basePlanLocked
     * @private
     */
    doAddWalls(joinedWalls: PlanController.JoinedWall[], basePlanLocked: boolean) {
        for (let index = 0; index < joinedWalls.length; index++) {
            let joinedNewWall = joinedWalls[index];
            {
                const wall: Wall = joinedNewWall.getWall();
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(wall);
                wall.setLevel(joinedNewWall.getLevel());
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
        for (let index = 0; index < joinedWalls.length; index++) {
            let joinedNewWall = joinedWalls[index];
            {
                const wall: Wall = joinedNewWall.getWall();
                const wallAtStart: Wall = joinedNewWall.getWallAtStart();
                if (wallAtStart != null) {
                    wall.setWallAtStart(wallAtStart);
                    if (joinedNewWall.isJoinedAtEndOfWallAtStart()) {
                        wallAtStart.setWallAtEnd(wall);
                    } else {
                        wallAtStart.setWallAtStart(wall);
                    }
                }
                const wallAtEnd: Wall = joinedNewWall.getWallAtEnd();
                if (wallAtEnd != null) {
                    wall.setWallAtEnd(wallAtEnd);
                    if (joinedNewWall.isJoinedAtStartOfWallAtEnd()) {
                        wallAtEnd.setWallAtStart(wall);
                    } else {
                        wallAtEnd.setWallAtEnd(wall);
                    }
                }
            }
        }
    }

    /**
     * Deletes walls referenced in <code>joinedDeletedWalls</code>.
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedDeletedWalls
     * @param {boolean} basePlanLocked
     * @private
     */
    doDeleteWalls(joinedDeletedWalls: PlanController.JoinedWall[], basePlanLocked: boolean) {
        for (let index = 0; index < joinedDeletedWalls.length; index++) {
            let joinedWall = joinedDeletedWalls[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteWall(joinedWall.getWall());
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Add <code>newRooms</code> to home and post an undoable new room line operation.
     * @param {Room[]} rooms
     */
    public addRooms(rooms: Array<Room>) {
        const newRooms: Room[] = /* toArray */rooms.slice(0);
        const roomsIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>rooms.length));
        let endIndex: number = /* size */(<number>this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms().length);
        for (let i: number = 0; i < roomsIndex.length; i++) {
            {
                roomsIndex[i] = endIndex++;
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addRoom$com_eteks_sweethome3d_model_Room$int(newRooms[i], roomsIndex[i]);
            };
        }
        this.postCreateRooms$com_eteks_sweethome3d_model_Room_A$int_A$java_util_List$boolean$boolean(newRooms, roomsIndex, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    public postCreateRooms$com_eteks_sweethome3d_model_Room_A$int_A$java_util_List$boolean$boolean(newRooms: Room[], roomsIndex: number[], oldSelectedItems: Array<Selectable>, oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean) {
        if (newRooms.length > 0) {
            let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            if (basePlanLocked) {
                for (let index = 0; index < newRooms.length; index++) {
                    let room = newRooms[index];
                    {
                        basePlanLocked = !this.isItemPartOfBasePlan(room) && basePlanLocked;
                    }
                }
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            const roomsLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomsCreationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, oldBasePlanLocked, oldAllLevelsSelection, newRooms, roomsIndex, roomsLevel, newBasePlanLocked));
        }
    }

    /**
     * Posts an undoable new room operation, about <code>newRooms</code>.
     * @param {com.eteks.sweethome3d.model.Room[]} newRooms
     * @param {int[]} roomsIndex
     * @param {*[]} oldSelectedItems
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @private
     */
    public postCreateRooms(newRooms?: any, roomsIndex?: any, oldSelectedItems?: any, oldBasePlanLocked?: any, oldAllLevelsSelection?: any) {
        if (((newRooms != null && newRooms instanceof <any>Array && (newRooms.length == 0 || newRooms[0] == null || (newRooms[0] != null && newRooms[0] instanceof <any>Room))) || newRooms === null) && ((roomsIndex != null && roomsIndex instanceof <any>Array && (roomsIndex.length == 0 || roomsIndex[0] == null || (typeof roomsIndex[0] === 'number'))) || roomsIndex === null) && ((oldSelectedItems != null && (oldSelectedItems instanceof Array)) || oldSelectedItems === null) && ((typeof oldBasePlanLocked === 'boolean') || oldBasePlanLocked === null) && ((typeof oldAllLevelsSelection === 'boolean') || oldAllLevelsSelection === null)) {
            return <any>this.postCreateRooms$com_eteks_sweethome3d_model_Room_A$int_A$java_util_List$boolean$boolean(newRooms, roomsIndex, oldSelectedItems, oldBasePlanLocked, oldAllLevelsSelection);
        } else if (((newRooms != null && (newRooms instanceof Array)) || newRooms === null) && ((roomsIndex != null && (roomsIndex instanceof Array)) || roomsIndex === null) && ((typeof oldSelectedItems === 'boolean') || oldSelectedItems === null) && ((typeof oldBasePlanLocked === 'boolean') || oldBasePlanLocked === null) && oldAllLevelsSelection === undefined) {
            return <any>this.postCreateRooms$java_util_List$java_util_List$boolean$boolean(newRooms, roomsIndex, oldSelectedItems, oldBasePlanLocked);
        } else throw new Error('invalid overload');
    }

    postCreateRooms$java_util_List$java_util_List$boolean$boolean(rooms: Array<Room>, oldSelection: Array<Selectable>, basePlanLocked: boolean, allLevelsSelection: boolean) {
        const newRooms: Room[] = /* toArray */rooms.slice(0);
        const roomsIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>rooms.length));
        const homeRooms: Array<Room> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getRooms();
        for (let i: number = 0; i < roomsIndex.length; i++) {
            {
                roomsIndex[i] = homeRooms.lastIndexOf(newRooms[i]);
            };
        }
        this.postCreateRooms$com_eteks_sweethome3d_model_Room_A$int_A$java_util_List$boolean$boolean(newRooms, roomsIndex, oldSelection, basePlanLocked, allLevelsSelection);
    }

    /**
     * Adds the <code>rooms</code> to plan component.
     * @param {com.eteks.sweethome3d.model.Room[]} rooms
     * @param {int[]} roomsIndices
     * @param {com.eteks.sweethome3d.model.Level[]} roomsLevels
     * @param {Level} uniqueRoomsLevel
     * @param {boolean} basePlanLocked
     * @private
     */
    doAddRooms(rooms: Room[], roomsIndices: number[], roomsLevels: Level[], uniqueRoomsLevel: Level, basePlanLocked: boolean) {
        for (let i: number = 0; i < roomsIndices.length; i++) {
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addRoom$com_eteks_sweethome3d_model_Room$int(rooms[i], roomsIndices[i]);
                rooms[i].setLevel(roomsLevels != null ? roomsLevels[i] : uniqueRoomsLevel);
            };
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Deletes <code>rooms</code>.
     * @param {com.eteks.sweethome3d.model.Room[]} rooms
     * @param {boolean} basePlanLocked
     * @private
     */
    doDeleteRooms(rooms: Room[], basePlanLocked: boolean) {
        for (let index = 0; index < rooms.length; index++) {
            let room = rooms[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteRoom(room);
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Add <code>dimensionLines</code> to home and post an undoable new dimension line operation.
     * @param {DimensionLine[]} dimensionLines
     */
    public addDimensionLines(dimensionLines: Array<DimensionLine>) {
        for (let index = 0; index < dimensionLines.length; index++) {
            let dimensionLine = dimensionLines[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addDimensionLine(dimensionLine);
            }
        }
        this.postCreateDimensionLines(dimensionLines, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    /**
     * Posts an undoable new dimension line operation, about <code>newDimensionLines</code>.
     * @param {DimensionLine[]} newDimensionLines
     * @param {*[]} oldSelectedItems
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @private
     */
    postCreateDimensionLines(newDimensionLines: Array<DimensionLine>, oldSelectedItems: Array<Selectable>, oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean) {
        if (/* size */(<number>newDimensionLines.length) > 0) {
            let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            if (basePlanLocked) {
                for (let index = 0; index < newDimensionLines.length; index++) {
                    let dimensionLine = newDimensionLines[index];
                    {
                        basePlanLocked = !this.isItemPartOfBasePlan(dimensionLine) && basePlanLocked;
                    }
                }
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            const dimensionLines: DimensionLine[] = /* toArray */newDimensionLines.slice(0);
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            const dimensionLinesLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLinesCreationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, oldBasePlanLocked, oldAllLevelsSelection, dimensionLines, dimensionLinesLevel, newBasePlanLocked));
        }
    }

    /**
     * Adds the dimension lines in <code>dimensionLines</code> to plan component.
     * @param {com.eteks.sweethome3d.model.DimensionLine[]} dimensionLines
     * @param {com.eteks.sweethome3d.model.Level[]} dimensionLinesLevels
     * @param {Level} uniqueDimensionLinesLevel
     * @param {boolean} basePlanLocked
     * @private
     */
    doAddDimensionLines(dimensionLines: DimensionLine[], dimensionLinesLevels: Level[], uniqueDimensionLinesLevel: Level, basePlanLocked: boolean) {
        for (let i: number = 0; i < dimensionLines.length; i++) {
            {
                const dimensionLine: DimensionLine = dimensionLines[i];
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addDimensionLine(dimensionLine);
                dimensionLine.setLevel(dimensionLinesLevels != null ? dimensionLinesLevels[i] : uniqueDimensionLinesLevel);
            };
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Deletes dimension lines in <code>dimensionLines</code>.
     * @param {com.eteks.sweethome3d.model.DimensionLine[]} dimensionLines
     * @param {boolean} basePlanLocked
     * @private
     */
    doDeleteDimensionLines(dimensionLines: DimensionLine[], basePlanLocked: boolean) {
        for (let index = 0; index < dimensionLines.length; index++) {
            let dimensionLine = dimensionLines[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteDimensionLine(dimensionLine);
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Adds <code>polylines</code> to home and posts an undoable new polyline line operation.
     * @param {Polyline[]} polylines
     */
    public addPolylines(polylines: Array<Polyline>) {
        const newPolylines: Polyline[] = /* toArray */polylines.slice(0);
        const polylinesIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>polylines.length));
        let endIndex: number = /* size */(<number>this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines().length);
        for (let i: number = 0; i < polylinesIndex.length; i++) {
            {
                polylinesIndex[i] = endIndex++;
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPolyline$com_eteks_sweethome3d_model_Polyline$int(newPolylines[i], polylinesIndex[i]);
            };
        }
        this.postCreatePolylines$com_eteks_sweethome3d_model_Polyline_A$int_A$java_util_List$boolean$boolean(newPolylines, polylinesIndex, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    public postCreatePolylines$com_eteks_sweethome3d_model_Polyline_A$int_A$java_util_List$boolean$boolean(newPolylines: Polyline[], polylinesIndex: number[], oldSelectedItems: Array<Selectable>, oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean) {
        if (newPolylines.length > 0) {
            let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            if (basePlanLocked) {
                for (let index = 0; index < newPolylines.length; index++) {
                    let polyline = newPolylines[index];
                    {
                        basePlanLocked = !this.isItemPartOfBasePlan(polyline) && basePlanLocked;
                    }
                }
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            const polylinesLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PolylinesCreationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, oldBasePlanLocked, oldAllLevelsSelection, newPolylines, polylinesIndex, polylinesLevel, newBasePlanLocked));
        }
    }

    /**
     * Posts an undoable new polyline operation about <code>newPolylines</code>.
     * @param {com.eteks.sweethome3d.model.Polyline[]} newPolylines
     * @param {int[]} polylinesIndex
     * @param {*[]} oldSelectedItems
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @private
     */
    public postCreatePolylines(newPolylines?: any, polylinesIndex?: any, oldSelectedItems?: any, oldBasePlanLocked?: any, oldAllLevelsSelection?: any) {
        if (((newPolylines != null && newPolylines instanceof <any>Array && (newPolylines.length == 0 || newPolylines[0] == null || (newPolylines[0] != null && newPolylines[0] instanceof <any>Polyline))) || newPolylines === null) && ((polylinesIndex != null && polylinesIndex instanceof <any>Array && (polylinesIndex.length == 0 || polylinesIndex[0] == null || (typeof polylinesIndex[0] === 'number'))) || polylinesIndex === null) && ((oldSelectedItems != null && (oldSelectedItems instanceof Array)) || oldSelectedItems === null) && ((typeof oldBasePlanLocked === 'boolean') || oldBasePlanLocked === null) && ((typeof oldAllLevelsSelection === 'boolean') || oldAllLevelsSelection === null)) {
            return <any>this.postCreatePolylines$com_eteks_sweethome3d_model_Polyline_A$int_A$java_util_List$boolean$boolean(newPolylines, polylinesIndex, oldSelectedItems, oldBasePlanLocked, oldAllLevelsSelection);
        } else if (((newPolylines != null && (newPolylines instanceof Array)) || newPolylines === null) && ((polylinesIndex != null && (polylinesIndex instanceof Array)) || polylinesIndex === null) && ((typeof oldSelectedItems === 'boolean') || oldSelectedItems === null) && ((typeof oldBasePlanLocked === 'boolean') || oldBasePlanLocked === null) && oldAllLevelsSelection === undefined) {
            return <any>this.postCreatePolylines$java_util_List$java_util_List$boolean$boolean(newPolylines, polylinesIndex, oldSelectedItems, oldBasePlanLocked);
        } else throw new Error('invalid overload');
    }

    postCreatePolylines$java_util_List$java_util_List$boolean$boolean(polylines: Array<Polyline>, oldSelection: Array<Selectable>, basePlanLocked: boolean, allLevelsSelection: boolean) {
        const newPolylines: Polyline[] = /* toArray */polylines.slice(0);
        const polylinesIndex: number[] = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>polylines.length));
        const homePolylines: Array<Polyline> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines();
        for (let i: number = 0; i < polylinesIndex.length; i++) {
            {
                polylinesIndex[i] = homePolylines.lastIndexOf(newPolylines[i]);
            };
        }
        this.postCreatePolylines$com_eteks_sweethome3d_model_Polyline_A$int_A$java_util_List$boolean$boolean(newPolylines, polylinesIndex, oldSelection, basePlanLocked, allLevelsSelection);
    }

    /**
     * Adds the <code>polylines</code> to plan component.
     * @param {com.eteks.sweethome3d.model.Polyline[]} polylines
     * @param {int[]} polylinesIndex
     * @param {com.eteks.sweethome3d.model.Level[]} polylinesLevels
     * @param {Level} uniqueDimensionLinesLevel
     * @param {boolean} basePlanLocked
     * @private
     */
    doAddPolylines(polylines: Polyline[], polylinesIndex: number[], polylinesLevels: Level[], uniqueDimensionLinesLevel: Level, basePlanLocked: boolean) {
        for (let i: number = 0; i < polylinesIndex.length; i++) {
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPolyline$com_eteks_sweethome3d_model_Polyline$int(polylines[i], polylinesIndex[i]);
                polylines[i].setLevel(polylinesLevels != null ? polylinesLevels[i] : uniqueDimensionLinesLevel);
            };
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Deletes <code>polylines</code>.
     * @param {com.eteks.sweethome3d.model.Polyline[]} polylines
     * @param {boolean} basePlanLocked
     * @private
     */
    doDeletePolylines(polylines: Polyline[], basePlanLocked: boolean) {
        for (let index = 0; index < polylines.length; index++) {
            let polyline = polylines[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deletePolyline(polyline);
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Add <code>labels</code> to home and post an undoable new label operation.
     * @param {Label[]} labels
     */
    public addLabels(labels: Array<Label>) {
        for (let index = 0; index < labels.length; index++) {
            let label = labels[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addLabel(label);
            }
        }
        this.postCreateLabels(labels, this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked(), this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
    }

    /**
     * Posts an undoable new label operation, about <code>newLabels</code>.
     * @param {Label[]} newLabels
     * @param {*[]} oldSelectedItems
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @private
     */
    postCreateLabels(newLabels: Array<Label>, oldSelectedItems: Array<Selectable>, oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean) {
        if (/* size */(<number>newLabels.length) > 0) {
            let basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            if (basePlanLocked) {
                for (let index = 0; index < newLabels.length; index++) {
                    let label = newLabels[index];
                    {
                        basePlanLocked = !this.isItemPartOfBasePlan(label) && basePlanLocked;
                    }
                }
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
            }
            const newBasePlanLocked: boolean = basePlanLocked;
            const labels: Label[] = /* toArray */newLabels.slice(0);
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            const labelsLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LabelsCreationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, oldBasePlanLocked, oldAllLevelsSelection, labels, labelsLevel, newBasePlanLocked));
        }
    }

    /**
     * Adds the labels in <code>labels</code> to plan component.
     * @param {com.eteks.sweethome3d.model.Label[]} labels
     * @param {com.eteks.sweethome3d.model.Level[]} labelsLevels
     * @param {Level} uniqueLabelLevel
     * @param {boolean} basePlanLocked
     * @private
     */
    doAddLabels(labels: Label[], labelsLevels: Level[], uniqueLabelLevel: Level, basePlanLocked: boolean) {
        for (let i: number = 0; i < labels.length; i++) {
            {
                const label: Label = labels[i];
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addLabel(label);
                label.setLevel(labelsLevels != null ? labelsLevels[i] : uniqueLabelLevel);
            };
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Deletes labels in <code>labels</code>.
     * @param {com.eteks.sweethome3d.model.Label[]} labels
     * @param {boolean} basePlanLocked
     * @private
     */
    doDeleteLabels(labels: Label[], basePlanLocked: boolean) {
        for (let index = 0; index < labels.length; index++) {
            let label = labels[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteLabel(label);
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setBasePlanLocked(basePlanLocked);
    }

    /**
     * Posts an undoable operation about <code>label</code> angle change.
     * @param {Label} label
     * @param {number} oldAngle
     * @private
     */
    postLabelRotation(label: Label, oldAngle: number) {
        const newAngle: number = label.getAngle();
        if (newAngle !== oldAngle) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LabelRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldAngle, label, newAngle));
        }
    }

    /**
     * Post to undo support an elevation change on <code>label</code>.
     * @param {Label} label
     * @param {number} oldElevation
     * @private
     */
    postLabelElevation(label: Label, oldElevation: number) {
        const newElevation: number = label.getElevation();
        if (newElevation !== oldElevation) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LabelElevationModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldElevation, label, newElevation));
        }
    }

    /**
     * Posts an undoable operation of a (<code>dx</code>, <code>dy</code>) move
     * of <code>movedItems</code>.
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} movedItems
     * @param {? extends com.eteks.sweethome3d.model.Selectable[]} oldSelectedItems
     * @param {number} dx
     * @param {number} dy
     * @private
     */
    postItemsMove(movedItems: Array<any>, oldSelectedItems: Array<any>, dx: number, dy: number) {
        if (dx !== 0 || dy !== 0) {
            const itemsArray: Selectable[] = /* toArray */movedItems.slice(0);
            const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            const oldSelection: Selectable[] = /* toArray */oldSelectedItems.slice(0);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.ItemsMovingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldSelection, allLevelsSelection, itemsArray, dx, dy));
        }
    }

    /**
     * Moves <code>movedItems</code> of (<code>dx</code>, <code>dy</code>) pixels,
     * selects them and make them visible.
     * @param {com.eteks.sweethome3d.model.Selectable[]} movedItems
     * @param {com.eteks.sweethome3d.model.Selectable[]} selectedItems
     * @param {number} dx
     * @param {number} dy
     * @param {boolean} allLevelsSelection
     * @private
     */
    doMoveAndShowItems(movedItems: Selectable[], selectedItems: Selectable[], dx: number, dy: number, allLevelsSelection: boolean) {
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.setAllLevelsSelection(allLevelsSelection);
        this.moveItems(/* asList */movedItems.slice(0), dx, dy);
        this.selectAndShowItems$java_util_List$boolean(/* asList */selectedItems.slice(0), allLevelsSelection);
    }

    /**
     * Posts an undoable operation of a (<code>dx</code>, <code>dy</code>) move
     * of the given <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} dx
     * @param {number} dy
     * @param {number} oldAngle
     * @param {number} oldDepth
     * @param {number} oldElevation
     * @param {boolean} oldDoorOrWindowBoundToWall
     * @private
     */
    postPieceOfFurnitureMove(piece: HomePieceOfFurniture, dx: number, dy: number, oldAngle: number, oldDepth: number, oldElevation: number, oldDoorOrWindowBoundToWall: boolean) {
        const newAngle: number = piece.getAngle();
        const newDepth: number = piece.getDepth();
        const newElevation: number = piece.getElevation();
        if (dx !== 0 || dy !== 0 || newAngle !== oldAngle || newDepth !== oldDepth || newElevation !== oldElevation) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureMovingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldAngle, oldDepth, oldElevation, oldDoorOrWindowBoundToWall, piece, dx, dy, newAngle, newDepth, newElevation));
        }
    }

    /**
     * Posts an undoable operation about duplication <code>items</code>.
     * @param {*[]} items
     * @param {*[]} oldSelection
     * @private
     */
    postItemsDuplication(items: Array<Selectable>, oldSelection: Array<Selectable>) {
        const basePlanLocked: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
        const allLevelsSelection: boolean = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
        const furniture: Array<HomePieceOfFurniture> = Home.getFurnitureSubList(items);
        for (let index = 0; index < furniture.length; index++) {
            let piece = furniture[index];
            {
                this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deletePieceOfFurniture(piece);
            }
        }
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.beginUpdate();
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DuplicationStartUndoableEdit(this, /* toArray */oldSelection.slice(0), allLevelsSelection));
        this.addFurniture$java_util_List(furniture);
        const emptyList: Array<Selectable> = /* emptyList */[];
        this.postCreateWalls(Home.getWallsSubList(items), emptyList, basePlanLocked, allLevelsSelection);
        this.postCreateRooms$java_util_List$java_util_List$boolean$boolean(Home.getRoomsSubList(items), emptyList, basePlanLocked, allLevelsSelection);
        this.postCreatePolylines$java_util_List$java_util_List$boolean$boolean(Home.getPolylinesSubList(items), emptyList, basePlanLocked, allLevelsSelection);
        this.postCreateDimensionLines(Home.getDimensionLinesSubList(items), emptyList, basePlanLocked, allLevelsSelection);
        this.postCreateLabels(Home.getLabelsSubList(items), emptyList, basePlanLocked, allLevelsSelection);
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DuplicationEndUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, /* toArray */items.slice(0)));
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.endUpdate();
        this.selectItems$java_util_List(items);
    }

    /**
     * Posts an undoable operation about <code>wall</code> resizing.
     * @param {Wall} wall
     * @param {number} oldX
     * @param {number} oldY
     * @param {boolean} startPoint
     * @private
     */
    postWallResize(wall: Wall, oldX: number, oldY: number, startPoint: boolean) {
        let newX: number;
        let newY: number;
        if (startPoint) {
            newX = wall.getXStart();
            newY = wall.getYStart();
        } else {
            newX = wall.getXEnd();
            newY = wall.getYEnd();
        }
        if (newX !== oldX || newY !== oldY) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldX, oldY, wall, startPoint, newX, newY));
        }
    }

    /**
     * Posts an undoable operation about <code>wall</code> arc extent change.
     * @param {Wall} wall
     * @param {number} oldArcExtent
     * @private
     */
    postWallArcExtent(wall: Wall, oldArcExtent: number) {
        const newArcExtent: number = wall.getArcExtent();
        if (newArcExtent !== oldArcExtent && (newArcExtent == null || !(newArcExtent === oldArcExtent))) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.WallArcExtentModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldArcExtent, wall, newArcExtent));
        }
    }

    /**
     * Posts an undoable operation about <code>room</code> resizing.
     * @param {Room} room
     * @param {number} oldX
     * @param {number} oldY
     * @param {number} pointIndex
     * @private
     */
    postRoomResize(room: Room, oldX: number, oldY: number, pointIndex: number) {
        const roomPoint: number[] = room.getPoints()[pointIndex];
        const newX: number = roomPoint[0];
        const newY: number = roomPoint[1];
        if (newX !== oldX || newY !== oldY) {
            const undoableEdit: javax.swing.undo.UndoableEdit = new PlanController.RoomResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldX, oldY, room, pointIndex, newX, newY);
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(undoableEdit);
        }
    }

    /**
     * Posts an undoable operation about <code>room</code> name offset change.
     * @param {Room} room
     * @param {number} oldNameXOffset
     * @param {number} oldNameYOffset
     * @private
     */
    postRoomNameOffset(room: Room, oldNameXOffset: number, oldNameYOffset: number) {
        const newNameXOffset: number = room.getNameXOffset();
        const newNameYOffset: number = room.getNameYOffset();
        if (newNameXOffset !== oldNameXOffset || newNameYOffset !== oldNameYOffset) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomNameOffsetModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldNameXOffset, oldNameYOffset, room, newNameXOffset, newNameYOffset));
        }
    }

    /**
     * Posts an undoable operation about <code>room</code> name angle change.
     * @param {Room} room
     * @param {number} oldNameAngle
     * @private
     */
    postRoomNameRotation(room: Room, oldNameAngle: number) {
        const newNameAngle: number = room.getNameAngle();
        if (newNameAngle !== oldNameAngle) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomNameRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldNameAngle, room, newNameAngle));
        }
    }

    /**
     * Posts an undoable operation about <code>room</code> area offset change.
     * @param {Room} room
     * @param {number} oldAreaXOffset
     * @param {number} oldAreaYOffset
     * @private
     */
    postRoomAreaOffset(room: Room, oldAreaXOffset: number, oldAreaYOffset: number) {
        const newAreaXOffset: number = room.getAreaXOffset();
        const newAreaYOffset: number = room.getAreaYOffset();
        if (newAreaXOffset !== oldAreaXOffset || newAreaYOffset !== oldAreaYOffset) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomAreaOffsetModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldAreaXOffset, oldAreaYOffset, room, newAreaXOffset, newAreaYOffset));
        }
    }

    /**
     * Posts an undoable operation about <code>room</code> area angle change.
     * @param {Room} room
     * @param {number} oldAreaAngle
     * @private
     */
    postRoomAreaRotation(room: Room, oldAreaAngle: number) {
        const newAreaAngle: number = room.getAreaAngle();
        if (newAreaAngle !== oldAreaAngle) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.RoomAreaRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldAreaAngle, room, newAreaAngle));
        }
    }

    /**
     * Post to undo support an angle change on <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldAngle
     * @param {boolean} oldDoorOrWindowBoundToWall
     * @private
     */
    postPieceOfFurnitureRotation(piece: HomePieceOfFurniture, oldAngle: number, oldDoorOrWindowBoundToWall: boolean) {
        const newAngle: number = piece.getAngle();
        if (newAngle !== oldAngle) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldAngle, oldDoorOrWindowBoundToWall, piece, newAngle));
        }
    }

    /**
     * Post to undo support a pitch change on <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldPitch
     * @param {number} oldWidthInPlan
     * @param {number} oldDepthInPlan
     * @param {number} oldHeightInPlan
     * @private
     */
    postPieceOfFurniturePitchRotation(piece: HomePieceOfFurniture, oldPitch: number, oldWidthInPlan: number, oldDepthInPlan: number, oldHeightInPlan: number) {
        const newPitch: number = piece.getPitch();
        if (newPitch !== oldPitch) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurniturePitchRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldPitch, oldWidthInPlan, oldDepthInPlan, oldHeightInPlan, piece, newPitch, piece.getWidthInPlan(), piece.getDepthInPlan(), piece.getHeightInPlan()));
        }
    }

    /**
     * Sets the pitch angle on the given piece without computing new size in plan.
     * @param {HomePieceOfFurniture} piece
     * @param {number} pitch
     * @param {number} widthInPlan
     * @param {number} depthInPlan
     * @param {number} heightInPlan
     * @private
     */
    setPieceOfFurniturePitch(piece: HomePieceOfFurniture, pitch: number, widthInPlan: number, depthInPlan: number, heightInPlan: number) {
        piece.removePropertyChangeListener(this.furnitureSizeChangeListener);
        piece.setPitch(pitch);
        piece.setWidthInPlan(widthInPlan);
        piece.setDepthInPlan(depthInPlan);
        piece.setHeightInPlan(heightInPlan);
        piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
    }

    /**
     * Post to undo support a roll change on <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldRoll
     * @param {number} oldWidthInPlan
     * @param {number} oldDepthInPlan
     * @param {number} oldHeightInPlan
     * @private
     */
    postPieceOfFurnitureRollRotation(piece: HomePieceOfFurniture, oldRoll: number, oldWidthInPlan: number, oldDepthInPlan: number, oldHeightInPlan: number) {
        const newRoll: number = piece.getRoll();
        if (newRoll !== oldRoll) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureRollRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldRoll, oldWidthInPlan, oldDepthInPlan, oldHeightInPlan, piece, newRoll, piece.getWidthInPlan(), piece.getDepthInPlan(), piece.getHeightInPlan()));
        }
    }

    /**
     * Sets the roll angle on the given piece without computing new size in plan.
     * @param {HomePieceOfFurniture} piece
     * @param {number} roll
     * @param {number} widthInPlan
     * @param {number} depthInPlan
     * @param {number} heightInPlan
     * @private
     */
    setPieceOfFurnitureRoll(piece: HomePieceOfFurniture, roll: number, widthInPlan: number, depthInPlan: number, heightInPlan: number) {
        piece.removePropertyChangeListener(this.furnitureSizeChangeListener);
        piece.setRoll(roll);
        piece.setWidthInPlan(widthInPlan);
        piece.setDepthInPlan(depthInPlan);
        piece.setHeightInPlan(heightInPlan);
        piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
    }

    /**
     * Post to undo support an elevation change on <code>piece</code>.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldElevation
     * @private
     */
    postPieceOfFurnitureElevation(piece: HomePieceOfFurniture, oldElevation: number) {
        const newElevation: number = piece.getElevation();
        if (newElevation !== oldElevation) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureElevationModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldElevation, piece, newElevation));
        }
    }

    /**
     * Post to undo support a height change on <code>piece</code>.
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @private
     */
    postPieceOfFurnitureHeightResize(resizedPiece: PlanController.ResizedPieceOfFurniture) {
        if (resizedPiece.getPieceOfFurniture().getHeight() !== resizedPiece.getHeight()) {
            this.postPieceOfFurnitureResize(resizedPiece, "undoPieceOfFurnitureHeightResizeName");
        }
    }

    /**
     * Post to undo support a width and depth change on <code>piece</code>.
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @private
     */
    postPieceOfFurnitureWidthAndDepthResize(resizedPiece: PlanController.ResizedPieceOfFurniture) {
        const piece: HomePieceOfFurniture = resizedPiece.getPieceOfFurniture();
        if (piece.getWidth() !== resizedPiece.getWidth() || piece.getDepth() !== resizedPiece.getDepth()) {
            this.postPieceOfFurnitureResize(resizedPiece, "undoPieceOfFurnitureWidthAndDepthResizeName");
        }
    }

    /**
     * Post to undo support a size change on <code>piece</code>.
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @param {string} presentationNameKey
     * @private
     */
    postPieceOfFurnitureResize(resizedPiece: PlanController.ResizedPieceOfFurniture, presentationNameKey: string) {
        const piece: HomePieceOfFurniture = resizedPiece.getPieceOfFurniture();
        const doorOrWindowBoundToWall: boolean = (piece != null && piece instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>piece).isBoundToWall();
        this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, presentationNameKey, doorOrWindowBoundToWall, resizedPiece, piece.getX(), piece.getY(), piece.getWidth(), piece.getDepth(), piece.getHeight()));
    }

    /**
     * Sets the size of the given piece of furniture.
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @param {number} width
     * @param {number} depth
     * @param {number} height
     * @private
     */
    setPieceOfFurnitureSize(resizedPiece: PlanController.ResizedPieceOfFurniture, width: number, depth: number, height: number) {
        const piece: HomePieceOfFurniture = resizedPiece.getPieceOfFurniture();
        piece.removePropertyChangeListener(this.furnitureSizeChangeListener);
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            {
                let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        childPiece.removePropertyChangeListener(this.furnitureSizeChangeListener);
                    }
                }
            }
        }
        PlanController.ResizedPieceOfFurniture.setPieceOfFurnitureSize(piece, width, depth, height);
        piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            {
                let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        childPiece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                    }
                }
            }
        }
    }

    /**
     * Resets the size of the given piece of furniture.
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @private
     */
    resetPieceOfFurnitureSize(resizedPiece: PlanController.ResizedPieceOfFurniture) {
        const piece: HomePieceOfFurniture = resizedPiece.getPieceOfFurniture();
        piece.removePropertyChangeListener(this.furnitureSizeChangeListener);
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            {
                let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        childPiece.removePropertyChangeListener(this.furnitureSizeChangeListener);
                    }
                }
            }
        }
        resizedPiece.reset();
        piece.addPropertyChangeListener(this.furnitureSizeChangeListener);
        if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
            {
                let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                for (let index = 0; index < array.length; index++) {
                    let childPiece = array[index];
                    {
                        childPiece.addPropertyChangeListener(this.furnitureSizeChangeListener);
                    }
                }
            }
        }
    }

    /**
     * Post to undo support a power modification on <code>light</code>.
     * @param {HomeLight} light
     * @param {number} oldPower
     * @private
     */
    postLightPowerModification(light: HomeLight, oldPower: number) {
        const newPower: number = light.getPower();
        if (newPower !== oldPower) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.LightPowerModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldPower, light, newPower));
        }
    }

    /**
     * Posts an undoable operation about <code>piece</code> name offset change.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldNameXOffset
     * @param {number} oldNameYOffset
     * @private
     */
    postPieceOfFurnitureNameOffset(piece: HomePieceOfFurniture, oldNameXOffset: number, oldNameYOffset: number) {
        const newNameXOffset: number = piece.getNameXOffset();
        const newNameYOffset: number = piece.getNameYOffset();
        if (newNameXOffset !== oldNameXOffset || newNameYOffset !== oldNameYOffset) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureNameOffsetModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldNameXOffset, oldNameYOffset, piece, newNameXOffset, newNameYOffset));
        }
    }

    /**
     * Posts an undoable operation about <code>piece</code> name angle change.
     * @param {HomePieceOfFurniture} piece
     * @param {number} oldNameAngle
     * @private
     */
    postPieceOfFurnitureNameRotation(piece: HomePieceOfFurniture, oldNameAngle: number) {
        const newNameAngle: number = piece.getNameAngle();
        if (newNameAngle !== oldNameAngle) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PieceOfFurnitureNameRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldNameAngle, piece, newNameAngle));
        }
    }

    /**
     * Posts an undoable operation about <code>dimensionLine</code> resizing.
     * @param {DimensionLine} dimensionLine
     * @param {number} oldX
     * @param {number} oldY
     * @param {boolean} startPoint
     * @param {boolean} reversed
     * @private
     */
    postDimensionLineResize(dimensionLine: DimensionLine, oldX: number, oldY: number, startPoint: boolean, reversed: boolean) {
        let newX: number;
        let newY: number;
        if (startPoint) {
            newX = dimensionLine.getXStart();
            newY = dimensionLine.getYStart();
        } else {
            newX = dimensionLine.getXEnd();
            newY = dimensionLine.getYEnd();
        }
        if (newX !== oldX || newY !== oldY || reversed) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLineResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldX, oldY, dimensionLine, newX, newY, startPoint, reversed));
        }
    }

    /**
     * Posts an undoable operation about <code>dimensionLine</code> offset change.
     * @param {DimensionLine} dimensionLine
     * @param {number} oldOffset
     * @private
     */
    postDimensionLineOffset(dimensionLine: DimensionLine, oldOffset: number) {
        const newOffset: number = dimensionLine.getOffset();
        if (newOffset !== oldOffset) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLineOffsetModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldOffset, dimensionLine, newOffset));
        }
    }

    /**
     * Post to undo support a pitch angle change on <code>dimensionLine</code>.
     * @param {DimensionLine} dimensionLine
     * @param {number} oldPitch
     * @private
     */
    postDimensionLinePitchRotation(dimensionLine: DimensionLine, oldPitch: number) {
        const newPitch: number = dimensionLine.getPitch();
        if (newPitch !== oldPitch) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLinePitchRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldPitch, dimensionLine, newPitch));
        }
    }

    /**
     * Posts an undoable operation about <code>dimensionLine</code> height change.
     * @param {DimensionLine} dimensionLine
     * @param {number} oldHeight
     * @private
     */
    postDimensionLineHeight(dimensionLine: DimensionLine, oldHeight: number) {
        const newHeight: number = dimensionLine.getElevationEnd() - dimensionLine.getElevationStart();
        if (newHeight !== oldHeight) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLineHeightResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldHeight, dimensionLine, newHeight));
        }
    }

    /**
     * Post to undo support an elevation change on <code>dimensionLine</code>.
     * @param {DimensionLine} dimensionLine
     * @param {number} oldElevation
     * @private
     */
    postDimensionLineElevation(dimensionLine: DimensionLine, oldElevation: number) {
        const newElevation: number = dimensionLine.getElevationStart();
        if (newElevation !== oldElevation) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.DimensionLineElevationModificationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldElevation, dimensionLine, newElevation));
        }
    }

    /**
     * Posts an undoable operation about <code>polyline</code> resizing.
     * @param {Polyline} polyline
     * @param {number} oldX
     * @param {number} oldY
     * @param {number} pointIndex
     * @private
     */
    postPolylineResize(polyline: Polyline, oldX: number, oldY: number, pointIndex: number) {
        const polylinePoint: number[] = polyline.getPoints()[pointIndex];
        const newX: number = polylinePoint[0];
        const newY: number = polylinePoint[1];
        if (newX !== oldX || newY !== oldY) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.PolylineResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldX, oldY, polyline, pointIndex, newX, newY));
        }
    }

    /**
     * Post to undo support a north direction change on <code>compass</code>.
     * @param {Compass} compass
     * @param {number} oldNorthDirection
     * @private
     */
    postCompassRotation(compass: Compass, oldNorthDirection: number) {
        const newNorthDirection: number = compass.getNorthDirection();
        if (newNorthDirection !== oldNorthDirection) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.CompassRotationUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldNorthDirection, compass, newNorthDirection));
        }
    }

    /**
     * Post to undo support a size change on <code>compass</code>.
     * @param {Compass} compass
     * @param {number} oldDiameter
     * @private
     */
    postCompassResize(compass: Compass, oldDiameter: number) {
        const newDiameter: number = compass.getDiameter();
        if (newDiameter !== oldDiameter) {
            this.__com_eteks_sweethome3d_viewcontroller_PlanController_undoSupport.postEdit(new PlanController.CompassResizingUndoableEdit(this, this.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences, oldDiameter, compass, newDiameter));
        }
    }

    /**
     * Returns the points of a general path which contains only one path.
     * @param {java.awt.geom.GeneralPath} path
     * @param {boolean} removeAlignedPoints
     * @return {float[][]}
     * @private
     */
    getPathPoints(path: java.awt.geom.GeneralPath, removeAlignedPoints: boolean): number[][] {
        const pathPoints: Array<number[]> = <any>([]);
        let previousPathPoint: number[] = null;
        for (const it: java.awt.geom.PathIterator = path.getPathIterator(null); !it.isDone(); it.next()) {
            {
                const pathPoint: number[] = [0, 0];
                if (it.currentSegment(pathPoint) !== java.awt.geom.PathIterator.SEG_CLOSE && (previousPathPoint == null || !/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(pathPoint, previousPathPoint))) {
                    let replacePoint: boolean = false;
                    if (removeAlignedPoints && /* size */(<number>pathPoints.length) > 1) {
                        const lastLineStartPoint: number[] = /* get */pathPoints[/* size */(<number>pathPoints.length) - 2];
                        const lastLineEndPoint: number[] = previousPathPoint;
                        replacePoint = java.awt.geom.Line2D.ptLineDistSq(lastLineStartPoint[0], lastLineStartPoint[1], lastLineEndPoint[0], lastLineEndPoint[1], pathPoint[0], pathPoint[1]) < 1.0E-4;
                    }
                    if (replacePoint) {
                    /* set */(pathPoints[/* size */(<number>pathPoints.length) - 1] = pathPoint);
                    } else {
                    /* add */(pathPoints.push(pathPoint) > 0);
                    }
                    previousPathPoint = pathPoint;
                }
            };
        }
        if (/* size */(<number>pathPoints.length) > 1 && /* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(/* get */pathPoints[0], /* get */pathPoints[/* size */(<number>pathPoints.length) - 1])) {
            /* remove */pathPoints.splice(/* size */(<number>pathPoints.length) - 1, 1)[0];
        }
        return /* toArray */pathPoints.slice(0);
    }

    /**
     * Returns the list of closed paths that may define rooms from
     * the current set of home walls.
     * @return {java.awt.geom.GeneralPath[]}
     * @private
     */
    getRoomPathsFromWalls(): Array<java.awt.geom.GeneralPath> {
        if (this.roomPathsCache == null) {
            const wallsArea: java.awt.geom.Area = this.getWallsArea(false);
            const roomPaths: Array<java.awt.geom.GeneralPath> = this.getAreaPaths(wallsArea);
            const insideWallsArea: java.awt.geom.Area = new java.awt.geom.Area(wallsArea);
            for (let index = 0; index < roomPaths.length; index++) {
                let roomPath = roomPaths[index];
                {
                    insideWallsArea.add(new java.awt.geom.Area(roomPath));
                }
            }
            this.roomPathsCache = roomPaths;
            this.insideWallsAreaCache = insideWallsArea;
        }
        return this.roomPathsCache;
    }

    /**
     * Returns the paths described by the given <code>area</code>.
     * @param {java.awt.geom.Area} area
     * @return {java.awt.geom.GeneralPath[]}
     * @private
     */
    getAreaPaths(area: java.awt.geom.Area): Array<java.awt.geom.GeneralPath> {
        const roomPaths: Array<java.awt.geom.GeneralPath> = <any>([]);
        let roomPath: java.awt.geom.GeneralPath = null;
        let previousRoomPoint: number[] = null;
        for (const it: java.awt.geom.PathIterator = area.getPathIterator(null, 0.5); !it.isDone(); it.next()) {
            {
                const roomPoint: number[] = [0, 0];
                switch ((it.currentSegment(roomPoint))) {
                    case java.awt.geom.PathIterator.SEG_MOVETO:
                        roomPath = new java.awt.geom.GeneralPath();
                        roomPath.moveTo(roomPoint[0], roomPoint[1]);
                        previousRoomPoint = roomPoint;
                        break;
                    case java.awt.geom.PathIterator.SEG_LINETO:
                        if ((roomPoint[0] !== previousRoomPoint[0] || roomPoint[1] !== previousRoomPoint[1]) && java.awt.geom.Point2D.distanceSq(roomPoint[0], roomPoint[1], previousRoomPoint[0], previousRoomPoint[1]) > 1.0E-10) {
                            roomPath.lineTo(roomPoint[0], roomPoint[1]);
                            previousRoomPoint = roomPoint;
                        }
                        break;
                    case java.awt.geom.PathIterator.SEG_CLOSE:
                        roomPath.closePath();
                /* add */(roomPaths.push(roomPath) > 0);
                        break;
                }
            };
        }
        return roomPaths;
    }

    /**
     * Returns the area that includes walls and inside walls area.
     * @return {java.awt.geom.Area}
     * @private
     */
    getInsideWallsArea(): java.awt.geom.Area {
        if (this.insideWallsAreaCache == null) {
            this.getRoomPathsFromWalls();
        }
        return this.insideWallsAreaCache;
    }

    /**
     * Returns the area covered by walls.
     * @param {boolean} includeBaseboards
     * @return {java.awt.geom.Area}
     * @private
     */
    getWallsArea(includeBaseboards: boolean): java.awt.geom.Area {
        if (!includeBaseboards && this.wallsAreaCache == null || includeBaseboards && this.wallsIncludingBaseboardsAreaCache == null) {
            const wallsArea: java.awt.geom.Area = new java.awt.geom.Area();
            const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
            {
                let array = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        if (wall.isAtLevel(selectedLevel)) {
                            wallsArea.add(new java.awt.geom.Area(this.getPath$float_A_A(wall.getPoints$boolean(includeBaseboards))));
                        }
                    }
                }
            }
            if (includeBaseboards) {
                this.wallsIncludingBaseboardsAreaCache = wallsArea;
            } else {
                this.wallsAreaCache = wallsArea;
            }
        }
        return includeBaseboards ? this.wallsIncludingBaseboardsAreaCache : this.wallsAreaCache;
    }

    public getPath$float_A_A(points: number[][]): java.awt.geom.GeneralPath {
        const path: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
        path.moveTo(points[0][0], points[0][1]);
        for (let i: number = 1; i < points.length; i++) {
            {
                path.lineTo(points[i][0], points[i][1]);
            };
        }
        path.closePath();
        return path;
    }

    /**
     * Returns the shape matching the coordinates in <code>points</code> array.
     * @param {float[][]} points
     * @return {java.awt.geom.GeneralPath}
     * @private
     */
    public getPath(points?: any): java.awt.geom.GeneralPath {
        if (((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null || points[0] instanceof Array)) || points === null)) {
            return <any>this.getPath$float_A_A(points);
        } else if (((points != null && points instanceof <any>java.awt.geom.Area) || points === null)) {
            return <any>this.getPath$java_awt_geom_Area(points);
        } else throw new Error('invalid overload');
    }

    getPath$java_awt_geom_Area(area: java.awt.geom.Area): java.awt.geom.GeneralPath {
        const path: java.awt.geom.GeneralPath = new java.awt.geom.GeneralPath();
        const point: number[] = [0, 0];
        for (const it: java.awt.geom.PathIterator = area.getPathIterator(null, 0.5); !it.isDone(); it.next()) {
            {
                switch ((it.currentSegment(point))) {
                    case java.awt.geom.PathIterator.SEG_MOVETO:
                        path.moveTo(point[0], point[1]);
                        break;
                    case java.awt.geom.PathIterator.SEG_LINETO:
                        path.lineTo(point[0], point[1]);
                        break;
                }
            };
        }
        return path;
    }

    /**
     * Selects the level of the first elevatable item in the current selection
     * if no selected item is visible at the selected level.
     * @private
     */
    selectLevelFromSelectedItems() {
        const selectedLevel: Level = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel();
        const selectedItems: Array<Selectable> = this.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
        for (let index = 0; index < selectedItems.length; index++) {
            let item = selectedItems[index];
            {
                if ((item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) && (<Elevatable><any>item).isAtLevel(selectedLevel)) {
                    return;
                }
            }
        }
        for (let index = 0; index < selectedItems.length; index++) {
            let item = selectedItems[index];
            {
                if (item != null && (item.constructor != null && item.constructor["__interfaces"] != null && item.constructor["__interfaces"].indexOf("com.eteks.sweethome3d.model.Elevatable") >= 0)) {
                    this.setSelectedLevel((<Elevatable><any>item).getLevel());
                    break;
                }
            }
        }
    }
}
PlanController["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController";
PlanController["__interfaces"] = ["com.eteks.sweethome3d.viewcontroller.Controller"];



export namespace PlanController {

    /**
     * Selectable modes in controller.
     * @class
     */
    export class Mode {
        public static SELECTION: PlanController.Mode; public static SELECTION_$LI$(): PlanController.Mode { if (Mode.SELECTION == null) { Mode.SELECTION = new PlanController.Mode("SELECTION"); } return Mode.SELECTION; }

        public static PANNING: PlanController.Mode; public static PANNING_$LI$(): PlanController.Mode { if (Mode.PANNING == null) { Mode.PANNING = new PlanController.Mode("PANNING"); } return Mode.PANNING; }

        public static WALL_CREATION: PlanController.Mode; public static WALL_CREATION_$LI$(): PlanController.Mode { if (Mode.WALL_CREATION == null) { Mode.WALL_CREATION = new PlanController.Mode("WALL_CREATION"); } return Mode.WALL_CREATION; }

        public static ROOM_CREATION: PlanController.Mode; public static ROOM_CREATION_$LI$(): PlanController.Mode { if (Mode.ROOM_CREATION == null) { Mode.ROOM_CREATION = new PlanController.Mode("ROOM_CREATION"); } return Mode.ROOM_CREATION; }

        public static POLYLINE_CREATION: PlanController.Mode; public static POLYLINE_CREATION_$LI$(): PlanController.Mode { if (Mode.POLYLINE_CREATION == null) { Mode.POLYLINE_CREATION = new PlanController.Mode("POLYLINE_CREATION"); } return Mode.POLYLINE_CREATION; }

        public static DIMENSION_LINE_CREATION: PlanController.Mode; public static DIMENSION_LINE_CREATION_$LI$(): PlanController.Mode { if (Mode.DIMENSION_LINE_CREATION == null) { Mode.DIMENSION_LINE_CREATION = new PlanController.Mode("DIMENSION_LINE_CREATION"); } return Mode.DIMENSION_LINE_CREATION; }

        public static LABEL_CREATION: PlanController.Mode; public static LABEL_CREATION_$LI$(): PlanController.Mode { if (Mode.LABEL_CREATION == null) { Mode.LABEL_CREATION = new PlanController.Mode("LABEL_CREATION"); } return Mode.LABEL_CREATION; }

        __name: string;

        constructor(name: string) {
            if (this.__name === undefined) { this.__name = null; }
            this.__name = name;
        }

        public name(): string {
            return this.__name;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.__name;
        }
    }
    Mode["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.Mode";


    /**
     * Undoable edit for plan locking.
     * @param {PlanController} controller
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Selectable[]} newSelectedItems
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LockingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        home: Home;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        newSelectedItems: Selectable[];

        public constructor(controller: PlanController, home: Home, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, newSelectedItems: Selectable[]) {
            super(preferences, PlanController, "undoLockBasePlan");
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.newSelectedItems === undefined) { this.newSelectedItems = null; }
            this.controller = controller;
            this.home = home;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.newSelectedItems = newSelectedItems;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setBasePlanLocked(false);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setBasePlanLocked(true);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.newSelectedItems.slice(0), this.allLevelsSelection);
        }
    }
    LockingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LockingUndoableEdit";
    LockingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for plan unlocking.
     * @param {PlanController} controller
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} selectedItems
     * @param {boolean} allLevelsSelection
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class UnlockingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        home: Home;

        selectedItems: Selectable[];

        allLevelsSelection: boolean;

        public constructor(controller: PlanController, home: Home, preferences: any, selectedItems: Selectable[], allLevelsSelection: boolean) {
            super(preferences, PlanController, "undoUnlockBasePlan");
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            this.controller = controller;
            this.home = home;
            this.selectedItems = selectedItems;
            this.allLevelsSelection = allLevelsSelection;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.home.setBasePlanLocked(true);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.selectedItems.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setBasePlanLocked(false);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.selectedItems.slice(0), false);
        }
    }
    UnlockingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.UnlockingUndoableEdit";
    UnlockingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for flipped items.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {float[][]} itemTextBaseOffsets
     * @param {boolean} horizontalFlip
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class FlippingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        allLevelsSelection: boolean;

        items: Selectable[];

        itemTextBaseOffsets: number[][];

        horizontalFlip: boolean;

        public constructor(controller: PlanController, preferences: any, allLevelsSelection: boolean, items: Selectable[], itemTextBaseOffsets: number[][], horizontalFlip: boolean) {
            super(preferences, PlanController, "undoFlipName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.items === undefined) { this.items = null; }
            if (this.itemTextBaseOffsets === undefined) { this.itemTextBaseOffsets = null; }
            if (this.horizontalFlip === undefined) { this.horizontalFlip = false; }
            this.controller = controller;
            this.allLevelsSelection = allLevelsSelection;
            this.items = items;
            this.itemTextBaseOffsets = itemTextBaseOffsets;
            this.horizontalFlip = horizontalFlip;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doFlipItems(this.items, this.itemTextBaseOffsets, this.horizontalFlip);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.items.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doFlipItems(this.items, this.itemTextBaseOffsets, this.horizontalFlip);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.items.slice(0), this.allLevelsSelection);
        }
    }
    FlippingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.FlippingUndoableEdit";
    FlippingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for joining walls.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedWalls
     * @param {float[]} joinPoint
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallsJoiningUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        joinedWalls: PlanController.JoinedWall[];

        joinPoint: number[];

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, joinedWalls: PlanController.JoinedWall[], joinPoint: number[]) {
            super(preferences, PlanController, "undoJoinWallsName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.joinedWalls === undefined) { this.joinedWalls = null; }
            if (this.joinPoint === undefined) { this.joinPoint = null; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.joinedWalls = joinedWalls;
            this.joinPoint = joinPoint;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            for (let index = 0; index < this.joinedWalls.length; index++) {
                let joinedWall = this.joinedWalls[index];
                {
                    const wall: Wall = joinedWall.getWall();
                    wall.setWallAtStart(joinedWall.getWallAtStart());
                    if (joinedWall.getWallAtStart() != null) {
                        if (joinedWall.isJoinedAtEndOfWallAtStart()) {
                            joinedWall.getWallAtStart().setWallAtEnd(wall);
                        } else {
                            joinedWall.getWallAtStart().setWallAtStart(wall);
                        }
                    }
                    wall.setWallAtEnd(joinedWall.getWallAtEnd());
                    if (joinedWall.getWallAtEnd() != null) {
                        if (joinedWall.isJoinedAtStartOfWallAtEnd()) {
                            joinedWall.getWallAtEnd().setWallAtStart(wall);
                        } else {
                            joinedWall.getWallAtEnd().setWallAtEnd(wall);
                        }
                    }
                    wall.setXStart(joinedWall.getXStart());
                    wall.setYStart(joinedWall.getYStart());
                    wall.setXEnd(joinedWall.getXEnd());
                    wall.setYEnd(joinedWall.getYEnd());
                }
            }
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doJoinWalls(this.joinedWalls, this.joinPoint);
        }
    }
    WallsJoiningUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallsJoiningUndoableEdit";
    WallsJoiningUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for reversing walls direction.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Wall[]} walls
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallsDirectionReversingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        walls: Wall[];

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, walls: Wall[]) {
            super(preferences, PlanController, "undoReverseWallsDirectionName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.walls === undefined) { this.walls = null; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.walls = walls;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doReverseWallsDirection(this.walls);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doReverseWallsDirection(this.walls);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.walls.slice(0), false);
        }
    }
    WallsDirectionReversingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallsDirectionReversingUndoableEdit";
    WallsDirectionReversingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for splitting wall.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {PlanController.JoinedWall} splitJoinedWall
     * @param {PlanController.JoinedWall} firstJoinedWall
     * @param {PlanController.JoinedWall} secondJoinedWall
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallSplittingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        splitJoinedWall: PlanController.JoinedWall;

        firstJoinedWall: PlanController.JoinedWall;

        secondJoinedWall: PlanController.JoinedWall;

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, splitJoinedWall: PlanController.JoinedWall, firstJoinedWall: PlanController.JoinedWall, secondJoinedWall: PlanController.JoinedWall, newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoSplitWallName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.splitJoinedWall === undefined) { this.splitJoinedWall = null; }
            if (this.firstJoinedWall === undefined) { this.firstJoinedWall = null; }
            if (this.secondJoinedWall === undefined) { this.secondJoinedWall = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.splitJoinedWall = splitJoinedWall;
            this.firstJoinedWall = firstJoinedWall;
            this.secondJoinedWall = secondJoinedWall;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeleteWalls([this.firstJoinedWall, this.secondJoinedWall], this.oldBasePlanLocked);
            this.controller.doAddWalls([this.splitJoinedWall], this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doDeleteWalls([this.splitJoinedWall], this.newBasePlanLocked);
            this.controller.doAddWalls([this.firstJoinedWall, this.secondJoinedWall], this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */[this.firstJoinedWall.getWall()].slice(0), false);
        }
    }
    WallSplittingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallSplittingUndoableEdit";
    WallSplittingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for text style modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.TextStyle[]} oldStyles
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {com.eteks.sweethome3d.model.TextStyle[]} styles
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class TextStyleModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        oldStyles: TextStyle[];

        items: Selectable[];

        styles: TextStyle[];

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, oldStyles: TextStyle[], items: Selectable[], styles: TextStyle[]) {
            super(preferences, PlanController, "undoModifyTextStyleName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.oldStyles === undefined) { this.oldStyles = null; }
            if (this.items === undefined) { this.items = null; }
            if (this.styles === undefined) { this.styles = null; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.oldStyles = oldStyles;
            this.items = items;
            this.styles = styles;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            PlanController.doModifyTextStyle(this.items, this.oldStyles);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            PlanController.doModifyTextStyle(this.items, this.styles);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }
    }
    TextStyleModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.TextStyleModificationUndoableEdit";
    TextStyleModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for level addition.
     * @param {PlanController} controller
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {Level} oldSelectedLevel
     * @param {Level} level0
     * @param {BackgroundImage} homeBackgroundImage
     * @param {Level} newLevel
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LevelAdditionUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        home: Home;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        oldSelectedLevel: Level;

        level0: Level;

        homeBackgroundImage: BackgroundImage;

        newLevel: Level;

        public constructor(controller: PlanController, home: Home, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, oldSelectedLevel: Level, level0: Level, homeBackgroundImage: BackgroundImage, newLevel: Level) {
            super(preferences, PlanController, "undoAddLevel");
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.oldSelectedLevel === undefined) { this.oldSelectedLevel = null; }
            if (this.level0 === undefined) { this.level0 = null; }
            if (this.homeBackgroundImage === undefined) { this.homeBackgroundImage = null; }
            if (this.newLevel === undefined) { this.newLevel = null; }
            this.controller = controller;
            this.home = home;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.oldSelectedLevel = oldSelectedLevel;
            this.level0 = level0;
            this.homeBackgroundImage = homeBackgroundImage;
            this.newLevel = newLevel;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setSelectedLevel(this.oldSelectedLevel);
            this.home.deleteLevel(this.newLevel);
            if (this.level0 != null) {
                this.home.setBackgroundImage(this.homeBackgroundImage);
                this.controller.moveHomeItemsToLevel(this.oldSelectedLevel);
                this.home.deleteLevel(this.level0);
            }
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            if (this.level0 != null) {
                this.home.addLevel(this.level0);
                this.controller.moveHomeItemsToLevel(this.level0);
                this.level0.setBackgroundImage(this.homeBackgroundImage);
                this.home.setBackgroundImage(null);
            }
            this.home.addLevel(this.newLevel);
            this.controller.setSelectedLevel(this.newLevel);
        }
    }
    LevelAdditionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LevelAdditionUndoableEdit";
    LevelAdditionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for level viewability modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {Level} selectedLevel
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LevelViewabilityModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        selectedLevel: Level;

        public constructor(controller: PlanController, preferences: any, selectedLevel: Level) {
            super(preferences, PlanController, "undoModifyLevelViewabilityName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            this.controller = controller;
            this.selectedLevel = selectedLevel;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setSelectedLevel(this.selectedLevel);
            this.selectedLevel.setViewable(!this.selectedLevel.isViewable());
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.setSelectedLevel(this.selectedLevel);
            this.selectedLevel.setViewable(!this.selectedLevel.isViewable());
        }
    }
    LevelViewabilityModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LevelViewabilityModificationUndoableEdit";
    LevelViewabilityModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the viewability modification of multiple levels.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {Level} selectedLevel
     * @param {boolean} selectedLevelViewable
     * @param {com.eteks.sweethome3d.model.Level[]} viewableLevels
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LevelsViewabilityModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        selectedLevel: Level;

        selectedLevelViewable: boolean;

        viewableLevels: Level[];

        public constructor(controller: PlanController, preferences: any, selectedLevel: Level, selectedLevelViewable: boolean, viewableLevels: Level[]) {
            super(preferences, PlanController, "undoModifyLevelViewabilityName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.selectedLevelViewable === undefined) { this.selectedLevelViewable = false; }
            if (this.viewableLevels === undefined) { this.viewableLevels = null; }
            this.controller = controller;
            this.selectedLevel = selectedLevel;
            this.selectedLevelViewable = selectedLevelViewable;
            this.viewableLevels = viewableLevels;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setSelectedLevel(this.selectedLevel);
            PlanController.setLevelsViewability(this.viewableLevels, true);
            this.selectedLevel.setViewable(this.selectedLevelViewable);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.setSelectedLevel(this.selectedLevel);
            PlanController.setLevelsViewability(this.viewableLevels, false);
            this.selectedLevel.setViewable(true);
        }
    }
    LevelsViewabilityModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LevelsViewabilityModificationUndoableEdit";
    LevelsViewabilityModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the viewability modification of all levels.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {Level} selectedLevel
     * @param {com.eteks.sweethome3d.model.Level[]} unviewableLevels
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class AllLevelsViewabilityModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        selectedLevel: Level;

        unviewableLevels: Level[];

        public constructor(controller: PlanController, preferences: any, selectedLevel: Level, unviewableLevels: Level[]) {
            super(preferences, PlanController, "undoModifyLevelViewabilityName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.selectedLevel === undefined) { this.selectedLevel = null; }
            if (this.unviewableLevels === undefined) { this.unviewableLevels = null; }
            this.controller = controller;
            this.selectedLevel = selectedLevel;
            this.unviewableLevels = unviewableLevels;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setSelectedLevel(this.selectedLevel);
            PlanController.setLevelsViewability(this.unviewableLevels, false);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.setSelectedLevel(this.selectedLevel);
            PlanController.setLevelsViewability(this.unviewableLevels, true);
        }
    }
    AllLevelsViewabilityModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.AllLevelsViewabilityModificationUndoableEdit";
    AllLevelsViewabilityModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the level deletion.
     * @param {PlanController} controller
     * @param {Home} home
     * @param {UserPreferences} preferences
     * @param {Level} oldSelectedLevel
     * @param {Level} remainingLevel
     * @param {number} remainingLevelElevation
     * @param {boolean} remainingLevelViewable
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LevelDeletionUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        home: Home;

        oldSelectedLevel: Level;

        remainingLevel: Level;

        remainingLevelElevation: number;

        remainingLevelViewable: boolean;

        public constructor(controller: PlanController, home: Home, preferences: any, oldSelectedLevel: Level, remainingLevel: Level, remainingLevelElevation: number, remainingLevelViewable: boolean) {
            super(preferences, PlanController, "undoDeleteSelectedLevel");
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.oldSelectedLevel === undefined) { this.oldSelectedLevel = null; }
            if (this.remainingLevel === undefined) { this.remainingLevel = null; }
            if (this.remainingLevelElevation === undefined) { this.remainingLevelElevation = null; }
            if (this.remainingLevelViewable === undefined) { this.remainingLevelViewable = false; }
            this.controller = controller;
            this.home = home;
            this.oldSelectedLevel = oldSelectedLevel;
            this.remainingLevel = remainingLevel;
            this.remainingLevelElevation = remainingLevelElevation;
            this.remainingLevelViewable = remainingLevelViewable;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            if (this.remainingLevel != null) {
                this.remainingLevel.setElevation(this.remainingLevelElevation);
                this.remainingLevel.setViewable(this.remainingLevelViewable);
            }
            this.home.addLevel(this.oldSelectedLevel);
            this.controller.setSelectedLevel(this.oldSelectedLevel);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.deleteLevel(this.oldSelectedLevel);
            if (this.remainingLevel != null) {
                this.remainingLevel.setElevation(0);
                this.remainingLevel.setViewable(true);
            }
        }
    }
    LevelDeletionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LevelDeletionUndoableEdit";
    LevelDeletionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room point addition.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {Room} room
     * @param {number} index
     * @param {number} x
     * @param {number} y
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomPointAdditionUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        room: Room;

        index: number;

        x: number;

        y: number;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], room: Room, index: number, x: number, y: number) {
            super(preferences, PlanController, "undoAddRoomPointName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.room === undefined) { this.room = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.room = room;
            this.index = index;
            this.x = x;
            this.y = y;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.removePoint(this.index);
            this.controller.selectAndShowItems$java_util_List(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.addPoint$float$float$int(this.x, this.y, this.index);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomPointAdditionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomPointAdditionUndoableEdit";
    RoomPointAdditionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room point deletion.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {Room} room
     * @param {number} index
     * @param {number} xPoint
     * @param {number} yPoint
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomPointDeletionUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        room: Room;

        index: number;

        xPoint: number;

        yPoint: number;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], room: Room, index: number, xPoint: number, yPoint: number) {
            super(preferences, PlanController, "undoDeleteRoomPointName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.room === undefined) { this.room = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.xPoint === undefined) { this.xPoint = 0; }
            if (this.yPoint === undefined) { this.yPoint = 0; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.room = room;
            this.index = index;
            this.xPoint = xPoint;
            this.yPoint = yPoint;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.addPoint$float$float$int(this.xPoint, this.yPoint, this.index);
            this.controller.selectAndShowItems$java_util_List(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.removePoint(this.index);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomPointDeletionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomPointDeletionUndoableEdit";
    RoomPointDeletionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room points modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {Room} room
     * @param {float[][]} oldPoints
     * @param {float[][]} newPoints
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomPointsModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        room: Room;

        oldPoints: number[][];

        newPoints: number[][];

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], room: Room, oldPoints: number[][], newPoints: number[][]) {
            super(preferences, PlanController, "undoRecomputeRoomPointsName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.room === undefined) { this.room = null; }
            if (this.oldPoints === undefined) { this.oldPoints = null; }
            if (this.newPoints === undefined) { this.newPoints = null; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.room = room;
            this.oldPoints = oldPoints;
            this.newPoints = newPoints;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.setPoints(this.oldPoints);
            this.controller.selectAndShowItems$java_util_List(/* asList */this.oldSelection.slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.setPoints(this.newPoints);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomPointsModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomPointsModificationUndoableEdit";
    RoomPointsModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for items deletion start.
     * @param {PlanController} controller
     * @param {Home} home
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Selectable[]} selectedItems
     * @class
     * @extends javax.swing.undo.AbstractUndoableEdit
     */
    export class ItemsDeletionStartUndoableEdit extends javax.swing.undo.AbstractUndoableEdit {
        controller: PlanController;

        home: Home;

        allLevelsSelection: boolean;

        selectedItems: Selectable[];

        public constructor(controller: PlanController, home: Home, allLevelsSelection: boolean, selectedItems: Selectable[]) {
            super();
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.selectedItems === undefined) { this.selectedItems = null; }
            this.controller = controller;
            this.home = home;
            this.allLevelsSelection = allLevelsSelection;
            this.selectedItems = selectedItems;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.selectedItems.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.removeSelectionListener(this.controller.getSelectionListener());
        }
    }
    ItemsDeletionStartUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ItemsDeletionStartUndoableEdit";
    ItemsDeletionStartUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for items deletion end.
     * @param {PlanController} controller
     * @param {Home} home
     * @class
     * @extends javax.swing.undo.AbstractUndoableEdit
     */
    export class ItemsDeletionEndUndoableEdit extends javax.swing.undo.AbstractUndoableEdit {
        controller: PlanController;

        home: Home;

        public constructor(controller: PlanController, home: Home) {
            super();
            if (this.controller === undefined) { this.controller = null; }
            if (this.home === undefined) { this.home = null; }
            this.controller = controller;
            this.home = home;
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.addSelectionListener(this.controller.getSelectionListener());
        }
    }
    ItemsDeletionEndUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ItemsDeletionEndUndoableEdit";
    ItemsDeletionEndUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for items deletion.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {boolean} basePlanLocked
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Selectable[]} deletedItems
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedDeletedWalls
     * @param {com.eteks.sweethome3d.model.Room[]} rooms
     * @param {int[]} roomsIndices
     * @param {com.eteks.sweethome3d.model.Level[]} roomsLevels
     * @param {com.eteks.sweethome3d.model.DimensionLine[]} dimensionLines
     * @param {com.eteks.sweethome3d.model.Level[]} dimensionLinesLevels
     * @param {com.eteks.sweethome3d.model.Polyline[]} polylines
     * @param {int[]} polylinesIndices
     * @param {com.eteks.sweethome3d.model.Level[]} polylinesLevels
     * @param {com.eteks.sweethome3d.model.Label[]} labels
     * @param {com.eteks.sweethome3d.model.Level[]} labelsLevels
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class ItemsDeletionUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        basePlanLocked: boolean;

        allLevelsSelection: boolean;

        deletedItems: Selectable[];

        joinedDeletedWalls: PlanController.JoinedWall[];

        rooms: Room[];

        roomsIndices: number[];

        roomsLevels: Level[];

        dimensionLines: DimensionLine[];

        dimensionLinesLevels: Level[];

        polylines: Polyline[];

        polylinesIndices: number[];

        polylinesLevels: Level[];

        labels: Label[];

        labelsLevels: Level[];

        public constructor(controller: PlanController, preferences: any, basePlanLocked: boolean, allLevelsSelection: boolean, deletedItems: Selectable[], joinedDeletedWalls: PlanController.JoinedWall[], rooms: Room[], roomsIndices: number[], roomsLevels: Level[], dimensionLines: DimensionLine[], dimensionLinesLevels: Level[], polylines: Polyline[], polylinesIndices: number[], polylinesLevels: Level[], labels: Label[], labelsLevels: Level[]) {
            super(preferences, PlanController, "undoDeleteSelectionName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.basePlanLocked === undefined) { this.basePlanLocked = false; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.deletedItems === undefined) { this.deletedItems = null; }
            if (this.joinedDeletedWalls === undefined) { this.joinedDeletedWalls = null; }
            if (this.rooms === undefined) { this.rooms = null; }
            if (this.roomsIndices === undefined) { this.roomsIndices = null; }
            if (this.roomsLevels === undefined) { this.roomsLevels = null; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesLevels === undefined) { this.dimensionLinesLevels = null; }
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.polylinesIndices === undefined) { this.polylinesIndices = null; }
            if (this.polylinesLevels === undefined) { this.polylinesLevels = null; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsLevels === undefined) { this.labelsLevels = null; }
            this.controller = controller;
            this.basePlanLocked = basePlanLocked;
            this.allLevelsSelection = allLevelsSelection;
            this.deletedItems = deletedItems;
            this.joinedDeletedWalls = joinedDeletedWalls;
            this.rooms = rooms;
            this.roomsIndices = roomsIndices;
            this.roomsLevels = roomsLevels;
            this.dimensionLines = dimensionLines;
            this.dimensionLinesLevels = dimensionLinesLevels;
            this.polylines = polylines;
            this.polylinesIndices = polylinesIndices;
            this.polylinesLevels = polylinesLevels;
            this.labels = labels;
            this.labelsLevels = labelsLevels;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doAddWalls(this.joinedDeletedWalls, this.basePlanLocked);
            this.controller.doAddRooms(this.rooms, this.roomsIndices, this.roomsLevels, null, this.basePlanLocked);
            this.controller.doAddDimensionLines(this.dimensionLines, this.dimensionLinesLevels, null, this.basePlanLocked);
            this.controller.doAddPolylines(this.polylines, this.polylinesIndices, this.polylinesLevels, null, this.basePlanLocked);
            this.controller.doAddLabels(this.labels, this.labelsLevels, null, this.basePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.deletedItems.slice(0), this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.selectItems$java_util_List(/* asList */this.deletedItems.slice(0));
            this.controller.doDeleteWalls(this.joinedDeletedWalls, this.basePlanLocked);
            this.controller.doDeleteRooms(this.rooms, this.basePlanLocked);
            this.controller.doDeleteDimensionLines(this.dimensionLines, this.basePlanLocked);
            this.controller.doDeletePolylines(this.polylines, this.basePlanLocked);
            this.controller.doDeleteLabels(this.labels, this.basePlanLocked);
        }
    }
    ItemsDeletionUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ItemsDeletionUndoableEdit";
    ItemsDeletionUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for items addition end.
     * @extends LocalizedUndoableEdit
     * @class
     */
    export class ItemsAdditionEndUndoableEdit extends LocalizedUndoableEdit {
        home: Home;

        items: Selectable[];

        constructor(home: Home, preferences: any, items: Selectable[]) {
            super(preferences, PlanController, "undoAddItemsName");
            if (this.home === undefined) { this.home = null; }
            if (this.items === undefined) { this.items = null; }
            this.home = home;
            this.items = items;
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.home.setSelectedItems(/* asList */this.items.slice(0));
        }
    }
    ItemsAdditionEndUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ItemsAdditionEndUndoableEdit";
    ItemsAdditionEndUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for walls creation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedNewWalls
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallsCreationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        joinedNewWalls: PlanController.JoinedWall[];

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, joinedNewWalls: PlanController.JoinedWall[], newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoCreateWallsName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.joinedNewWalls === undefined) { this.joinedNewWalls = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.joinedNewWalls = joinedNewWalls;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeleteWalls(this.joinedNewWalls, this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doAddWalls(this.joinedNewWalls, this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(PlanController.JoinedWall.getWalls(this.joinedNewWalls), false);
        }
    }
    WallsCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallsCreationUndoableEdit";
    WallsCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for rooms creation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {com.eteks.sweethome3d.model.Room[]} newRooms
     * @param {int[]} roomsIndex
     * @param {Level} roomsLevel
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomsCreationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        newRooms: Room[];

        roomsIndex: number[];

        roomsLevel: Level;

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, newRooms: Room[], roomsIndex: number[], roomsLevel: Level, newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoCreateRoomsName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.newRooms === undefined) { this.newRooms = null; }
            if (this.roomsIndex === undefined) { this.roomsIndex = null; }
            if (this.roomsLevel === undefined) { this.roomsLevel = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.newRooms = newRooms;
            this.roomsIndex = roomsIndex;
            this.roomsLevel = roomsLevel;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeleteRooms(this.newRooms, this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doAddRooms(this.newRooms, this.roomsIndex, null, this.roomsLevel, this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.newRooms.slice(0), false);
        }
    }
    RoomsCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomsCreationUndoableEdit";
    RoomsCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension lines creation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {com.eteks.sweethome3d.model.DimensionLine[]} dimensionLines
     * @param {Level} dimensionLinesLevel
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLinesCreationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        dimensionLines: DimensionLine[];

        dimensionLinesLevel: Level;

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, dimensionLines: DimensionLine[], dimensionLinesLevel: Level, newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoCreateDimensionLinesName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.dimensionLines === undefined) { this.dimensionLines = null; }
            if (this.dimensionLinesLevel === undefined) { this.dimensionLinesLevel = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.dimensionLines = dimensionLines;
            this.dimensionLinesLevel = dimensionLinesLevel;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeleteDimensionLines(this.dimensionLines, this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doAddDimensionLines(this.dimensionLines, null, this.dimensionLinesLevel, this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.dimensionLines.slice(0), false);
        }
    }
    DimensionLinesCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLinesCreationUndoableEdit";
    DimensionLinesCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for polylines creation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {com.eteks.sweethome3d.model.Polyline[]} newPolylines
     * @param {int[]} polylinesIndex
     * @param {Level} polylinesLevel
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PolylinesCreationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        newPolylines: Polyline[];

        polylinesIndex: number[];

        polylinesLevel: Level;

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, newPolylines: Polyline[], polylinesIndex: number[], polylinesLevel: Level, newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoCreatePolylinesName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.newPolylines === undefined) { this.newPolylines = null; }
            if (this.polylinesIndex === undefined) { this.polylinesIndex = null; }
            if (this.polylinesLevel === undefined) { this.polylinesLevel = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.newPolylines = newPolylines;
            this.polylinesIndex = polylinesIndex;
            this.polylinesLevel = polylinesLevel;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeletePolylines(this.newPolylines, this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doAddPolylines(this.newPolylines, this.polylinesIndex, null, this.polylinesLevel, this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List(/* asList */this.newPolylines.slice(0));
        }
    }
    PolylinesCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PolylinesCreationUndoableEdit";
    PolylinesCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for label creation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} oldBasePlanLocked
     * @param {boolean} oldAllLevelsSelection
     * @param {com.eteks.sweethome3d.model.Label[]} labels
     * @param {Level} labelsLevel
     * @param {boolean} newBasePlanLocked
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LabelsCreationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        labels: Label[];

        labelsLevel: Level;

        newBasePlanLocked: boolean;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], oldBasePlanLocked: boolean, oldAllLevelsSelection: boolean, labels: Label[], labelsLevel: Level, newBasePlanLocked: boolean) {
            super(preferences, PlanController, "undoCreateLabelsName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.labels === undefined) { this.labels = null; }
            if (this.labelsLevel === undefined) { this.labelsLevel = null; }
            if (this.newBasePlanLocked === undefined) { this.newBasePlanLocked = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.oldBasePlanLocked = oldBasePlanLocked;
            this.oldAllLevelsSelection = oldAllLevelsSelection;
            this.labels = labels;
            this.labelsLevel = labelsLevel;
            this.newBasePlanLocked = newBasePlanLocked;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doDeleteLabels(this.labels, this.oldBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.oldAllLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doAddLabels(this.labels, null, this.labelsLevel, this.newBasePlanLocked);
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.labels.slice(0), false);
        }
    }
    LabelsCreationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelsCreationUndoableEdit";
    LabelsCreationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for label rotation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldAngle
     * @param {Label} label
     * @param {number} newAngle
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LabelRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldAngle: number;

        label: Label;

        newAngle: number;

        public constructor(controller: PlanController, preferences: any, oldAngle: number, label: Label, newAngle: number) {
            super(preferences, PlanController, "undoLabelRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldAngle === undefined) { this.oldAngle = 0; }
            if (this.label === undefined) { this.label = null; }
            if (this.newAngle === undefined) { this.newAngle = 0; }
            this.controller = controller;
            this.oldAngle = oldAngle;
            this.label = label;
            this.newAngle = newAngle;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.label.setAngle(this.oldAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.label].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.label.setAngle(this.newAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.label].slice(0));
        }
    }
    LabelRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelRotationUndoableEdit";
    LabelRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for label elevation modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldElevation
     * @param {Label} label
     * @param {number} newElevation
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LabelElevationModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldElevation: number;

        label: Label;

        newElevation: number;

        public constructor(controller: PlanController, preferences: any, oldElevation: number, label: Label, newElevation: number) {
            super(preferences, PlanController, oldElevation < newElevation ? "undoLabelRaiseName" : "undoLabelLowerName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.label === undefined) { this.label = null; }
            if (this.newElevation === undefined) { this.newElevation = 0; }
            this.controller = controller;
            this.oldElevation = oldElevation;
            this.label = label;
            this.newElevation = newElevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.label.setElevation(this.oldElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.label].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.label.setElevation(this.newElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.label].slice(0));
        }
    }
    LabelElevationModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelElevationModificationUndoableEdit";
    LabelElevationModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for moving items.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @param {number} dx
     * @param {number} dy
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class ItemsMovingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        itemsArray: Selectable[];

        dx: number;

        dy: number;

        public constructor(controller: PlanController, preferences: any, oldSelection: Selectable[], allLevelsSelection: boolean, items: Selectable[], dx: number, dy: number) {
            super(preferences, PlanController, "undoMoveSelectionName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            if (this.itemsArray === undefined) { this.itemsArray = null; }
            if (this.dx === undefined) { this.dx = 0; }
            if (this.dy === undefined) { this.dy = 0; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
            this.itemsArray = items;
            this.dx = dx;
            this.dy = dy;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.doMoveAndShowItems(this.itemsArray, this.oldSelection, -this.dx, -this.dy, this.allLevelsSelection);
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.doMoveAndShowItems(this.itemsArray, this.itemsArray, this.dx, this.dy, this.allLevelsSelection);
        }
    }
    ItemsMovingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ItemsMovingUndoableEdit";
    ItemsMovingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for moving a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldAngle
     * @param {number} oldDepth
     * @param {number} oldElevation
     * @param {boolean} oldDoorOrWindowBoundToWall
     * @param {HomePieceOfFurniture} piece
     * @param {number} dx
     * @param {number} dy
     * @param {number} newAngle
     * @param {number} newDepth
     * @param {number} newElevation
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureMovingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldAngle: number;

        oldDepth: number;

        oldElevation: number;

        oldDoorOrWindowBoundToWall: boolean;

        piece: HomePieceOfFurniture;

        dx: number;

        dy: number;

        newAngle: number;

        newDepth: number;

        newElevation: number;

        public constructor(controller: PlanController, preferences: any, oldAngle: number, oldDepth: number, oldElevation: number, oldDoorOrWindowBoundToWall: boolean, piece: HomePieceOfFurniture, dx: number, dy: number, newAngle: number, newDepth: number, newElevation: number) {
            super(preferences, PlanController, "undoMoveSelectionName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldAngle === undefined) { this.oldAngle = 0; }
            if (this.oldDepth === undefined) { this.oldDepth = 0; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.oldDoorOrWindowBoundToWall === undefined) { this.oldDoorOrWindowBoundToWall = false; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.dx === undefined) { this.dx = 0; }
            if (this.dy === undefined) { this.dy = 0; }
            if (this.newAngle === undefined) { this.newAngle = 0; }
            if (this.newDepth === undefined) { this.newDepth = 0; }
            if (this.newElevation === undefined) { this.newElevation = 0; }
            this.controller = controller;
            this.oldAngle = oldAngle;
            this.oldDepth = oldDepth;
            this.oldElevation = oldElevation;
            this.oldDoorOrWindowBoundToWall = oldDoorOrWindowBoundToWall;
            this.piece = piece;
            this.dx = dx;
            this.dy = dy;
            this.newAngle = newAngle;
            this.newDepth = newDepth;
            this.newElevation = newElevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.piece.move(-this.dx, -this.dy);
            this.piece.setAngle(this.oldAngle);
            if ((this.piece != null && this.piece instanceof <any>HomeDoorOrWindow) && this.piece.isResizable() && this.controller.isItemResizable(this.piece)) {
                this.piece.setDepth(this.oldDepth);
            }
            this.piece.setElevation(this.oldElevation);
            if (this.piece != null && this.piece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>this.piece).setBoundToWall(this.oldDoorOrWindowBoundToWall);
            }
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.piece.move(this.dx, this.dy);
            this.piece.setAngle(this.newAngle);
            if ((this.piece != null && this.piece instanceof <any>HomeDoorOrWindow) && this.piece.isResizable() && this.controller.isItemResizable(this.piece)) {
                this.piece.setDepth(this.newDepth);
            }
            this.piece.setElevation(this.newElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureMovingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureMovingUndoableEdit";
    PieceOfFurnitureMovingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for duplication start.
     * @param {PlanController} controller
     * @param {com.eteks.sweethome3d.model.Selectable[]} oldSelection
     * @param {boolean} allLevelsSelection
     * @class
     * @extends javax.swing.undo.AbstractUndoableEdit
     */
    export class DuplicationStartUndoableEdit extends javax.swing.undo.AbstractUndoableEdit {
        controller: PlanController;

        oldSelection: Selectable[];

        allLevelsSelection: boolean;

        public constructor(controller: PlanController, oldSelection: Selectable[], allLevelsSelection: boolean) {
            super();
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.allLevelsSelection === undefined) { this.allLevelsSelection = false; }
            this.controller = controller;
            this.oldSelection = oldSelection;
            this.allLevelsSelection = allLevelsSelection;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.selectAndShowItems$java_util_List$boolean(/* asList */this.oldSelection.slice(0), this.allLevelsSelection);
        }
    }
    DuplicationStartUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DuplicationStartUndoableEdit";
    DuplicationStartUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for duplication end.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {com.eteks.sweethome3d.model.Selectable[]} items
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DuplicationEndUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        items: Selectable[];

        public constructor(controller: PlanController, preferences: any, items: Selectable[]) {
            super(preferences, PlanController, "undoDuplicateSelectionName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.items === undefined) { this.items = null; }
            this.controller = controller;
            this.items = items;
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.selectAndShowItems$java_util_List(/* asList */this.items.slice(0));
        }
    }
    DuplicationEndUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DuplicationEndUndoableEdit";
    DuplicationEndUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for wall resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldX
     * @param {number} oldY
     * @param {Wall} wall
     * @param {boolean} startPoint
     * @param {number} newX
     * @param {number} newY
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldX: number;

        oldY: number;

        wall: Wall;

        startPoint: boolean;

        newX: number;

        newY: number;

        public constructor(controller: PlanController, preferences: any, oldX: number, oldY: number, wall: Wall, startPoint: boolean, newX: number, newY: number) {
            super(preferences, PlanController, "undoWallResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.wall === undefined) { this.wall = null; }
            if (this.startPoint === undefined) { this.startPoint = false; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            this.controller = controller;
            this.oldX = oldX;
            this.oldY = oldY;
            this.wall = wall;
            this.startPoint = startPoint;
            this.newX = newX;
            this.newY = newY;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            PlanController.moveWallPoint(this.wall, this.oldX, this.oldY, this.startPoint);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.wall].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            PlanController.moveWallPoint(this.wall, this.newX, this.newY, this.startPoint);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.wall].slice(0));
        }
    }
    WallResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallResizingUndoableEdit";
    WallResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for wall arc extent modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldArcExtent
     * @param {Wall} wall
     * @param {number} newArcExtent
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class WallArcExtentModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldArcExtent: number;

        wall: Wall;

        newArcExtent: number;

        public constructor(controller: PlanController, preferences: any, oldArcExtent: number, wall: Wall, newArcExtent: number) {
            super(preferences, PlanController, "undoWallArcExtentName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldArcExtent === undefined) { this.oldArcExtent = null; }
            if (this.wall === undefined) { this.wall = null; }
            if (this.newArcExtent === undefined) { this.newArcExtent = null; }
            this.controller = controller;
            this.oldArcExtent = oldArcExtent;
            this.wall = wall;
            this.newArcExtent = newArcExtent;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.wall.setArcExtent(this.oldArcExtent);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.wall].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.wall.setArcExtent(this.newArcExtent);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.wall].slice(0));
        }
    }
    WallArcExtentModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallArcExtentModificationUndoableEdit";
    WallArcExtentModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldX
     * @param {number} oldY
     * @param {Room} room
     * @param {number} pointIndex
     * @param {number} newX
     * @param {number} newY
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldX: number;

        oldY: number;

        room: Room;

        pointIndex: number;

        newX: number;

        newY: number;

        public constructor(controller: PlanController, preferences: any, oldX: number, oldY: number, room: Room, pointIndex: number, newX: number, newY: number) {
            super(preferences, PlanController, "undoRoomResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.room === undefined) { this.room = null; }
            if (this.pointIndex === undefined) { this.pointIndex = 0; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            this.controller = controller;
            this.oldX = oldX;
            this.oldY = oldY;
            this.room = room;
            this.pointIndex = pointIndex;
            this.newX = newX;
            this.newY = newY;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            PlanController.moveRoomPoint(this.room, this.oldX, this.oldY, this.pointIndex);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            PlanController.moveRoomPoint(this.room, this.newX, this.newY, this.pointIndex);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomResizingUndoableEdit";
    RoomResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room name offset modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldNameXOffset
     * @param {number} oldNameYOffset
     * @param {Room} room
     * @param {number} newNameXOffset
     * @param {number} newNameYOffset
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomNameOffsetModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldNameXOffset: number;

        oldNameYOffset: number;

        room: Room;

        newNameXOffset: number;

        newNameYOffset: number;

        public constructor(controller: PlanController, preferences: any, oldNameXOffset: number, oldNameYOffset: number, room: Room, newNameXOffset: number, newNameYOffset: number) {
            super(preferences, PlanController, "undoRoomNameOffsetName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldNameXOffset === undefined) { this.oldNameXOffset = 0; }
            if (this.oldNameYOffset === undefined) { this.oldNameYOffset = 0; }
            if (this.room === undefined) { this.room = null; }
            if (this.newNameXOffset === undefined) { this.newNameXOffset = 0; }
            if (this.newNameYOffset === undefined) { this.newNameYOffset = 0; }
            this.controller = controller;
            this.oldNameXOffset = oldNameXOffset;
            this.oldNameYOffset = oldNameYOffset;
            this.room = room;
            this.newNameXOffset = newNameXOffset;
            this.newNameYOffset = newNameYOffset;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.setNameXOffset(this.oldNameXOffset);
            this.room.setNameYOffset(this.oldNameYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.setNameXOffset(this.newNameXOffset);
            this.room.setNameYOffset(this.newNameYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomNameOffsetModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomNameOffsetModificationUndoableEdit";
    RoomNameOffsetModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room name rotation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldNameAngle
     * @param {Room} room
     * @param {number} newNameAngle
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomNameRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldNameAngle: number;

        room: Room;

        newNameAngle: number;

        public constructor(controller: PlanController, preferences: any, oldNameAngle: number, room: Room, newNameAngle: number) {
            super(preferences, PlanController, "undoRoomNameRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldNameAngle === undefined) { this.oldNameAngle = 0; }
            if (this.room === undefined) { this.room = null; }
            if (this.newNameAngle === undefined) { this.newNameAngle = 0; }
            this.controller = controller;
            this.oldNameAngle = oldNameAngle;
            this.room = room;
            this.newNameAngle = newNameAngle;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.setNameAngle(this.oldNameAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.setNameAngle(this.newNameAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomNameRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomNameRotationUndoableEdit";
    RoomNameRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room area offset modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldAreaXOffset
     * @param {number} oldAreaYOffset
     * @param {Room} room
     * @param {number} newAreaXOffset
     * @param {number} newAreaYOffset
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomAreaOffsetModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldAreaXOffset: number;

        oldAreaYOffset: number;

        room: Room;

        newAreaXOffset: number;

        newAreaYOffset: number;

        public constructor(controller: PlanController, preferences: any, oldAreaXOffset: number, oldAreaYOffset: number, room: Room, newAreaXOffset: number, newAreaYOffset: number) {
            super(preferences, PlanController, "undoRoomAreaOffsetName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldAreaXOffset === undefined) { this.oldAreaXOffset = 0; }
            if (this.oldAreaYOffset === undefined) { this.oldAreaYOffset = 0; }
            if (this.room === undefined) { this.room = null; }
            if (this.newAreaXOffset === undefined) { this.newAreaXOffset = 0; }
            if (this.newAreaYOffset === undefined) { this.newAreaYOffset = 0; }
            this.controller = controller;
            this.oldAreaXOffset = oldAreaXOffset;
            this.oldAreaYOffset = oldAreaYOffset;
            this.room = room;
            this.newAreaXOffset = newAreaXOffset;
            this.newAreaYOffset = newAreaYOffset;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.setAreaXOffset(this.oldAreaXOffset);
            this.room.setAreaYOffset(this.oldAreaYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.setAreaXOffset(this.newAreaXOffset);
            this.room.setAreaYOffset(this.newAreaYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomAreaOffsetModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomAreaOffsetModificationUndoableEdit";
    RoomAreaOffsetModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for room area rotation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldAreaAngle
     * @param {Room} room
     * @param {number} newAreaAngle
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class RoomAreaRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldAreaAngle: number;

        room: Room;

        newAreaAngle: number;

        public constructor(controller: PlanController, preferences: any, oldAreaAngle: number, room: Room, newAreaAngle: number) {
            super(preferences, PlanController, "undoRoomAreaRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldAreaAngle === undefined) { this.oldAreaAngle = 0; }
            if (this.room === undefined) { this.room = null; }
            if (this.newAreaAngle === undefined) { this.newAreaAngle = 0; }
            this.controller = controller;
            this.oldAreaAngle = oldAreaAngle;
            this.room = room;
            this.newAreaAngle = newAreaAngle;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.room.setAreaAngle(this.oldAreaAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.room.setAreaAngle(this.newAreaAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.room].slice(0));
        }
    }
    RoomAreaRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomAreaRotationUndoableEdit";
    RoomAreaRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the rotation of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldAngle
     * @param {boolean} oldDoorOrWindowBoundToWall
     * @param {HomePieceOfFurniture} piece
     * @param {number} newAngle
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldAngle: number;

        oldDoorOrWindowBoundToWall: boolean;

        piece: HomePieceOfFurniture;

        newAngle: number;

        public constructor(controller: PlanController, preferences: any, oldAngle: number, oldDoorOrWindowBoundToWall: boolean, piece: HomePieceOfFurniture, newAngle: number) {
            super(preferences, PlanController, "undoPieceOfFurnitureRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldAngle === undefined) { this.oldAngle = 0; }
            if (this.oldDoorOrWindowBoundToWall === undefined) { this.oldDoorOrWindowBoundToWall = false; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newAngle === undefined) { this.newAngle = 0; }
            this.controller = controller;
            this.oldAngle = oldAngle;
            this.oldDoorOrWindowBoundToWall = oldDoorOrWindowBoundToWall;
            this.piece = piece;
            this.newAngle = newAngle;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.piece.setAngle(this.oldAngle);
            if (this.piece != null && this.piece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>this.piece).setBoundToWall(this.oldDoorOrWindowBoundToWall);
            }
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.piece.setAngle(this.newAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureRotationUndoableEdit";
    PieceOfFurnitureRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the pitch rotation of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldPitch
     * @param {number} oldWidthInPlan
     * @param {number} oldDepthInPlan
     * @param {number} oldHeightInPlan
     * @param {HomePieceOfFurniture} piece
     * @param {number} newPitch
     * @param {number} newWidthInPlan
     * @param {number} newDepthInPlan
     * @param {number} newHeightInPlan
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurniturePitchRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldPitch: number;

        oldWidthInPlan: number;

        oldDepthInPlan: number;

        oldHeightInPlan: number;

        piece: HomePieceOfFurniture;

        newPitch: number;

        newWidthInPlan: number;

        newDepthInPlan: number;

        newHeightInPlan: number;

        public constructor(controller: PlanController, preferences: any, oldPitch: number, oldWidthInPlan: number, oldDepthInPlan: number, oldHeightInPlan: number, piece: HomePieceOfFurniture, newPitch: number, newWidthInPlan: number, newDepthInPlan: number, newHeightInPlan: number) {
            super(preferences, PlanController, "undoPieceOfFurnitureRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldPitch === undefined) { this.oldPitch = 0; }
            if (this.oldWidthInPlan === undefined) { this.oldWidthInPlan = 0; }
            if (this.oldDepthInPlan === undefined) { this.oldDepthInPlan = 0; }
            if (this.oldHeightInPlan === undefined) { this.oldHeightInPlan = 0; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newPitch === undefined) { this.newPitch = 0; }
            if (this.newWidthInPlan === undefined) { this.newWidthInPlan = 0; }
            if (this.newDepthInPlan === undefined) { this.newDepthInPlan = 0; }
            if (this.newHeightInPlan === undefined) { this.newHeightInPlan = 0; }
            this.controller = controller;
            this.oldPitch = oldPitch;
            this.oldWidthInPlan = oldWidthInPlan;
            this.oldDepthInPlan = oldDepthInPlan;
            this.oldHeightInPlan = oldHeightInPlan;
            this.piece = piece;
            this.newPitch = newPitch;
            this.newWidthInPlan = newWidthInPlan;
            this.newDepthInPlan = newDepthInPlan;
            this.newHeightInPlan = newHeightInPlan;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setPieceOfFurniturePitch(this.piece, this.oldPitch, this.oldWidthInPlan, this.oldDepthInPlan, this.oldHeightInPlan);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.setPieceOfFurniturePitch(this.piece, this.newPitch, this.newWidthInPlan, this.newDepthInPlan, this.newHeightInPlan);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurniturePitchRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurniturePitchRotationUndoableEdit";
    PieceOfFurniturePitchRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the roll rotation of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldRoll
     * @param {number} oldWidthInPlan
     * @param {number} oldDepthInPlan
     * @param {number} oldHeightInPlan
     * @param {HomePieceOfFurniture} piece
     * @param {number} newRoll
     * @param {number} newWidthInPlan
     * @param {number} newDepthInPlan
     * @param {number} newHeightInPlan
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureRollRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldRoll: number;

        oldWidthInPlan: number;

        oldDepthInPlan: number;

        oldHeightInPlan: number;

        piece: HomePieceOfFurniture;

        newRoll: number;

        newWidthInPlan: number;

        newDepthInPlan: number;

        newHeightInPlan: number;

        public constructor(controller: PlanController, preferences: any, oldRoll: number, oldWidthInPlan: number, oldDepthInPlan: number, oldHeightInPlan: number, piece: HomePieceOfFurniture, newRoll: number, newWidthInPlan: number, newDepthInPlan: number, newHeightInPlan: number) {
            super(preferences, PlanController, "undoPieceOfFurnitureRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldRoll === undefined) { this.oldRoll = 0; }
            if (this.oldWidthInPlan === undefined) { this.oldWidthInPlan = 0; }
            if (this.oldDepthInPlan === undefined) { this.oldDepthInPlan = 0; }
            if (this.oldHeightInPlan === undefined) { this.oldHeightInPlan = 0; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newRoll === undefined) { this.newRoll = 0; }
            if (this.newWidthInPlan === undefined) { this.newWidthInPlan = 0; }
            if (this.newDepthInPlan === undefined) { this.newDepthInPlan = 0; }
            if (this.newHeightInPlan === undefined) { this.newHeightInPlan = 0; }
            this.controller = controller;
            this.oldRoll = oldRoll;
            this.oldWidthInPlan = oldWidthInPlan;
            this.oldDepthInPlan = oldDepthInPlan;
            this.oldHeightInPlan = oldHeightInPlan;
            this.piece = piece;
            this.newRoll = newRoll;
            this.newWidthInPlan = newWidthInPlan;
            this.newDepthInPlan = newDepthInPlan;
            this.newHeightInPlan = newHeightInPlan;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.setPieceOfFurnitureRoll(this.piece, this.oldRoll, this.oldWidthInPlan, this.oldDepthInPlan, this.oldHeightInPlan);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.controller.setPieceOfFurnitureRoll(this.piece, this.newRoll, this.newWidthInPlan, this.newDepthInPlan, this.newHeightInPlan);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureRollRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureRollRotationUndoableEdit";
    PieceOfFurnitureRollRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the elevation modification of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldElevation
     * @param {HomePieceOfFurniture} piece
     * @param {number} newElevation
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureElevationModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldElevation: number;

        piece: HomePieceOfFurniture;

        newElevation: number;

        public constructor(controller: PlanController, preferences: any, oldElevation: number, piece: HomePieceOfFurniture, newElevation: number) {
            super(preferences, PlanController, oldElevation < newElevation ? "undoPieceOfFurnitureRaiseName" : "undoPieceOfFurnitureLowerName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newElevation === undefined) { this.newElevation = 0; }
            this.controller = controller;
            this.oldElevation = oldElevation;
            this.piece = piece;
            this.newElevation = newElevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.piece.setElevation(this.oldElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.piece.setElevation(this.newElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureElevationModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureElevationModificationUndoableEdit";
    PieceOfFurnitureElevationModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the resizing of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {string} presentationNameKey
     * @param {boolean} doorOrWindowBoundToWall
     * @param {PlanController.ResizedPieceOfFurniture} resizedPiece
     * @param {number} newX
     * @param {number} newY
     * @param {number} newWidth
     * @param {number} newDepth
     * @param {number} newHeight
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        doorOrWindowBoundToWall: boolean;

        resizedPiece: PlanController.ResizedPieceOfFurniture;

        newX: number;

        newY: number;

        newWidth: number;

        newDepth: number;

        newHeight: number;

        public constructor(controller: PlanController, preferences: any, presentationNameKey: string, doorOrWindowBoundToWall: boolean, resizedPiece: PlanController.ResizedPieceOfFurniture, newX: number, newY: number, newWidth: number, newDepth: number, newHeight: number) {
            super(preferences, PlanController, presentationNameKey);
            if (this.controller === undefined) { this.controller = null; }
            if (this.doorOrWindowBoundToWall === undefined) { this.doorOrWindowBoundToWall = false; }
            if (this.resizedPiece === undefined) { this.resizedPiece = null; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            if (this.newWidth === undefined) { this.newWidth = 0; }
            if (this.newDepth === undefined) { this.newDepth = 0; }
            if (this.newHeight === undefined) { this.newHeight = 0; }
            this.controller = controller;
            this.doorOrWindowBoundToWall = doorOrWindowBoundToWall;
            this.resizedPiece = resizedPiece;
            this.newX = newX;
            this.newY = newY;
            this.newWidth = newWidth;
            this.newDepth = newDepth;
            this.newHeight = newHeight;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.controller.resetPieceOfFurnitureSize(this.resizedPiece);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.resizedPiece.getPieceOfFurniture()].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            const piece: HomePieceOfFurniture = this.resizedPiece.getPieceOfFurniture();
            piece.setX(this.newX);
            piece.setY(this.newY);
            this.controller.setPieceOfFurnitureSize(this.resizedPiece, this.newWidth, this.newDepth, this.newHeight);
            if (piece != null && piece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>piece).setBoundToWall(this.doorOrWindowBoundToWall);
            }
            this.controller.selectAndShowItems$java_util_List(/* asList */[piece].slice(0));
        }
    }
    PieceOfFurnitureResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureResizingUndoableEdit";
    PieceOfFurnitureResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the light power modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldPower
     * @param {HomeLight} light
     * @param {number} newPower
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class LightPowerModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldPower: number;

        light: HomeLight;

        newPower: number;

        public constructor(controller: PlanController, preferences: any, oldPower: number, light: HomeLight, newPower: number) {
            super(preferences, PlanController, "undoLightPowerModificationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldPower === undefined) { this.oldPower = 0; }
            if (this.light === undefined) { this.light = null; }
            if (this.newPower === undefined) { this.newPower = 0; }
            this.controller = controller;
            this.oldPower = oldPower;
            this.light = light;
            this.newPower = newPower;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.light.setPower(this.oldPower);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.light].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.light.setPower(this.newPower);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.light].slice(0));
        }
    }
    LightPowerModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LightPowerModificationUndoableEdit";
    LightPowerModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the name offset modification of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldNameXOffset
     * @param {number} oldNameYOffset
     * @param {HomePieceOfFurniture} piece
     * @param {number} newNameXOffset
     * @param {number} newNameYOffset
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureNameOffsetModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldNameXOffset: number;

        oldNameYOffset: number;

        piece: HomePieceOfFurniture;

        newNameXOffset: number;

        newNameYOffset: number;

        public constructor(controller: PlanController, preferences: any, oldNameXOffset: number, oldNameYOffset: number, piece: HomePieceOfFurniture, newNameXOffset: number, newNameYOffset: number) {
            super(preferences, PlanController, "undoPieceOfFurnitureNameOffsetName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldNameXOffset === undefined) { this.oldNameXOffset = 0; }
            if (this.oldNameYOffset === undefined) { this.oldNameYOffset = 0; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newNameXOffset === undefined) { this.newNameXOffset = 0; }
            if (this.newNameYOffset === undefined) { this.newNameYOffset = 0; }
            this.controller = controller;
            this.oldNameXOffset = oldNameXOffset;
            this.oldNameYOffset = oldNameYOffset;
            this.piece = piece;
            this.newNameXOffset = newNameXOffset;
            this.newNameYOffset = newNameYOffset;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.piece.setNameXOffset(this.oldNameXOffset);
            this.piece.setNameYOffset(this.oldNameYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.piece.setNameXOffset(this.newNameXOffset);
            this.piece.setNameYOffset(this.newNameYOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureNameOffsetModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureNameOffsetModificationUndoableEdit";
    PieceOfFurnitureNameOffsetModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the name rotation of a piece of furniture.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldNameAngle
     * @param {HomePieceOfFurniture} piece
     * @param {number} newNameAngle
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PieceOfFurnitureNameRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldNameAngle: number;

        piece: HomePieceOfFurniture;

        newNameAngle: number;

        public constructor(controller: PlanController, preferences: any, oldNameAngle: number, piece: HomePieceOfFurniture, newNameAngle: number) {
            super(preferences, PlanController, "undoPieceOfFurnitureNameRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldNameAngle === undefined) { this.oldNameAngle = 0; }
            if (this.piece === undefined) { this.piece = null; }
            if (this.newNameAngle === undefined) { this.newNameAngle = 0; }
            this.controller = controller;
            this.oldNameAngle = oldNameAngle;
            this.piece = piece;
            this.newNameAngle = newNameAngle;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.piece.setNameAngle(this.oldNameAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.piece.setNameAngle(this.newNameAngle);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.piece].slice(0));
        }
    }
    PieceOfFurnitureNameRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureNameRotationUndoableEdit";
    PieceOfFurnitureNameRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension line resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldX
     * @param {number} oldY
     * @param {DimensionLine} dimensionLine
     * @param {number} newX
     * @param {number} newY
     * @param {boolean} startPoint
     * @param {boolean} reversed
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLineResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldX: number;

        oldY: number;

        dimensionLine: DimensionLine;

        newX: number;

        newY: number;

        startPoint: boolean;

        reversed: boolean;

        public constructor(controller: PlanController, preferences: any, oldX: number, oldY: number, dimensionLine: DimensionLine, newX: number, newY: number, startPoint: boolean, reversed: boolean) {
            super(preferences, PlanController, "undoDimensionLineResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            if (this.startPoint === undefined) { this.startPoint = false; }
            if (this.reversed === undefined) { this.reversed = false; }
            this.controller = controller;
            this.oldX = oldX;
            this.oldY = oldY;
            this.dimensionLine = dimensionLine;
            this.newX = newX;
            this.newY = newY;
            this.startPoint = startPoint;
            this.reversed = reversed;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            if (this.reversed) {
                PlanController.reverseDimensionLine(this.dimensionLine);
                PlanController.moveDimensionLinePoint(this.dimensionLine, this.oldX, this.oldY, !this.startPoint);
            } else {
                PlanController.moveDimensionLinePoint(this.dimensionLine, this.oldX, this.oldY, this.startPoint);
            }
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            if (this.reversed) {
                PlanController.moveDimensionLinePoint(this.dimensionLine, this.newX, this.newY, !this.startPoint);
                PlanController.reverseDimensionLine(this.dimensionLine);
            } else {
                PlanController.moveDimensionLinePoint(this.dimensionLine, this.newX, this.newY, this.startPoint);
            }
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }
    }
    DimensionLineResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineResizingUndoableEdit";
    DimensionLineResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension line offset modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldOffset
     * @param {DimensionLine} dimensionLine
     * @param {number} newOffset
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLineOffsetModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldOffset: number;

        dimensionLine: DimensionLine;

        newOffset: number;

        public constructor(controller: PlanController, preferences: any, oldOffset: number, dimensionLine: DimensionLine, newOffset: number) {
            super(preferences, PlanController, "undoDimensionLineOffsetName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldOffset === undefined) { this.oldOffset = 0; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.newOffset === undefined) { this.newOffset = 0; }
            this.controller = controller;
            this.oldOffset = oldOffset;
            this.dimensionLine = dimensionLine;
            this.newOffset = newOffset;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.dimensionLine.setOffset(this.oldOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.dimensionLine.setOffset(this.newOffset);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }
    }
    DimensionLineOffsetModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineOffsetModificationUndoableEdit";
    DimensionLineOffsetModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for the pitch angle modification of a dimension line.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldPitch
     * @param {DimensionLine} dimensionLine
     * @param {number} newPitch
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLinePitchRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldPitch: number;

        dimensionLine: DimensionLine;

        newPitch: number;

        public constructor(controller: PlanController, preferences: any, oldPitch: number, dimensionLine: DimensionLine, newPitch: number) {
            super(preferences, PlanController, "undoDimensionLineRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldPitch === undefined) { this.oldPitch = 0; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.newPitch === undefined) { this.newPitch = 0; }
            this.controller = controller;
            this.oldPitch = oldPitch;
            this.dimensionLine = dimensionLine;
            this.newPitch = newPitch;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.dimensionLine.setPitch(this.oldPitch);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.dimensionLine.setPitch(this.newPitch);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }
    }
    DimensionLinePitchRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLinePitchRotationUndoableEdit";
    DimensionLinePitchRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension line height resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldHeight
     * @param {DimensionLine} dimensionLine
     * @param {number} newHeight
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLineHeightResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldHeight: number;

        dimensionLine: DimensionLine;

        newHeight: number;

        public constructor(controller: PlanController, preferences: any, oldHeight: number, dimensionLine: DimensionLine, newHeight: number) {
            super(preferences, PlanController, "undoDimensionLineHeightResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldHeight === undefined) { this.oldHeight = 0; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.newHeight === undefined) { this.newHeight = 0; }
            this.controller = controller;
            this.oldHeight = oldHeight;
            this.dimensionLine = dimensionLine;
            this.newHeight = newHeight;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.dimensionLine.setElevationEnd(this.dimensionLine.getElevationStart() + this.oldHeight);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.dimensionLine.setElevationEnd(this.dimensionLine.getElevationStart() + this.newHeight);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }
    }
    DimensionLineHeightResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineHeightResizingUndoableEdit";
    DimensionLineHeightResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for dimension label elevation modification.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldElevation
     * @param {DimensionLine} dimensionLine
     * @param {number} newElevation
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class DimensionLineElevationModificationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldElevation: number;

        dimensionLine: DimensionLine;

        newElevation: number;

        public constructor(controller: PlanController, preferences: any, oldElevation: number, dimensionLine: DimensionLine, newElevation: number) {
            super(preferences, PlanController, oldElevation < newElevation ? "undoDimensionLineRaiseName" : "undoDimensionLineLowerName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.dimensionLine === undefined) { this.dimensionLine = null; }
            if (this.newElevation === undefined) { this.newElevation = 0; }
            this.controller = controller;
            this.oldElevation = oldElevation;
            this.dimensionLine = dimensionLine;
            this.newElevation = newElevation;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.dimensionLine.setElevationStart(this.oldElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.dimensionLine.setElevationStart(this.newElevation);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.dimensionLine].slice(0));
        }
    }
    DimensionLineElevationModificationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineElevationModificationUndoableEdit";
    DimensionLineElevationModificationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for polyline resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldX
     * @param {number} oldY
     * @param {Polyline} polyline
     * @param {number} pointIndex
     * @param {number} newX
     * @param {number} newY
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class PolylineResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldX: number;

        oldY: number;

        polyline: Polyline;

        pointIndex: number;

        newX: number;

        newY: number;

        public constructor(controller: PlanController, preferences: any, oldX: number, oldY: number, polyline: Polyline, pointIndex: number, newX: number, newY: number) {
            super(preferences, PlanController, "undoPolylineResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.polyline === undefined) { this.polyline = null; }
            if (this.pointIndex === undefined) { this.pointIndex = 0; }
            if (this.newX === undefined) { this.newX = 0; }
            if (this.newY === undefined) { this.newY = 0; }
            this.controller = controller;
            this.oldX = oldX;
            this.oldY = oldY;
            this.polyline = polyline;
            this.pointIndex = pointIndex;
            this.newX = newX;
            this.newY = newY;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.polyline.setPoint(this.oldX, this.oldY, this.pointIndex);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.polyline].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.polyline.setPoint(this.newX, this.newY, this.pointIndex);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.polyline].slice(0));
        }
    }
    PolylineResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PolylineResizingUndoableEdit";
    PolylineResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for compass rotation.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldNorthDirection
     * @param {Compass} compass
     * @param {number} newNorthDirection
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class CompassRotationUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldNorthDirection: number;

        compass: Compass;

        newNorthDirection: number;

        public constructor(controller: PlanController, preferences: any, oldNorthDirection: number, compass: Compass, newNorthDirection: number) {
            super(preferences, PlanController, "undoCompassRotationName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldNorthDirection === undefined) { this.oldNorthDirection = 0; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.newNorthDirection === undefined) { this.newNorthDirection = 0; }
            this.controller = controller;
            this.compass = compass;
            this.newNorthDirection = newNorthDirection;
            this.oldNorthDirection = oldNorthDirection;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.compass.setNorthDirection(this.oldNorthDirection);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.compass].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.compass.setNorthDirection(this.newNorthDirection);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.compass].slice(0));
        }
    }
    CompassRotationUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CompassRotationUndoableEdit";
    CompassRotationUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Undoable edit for compass resizing.
     * @param {PlanController} controller
     * @param {UserPreferences} preferences
     * @param {number} oldDiameter
     * @param {Compass} compass
     * @param {number} newDiameter
     * @class
     * @extends LocalizedUndoableEdit
     */
    export class CompassResizingUndoableEdit extends LocalizedUndoableEdit {
        controller: PlanController;

        oldDiameter: number;

        compass: Compass;

        newDiameter: number;

        public constructor(controller: PlanController, preferences: any, oldDiameter: number, compass: Compass, newDiameter: number) {
            super(preferences, PlanController, "undoCompassResizeName");
            if (this.controller === undefined) { this.controller = null; }
            if (this.oldDiameter === undefined) { this.oldDiameter = 0; }
            if (this.compass === undefined) { this.compass = null; }
            if (this.newDiameter === undefined) { this.newDiameter = 0; }
            this.controller = controller;
            this.oldDiameter = oldDiameter;
            this.compass = compass;
            this.newDiameter = newDiameter;
        }

        /**
         * 
         */
        public undo() {
            super.undo();
            this.compass.setDiameter(this.oldDiameter);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.compass].slice(0));
        }

        /**
         * 
         */
        public redo() {
            super.redo();
            this.compass.setDiameter(this.newDiameter);
            this.controller.selectAndShowItems$java_util_List(/* asList */[this.compass].slice(0));
        }
    }
    CompassResizingUndoableEdit["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CompassResizingUndoableEdit";
    CompassResizingUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit"];



    /**
     * Stores the size of a resized piece of furniture.
     * @param {HomePieceOfFurniture} piece
     * @class
     */
    export class ResizedPieceOfFurniture {
        piece: HomePieceOfFurniture;

        x: number;

        y: number;

        width: number;

        depth: number;

        height: number;

        doorOrWindowBoundToWall: boolean;

        groupFurnitureX: number[];

        groupFurnitureY: number[];

        groupFurnitureWidth: number[];

        groupFurnitureDepth: number[];

        groupFurnitureHeight: number[];

        public constructor(piece: HomePieceOfFurniture) {
            if (this.piece === undefined) { this.piece = null; }
            if (this.x === undefined) { this.x = 0; }
            if (this.y === undefined) { this.y = 0; }
            if (this.width === undefined) { this.width = 0; }
            if (this.depth === undefined) { this.depth = 0; }
            if (this.height === undefined) { this.height = 0; }
            if (this.doorOrWindowBoundToWall === undefined) { this.doorOrWindowBoundToWall = false; }
            if (this.groupFurnitureX === undefined) { this.groupFurnitureX = null; }
            if (this.groupFurnitureY === undefined) { this.groupFurnitureY = null; }
            if (this.groupFurnitureWidth === undefined) { this.groupFurnitureWidth = null; }
            if (this.groupFurnitureDepth === undefined) { this.groupFurnitureDepth = null; }
            if (this.groupFurnitureHeight === undefined) { this.groupFurnitureHeight = null; }
            this.piece = piece;
            this.x = piece.getX();
            this.y = piece.getY();
            this.width = piece.getWidth();
            this.depth = piece.getDepth();
            this.height = piece.getHeight();
            this.doorOrWindowBoundToWall = (piece != null && piece instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>piece).isBoundToWall();
            if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                const groupFurniture: Array<HomePieceOfFurniture> = (<HomeFurnitureGroup>piece).getAllFurniture();
                this.groupFurnitureX = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
                this.groupFurnitureY = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
                this.groupFurnitureWidth = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
                this.groupFurnitureDepth = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
                this.groupFurnitureHeight = (s => { let a = []; while (s-- > 0) a.push(0); return a; })(/* size */(<number>groupFurniture.length));
                for (let i: number = 0; i < /* size */(<number>groupFurniture.length); i++) {
                    {
                        const groupPiece: HomePieceOfFurniture = /* get */groupFurniture[i];
                        this.groupFurnitureX[i] = groupPiece.getX();
                        this.groupFurnitureY[i] = groupPiece.getY();
                        this.groupFurnitureWidth[i] = groupPiece.getWidth();
                        this.groupFurnitureDepth[i] = groupPiece.getDepth();
                        this.groupFurnitureHeight[i] = groupPiece.getHeight();
                    };
                }
            } else {
                this.groupFurnitureX = null;
                this.groupFurnitureY = null;
                this.groupFurnitureWidth = null;
                this.groupFurnitureDepth = null;
                this.groupFurnitureHeight = null;
            }
        }

        public getPieceOfFurniture(): HomePieceOfFurniture {
            return this.piece;
        }

        public getWidth(): number {
            return this.width;
        }

        public getDepth(): number {
            return this.depth;
        }

        public getHeight(): number {
            return this.height;
        }

        public isDoorOrWindowBoundToWall(): boolean {
            return this.doorOrWindowBoundToWall;
        }

        public reset() {
            this.piece.setX(this.x);
            this.piece.setY(this.y);
            ResizedPieceOfFurniture.setPieceOfFurnitureSize(this.piece, this.width, this.depth, this.height);
            if (this.piece != null && this.piece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>this.piece).setBoundToWall(this.doorOrWindowBoundToWall);
            }
            if (this.piece != null && this.piece instanceof <any>HomeFurnitureGroup) {
                const groupFurniture: Array<HomePieceOfFurniture> = (<HomeFurnitureGroup>this.piece).getAllFurniture();
                for (let i: number = 0; i < /* size */(<number>groupFurniture.length); i++) {
                    {
                        const groupPiece: HomePieceOfFurniture = /* get */groupFurniture[i];
                        if (this.piece.isResizable()) {
                            groupPiece.setX(this.groupFurnitureX[i]);
                            groupPiece.setY(this.groupFurnitureY[i]);
                            ResizedPieceOfFurniture.setPieceOfFurnitureSize(groupPiece, this.groupFurnitureWidth[i], this.groupFurnitureDepth[i], this.groupFurnitureHeight[i]);
                        }
                    };
                }
            }
        }

        public static setPieceOfFurnitureSize(piece: HomePieceOfFurniture, width: number, depth: number, height: number) {
            if (piece.isHorizontallyRotated()) {
                const scale: number = width / piece.getWidth();
                piece.scale(scale);
                piece.setWidthInPlan(scale * piece.getWidthInPlan());
                piece.setDepthInPlan(scale * piece.getDepthInPlan());
                piece.setHeightInPlan(scale * piece.getHeightInPlan());
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.setWidthInPlan(scale * childPiece.getWidthInPlan());
                                childPiece.setDepthInPlan(scale * childPiece.getDepthInPlan());
                                childPiece.setHeightInPlan(scale * childPiece.getHeightInPlan());
                            }
                        }
                    }
                }
            } else {
                const widthInPlan: number = piece.getWidthInPlan() * width / piece.getWidth();
                piece.setWidth(width);
                piece.setWidthInPlan(widthInPlan);
                const depthInPlan: number = piece.getDepthInPlan() * depth / piece.getDepth();
                piece.setDepth(depth);
                piece.setDepthInPlan(depthInPlan);
                const heightInPlan: number = piece.getHeightInPlan() * height / piece.getHeight();
                piece.setHeight(height);
                piece.setHeightInPlan(heightInPlan);
                if (piece != null && piece instanceof <any>HomeFurnitureGroup) {
                    {
                        let array = (<HomeFurnitureGroup>piece).getAllFurniture();
                        for (let index = 0; index < array.length; index++) {
                            let childPiece = array[index];
                            {
                                childPiece.setWidthInPlan(childPiece.getWidth());
                                childPiece.setDepthInPlan(childPiece.getDepth());
                                childPiece.setHeightInPlan(childPiece.getHeight());
                            }
                        }
                    }
                }
            }
        }
    }
    ResizedPieceOfFurniture["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ResizedPieceOfFurniture";


    /**
     * Stores the walls at start and at end of a given wall. This data are useful
     * to add a collection of walls after an undo/redo delete operation.
     * @param {Wall} wall
     * @class
     */
    export class JoinedWall {
        wall: Wall;

        level: Level;

        xStart: number;

        yStart: number;

        xEnd: number;

        yEnd: number;

        wallAtStart: Wall;

        wallAtEnd: Wall;

        joinedAtEndOfWallAtStart: boolean;

        joinedAtStartOfWallAtEnd: boolean;

        public constructor(wall: Wall) {
            if (this.wall === undefined) { this.wall = null; }
            if (this.level === undefined) { this.level = null; }
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xEnd === undefined) { this.xEnd = 0; }
            if (this.yEnd === undefined) { this.yEnd = 0; }
            if (this.wallAtStart === undefined) { this.wallAtStart = null; }
            if (this.wallAtEnd === undefined) { this.wallAtEnd = null; }
            if (this.joinedAtEndOfWallAtStart === undefined) { this.joinedAtEndOfWallAtStart = false; }
            if (this.joinedAtStartOfWallAtEnd === undefined) { this.joinedAtStartOfWallAtEnd = false; }
            this.wall = wall;
            this.level = wall.getLevel();
            this.xStart = wall.getXStart();
            this.xEnd = wall.getXEnd();
            this.yStart = wall.getYStart();
            this.yEnd = wall.getYEnd();
            this.wallAtStart = wall.getWallAtStart();
            this.joinedAtEndOfWallAtStart = this.wallAtStart != null && this.wallAtStart.getWallAtEnd() === wall;
            this.wallAtEnd = wall.getWallAtEnd();
            this.joinedAtStartOfWallAtEnd = this.wallAtEnd != null && this.wallAtEnd.getWallAtStart() === wall;
        }

        public getWall(): Wall {
            return this.wall;
        }

        public getLevel(): Level {
            return this.level;
        }

        public getXStart(): number {
            return this.xStart;
        }

        public getYStart(): number {
            return this.yStart;
        }

        public getXEnd(): number {
            return this.xEnd;
        }

        public getYEnd(): number {
            return this.yEnd;
        }

        public getWallAtEnd(): Wall {
            return this.wallAtEnd;
        }

        public getWallAtStart(): Wall {
            return this.wallAtStart;
        }

        public isJoinedAtEndOfWallAtStart(): boolean {
            return this.joinedAtEndOfWallAtStart;
        }

        public isJoinedAtStartOfWallAtEnd(): boolean {
            return this.joinedAtStartOfWallAtEnd;
        }

        /**
         * A helper method that builds an array of <code>JoinedWall</code> objects
         * for a given list of walls.
         * @param {Wall[]} walls
         * @return {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]}
         */
        public static getJoinedWalls(walls: Array<Wall>): PlanController.JoinedWall[] {
            const joinedWalls: PlanController.JoinedWall[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(/* size */(<number>walls.length));
            for (let i: number = 0; i < joinedWalls.length; i++) {
                {
                    joinedWalls[i] = new PlanController.JoinedWall(/* get */walls[i]);
                };
            }
            return joinedWalls;
        }

        /**
         * A helper method that builds a list of <code>Wall</code> objects
         * for a given array of <code>JoinedWall</code> objects.
         * @param {com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall[]} joinedWalls
         * @return {Wall[]}
         */
        public static getWalls(joinedWalls: PlanController.JoinedWall[]): Array<Wall> {
            const walls: Wall[] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(joinedWalls.length);
            for (let i: number = 0; i < joinedWalls.length; i++) {
                {
                    walls[i] = joinedWalls[i].getWall();
                };
            }
            return /* asList */walls.slice(0);
        }
    }
    JoinedWall["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.JoinedWall";


    /**
     * A point which coordinates are computed with an angle magnetism algorithm.
     * @param {number} xStart
     * @param {number} yStart
     * @param {number} x
     * @param {number} y
     * @param {LengthUnit} unit
     * @param {number} maxLengthDelta
     * @param {number} circleSteps
     * @class
     */
    export class PointWithAngleMagnetism {
        static CIRCLE_STEPS_15_DEG: number = 24;

        x: number;

        y: number;

        angle: number;

        public constructor(xStart?: any, yStart?: any, x?: any, y?: any, unit?: any, maxLengthDelta?: any, circleSteps?: any) {
            if (((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((unit != null) || unit === null) && ((typeof maxLengthDelta === 'number') || maxLengthDelta === null) && ((typeof circleSteps === 'number') || circleSteps === null)) {
                let __args = arguments;
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.angle === undefined) { this.angle = 0; }
                this.x = x;
                this.y = y;
                if (xStart === x) {
                    const magnetizedLength: number = unit.getMagnetizedLength(Math.abs(yStart - y), maxLengthDelta);
                    this.y = yStart + <number>(magnetizedLength * /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(y - yStart));
                } else if (yStart === y) {
                    const magnetizedLength: number = unit.getMagnetizedLength(Math.abs(xStart - x), maxLengthDelta);
                    this.x = xStart + <number>(magnetizedLength * /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(x - xStart));
                } else {
                    const angleStep: number = 2 * Math.PI / circleSteps;
                    const angle: number = Math.atan2(yStart - y, x - xStart);
                    const previousStepAngle: number = Math.floor(angle / angleStep) * angleStep;
                    let angle1: number;
                    let tanAngle1: number;
                    let angle2: number;
                    let tanAngle2: number;
                    if (Math.tan(angle) > 0) {
                        angle1 = previousStepAngle;
                        tanAngle1 = Math.tan(previousStepAngle);
                        angle2 = previousStepAngle + angleStep;
                        tanAngle2 = Math.tan(previousStepAngle + angleStep);
                    } else {
                        angle1 = previousStepAngle + angleStep;
                        tanAngle1 = Math.tan(previousStepAngle + angleStep);
                        angle2 = previousStepAngle;
                        tanAngle2 = Math.tan(previousStepAngle);
                    }
                    const firstQuarterTanAngle1: number = Math.abs(tanAngle1);
                    const firstQuarterTanAngle2: number = Math.abs(tanAngle2);
                    const xEnd1: number = Math.abs(xStart - x);
                    const yEnd2: number = Math.abs(yStart - y);
                    let xEnd2: number = 0;
                    if (firstQuarterTanAngle2 > 1.0E-10) {
                        xEnd2 = <number>(yEnd2 / firstQuarterTanAngle2);
                    }
                    let yEnd1: number = 0;
                    if (firstQuarterTanAngle1 < 1.0E10) {
                        yEnd1 = <number>(xEnd1 * firstQuarterTanAngle1);
                    }
                    let magnetismAngle: number;
                    if (Math.abs(xEnd2 - xEnd1) < Math.abs(yEnd1 - yEnd2)) {
                        magnetismAngle = angle2;
                        this.x = xStart + <number>((yStart - y) / tanAngle2);
                    } else {
                        magnetismAngle = angle1;
                        this.y = yStart - <number>((x - xStart) * tanAngle1);
                    }
                    const magnetizedLength: number = unit.getMagnetizedLength(<number>java.awt.geom.Point2D.distance(xStart, yStart, this.x, this.y), maxLengthDelta);
                    this.x = xStart + <number>(magnetizedLength * Math.cos(magnetismAngle));
                    this.y = yStart - <number>(magnetizedLength * Math.sin(magnetismAngle));
                    this.angle = <number>magnetismAngle;
                }
            } else if (((typeof xStart === 'number') || xStart === null) && ((typeof yStart === 'number') || yStart === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((unit != null) || unit === null) && ((typeof maxLengthDelta === 'number') || maxLengthDelta === null) && circleSteps === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let circleSteps: any = PointWithAngleMagnetism.CIRCLE_STEPS_15_DEG;
                    if (this.x === undefined) { this.x = 0; }
                    if (this.y === undefined) { this.y = 0; }
                    if (this.angle === undefined) { this.angle = 0; }
                    this.x = x;
                    this.y = y;
                    if (xStart === x) {
                        const magnetizedLength: number = unit.getMagnetizedLength(Math.abs(yStart - y), maxLengthDelta);
                        this.y = yStart + <number>(magnetizedLength * /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(y - yStart));
                    } else if (yStart === y) {
                        const magnetizedLength: number = unit.getMagnetizedLength(Math.abs(xStart - x), maxLengthDelta);
                        this.x = xStart + <number>(magnetizedLength * /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(x - xStart));
                    } else {
                        const angleStep: number = 2 * Math.PI / circleSteps;
                        const angle: number = Math.atan2(yStart - y, x - xStart);
                        const previousStepAngle: number = Math.floor(angle / angleStep) * angleStep;
                        let angle1: number;
                        let tanAngle1: number;
                        let angle2: number;
                        let tanAngle2: number;
                        if (Math.tan(angle) > 0) {
                            angle1 = previousStepAngle;
                            tanAngle1 = Math.tan(previousStepAngle);
                            angle2 = previousStepAngle + angleStep;
                            tanAngle2 = Math.tan(previousStepAngle + angleStep);
                        } else {
                            angle1 = previousStepAngle + angleStep;
                            tanAngle1 = Math.tan(previousStepAngle + angleStep);
                            angle2 = previousStepAngle;
                            tanAngle2 = Math.tan(previousStepAngle);
                        }
                        const firstQuarterTanAngle1: number = Math.abs(tanAngle1);
                        const firstQuarterTanAngle2: number = Math.abs(tanAngle2);
                        const xEnd1: number = Math.abs(xStart - x);
                        const yEnd2: number = Math.abs(yStart - y);
                        let xEnd2: number = 0;
                        if (firstQuarterTanAngle2 > 1.0E-10) {
                            xEnd2 = <number>(yEnd2 / firstQuarterTanAngle2);
                        }
                        let yEnd1: number = 0;
                        if (firstQuarterTanAngle1 < 1.0E10) {
                            yEnd1 = <number>(xEnd1 * firstQuarterTanAngle1);
                        }
                        let magnetismAngle: number;
                        if (Math.abs(xEnd2 - xEnd1) < Math.abs(yEnd1 - yEnd2)) {
                            magnetismAngle = angle2;
                            this.x = xStart + <number>((yStart - y) / tanAngle2);
                        } else {
                            magnetismAngle = angle1;
                            this.y = yStart - <number>((x - xStart) * tanAngle1);
                        }
                        const magnetizedLength: number = unit.getMagnetizedLength(<number>java.awt.geom.Point2D.distance(xStart, yStart, this.x, this.y), maxLengthDelta);
                        this.x = xStart + <number>(magnetizedLength * Math.cos(magnetismAngle));
                        this.y = yStart - <number>(magnetizedLength * Math.sin(magnetismAngle));
                        this.angle = <number>magnetismAngle;
                    }
                }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.angle === undefined) { this.angle = 0; }
            } else throw new Error('invalid overload');
        }

        /**
         * Returns the abscissa of end point.
         * @return {number}
         */
        public getX(): number {
            return this.x;
        }

        /**
         * Sets the abscissa of end point.
         * @param {number} x
         */
        setX(x: number) {
            this.x = x;
        }

        /**
         * Returns the ordinate of end point.
         * @return {number}
         */
        public getY(): number {
            return this.y;
        }

        /**
         * Sets the ordinate of end point.
         * @param {number} y
         */
        setY(y: number) {
            this.y = y;
        }

        getAngle(): number {
            return this.angle;
        }
    }
    PointWithAngleMagnetism["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PointWithAngleMagnetism";


    /**
     * A point which coordinates are equal to the closest point of a wall or a room.
     * @param {Room} editedRoom
     * @param {number} editedPointIndex
     * @param {number} x
     * @param {number} y
     * @class
     */
    export class PointMagnetizedToClosestWallOrRoomPoint {
        public __parent: any;
        x: number;

        y: number;

        magnetized: boolean;

        public constructor(__parent: any, editedRoom?: any, editedPointIndex?: any, x?: any, y?: any) {
            if (((editedRoom != null && editedRoom instanceof <any>Room) || editedRoom === null) && ((typeof editedPointIndex === 'number') || editedPointIndex === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                let __args = Array.prototype.slice.call(arguments, [1]);
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.magnetized === undefined) { this.magnetized = false; }
                const margin: number = __parent.getSelectionMargin();
                let smallestDistance: number = 1.7976931348623157E308;
                {
                    let array = __parent.getRoomPathsFromWalls();
                    for (let index = 0; index < array.length; index++) {
                        let roomPath = array[index];
                        {
                            smallestDistance = this.updateMagnetizedPoint(-1, x, y, smallestDistance, __parent.getPathPoints(roomPath, false));
                        }
                    }
                }
                {
                    let array = __parent.getDetectableRoomsAtSelectedLevel();
                    for (let index = 0; index < array.length; index++) {
                        let room = array[index];
                        {
                            smallestDistance = this.updateMagnetizedPoint(room === editedRoom ? editedPointIndex : -1, x, y, smallestDistance, room.getPoints());
                        }
                    }
                }
                this.magnetized = smallestDistance <= margin * margin;
                if (!this.magnetized) {
                    this.x = x;
                    this.y = y;
                }
            } else if (((typeof editedRoom === 'number') || editedRoom === null) && ((typeof editedPointIndex === 'number') || editedPointIndex === null) && x === undefined && y === undefined) {
                let __args = Array.prototype.slice.call(arguments, [1]);
                let x: any = __args[0];
                let y: any = __args[1];
                {
                    let __args = Array.prototype.slice.call(arguments, [1]);
                    let editedRoom: any = null;
                    let editedPointIndex: any = -1;
                    if (this.x === undefined) { this.x = 0; }
                    if (this.y === undefined) { this.y = 0; }
                    if (this.magnetized === undefined) { this.magnetized = false; }
                    const margin: number = __parent.getSelectionMargin();
                    let smallestDistance: number = 1.7976931348623157E308;
                    {
                        let array = __parent.getRoomPathsFromWalls();
                        for (let index = 0; index < array.length; index++) {
                            let roomPath = array[index];
                            {
                                smallestDistance = this.updateMagnetizedPoint(-1, x, y, smallestDistance, __parent.getPathPoints(roomPath, false));
                            }
                        }
                    }
                    {
                        let array = __parent.getDetectableRoomsAtSelectedLevel();
                        for (let index = 0; index < array.length; index++) {
                            let room = array[index];
                            {
                                smallestDistance = this.updateMagnetizedPoint(room === editedRoom ? editedPointIndex : -1, x, y, smallestDistance, room.getPoints());
                            }
                        }
                    }
                    this.magnetized = smallestDistance <= margin * margin;
                    if (!this.magnetized) {
                        this.x = x;
                        this.y = y;
                    }
                }
                if (this.x === undefined) { this.x = 0; }
                if (this.y === undefined) { this.y = 0; }
                if (this.magnetized === undefined) { this.magnetized = false; }
            } else throw new Error('invalid overload');
        }

        updateMagnetizedPoint(editedPointIndex: number, x: number, y: number, smallestDistance: number, points: number[][]): number {
            for (let i: number = 0; i < points.length; i++) {
                {
                    if (i !== editedPointIndex) {
                        const distance: number = java.awt.geom.Point2D.distanceSq(points[i][0], points[i][1], x, y);
                        if (distance < smallestDistance) {
                            this.x = points[i][0];
                            this.y = points[i][1];
                            smallestDistance = distance;
                        }
                    }
                };
            }
            return smallestDistance;
        }

        /**
         * Returns the abscissa of end point computed with magnetism.
         * @return {number}
         */
        public getX(): number {
            return this.x;
        }

        /**
         * Returns the ordinate of end point computed with magnetism.
         * @return {number}
         */
        public getY(): number {
            return this.y;
        }

        public isMagnetized(): boolean {
            return this.magnetized;
        }
    }
    PointMagnetizedToClosestWallOrRoomPoint["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PointMagnetizedToClosestWallOrRoomPoint";


    /**
     * Controller state classes super class.
     * @class
     */
    export abstract class ControllerState {
        public enter() {
        }

        public exit() {
        }

        public abstract getMode(): PlanController.Mode;

        public setMode(mode: PlanController.Mode) {
        }

        public isModificationState(): boolean {
            return false;
        }

        public isBasePlanModificationState(): boolean {
            return false;
        }

        public deleteSelection() {
        }

        public escape() {
        }

        public moveSelection(dx: number, dy: number) {
        }

        public toggleMagnetism(magnetismToggled: boolean) {
        }

        public setAlignmentActivated(alignmentActivated: boolean) {
        }

        public setDuplicationActivated(duplicationActivated: boolean) {
        }

        public setEditionActivated(editionActivated: boolean) {
        }

        public updateEditableProperty(editableField: any, value: any) {
        }

        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
        }

        public releaseMouse(x: number, y: number) {
        }

        public moveMouse(x: number, y: number) {
        }

        public zoom(factor: number) {
        }

        constructor() {
        }
    }
    ControllerState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ControllerState";


    /**
     * A point with coordinates computed with angle and wall points magnetism.
     * @param {Wall} editedWall
     * @param {number} xWall
     * @param {number} yWall
     * @param {number} x
     * @param {number} y
     * @class
     * @extends PlanController.PointWithAngleMagnetism
     */
    export class WallPointWithAngleMagnetism extends PlanController.PointWithAngleMagnetism {
        public __parent: any;
        public constructor(__parent: any, editedWall: Wall, xWall: number, yWall: number, x: number, y: number) {
            super(xWall, yWall, x, y, __parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), __parent.getView().getPixelLength());
            this.__parent = __parent;
            const margin: number = PlanController.PIXEL_MARGIN / __parent.getScale();
            let deltaXToClosestWall: number = Infinity;
            let deltaYToClosestWall: number = Infinity;
            let xClosestWall: number = 0;
            let yClosestWall: number = 0;
            {
                let array = __parent.getDetectableWallsAtSelectedLevel();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        if (wall !== editedWall) {
                            if (Math.abs(this.getX() - wall.getXStart()) < margin && (editedWall == null || !this.equalsWallPoint(wall.getXStart(), wall.getYStart(), editedWall))) {
                                if (Math.abs(deltaYToClosestWall) > Math.abs(this.getY() - wall.getYStart())) {
                                    xClosestWall = wall.getXStart();
                                    deltaYToClosestWall = this.getY() - yClosestWall;
                                }
                            } else if (Math.abs(this.getX() - wall.getXEnd()) < margin && (editedWall == null || !this.equalsWallPoint(wall.getXEnd(), wall.getYEnd(), editedWall))) {
                                if (Math.abs(deltaYToClosestWall) > Math.abs(this.getY() - wall.getYEnd())) {
                                    xClosestWall = wall.getXEnd();
                                    deltaYToClosestWall = this.getY() - yClosestWall;
                                }
                            }
                            if (Math.abs(this.getY() - wall.getYStart()) < margin && (editedWall == null || !this.equalsWallPoint(wall.getXStart(), wall.getYStart(), editedWall))) {
                                if (Math.abs(deltaXToClosestWall) > Math.abs(this.getX() - wall.getXStart())) {
                                    yClosestWall = wall.getYStart();
                                    deltaXToClosestWall = this.getX() - xClosestWall;
                                }
                            } else if (Math.abs(this.getY() - wall.getYEnd()) < margin && (editedWall == null || !this.equalsWallPoint(wall.getXEnd(), wall.getYEnd(), editedWall))) {
                                if (Math.abs(deltaXToClosestWall) > Math.abs(this.getX() - wall.getXEnd())) {
                                    yClosestWall = wall.getYEnd();
                                    deltaXToClosestWall = this.getX() - xClosestWall;
                                }
                            }
                        }
                    }
                }
            }
            if (editedWall != null) {
                const alpha: number = -Math.tan(this.getAngle());
                const beta: number = Math.abs(alpha) < 1.0E10 ? yWall - alpha * xWall : Infinity;
                if (deltaXToClosestWall !== Infinity && Math.abs(alpha) > 1.0E-10) {
                    const newX: number = <number>((yClosestWall - beta) / alpha);
                    if (java.awt.geom.Point2D.distanceSq(this.getX(), this.getY(), newX, yClosestWall) <= margin * margin) {
                        this.setX(newX);
                        this.setY(yClosestWall);
                        return;
                    }
                }
                if (deltaYToClosestWall !== Infinity && beta !== Infinity) {
                    const newY: number = <number>(alpha * xClosestWall + beta);
                    if (java.awt.geom.Point2D.distanceSq(this.getX(), this.getY(), xClosestWall, newY) <= margin * margin) {
                        this.setX(xClosestWall);
                        this.setY(newY);
                    }
                }
            } else {
                if (deltaXToClosestWall !== Infinity) {
                    this.setY(yClosestWall);
                }
                if (deltaYToClosestWall !== Infinity) {
                    this.setX(xClosestWall);
                }
            }
        }

        /**
         * Returns <code>true</code> if <code>wall</code> start or end point
         * equals the point (<code>x</code>, <code>y</code>).
         * @param {number} x
         * @param {number} y
         * @param {Wall} wall
         * @return {boolean}
         * @private
         */
        equalsWallPoint(x: number, y: number, wall: Wall): boolean {
            return x === wall.getXStart() && y === wall.getYStart() || x === wall.getXEnd() && y === wall.getYEnd();
        }
    }
    WallPointWithAngleMagnetism["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallPointWithAngleMagnetism";


    /**
     * A point with coordinates computed with angle and room points magnetism.
     * @param {Room} editedRoom
     * @param {number} editedPointIndex
     * @param {number} xRoom
     * @param {number} yRoom
     * @param {number} x
     * @param {number} y
     * @class
     * @extends PlanController.PointWithAngleMagnetism
     */
    export class RoomPointWithAngleMagnetism extends PlanController.PointWithAngleMagnetism {
        public __parent: any;
        public constructor(__parent: any, editedRoom: Room, editedPointIndex: number, xRoom: number, yRoom: number, x: number, y: number) {
            super(xRoom, yRoom, x, y, __parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), __parent.getView().getPixelLength());
            this.__parent = __parent;
            const planScale: number = __parent.getScale();
            const margin: number = PlanController.PIXEL_MARGIN / planScale;
            let deltaXToClosestObject: number = Infinity;
            let deltaYToClosestObject: number = Infinity;
            let xClosestObject: number = 0;
            let yClosestObject: number = 0;
            {
                let array = __parent.getDetectableRoomsAtSelectedLevel();
                for (let index = 0; index < array.length; index++) {
                    let room = array[index];
                    {
                        const roomPoints: number[][] = room.getPoints();
                        for (let i: number = 0; i < roomPoints.length; i++) {
                            {
                                if (editedPointIndex === -1 || (i !== editedPointIndex && roomPoints.length > 2)) {
                                    if (Math.abs(this.getX() - roomPoints[i][0]) < margin && Math.abs(deltaYToClosestObject) > Math.abs(this.getY() - roomPoints[i][1])) {
                                        xClosestObject = roomPoints[i][0];
                                        deltaYToClosestObject = this.getY() - roomPoints[i][1];
                                    }
                                    if (Math.abs(this.getY() - roomPoints[i][1]) < margin && Math.abs(deltaXToClosestObject) > Math.abs(this.getX() - roomPoints[i][0])) {
                                        yClosestObject = roomPoints[i][1];
                                        deltaXToClosestObject = this.getX() - roomPoints[i][0];
                                    }
                                }
                            };
                        }
                    }
                }
            }
            {
                let array = __parent.getDetectableWallsAtSelectedLevel();
                for (let index = 0; index < array.length; index++) {
                    let wall = array[index];
                    {
                        let wallPoints: number[][] = wall.getPoints$();
                        wallPoints = [wallPoints[0], wallPoints[(wallPoints.length / 2 | 0) - 1], wallPoints[(wallPoints.length / 2 | 0)], wallPoints[wallPoints.length - 1]];
                        for (let i: number = 0; i < wallPoints.length; i++) {
                            {
                                if (Math.abs(this.getX() - wallPoints[i][0]) < margin && Math.abs(deltaYToClosestObject) > Math.abs(this.getY() - wallPoints[i][1])) {
                                    xClosestObject = wallPoints[i][0];
                                    deltaYToClosestObject = this.getY() - wallPoints[i][1];
                                }
                                if (Math.abs(this.getY() - wallPoints[i][1]) < margin && Math.abs(deltaXToClosestObject) > Math.abs(this.getX() - wallPoints[i][0])) {
                                    yClosestObject = wallPoints[i][1];
                                    deltaXToClosestObject = this.getX() - wallPoints[i][0];
                                }
                            };
                        }
                    }
                }
            }
            if (editedRoom != null) {
                const alpha: number = -Math.tan(this.getAngle());
                const beta: number = Math.abs(alpha) < 1.0E10 ? yRoom - alpha * xRoom : Infinity;
                if (deltaXToClosestObject !== Infinity && Math.abs(alpha) > 1.0E-10) {
                    const newX: number = <number>((yClosestObject - beta) / alpha);
                    if (java.awt.geom.Point2D.distanceSq(this.getX(), this.getY(), newX, yClosestObject) <= margin * margin) {
                        this.setX(newX);
                        this.setY(yClosestObject);
                        return;
                    }
                }
                if (deltaYToClosestObject !== Infinity && beta !== Infinity) {
                    const newY: number = <number>(alpha * xClosestObject + beta);
                    if (java.awt.geom.Point2D.distanceSq(this.getX(), this.getY(), xClosestObject, newY) <= margin * margin) {
                        this.setX(xClosestObject);
                        this.setY(newY);
                    }
                }
            } else {
                if (deltaXToClosestObject !== Infinity) {
                    this.setY(yClosestObject);
                }
                if (deltaYToClosestObject !== Infinity) {
                    this.setX(xClosestObject);
                }
            }
        }
    }
    RoomPointWithAngleMagnetism["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomPointWithAngleMagnetism";


    /**
     * A decorator on controller state, useful to change the behavior of an existing state.
     * @param {PlanController.ControllerState} state
     * @class
     * @extends PlanController.ControllerState
     */
    export abstract class ControllerStateDecorator extends PlanController.ControllerState {
        state: PlanController.ControllerState;

        public constructor(state: PlanController.ControllerState) {
            super();
            if (this.state === undefined) { this.state = null; }
            this.state = state;
        }

        /**
         * 
         */
        public enter() {
            this.state.enter();
        }

        /**
         * 
         */
        public exit() {
            this.state.exit();
        }

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return this.state.getMode();
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            this.state.setMode(mode);
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return this.state.isModificationState();
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.state.isBasePlanModificationState();
        }

        /**
         * 
         */
        public deleteSelection() {
            this.state.deleteSelection();
        }

        /**
         * 
         */
        public escape() {
            this.state.escape();
        }

        /**
         * 
         * @param {number} dx
         * @param {number} dy
         */
        public moveSelection(dx: number, dy: number) {
            this.state.moveSelection(dx, dy);
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.state.toggleMagnetism(magnetismToggled);
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.state.setAlignmentActivated(alignmentActivated);
        }

        /**
         * 
         * @param {boolean} duplicationActivated
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            this.state.setDuplicationActivated(duplicationActivated);
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            this.state.setEditionActivated(editionActivated);
        }

        /**
         * 
         * @param {string} editableField
         * @param {Object} value
         */
        public updateEditableProperty(editableField: any, value: any) {
            this.state.updateEditableProperty(editableField, value);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            this.state.pressMouse(x, y, clickCount, shiftDown, duplicationActivated);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.state.releaseMouse(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            this.state.moveMouse(x, y);
        }

        /**
         * 
         * @param {number} factor
         */
        public zoom(factor: number) {
            this.state.zoom(factor);
        }
    }
    ControllerStateDecorator["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.ControllerStateDecorator";


    /**
     * Abstract state able to manage the transition to other modes.
     * @extends PlanController.ControllerState
     * @class
     */
    export abstract class AbstractModeChangeState extends PlanController.ControllerState {
        public __parent: any;
        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.PANNING_$LI$()) {
                this.__parent.setState(this.__parent.getPanningState());
            } else if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getWallCreationState());
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getRoomCreationState());
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public deleteSelection() {
            this.__parent.deleteItems(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems());
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {number} dx
         * @param {number} dy
         */
        public moveSelection(dx: number, dy: number) {
            this.__parent.moveAndShowSelectedItems(dx, dy);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {number} factor
         */
        public zoom(factor: number) {
            this.__parent.setScale(this.__parent.getScale() * factor);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
        }
    }
    AbstractModeChangeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.AbstractModeChangeState";


    /**
     * Move selection state. This state manages the move of current selected items
     * with mouse and the selection of one item, if mouse isn't moved while button
     * is depressed. If duplication is activated during the move of the mouse,
     * moved items are duplicated first.
     * @extends PlanController.ControllerState
     * @class
     */
    export class SelectionMoveState extends PlanController.ControllerState {
        public __parent: any;
        xLastMouseMove: number;

        yLastMouseMove: number;

        mouseMoved: boolean;

        oldSelection: Array<Selectable>;

        selectionUpdateNeeded: boolean;

        movedItems: Array<Selectable>;

        duplicatedItems: Array<Selectable>;

        movedPieceOfFurniture: HomePieceOfFurniture;

        angleMovedPieceOfFurniture: number;

        depthMovedPieceOfFurniture: number;

        elevationMovedPieceOfFurniture: number;

        xMovedPieceOfFurniture: number;

        yMovedPieceOfFurniture: number;

        movedDoorOrWindowBoundToWall: boolean;

        magnetismEnabled: boolean;

        duplicationActivated: boolean;

        alignmentActivated: boolean;

        basePlanModification: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.basePlanModification;
        }

        /**
         * 
         */
        public enter() {
            this.xLastMouseMove = this.__parent.getXLastMousePress();
            this.yLastMouseMove = this.__parent.getYLastMousePress();
            this.mouseMoved = false;
            const selectableItemsUnderCursor: Array<Selectable> = this.__parent.getSelectableItemsAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            const selectableItemsAndGroupsFurnitureUnderCursor: Array<Selectable> = <any>(selectableItemsUnderCursor.slice(0));
            const selectionMargin: number = this.__parent.getSelectionMargin();
            for (let index = 0; index < selectableItemsUnderCursor.length; index++) {
                let item = selectableItemsUnderCursor[index];
                {
                    if (item != null && item instanceof <any>HomeFurnitureGroup) {
                        {
                            let array = (<HomeFurnitureGroup><any>item).getAllFurniture();
                            for (let index1 = 0; index1 < array.length; index1++) {
                                let piece = array[index1];
                                {
                                    if (piece.containsPoint(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), selectionMargin)) {
                                        /* add */(selectableItemsAndGroupsFurnitureUnderCursor.push(piece) > 0);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.oldSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            this.selectionUpdateNeeded = /* disjoint */((c1, c2) => { for (let i = 0; i < c1.length; i++) { if (c2.indexOf(<any>c1[i]) >= 0) return false; } return true; })(selectableItemsAndGroupsFurnitureUnderCursor, this.oldSelection);
            if (this.selectionUpdateNeeded && this.__parent.getPointerTypeLastMousePress() !== View.PointerType.TOUCH) {
                this.__parent.selectItem(this.__parent.getSelectableItemAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), false));
            }
            const selectedItems: Array<Selectable> = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.movedItems = <any>([]);
            this.basePlanModification = false;
            for (let index = 0; index < selectedItems.length; index++) {
                let item = selectedItems[index];
                {
                    if (this.__parent.isItemMovable(item)) {
                        /* add */(this.movedItems.push(item) > 0);
                        if (!this.basePlanModification && this.__parent.isItemPartOfBasePlan(item)) {
                            this.basePlanModification = true;
                        }
                    }
                }
            }
            if (/* size */(<number>this.movedItems.length) === 1 && (/* get */this.movedItems[0] != null && /* get */this.movedItems[0] instanceof <any>HomePieceOfFurniture)) {
                this.movedPieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.movedItems[0];
                this.xMovedPieceOfFurniture = this.movedPieceOfFurniture.getX();
                this.yMovedPieceOfFurniture = this.movedPieceOfFurniture.getY();
                this.angleMovedPieceOfFurniture = this.movedPieceOfFurniture.getAngle();
                this.depthMovedPieceOfFurniture = this.movedPieceOfFurniture.getDepth();
                this.elevationMovedPieceOfFurniture = this.movedPieceOfFurniture.getElevation();
                this.movedDoorOrWindowBoundToWall = (this.movedPieceOfFurniture != null && this.movedPieceOfFurniture instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>this.movedPieceOfFurniture).isBoundToWall();
            }
            this.duplicatedItems = null;
            this.duplicationActivated = this.__parent.wasDuplicationActivatedLastMousePress() && !this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            if (!(this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH && this.selectionUpdateNeeded)) {
                this.__parent.getView().setCursor(PlanView.CursorType.MOVE);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH && this.selectionUpdateNeeded) {
                this.__parent.setState(new SelectionMoveState.SelectionMoveState$0(this, this.__parent.getPanningState()));
            } else {
                if (!this.mouseMoved) {
                    this.toggleDuplication(this.duplicationActivated);
                }
                if (this.alignmentActivated) {
                    const alignedPoint: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), this.__parent.getView().getPixelLength(), 4);
                    x = alignedPoint.getX();
                    y = alignedPoint.getY();
                }
                if (this.movedPieceOfFurniture != null) {
                    this.movedPieceOfFurniture.setX(this.xMovedPieceOfFurniture);
                    this.movedPieceOfFurniture.setY(this.yMovedPieceOfFurniture);
                    this.movedPieceOfFurniture.setAngle(this.angleMovedPieceOfFurniture);
                    if ((this.movedPieceOfFurniture != null && this.movedPieceOfFurniture instanceof <any>HomeDoorOrWindow) && this.movedPieceOfFurniture.isResizable() && this.__parent.isItemResizable(this.movedPieceOfFurniture)) {
                        this.movedPieceOfFurniture.setDepth(this.depthMovedPieceOfFurniture);
                    }
                    this.movedPieceOfFurniture.setElevation(this.elevationMovedPieceOfFurniture);
                    this.movedPieceOfFurniture.move(x - this.__parent.getXLastMousePress(), y - this.__parent.getYLastMousePress());
                    if (this.magnetismEnabled && !this.alignmentActivated) {
                        const elevationAdjusted: boolean = this.__parent.adjustPieceOfFurnitureElevation(this.movedPieceOfFurniture, true, 3.4028235E38) != null;
                        const magnetWall: Wall = this.__parent.adjustPieceOfFurnitureOnWallAt(this.movedPieceOfFurniture, x, y, false);
                        let referencePiece: HomePieceOfFurniture = null;
                        if (!elevationAdjusted) {
                            referencePiece = this.__parent.adjustPieceOfFurnitureSideBySideAt(this.movedPieceOfFurniture, false, magnetWall);
                        }
                        if (referencePiece == null) {
                            this.__parent.adjustPieceOfFurnitureInShelfBox(this.movedPieceOfFurniture, false);
                        }
                        if (this.__parent.feedbackDisplayed && magnetWall != null) {
                            this.__parent.getView().setDimensionLinesFeedback(this.__parent.getDimensionLinesAlongWall(this.movedPieceOfFurniture, magnetWall));
                        } else {
                            this.__parent.getView().setDimensionLinesFeedback(null);
                        }
                    }
                } else {
                    this.__parent.moveItems(this.movedItems, x - this.xLastMouseMove, y - this.yLastMouseMove);
                }
                if (!this.mouseMoved) {
                    this.__parent.selectItems(this.movedItems, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
                }
                this.__parent.getView().makePointVisible(x, y);
                this.xLastMouseMove = x;
                this.yLastMouseMove = y;
                this.mouseMoved = true;
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            if (this.mouseMoved) {
                if (/* size */(<number>this.movedItems.length) > 0 && !(/* get */this.movedItems[0] != null && /* get */this.movedItems[0] instanceof <any>Camera)) {
                    if (this.duplicatedItems != null) {
                        this.__parent.postItemsDuplication(this.movedItems, this.duplicatedItems);
                    } else if (this.movedPieceOfFurniture != null) {
                        this.__parent.postPieceOfFurnitureMove(this.movedPieceOfFurniture, this.movedPieceOfFurniture.getX() - this.xMovedPieceOfFurniture, this.movedPieceOfFurniture.getY() - this.yMovedPieceOfFurniture, this.angleMovedPieceOfFurniture, this.depthMovedPieceOfFurniture, this.elevationMovedPieceOfFurniture, this.movedDoorOrWindowBoundToWall);
                    } else {
                        this.__parent.postItemsMove(this.movedItems, this.oldSelection, this.xLastMouseMove - this.__parent.getXLastMousePress(), this.yLastMouseMove - this.__parent.getYLastMousePress());
                    }
                }
            } else {
                if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH || !/* disjoint */((c1, c2) => { for (let i = 0; i < c1.length; i++) { if (c2.indexOf(<any>c1[i]) >= 0) return false; } return true; })(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems(), this.oldSelection)) {
                    const itemUnderCursor: Selectable = this.__parent.getSelectableItemAt(x, y, false);
                    if (itemUnderCursor != null) {
                        this.__parent.selectItem(itemUnderCursor);
                    } else {
                        this.__parent.deselectAll();
                    }
                }
            }
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.movedPieceOfFurniture != null) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                if (!this.magnetismEnabled) {
                    this.__parent.getView().deleteFeedback();
                }
            }
        }

        /**
         * 
         */
        public escape() {
            if (this.mouseMoved) {
                if (this.duplicatedItems != null) {
                    this.__parent.doDeleteItems(this.movedItems);
                    this.__parent.selectItems(this.duplicatedItems);
                } else {
                    if (this.movedPieceOfFurniture != null) {
                        this.movedPieceOfFurniture.setX(this.xMovedPieceOfFurniture);
                        this.movedPieceOfFurniture.setY(this.yMovedPieceOfFurniture);
                        this.movedPieceOfFurniture.setAngle(this.angleMovedPieceOfFurniture);
                        if ((this.movedPieceOfFurniture != null && this.movedPieceOfFurniture instanceof <any>HomeDoorOrWindow) && this.movedPieceOfFurniture.isResizable() && this.__parent.isItemResizable(this.movedPieceOfFurniture)) {
                            this.movedPieceOfFurniture.setDepth(this.depthMovedPieceOfFurniture);
                        }
                        this.movedPieceOfFurniture.setElevation(this.elevationMovedPieceOfFurniture);
                        if (this.movedPieceOfFurniture != null && this.movedPieceOfFurniture instanceof <any>HomeDoorOrWindow) {
                            (<HomeDoorOrWindow>this.movedPieceOfFurniture).setBoundToWall(this.movedDoorOrWindowBoundToWall);
                        }
                    } else {
                        this.__parent.moveItems(this.movedItems, this.__parent.getXLastMousePress() - this.xLastMouseMove, this.__parent.getYLastMousePress() - this.yLastMouseMove);
                    }
                }
            }
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} duplicationActivated
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            duplicationActivated = !this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection() && duplicationActivated;
            if (this.mouseMoved) {
                this.toggleDuplication(duplicationActivated);
            }
            this.duplicationActivated = duplicationActivated;
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH && this.selectionUpdateNeeded && !this.duplicationActivated) {
                this.__parent.setState(this.__parent.getSelectionState());
                this.__parent.pressMouse$float$float$int$boolean$boolean$boolean$boolean$com_eteks_sweethome3d_viewcontroller_View_PointerType(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), 1, true, false, false, false, this.__parent.getPointerTypeLastMousePress());
            } else {
                this.alignmentActivated = alignmentActivated;
                if (this.mouseMoved) {
                    this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                }
                if (this.alignmentActivated) {
                    this.__parent.getView().deleteFeedback();
                }
            }
        }

        toggleDuplication(duplicationActivated: boolean) {
            if (/* size */(<number>this.movedItems.length) > 1 || (/* size */(<number>this.movedItems.length) === 1 && !(/* get */this.movedItems[0] != null && /* get */this.movedItems[0] instanceof <any>Camera) && !(/* get */this.movedItems[0] != null && /* get */this.movedItems[0] instanceof <any>Compass))) {
                if (duplicationActivated && this.duplicatedItems == null) {
                    this.duplicatedItems = this.movedItems;
                    this.movedItems = <any>([]);
                    {
                        let array = Home.duplicate(this.duplicatedItems);
                        for (let index = 0; index < array.length; index++) {
                            let item = array[index];
                            {
                                if (item != null && item instanceof <any>Wall) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addWall(<Wall><any>item);
                                } else if (item != null && item instanceof <any>Room) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addRoom$com_eteks_sweethome3d_model_Room(<Room><any>item);
                                } else if (item != null && item instanceof <any>Polyline) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPolyline$com_eteks_sweethome3d_model_Polyline(<Polyline><any>item);
                                } else if (item != null && item instanceof <any>DimensionLine) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addDimensionLine(<DimensionLine><any>item);
                                } else if (item != null && item instanceof <any>HomePieceOfFurniture) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addPieceOfFurniture$com_eteks_sweethome3d_model_HomePieceOfFurniture(<HomePieceOfFurniture><any>item);
                                } else if (item != null && item instanceof <any>Label) {
                                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addLabel(<Label><any>item);
                                } else {
                                    continue;
                                }
                                /* add */(this.movedItems.push(item) > 0);
                            }
                        }
                    }
                    if (this.movedPieceOfFurniture != null) {
                        this.movedPieceOfFurniture.setX(this.xMovedPieceOfFurniture);
                        this.movedPieceOfFurniture.setY(this.yMovedPieceOfFurniture);
                        this.movedPieceOfFurniture.setAngle(this.angleMovedPieceOfFurniture);
                        if ((this.movedPieceOfFurniture != null && this.movedPieceOfFurniture instanceof <any>HomeDoorOrWindow) && this.movedPieceOfFurniture.isResizable() && this.__parent.isItemResizable(this.movedPieceOfFurniture)) {
                            this.movedPieceOfFurniture.setDepth(this.depthMovedPieceOfFurniture);
                        }
                        this.movedPieceOfFurniture.setElevation(this.elevationMovedPieceOfFurniture);
                        this.movedPieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.movedItems[0];
                    } else {
                        this.__parent.moveItems(this.duplicatedItems, this.__parent.getXLastMousePress() - this.xLastMouseMove, this.__parent.getYLastMousePress() - this.yLastMouseMove);
                    }
                    this.__parent.getView().setCursor(PlanView.CursorType.DUPLICATION);
                } else if (!duplicationActivated && this.duplicatedItems != null) {
                    this.__parent.doDeleteItems(this.movedItems);
                    this.__parent.moveItems(this.duplicatedItems, this.xLastMouseMove - this.__parent.getXLastMousePress(), this.yLastMouseMove - this.__parent.getYLastMousePress());
                    this.movedItems = this.duplicatedItems;
                    this.duplicatedItems = null;
                    if (this.movedPieceOfFurniture != null) {
                        this.movedPieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.movedItems[0];
                    }
                    this.__parent.getView().setCursor(PlanView.CursorType.MOVE);
                }
                this.__parent.selectItems(this.movedItems, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
            }
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
            this.movedItems = null;
            this.duplicatedItems = null;
            this.movedPieceOfFurniture = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.mouseMoved === undefined) { this.mouseMoved = false; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.selectionUpdateNeeded === undefined) { this.selectionUpdateNeeded = false; }
            if (this.movedItems === undefined) { this.movedItems = null; }
            if (this.duplicatedItems === undefined) { this.duplicatedItems = null; }
            if (this.movedPieceOfFurniture === undefined) { this.movedPieceOfFurniture = null; }
            if (this.angleMovedPieceOfFurniture === undefined) { this.angleMovedPieceOfFurniture = 0; }
            if (this.depthMovedPieceOfFurniture === undefined) { this.depthMovedPieceOfFurniture = 0; }
            if (this.elevationMovedPieceOfFurniture === undefined) { this.elevationMovedPieceOfFurniture = 0; }
            if (this.xMovedPieceOfFurniture === undefined) { this.xMovedPieceOfFurniture = 0; }
            if (this.yMovedPieceOfFurniture === undefined) { this.yMovedPieceOfFurniture = 0; }
            if (this.movedDoorOrWindowBoundToWall === undefined) { this.movedDoorOrWindowBoundToWall = false; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.duplicationActivated === undefined) { this.duplicationActivated = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.basePlanModification === undefined) { this.basePlanModification = false; }
        }
    }
    SelectionMoveState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.SelectionMoveState";


    export namespace SelectionMoveState {

        export class SelectionMoveState$0 extends PlanController.ControllerStateDecorator {
            public __parent: any;
            /**
             * 
             */
            public enter() {
                super.enter();
                this.pressMouse(this.__parent.__parent.getXLastMousePress(), this.__parent.__parent.getYLastMousePress(), 1, this.__parent.__parent.wasShiftDownLastMousePress(), this.__parent.__parent.wasDuplicationActivatedLastMousePress());
                this.moveMouse(this.__parent.__parent.getXLastMouseMove(), this.__parent.__parent.getYLastMouseMove());
            }

            /**
             * 
             * @param {number} x
             * @param {number} y
             */
            public releaseMouse(x: number, y: number) {
                this.escape();
            }

            /**
             * 
             */
            public escape() {
                super.escape();
                this.__parent.__parent.setState(this.__parent.__parent.getSelectionState());
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }

    }


    /**
     * Selection with rectangle state. This state manages selection when mouse
     * press is done outside of an item or when mouse press is done with shift key
     * down.
     * @extends PlanController.ControllerState
     * @class
     */
    export class RectangleSelectionState extends PlanController.ControllerState {
        public __parent: any;
        selectedItemsMousePressed: Array<Selectable>;

        ignoreRectangleSelection: boolean;

        mouseMoved: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            const itemUnderCursor: Selectable = this.__parent.getSelectableItemAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            if (itemUnderCursor == null && !this.__parent.wasShiftDownLastMousePress()) {
                this.__parent.deselectAll();
            }
            this.selectedItemsMousePressed = <any>(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems().slice(0));
            const furniture: Array<HomePieceOfFurniture> = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getFurniture();
            this.ignoreRectangleSelection = false;
            for (let index = 0; index < this.selectedItemsMousePressed.length; index++) {
                let item = this.selectedItemsMousePressed[index];
                {
                    if ((item != null && item instanceof <any>HomePieceOfFurniture) && !/* contains */(furniture.indexOf(<any>(item)) >= 0)) {
                        this.ignoreRectangleSelection = true;
                        break;
                    }
                }
            }
            this.mouseMoved = false;
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            this.mouseMoved = true;
            if (!this.ignoreRectangleSelection) {
                this.updateSelectedItems(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y, this.selectedItemsMousePressed);
                if (this.__parent.feedbackDisplayed) {
                    const planView: PlanView = this.__parent.getView();
                    planView.setRectangleFeedback(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y);
                }
                this.__parent.planView.makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            if (!this.mouseMoved) {
                const itemUnderCursor: Selectable = this.__parent.getSelectableItemAt(x, y, false);
                if (itemUnderCursor != null) {
                    if (/* contains */(this.selectedItemsMousePressed.indexOf(<any>(itemUnderCursor)) >= 0)) {
                        /* remove */(a => { let index = a.indexOf(itemUnderCursor); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.selectedItemsMousePressed);
                    } else {
                        for (let i: number = /* size */(<number>this.selectedItemsMousePressed.length) - 1; i >= 0; i--) {
                            {
                                const item: Selectable = /* get */this.selectedItemsMousePressed[i];
                                if ((item != null && item instanceof <any>Camera) || ((itemUnderCursor != null && itemUnderCursor instanceof <any>HomePieceOfFurniture) && (item != null && item instanceof <any>HomeFurnitureGroup) && /* contains */((<HomeFurnitureGroup><any>item).getAllFurniture().indexOf(<any>(itemUnderCursor)) >= 0)) || ((itemUnderCursor != null && itemUnderCursor instanceof <any>HomeFurnitureGroup) && (item != null && item instanceof <any>HomePieceOfFurniture) && /* contains */((<HomeFurnitureGroup><any>itemUnderCursor).getAllFurniture().indexOf(<any>(item)) >= 0))) {
                                /* remove */this.selectedItemsMousePressed.splice(i, 1)[0];
                                }
                            };
                        }
                        if (!(itemUnderCursor != null && itemUnderCursor instanceof <any>Camera) || /* size */(<number>this.selectedItemsMousePressed.length) === 0) {
                            /* add */(this.selectedItemsMousePressed.push(itemUnderCursor) > 0);
                        }
                    }
                    this.__parent.selectItems(this.selectedItemsMousePressed, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection() && this.__parent.wasShiftDownLastMousePress());
                }
            }
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
            this.selectedItemsMousePressed = null;
        }

        /**
         * Updates selection from <code>selectedItemsMousePressed</code> and the
         * items that intersects the rectangle at coordinates (<code>x0</code>,
         * <code>y0</code>) and (<code>x1</code>, <code>y1</code>).
         * @param {number} x0
         * @param {number} y0
         * @param {number} x1
         * @param {number} y1
         * @param {*[]} selectedItemsMousePressed
         * @private
         */
        updateSelectedItems(x0: number, y0: number, x1: number, y1: number, selectedItemsMousePressed: Array<Selectable>) {
            let selectedItems: Array<Selectable>;
            const shiftDown: boolean = this.__parent.wasShiftDownLastMousePress();
            if (shiftDown) {
                selectedItems = <any>(selectedItemsMousePressed.slice(0));
            } else {
                selectedItems = <any>([]);
            }
            {
                let array = this.__parent.getSelectableItemsIntersectingRectangle(x0, y0, x1, y1);
                for (let index = 0; index < array.length; index++) {
                    let item = array[index];
                    {
                        if (!(item != null && item instanceof <any>Camera)) {
                            if (shiftDown) {
                                if (/* contains */(selectedItemsMousePressed.indexOf(<any>(item)) >= 0)) {
                                    /* remove */(a => { let index = a.indexOf(item); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems);
                                } else {
                                    /* add */(selectedItems.push(item) > 0);
                                }
                            } else if (!/* contains */(selectedItemsMousePressed.indexOf(<any>(item)) >= 0)) {
                                /* add */(selectedItems.push(item) > 0);
                            }
                        }
                    }
                }
            }
            this.__parent.selectItems(selectedItems, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection() && shiftDown);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedItemsMousePressed === undefined) { this.selectedItemsMousePressed = null; }
            if (this.ignoreRectangleSelection === undefined) { this.ignoreRectangleSelection = false; }
            if (this.mouseMoved === undefined) { this.mouseMoved = false; }
        }
    }
    RectangleSelectionState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RectangleSelectionState";


    /**
     * Panning state.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PanningState extends PlanController.ControllerState {
        public __parent: any;
        xLastMouseMove: number;

        yLastMouseMove: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.PANNING_$LI$();
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getWallCreationState());
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getRoomCreationState());
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.PANNING);
        }

        /**
         * 
         * @param {number} dx
         * @param {number} dy
         */
        public moveSelection(dx: number, dy: number) {
            this.__parent.getView().moveView(dx * 10, dy * 10);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 1) {
                this.xLastMouseMove = this.__parent.getView().convertXModelToScreen(x);
                this.yLastMouseMove = this.__parent.getView().convertYModelToScreen(y);
            } else {
                this.xLastMouseMove = null;
                this.yLastMouseMove = null;
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.xLastMouseMove != null) {
                const newX: number = this.__parent.getView().convertXModelToScreen(x);
                const newY: number = this.__parent.getView().convertYModelToScreen(y);
                this.__parent.getView().moveView((this.xLastMouseMove - newX) / this.__parent.getScale(), (this.yLastMouseMove - newY) / this.__parent.getScale());
                this.xLastMouseMove = newX;
                this.yLastMouseMove = newY;
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.xLastMouseMove = null;
        }

        /**
         * 
         */
        public escape() {
            this.xLastMouseMove = null;
        }

        /**
         * 
         * @param {number} factor
         */
        public zoom(factor: number) {
            this.__parent.setScale(this.__parent.getScale() * factor);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = null; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = null; }
        }
    }
    PanningState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PanningState";


    /**
     * Drag and drop state. This state manages the dragging of items
     * transfered from outside of plan view with the mouse.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DragAndDropState extends PlanController.ControllerState {
        public __parent: any;
        xLastMouseMove: number;

        yLastMouseMove: number;

        draggedPieceOfFurniture: HomePieceOfFurniture;

        xDraggedPieceOfFurniture: number;

        yDraggedPieceOfFurniture: number;

        angleDraggedPieceOfFurniture: number;

        depthDraggedPieceOfFurniture: number;

        elevationDraggedPieceOfFurniture: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.draggedPieceOfFurniture != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.draggedPieceOfFurniture);
        }

        /**
         * 
         */
        public enter() {
            this.xLastMouseMove = 0;
            this.yLastMouseMove = 0;
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setDraggedItemsFeedback(this.__parent.draggedItems);
            }
            if (/* size */(<number>this.__parent.draggedItems.length) === 1 && (/* get */this.__parent.draggedItems[0] != null && /* get */this.__parent.draggedItems[0] instanceof <any>HomePieceOfFurniture)) {
                this.draggedPieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.__parent.draggedItems[0];
                this.xDraggedPieceOfFurniture = this.draggedPieceOfFurniture.getX();
                this.yDraggedPieceOfFurniture = this.draggedPieceOfFurniture.getY();
                this.angleDraggedPieceOfFurniture = this.draggedPieceOfFurniture.getAngle();
                this.depthDraggedPieceOfFurniture = this.draggedPieceOfFurniture.getDepth();
                this.elevationDraggedPieceOfFurniture = this.draggedPieceOfFurniture.getElevation();
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const draggedItemsFeedback: Array<Selectable> = <any>(this.__parent.draggedItems.slice(0));
            this.__parent.moveItems(this.__parent.draggedItems, x - this.xLastMouseMove, y - this.yLastMouseMove);
            if (this.draggedPieceOfFurniture != null && this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) {
                this.draggedPieceOfFurniture.setX(this.xDraggedPieceOfFurniture);
                this.draggedPieceOfFurniture.setY(this.yDraggedPieceOfFurniture);
                this.draggedPieceOfFurniture.setAngle(this.angleDraggedPieceOfFurniture);
                if (this.draggedPieceOfFurniture.isResizable()) {
                    this.draggedPieceOfFurniture.setDepth(this.depthDraggedPieceOfFurniture);
                    this.draggedPieceOfFurniture.setDepthInPlan(this.depthDraggedPieceOfFurniture);
                }
                this.draggedPieceOfFurniture.setElevation(this.elevationDraggedPieceOfFurniture);
                this.draggedPieceOfFurniture.move(x, y);
                const elevationAdjusted: boolean = this.__parent.adjustPieceOfFurnitureElevation(this.draggedPieceOfFurniture, false, 3.4028235E38) != null;
                const magnetWall: Wall = this.__parent.adjustPieceOfFurnitureOnWallAt(this.draggedPieceOfFurniture, x, y, true);
                let referencePiece: HomePieceOfFurniture = null;
                if (!elevationAdjusted) {
                    referencePiece = this.__parent.adjustPieceOfFurnitureSideBySideAt(this.draggedPieceOfFurniture, magnetWall == null, magnetWall);
                }
                if (referencePiece == null) {
                    this.__parent.adjustPieceOfFurnitureInShelfBox(this.draggedPieceOfFurniture, magnetWall == null);
                }
                if (this.__parent.feedbackDisplayed && magnetWall != null) {
                    this.__parent.getView().setDimensionLinesFeedback(this.__parent.getDimensionLinesAlongWall(this.draggedPieceOfFurniture, magnetWall));
                } else {
                    this.__parent.getView().setDimensionLinesFeedback(null);
                }
            }
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setDraggedItemsFeedback(draggedItemsFeedback);
            }
            this.xLastMouseMove = x;
            this.yLastMouseMove = y;
        }

        /**
         * 
         */
        public exit() {
            this.draggedPieceOfFurniture = null;
            this.__parent.getView().deleteFeedback();
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.draggedPieceOfFurniture === undefined) { this.draggedPieceOfFurniture = null; }
            if (this.xDraggedPieceOfFurniture === undefined) { this.xDraggedPieceOfFurniture = 0; }
            if (this.yDraggedPieceOfFurniture === undefined) { this.yDraggedPieceOfFurniture = 0; }
            if (this.angleDraggedPieceOfFurniture === undefined) { this.angleDraggedPieceOfFurniture = 0; }
            if (this.depthDraggedPieceOfFurniture === undefined) { this.depthDraggedPieceOfFurniture = 0; }
            if (this.elevationDraggedPieceOfFurniture === undefined) { this.elevationDraggedPieceOfFurniture = 0; }
        }
    }
    DragAndDropState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DragAndDropState";


    /**
     * Wall modification state.
     * @extends PlanController.ControllerState
     * @class
     */
    export abstract class AbstractWallState extends PlanController.ControllerState {
        public __parent: any;
        wallLengthToolTipFeedback: string;

        wallAngleToolTipFeedback: string;

        wallArcExtentToolTipFeedback: string;

        wallThicknessToolTipFeedback: string;

        /**
         * 
         */
        public enter() {
            this.wallLengthToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "wallLengthToolTipFeedback");
            try {
                this.wallAngleToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "wallAngleToolTipFeedback");
            } catch (ex) {
            }
            this.wallArcExtentToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "wallArcExtentToolTipFeedback");
            try {
                this.wallThicknessToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "wallThicknessToolTipFeedback");
            } catch (ex) {
            }
        }

        getToolTipFeedbackText(wall: Wall, ignoreArcExtent: boolean): string {
            const arcExtent: number = wall.getArcExtent();
            if (!ignoreArcExtent && arcExtent != null) {
                return "<html>" + CoreTools.format(this.wallArcExtentToolTipFeedback, Math.round(/* toDegrees */(x => x * 180 / Math.PI)(arcExtent)));
            } else {
                const startPointToEndPointDistance: number = wall.getStartPointToEndPointDistance();
                let toolTipFeedbackText: string = "<html>" + CoreTools.format(this.wallLengthToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(startPointToEndPointDistance));
                if (this.wallAngleToolTipFeedback != null && this.wallAngleToolTipFeedback.length > 0) {
                    toolTipFeedbackText += "<br>" + CoreTools.format(this.wallAngleToolTipFeedback, this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall$float(wall, startPointToEndPointDistance));
                }
                if (this.wallThicknessToolTipFeedback != null && this.wallThicknessToolTipFeedback.length > 0) {
                    toolTipFeedbackText += "<br>" + CoreTools.format(this.wallThicknessToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(wall.getThickness()));
                }
                return toolTipFeedbackText;
            }
        }

        getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall(wall: Wall): number {
            return this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall$float(wall, wall.getStartPointToEndPointDistance());
        }

        public getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall$float(wall: Wall, startPointToEndPointDistance: number): number {
            const wallAtStart: Wall = wall.getWallAtStart();
            if (wallAtStart != null) {
                const wallAtStartSegmentDistance: number = wallAtStart.getStartPointToEndPointDistance();
                if (startPointToEndPointDistance !== 0 && wallAtStartSegmentDistance !== 0) {
                    const xWallVector: number = (wall.getXEnd() - wall.getXStart()) / startPointToEndPointDistance;
                    const yWallVector: number = (wall.getYEnd() - wall.getYStart()) / startPointToEndPointDistance;
                    let xWallAtStartVector: number = (wallAtStart.getXEnd() - wallAtStart.getXStart()) / wallAtStartSegmentDistance;
                    let yWallAtStartVector: number = (wallAtStart.getYEnd() - wallAtStart.getYStart()) / wallAtStartSegmentDistance;
                    if (wallAtStart.getWallAtStart() === wall) {
                        xWallAtStartVector = -xWallAtStartVector;
                        yWallAtStartVector = -yWallAtStartVector;
                    }
                    let wallAngle: number = (<number>Math.round(180 - /* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(yWallVector * xWallAtStartVector - xWallVector * yWallAtStartVector, xWallVector * xWallAtStartVector + yWallVector * yWallAtStartVector))) | 0);
                    if (wallAngle > 180) {
                        wallAngle -= 360;
                    }
                    return wallAngle;
                }
            }
            if (startPointToEndPointDistance === 0) {
                return 0;
            } else {
                return (<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(wall.getYStart() - wall.getYEnd(), wall.getXEnd() - wall.getXStart()))) | 0);
            }
        }

        public getWallAngleInDegrees(wall?: any, startPointToEndPointDistance?: any): number {
            if (((wall != null && wall instanceof <any>Wall) || wall === null) && ((typeof startPointToEndPointDistance === 'number') || startPointToEndPointDistance === null)) {
                return <any>this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall$float(wall, startPointToEndPointDistance);
            } else if (((wall != null && wall instanceof <any>Wall) || wall === null) && startPointToEndPointDistance === undefined) {
                return <any>this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall(wall);
            } else throw new Error('invalid overload');
        }

        /**
         * Returns arc extent from the circumscribed circle of the triangle
         * with vertices (x1, y1) (x2, y2) (x, y).
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        getArcExtent(x1: number, y1: number, x2: number, y2: number, x: number, y: number): number {
            const arcCenter: number[] = this.getCircumscribedCircleCenter(x1, y1, x2, y2, x, y);
            const startPointToBissectorLine1Distance: number = java.awt.geom.Point2D.distance(x1, y1, x2, y2) / 2;
            const arcCenterToWallDistance: number = /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(arcCenter[0]) || /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(arcCenter[1]) ? Infinity : java.awt.geom.Line2D.ptLineDist(x1, y1, x2, y2, arcCenter[0], arcCenter[1]);
            const mousePosition: number = java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, x, y);
            const centerPosition: number = java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, arcCenter[0], arcCenter[1]);
            let arcExtent: number;
            if (centerPosition === mousePosition) {
                arcExtent = <number>(Math.PI + 2 * Math.atan2(arcCenterToWallDistance, startPointToBissectorLine1Distance));
            } else {
                arcExtent = <number>(2 * Math.atan2(startPointToBissectorLine1Distance, arcCenterToWallDistance));
            }
            arcExtent = Math.min(arcExtent, 3 * <number>Math.PI / 2);
            arcExtent *= mousePosition;
            return arcExtent;
        }

        /**
         * Returns the circumscribed circle of the triangle with vertices (x1, y1) (x2, y2) (x, y).
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x
         * @param {number} y
         * @return {float[]}
         * @private
         */
        getCircumscribedCircleCenter(x1: number, y1: number, x2: number, y2: number, x: number, y: number): number[] {
            const bissectorLine1: number[][] = this.getBissectorLine(x1, y1, x2, y2);
            const bissectorLine2: number[][] = this.getBissectorLine(x1, y1, x, y);
            const arcCenter: number[] = PlanController.computeIntersection(bissectorLine1[0], bissectorLine1[1], bissectorLine2[0], bissectorLine2[1]);
            return arcCenter;
        }

        getBissectorLine(x1: number, y1: number, x2: number, y2: number): number[][] {
            const xMiddlePoint: number = (x1 + x2) / 2;
            const yMiddlePoint: number = (y1 + y2) / 2;
            const bissectorLineAlpha: number = (x1 - x2) / (y2 - y1);
            if (bissectorLineAlpha > 1.0E10) {
                return [[xMiddlePoint, yMiddlePoint], [xMiddlePoint, yMiddlePoint + 1]];
            } else {
                return [[xMiddlePoint, yMiddlePoint], [xMiddlePoint + 1, bissectorLineAlpha + yMiddlePoint]];
            }
        }

        showWallAngleFeedback(wall: Wall, ignoreArcExtent: boolean) {
            const arcExtent: number = wall.getArcExtent();
            if (!ignoreArcExtent && arcExtent != null) {
                if (arcExtent < 0) {
                    this.__parent.getView().setAngleFeedback(wall.getXArcCircleCenter(), wall.getYArcCircleCenter(), wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd());
                } else {
                    this.__parent.getView().setAngleFeedback(wall.getXArcCircleCenter(), wall.getYArcCircleCenter(), wall.getXEnd(), wall.getYEnd(), wall.getXStart(), wall.getYStart());
                }
            } else if (this.wallAngleToolTipFeedback != null && this.wallAngleToolTipFeedback.length > 0) {
                const wallAtStart: Wall = wall.getWallAtStart();
                if (wallAtStart != null) {
                    if (wallAtStart.getWallAtStart() === wall) {
                        if (this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall(wall) > 0) {
                            this.__parent.getView().setAngleFeedback(wall.getXStart(), wall.getYStart(), wallAtStart.getXEnd(), wallAtStart.getYEnd(), wall.getXEnd(), wall.getYEnd());
                        } else {
                            this.__parent.getView().setAngleFeedback(wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd(), wallAtStart.getXEnd(), wallAtStart.getYEnd());
                        }
                    } else {
                        if (this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall(wall) > 0) {
                            this.__parent.getView().setAngleFeedback(wall.getXStart(), wall.getYStart(), wallAtStart.getXStart(), wallAtStart.getYStart(), wall.getXEnd(), wall.getYEnd());
                        } else {
                            this.__parent.getView().setAngleFeedback(wall.getXStart(), wall.getYStart(), wall.getXEnd(), wall.getYEnd(), wallAtStart.getXStart(), wallAtStart.getYStart());
                        }
                    }
                }
            }
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.wallLengthToolTipFeedback === undefined) { this.wallLengthToolTipFeedback = null; }
            if (this.wallAngleToolTipFeedback === undefined) { this.wallAngleToolTipFeedback = null; }
            if (this.wallArcExtentToolTipFeedback === undefined) { this.wallArcExtentToolTipFeedback = null; }
            if (this.wallThicknessToolTipFeedback === undefined) { this.wallThicknessToolTipFeedback = null; }
        }
    }
    AbstractWallState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.AbstractWallState";


    /**
     * Furniture rotation state. This states manages the rotation of a piece of furniture around the vertical axis.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        selectedPiece: HomePieceOfFurniture;

        angleMousePress: number;

        oldAngle: number;

        doorOrWindowBoundToWall: boolean;

        rotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.selectedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.selectedPiece);
        }

        /**
         * 
         */
        public enter() {
            this.rotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "rotationToolTipFeedback");
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedPiece.getY() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedPiece.getX());
            this.oldAngle = this.selectedPiece.getAngle();
            this.doorOrWindowBoundToWall = (this.selectedPiece != null && this.selectedPiece instanceof <any>HomeDoorOrWindow) && (<HomeDoorOrWindow>this.selectedPiece).isBoundToWall();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldAngle), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedPiece.getX() || y !== this.selectedPiece.getY()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedPiece.getY() - y, x - this.selectedPiece.getX());
                let newAngle: number = this.oldAngle - angleMouseMove + this.angleMousePress;
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / PieceOfFurnitureRotationState.STEP_COUNT;
                    newAngle = Math.round(newAngle / angleStep) * angleStep;
                }
                this.selectedPiece.setAngle(newAngle);
                const planView: PlanView = this.__parent.getView();
                planView.makePointVisible(x, y);
                if (this.__parent.feedbackDisplayed) {
                    planView.setToolTipFeedback(this.getToolTipFeedbackText(newAngle), x, y);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureRotation(this.selectedPiece, this.oldAngle, this.doorOrWindowBoundToWall);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setAngle(this.oldAngle);
            if (this.selectedPiece != null && this.selectedPiece instanceof <any>HomeDoorOrWindow) {
                (<HomeDoorOrWindow>this.selectedPiece).setBoundToWall(this.doorOrWindowBoundToWall);
            }
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedPiece = null;
        }

        getToolTipFeedbackText(angle: number): string {
            return CoreTools.format(this.rotationToolTipFeedback, (Math.round(/* toDegrees */(x => x * 180 / Math.PI)(angle)) + 360) % 360);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.oldAngle === undefined) { this.oldAngle = 0; }
            if (this.doorOrWindowBoundToWall === undefined) { this.doorOrWindowBoundToWall = false; }
            if (this.rotationToolTipFeedback === undefined) { this.rotationToolTipFeedback = null; }
        }
    }
    PieceOfFurnitureRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureRotationState";


    /**
     * Furniture pitch rotation state. This states manages the rotation of a piece of furniture
     * around the horizontal pitch (transversal) axis.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurniturePitchRotationState extends PlanController.ControllerState {
        public __parent: any;
        selectedPiece: HomePieceOfFurniture;

        oldPitch: number;

        oldWidthInPlan: number;

        oldDepthInPlan: number;

        oldHeightInPlan: number;

        pitchRotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.selectedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.selectedPiece);
        }

        /**
         * 
         */
        public enter() {
            this.pitchRotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "pitchRotationToolTipFeedback");
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldPitch = this.selectedPiece.getPitch();
            this.oldWidthInPlan = this.selectedPiece.getWidthInPlan();
            this.oldDepthInPlan = this.selectedPiece.getDepthInPlan();
            this.oldHeightInPlan = this.selectedPiece.getHeightInPlan();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldPitch), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            let newPitch: number = <number>(this.oldPitch - (y - this.__parent.getYLastMousePress()) * Math.cos(this.selectedPiece.getAngle()) * Math.PI / 360 + (x - this.__parent.getXLastMousePress()) * Math.sin(this.selectedPiece.getAngle()) * Math.PI / 360);
            if (Math.abs(newPitch) < 1.0E-8) {
                newPitch = 0;
            }
            this.selectedPiece.setPitch(newPitch);
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(newPitch), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurniturePitchRotation(this.selectedPiece, this.oldPitch, this.oldWidthInPlan, this.oldDepthInPlan, this.oldHeightInPlan);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setPitch(this.oldPitch);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedPiece = null;
        }

        getToolTipFeedbackText(pitch: number): string {
            return CoreTools.format(this.pitchRotationToolTipFeedback, (Math.round(/* toDegrees */(x => x * 180 / Math.PI)(pitch)) + 360) % 360);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.oldPitch === undefined) { this.oldPitch = 0; }
            if (this.oldWidthInPlan === undefined) { this.oldWidthInPlan = 0; }
            if (this.oldDepthInPlan === undefined) { this.oldDepthInPlan = 0; }
            if (this.oldHeightInPlan === undefined) { this.oldHeightInPlan = 0; }
            if (this.pitchRotationToolTipFeedback === undefined) { this.pitchRotationToolTipFeedback = null; }
        }
    }
    PieceOfFurniturePitchRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurniturePitchRotationState";


    /**
     * Furniture roll rotation state. This states manages the rotation of a piece of furniture
     * around the horizontal roll axis.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureRollRotationState extends PlanController.ControllerState {
        public __parent: any;
        selectedPiece: HomePieceOfFurniture;

        oldRoll: number;

        oldWidthInPlan: number;

        oldDepthInPlan: number;

        oldHeightInPlan: number;

        rollRotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.selectedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.selectedPiece);
        }

        /**
         * 
         */
        public enter() {
            this.rollRotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "rollRotationToolTipFeedback");
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldRoll = this.selectedPiece.getRoll();
            this.oldWidthInPlan = this.selectedPiece.getWidthInPlan();
            this.oldDepthInPlan = this.selectedPiece.getDepthInPlan();
            this.oldHeightInPlan = this.selectedPiece.getHeightInPlan();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldRoll), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            let newRoll: number = <number>(this.oldRoll + (y - this.__parent.getYLastMousePress()) * Math.sin(this.selectedPiece.getAngle()) * Math.PI / 360 + (x - this.__parent.getXLastMousePress()) * Math.cos(this.selectedPiece.getAngle()) * Math.PI / 360);
            if (Math.abs(newRoll) < 1.0E-8) {
                newRoll = 0;
            }
            this.selectedPiece.setRoll(newRoll);
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(newRoll), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureRollRotation(this.selectedPiece, this.oldRoll, this.oldWidthInPlan, this.oldDepthInPlan, this.oldHeightInPlan);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setRoll(this.oldRoll);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedPiece = null;
        }

        getToolTipFeedbackText(roll: number): string {
            return CoreTools.format(this.rollRotationToolTipFeedback, (Math.round(/* toDegrees */(x => x * 180 / Math.PI)(roll)) + 360) % 360);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.oldRoll === undefined) { this.oldRoll = 0; }
            if (this.oldWidthInPlan === undefined) { this.oldWidthInPlan = 0; }
            if (this.oldDepthInPlan === undefined) { this.oldDepthInPlan = 0; }
            if (this.oldHeightInPlan === undefined) { this.oldHeightInPlan = 0; }
            if (this.rollRotationToolTipFeedback === undefined) { this.rollRotationToolTipFeedback = null; }
        }
    }
    PieceOfFurnitureRollRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureRollRotationState";


    /**
     * Furniture elevation state. This states manages the elevation change of a piece of furniture.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureElevationState extends PlanController.ControllerState {
        public __parent: any;
        magnetismEnabled: boolean;

        deltaYToElevationPoint: number;

        selectedPiece: HomePieceOfFurniture;

        oldElevation: number;

        elevationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.selectedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.selectedPiece);
        }

        /**
         * 
         */
        public enter() {
            this.elevationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "elevationToolTipFeedback");
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            const elevationPoint: number[] = this.selectedPiece.getPoints()[1];
            this.deltaYToElevationPoint = this.__parent.getYLastMousePress() - elevationPoint[1];
            this.oldElevation = this.selectedPiece.getElevation();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldElevation), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const topRightPoint: number[] = this.selectedPiece.getPoints()[1];
            const deltaY: number = y - this.deltaYToElevationPoint - topRightPoint[1];
            let newElevation: number = this.oldElevation - deltaY;
            newElevation = Math.min(Math.max(newElevation, 0.0), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumElevation());
            if (this.magnetismEnabled) {
                newElevation = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newElevation, planView.getPixelLength());
            }
            this.selectedPiece.setElevation(newElevation);
            if (this.magnetismEnabled && this.selectedPiece != null) {
                this.__parent.adjustPieceOfFurnitureElevation(this.selectedPiece, false, 3 * PlanController.PIXEL_MARGIN / this.__parent.getScale());
            }
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedPiece.getElevation()), x, y);
            }
            planView.makeSelectionVisible();
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureElevation(this.selectedPiece, this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setElevation(this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedPiece = null;
        }

        getToolTipFeedbackText(height: number): string {
            return CoreTools.format(this.elevationToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(height));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.deltaYToElevationPoint === undefined) { this.deltaYToElevationPoint = 0; }
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.elevationToolTipFeedback === undefined) { this.elevationToolTipFeedback = null; }
        }
    }
    PieceOfFurnitureElevationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureElevationState";


    /**
     * Furniture height state. This states manages the height resizing of a piece of furniture.
     * Caution: Do not use for furniture with a roll or pitch angle different from 0
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureHeightState extends PlanController.ControllerState {
        public __parent: any;
        magnetismEnabled: boolean;

        deltaYToResizePoint: number;

        resizedPiece: PlanController.ResizedPieceOfFurniture;

        topLeftPoint: number[];

        resizePoint: number[];

        resizeToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.resizedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.resizedPiece.getPieceOfFurniture());
        }

        /**
         * 
         */
        public enter() {
            this.resizeToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "heightResizeToolTipFeedback");
            const selectedPiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.resizedPiece = new PlanController.ResizedPieceOfFurniture(selectedPiece);
            const resizedPiecePoints: number[][] = selectedPiece.getPoints();
            this.resizePoint = resizedPiecePoints[3];
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - this.resizePoint[1];
            this.topLeftPoint = resizedPiecePoints[0];
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(selectedPiece.getHeight()), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const selectedPiece: HomePieceOfFurniture = this.resizedPiece.getPieceOfFurniture();
            const deltaY: number = y - this.deltaYToResizePoint - this.resizePoint[1];
            let newHeight: number = this.resizedPiece.getHeight() - deltaY;
            newHeight = Math.max(newHeight, 0.0);
            if (this.magnetismEnabled) {
                newHeight = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newHeight, planView.getPixelLength());
            }
            newHeight = Math.min(Math.max(newHeight, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength()), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength());
            if (selectedPiece.isDeformable() && !selectedPiece.isHorizontallyRotated() && selectedPiece.getModelTransformations() == null) {
                this.__parent.setPieceOfFurnitureSize(this.resizedPiece, this.resizedPiece.getWidth(), this.resizedPiece.getDepth(), newHeight);
            } else {
                const scale: number = newHeight / this.resizedPiece.getHeight();
                const newWidth: number = this.resizedPiece.getWidth() * scale;
                const newDepth: number = this.resizedPiece.getDepth() * scale;
                const angle: number = selectedPiece.getAngle();
                const cos: number = Math.cos(angle);
                const sin: number = Math.sin(angle);
                const newX: number = <number>(this.topLeftPoint[0] + (newWidth * cos - newDepth * sin) / 2.0);
                const newY: number = <number>(this.topLeftPoint[1] + (newWidth * sin + newDepth * cos) / 2.0);
                selectedPiece.setX(newX);
                selectedPiece.setY(newY);
                this.__parent.setPieceOfFurnitureSize(this.resizedPiece, newWidth, newDepth, newHeight);
            }
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newHeight), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureHeightResize(this.resizedPiece);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.__parent.resetPieceOfFurnitureSize(this.resizedPiece);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.resizedPiece = null;
        }

        getToolTipFeedbackText(height: number): string {
            return CoreTools.format(this.resizeToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(height));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.resizedPiece === undefined) { this.resizedPiece = null; }
            if (this.topLeftPoint === undefined) { this.topLeftPoint = null; }
            if (this.resizePoint === undefined) { this.resizePoint = null; }
            if (this.resizeToolTipFeedback === undefined) { this.resizeToolTipFeedback = null; }
        }
    }
    PieceOfFurnitureHeightState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureHeightState";


    /**
     * Furniture resize state. This states manages the resizing of a piece of furniture.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureResizeState extends PlanController.ControllerState {
        public __parent: any;
        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        widthOrDepthResizingActivated: boolean;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        resizedPiece: PlanController.ResizedPieceOfFurniture;

        resizedPieceWidthInPlan: number;

        resizePoint: number[];

        topLeftPoint: number[];

        widthResizeToolTipFeedback: string;

        depthResizeToolTipFeedback: string;

        heightResizeToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return this.resizedPiece != null && this.__parent.isPieceOfFurniturePartOfBasePlan(this.resizedPiece.getPieceOfFurniture());
        }

        /**
         * 
         */
        public enter() {
            this.widthResizeToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "widthResizeToolTipFeedback");
            this.depthResizeToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "depthResizeToolTipFeedback");
            this.heightResizeToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "heightResizeToolTipFeedback");
            const selectedPiece: HomePieceOfFurniture = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.resizedPiece = new PlanController.ResizedPieceOfFurniture(selectedPiece);
            this.resizedPieceWidthInPlan = selectedPiece.getWidthInPlan();
            const resizedPiecePoints: number[][] = selectedPiece.getPoints();
            this.resizePoint = resizedPiecePoints[2];
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - this.resizePoint[0];
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - this.resizePoint[1];
            this.topLeftPoint = resizedPiecePoints[0];
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.widthOrDepthResizingActivated = this.__parent.wasDuplicationActivatedLastMousePress();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(selectedPiece.getWidth(), selectedPiece.getDepth(), selectedPiece.getHeight()), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const selectedPiece: HomePieceOfFurniture = this.resizedPiece.getPieceOfFurniture();
            const angle: number = selectedPiece.getAngle();
            const cos: number = Math.cos(angle);
            const sin: number = Math.sin(angle);
            const deltaX: number = x - this.deltaXToResizePoint - this.topLeftPoint[0];
            const deltaY: number = y - this.deltaYToResizePoint - this.topLeftPoint[1];
            let newWidth: number = <number>(deltaY * sin + deltaX * cos);
            if (this.magnetismEnabled) {
                newWidth = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newWidth, planView.getPixelLength());
            }
            newWidth = Math.min(Math.max(newWidth, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength()), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength());
            let newDepth: number = this.resizedPiece.getDepth();
            let newHeight: number = this.resizedPiece.getHeight();
            let doorOrWindowBoundToWall: boolean = this.resizedPiece.isDoorOrWindowBoundToWall();
            if (this.isProprortionallyResized(selectedPiece)) {
                const scale: number = newWidth / this.resizedPieceWidthInPlan;
                newWidth = this.resizedPiece.getWidth() * scale;
                newDepth = this.resizedPiece.getDepth() * scale;
                newHeight = this.resizedPiece.getHeight() * scale;
                doorOrWindowBoundToWall = newDepth === this.resizedPiece.getDepth();
            } else if (!selectedPiece.isWidthDepthDeformable()) {
                newDepth = this.resizedPiece.getDepth() * newWidth / this.resizedPiece.getWidth();
            } else if (!this.resizedPiece.isDoorOrWindowBoundToWall() || !this.magnetismEnabled || this.widthOrDepthResizingActivated) {
                newDepth = <number>(deltaY * cos - deltaX * sin);
                if (this.magnetismEnabled) {
                    newDepth = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newDepth, planView.getPixelLength());
                }
                newDepth = Math.min(Math.max(newDepth, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength()), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength());
                doorOrWindowBoundToWall = newDepth === this.resizedPiece.getDepth();
                if (this.widthOrDepthResizingActivated) {
                    if (/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(java.awt.geom.Line2D.relativeCCW(this.topLeftPoint[0], this.topLeftPoint[1], this.resizePoint[0], this.resizePoint[1], x - this.deltaXToResizePoint, y - this.deltaYToResizePoint)) >= 0) {
                        newDepth = this.resizedPiece.getDepth();
                    } else {
                        newWidth = this.resizedPiece.getWidth();
                    }
                }
            }
            this.__parent.setPieceOfFurnitureSize(this.resizedPiece, newWidth, newDepth, newHeight);
            if (this.resizedPiece.isDoorOrWindowBoundToWall()) {
                (<HomeDoorOrWindow>selectedPiece).setBoundToWall(this.magnetismEnabled && doorOrWindowBoundToWall);
            }
            const newX: number = <number>(this.topLeftPoint[0] + (selectedPiece.getWidthInPlan() * cos - selectedPiece.getDepthInPlan() * sin) / 2.0);
            const newY: number = <number>(this.topLeftPoint[1] + (selectedPiece.getWidthInPlan() * sin + selectedPiece.getDepthInPlan() * cos) / 2.0);
            selectedPiece.setX(newX);
            selectedPiece.setY(newY);
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newWidth, newDepth, newHeight), x, y);
            }
        }

        /**
         * Returns <code>true</code> if the <code>piece</code> should be proportionally resized.
         * @param {HomePieceOfFurniture} piece
         * @return {boolean}
         * @private
         */
        isProprortionallyResized(piece: HomePieceOfFurniture): boolean {
            return !piece.isDeformable() || piece.isHorizontallyRotated() || piece.getModelTransformations() != null || this.alignmentActivated;
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureWidthAndDepthResize(this.resizedPiece);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} duplicationActivated
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            this.widthOrDepthResizingActivated = duplicationActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.__parent.resetPieceOfFurnitureSize(this.resizedPiece);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.resizedPiece = null;
        }

        getToolTipFeedbackText(width: number, depth: number, height: number): string {
            let toolTipFeedbackText: string = "<html>" + CoreTools.format(this.widthResizeToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(width));
            if (!(this.resizedPiece.getPieceOfFurniture() != null && this.resizedPiece.getPieceOfFurniture() instanceof <any>HomeDoorOrWindow) || !(<HomeDoorOrWindow>this.resizedPiece.getPieceOfFurniture()).isBoundToWall() || this.isProprortionallyResized(this.resizedPiece.getPieceOfFurniture())) {
                toolTipFeedbackText += "<br>" + CoreTools.format(this.depthResizeToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(depth));
            }
            if (this.isProprortionallyResized(this.resizedPiece.getPieceOfFurniture())) {
                toolTipFeedbackText += "<br>" + CoreTools.format(this.heightResizeToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(height));
            }
            return toolTipFeedbackText;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.widthOrDepthResizingActivated === undefined) { this.widthOrDepthResizingActivated = false; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.resizedPiece === undefined) { this.resizedPiece = null; }
            if (this.resizedPieceWidthInPlan === undefined) { this.resizedPieceWidthInPlan = 0; }
            if (this.resizePoint === undefined) { this.resizePoint = null; }
            if (this.topLeftPoint === undefined) { this.topLeftPoint = null; }
            if (this.widthResizeToolTipFeedback === undefined) { this.widthResizeToolTipFeedback = null; }
            if (this.depthResizeToolTipFeedback === undefined) { this.depthResizeToolTipFeedback = null; }
            if (this.heightResizeToolTipFeedback === undefined) { this.heightResizeToolTipFeedback = null; }
        }
    }
    PieceOfFurnitureResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureResizeState";


    /**
     * Light power state. This states manages the power modification of a light.
     * @extends PlanController.ControllerState
     * @class
     */
    export class LightPowerModificationState extends PlanController.ControllerState {
        public __parent: any;
        deltaXToModificationPoint: number;

        selectedLight: HomeLight;

        oldPower: number;

        lightPowerToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.lightPowerToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "lightPowerToolTipFeedback");
            this.selectedLight = <HomeLight><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            const resizePoint: number[] = this.selectedLight.getPoints()[3];
            this.deltaXToModificationPoint = this.__parent.getXLastMousePress() - resizePoint[0];
            this.oldPower = this.selectedLight.getPower();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldPower), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const bottomLeftPoint: number[] = this.selectedLight.getPoints()[3];
            const deltaX: number = x - this.deltaXToModificationPoint - bottomLeftPoint[0];
            let newPower: number = this.oldPower + deltaX / 100.0 * this.__parent.getScale();
            newPower = Math.min(Math.max(newPower, 0.0), 1.0);
            this.selectedLight.setPower(newPower);
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newPower), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postLightPowerModification(this.selectedLight, this.oldPower);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedLight.setPower(this.oldPower);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedLight = null;
        }

        getToolTipFeedbackText(power: number): string {
            return CoreTools.format(this.lightPowerToolTipFeedback, Math.round(power * 100));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.deltaXToModificationPoint === undefined) { this.deltaXToModificationPoint = 0; }
            if (this.selectedLight === undefined) { this.selectedLight = null; }
            if (this.oldPower === undefined) { this.oldPower = 0; }
            if (this.lightPowerToolTipFeedback === undefined) { this.lightPowerToolTipFeedback = null; }
        }
    }
    LightPowerModificationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LightPowerModificationState";


    /**
     * Furniture name offset state. This state manages the name offset of a piece of furniture.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureNameOffsetState extends PlanController.ControllerState {
        public __parent: any;
        selectedPiece: HomePieceOfFurniture;

        oldNameXOffset: number;

        oldNameYOffset: number;

        xLastMouseMove: number;

        yLastMouseMove: number;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldNameXOffset = this.selectedPiece.getNameXOffset();
            this.oldNameYOffset = this.selectedPiece.getNameYOffset();
            this.xLastMouseMove = this.__parent.getXLastMousePress();
            this.yLastMouseMove = this.__parent.getYLastMousePress();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.alignmentActivated) {
                const alignedPoint: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), this.__parent.getView().getPixelLength(), 4);
                x = alignedPoint.getX();
                y = alignedPoint.getY();
            }
            this.selectedPiece.setNameXOffset(this.selectedPiece.getNameXOffset() + x - this.xLastMouseMove);
            this.selectedPiece.setNameYOffset(this.selectedPiece.getNameYOffset() + y - this.yLastMouseMove);
            this.xLastMouseMove = x;
            this.yLastMouseMove = y;
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureNameOffset(this.selectedPiece, this.oldNameXOffset, this.oldNameYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setNameXOffset(this.oldNameXOffset);
            this.selectedPiece.setNameYOffset(this.oldNameYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedPiece = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.oldNameXOffset === undefined) { this.oldNameXOffset = 0; }
            if (this.oldNameYOffset === undefined) { this.oldNameYOffset = 0; }
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    PieceOfFurnitureNameOffsetState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureNameOffsetState";


    /**
     * Furniture name rotation state. This state manages the name rotation of a piece of furniture.
     * @extends PlanController.ControllerState
     * @class
     */
    export class PieceOfFurnitureNameRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        selectedPiece: HomePieceOfFurniture;

        oldNameAngle: number;

        angleMousePress: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedPiece = <HomePieceOfFurniture><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedPiece.getY() + this.selectedPiece.getNameYOffset() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedPiece.getX() - this.selectedPiece.getNameXOffset());
            this.oldNameAngle = this.selectedPiece.getNameAngle();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedPiece.getX() + this.selectedPiece.getNameXOffset() || y !== this.selectedPiece.getY() + this.selectedPiece.getNameYOffset()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedPiece.getY() + this.selectedPiece.getNameYOffset() - y, x - this.selectedPiece.getX() - this.selectedPiece.getNameXOffset());
                let newAngle: number = this.oldNameAngle - angleMouseMove + this.angleMousePress;
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / PieceOfFurnitureNameRotationState.STEP_COUNT;
                    newAngle = Math.round(newAngle / angleStep) * angleStep;
                }
                this.selectedPiece.setNameAngle(newAngle);
                this.__parent.getView().makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPieceOfFurnitureNameRotation(this.selectedPiece, this.oldNameAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPiece.setNameAngle(this.oldNameAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedPiece = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedPiece === undefined) { this.selectedPiece = null; }
            if (this.oldNameAngle === undefined) { this.oldNameAngle = 0; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    PieceOfFurnitureNameRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PieceOfFurnitureNameRotationState";


    /**
     * Camera yaw change state. This states manages the change of the observer camera yaw angle.
     * @extends PlanController.ControllerState
     * @class
     */
    export class CameraYawRotationState extends PlanController.ControllerState {
        public __parent: any;
        selectedCamera: ObserverCamera;

        oldYaw: number;

        xLastMouseMove: number;

        yLastMouseMove: number;

        angleLastMouseMove: number;

        rotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.rotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "cameraYawRotationToolTipFeedback");
            this.selectedCamera = <ObserverCamera><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldYaw = this.selectedCamera.getYaw();
            this.xLastMouseMove = this.__parent.getXLastMousePress();
            this.yLastMouseMove = this.__parent.getYLastMousePress();
            this.angleLastMouseMove = <number>Math.atan2(this.selectedCamera.getY() - this.yLastMouseMove, this.xLastMouseMove - this.selectedCamera.getX());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldYaw), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedCamera.getX() || y !== this.selectedCamera.getY()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedCamera.getY() - y, x - this.selectedCamera.getX());
                let deltaYaw: number = this.angleLastMouseMove - angleMouseMove;
                const orientation: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })((y - this.selectedCamera.getY()) * (this.xLastMouseMove - this.selectedCamera.getX()) - (this.yLastMouseMove - this.selectedCamera.getY()) * (x - this.selectedCamera.getX()));
                if (orientation < 0 && deltaYaw > 0) {
                    deltaYaw -= <number>(Math.PI * 2.0);
                } else if (orientation > 0 && deltaYaw < 0) {
                    deltaYaw += <number>(Math.PI * 2.0);
                }
                const newYaw: number = this.selectedCamera.getYaw() + deltaYaw;
                this.selectedCamera.setYaw(newYaw);
                if (this.__parent.feedbackDisplayed) {
                    this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(newYaw), x, y);
                }
                this.xLastMouseMove = x;
                this.yLastMouseMove = y;
                this.angleLastMouseMove = angleMouseMove;
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedCamera.setYaw(this.oldYaw);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedCamera = null;
        }

        getToolTipFeedbackText(angle: number): string {
            return CoreTools.format(this.rotationToolTipFeedback, (Math.round(/* toDegrees */(x => x * 180 / Math.PI)(angle)) + 360) % 360);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedCamera === undefined) { this.selectedCamera = null; }
            if (this.oldYaw === undefined) { this.oldYaw = 0; }
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.angleLastMouseMove === undefined) { this.angleLastMouseMove = 0; }
            if (this.rotationToolTipFeedback === undefined) { this.rotationToolTipFeedback = null; }
        }
    }
    CameraYawRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CameraYawRotationState";


    /**
     * Camera pitch rotation state. This states manages the change of the observer camera pitch angle.
     * @extends PlanController.ControllerState
     * @class
     */
    export class CameraPitchRotationState extends PlanController.ControllerState {
        public __parent: any;
        selectedCamera: ObserverCamera;

        oldPitch: number;

        rotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.rotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "cameraPitchRotationToolTipFeedback");
            this.selectedCamera = <ObserverCamera><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldPitch = this.selectedCamera.getPitch();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldPitch), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            let newPitch: number = <number>(this.oldPitch + (y - this.__parent.getYLastMousePress()) * Math.cos(this.selectedCamera.getYaw()) * Math.PI / 360 - (x - this.__parent.getXLastMousePress()) * Math.sin(this.selectedCamera.getYaw()) * Math.PI / 360);
            newPitch = Math.max(newPitch, -<number>Math.PI / 2);
            newPitch = Math.min(newPitch, <number>Math.PI / 2);
            this.selectedCamera.setPitch(newPitch);
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(newPitch), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedCamera.setPitch(this.oldPitch);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedCamera = null;
        }

        getToolTipFeedbackText(angle: number): string {
            return CoreTools.format(this.rotationToolTipFeedback, Math.round(/* toDegrees */(x => x * 180 / Math.PI)(angle)) % 360);
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedCamera === undefined) { this.selectedCamera = null; }
            if (this.oldPitch === undefined) { this.oldPitch = 0; }
            if (this.rotationToolTipFeedback === undefined) { this.rotationToolTipFeedback = null; }
        }
    }
    CameraPitchRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CameraPitchRotationState";


    /**
     * Camera elevation state. This states manages the change of the observer camera elevation.
     * @extends PlanController.ControllerState
     * @class
     */
    export class CameraElevationState extends PlanController.ControllerState {
        public __parent: any;
        selectedCamera: ObserverCamera;

        oldElevation: number;

        cameraElevationToolTipFeedback: string;

        observerHeightToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.cameraElevationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "cameraElevationToolTipFeedback");
            this.observerHeightToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "observerHeightToolTipFeedback");
            this.selectedCamera = <ObserverCamera><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldElevation = this.selectedCamera.getZ();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldElevation), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            let newElevation: number = <number>(this.oldElevation - (y - this.__parent.getYLastMousePress()));
            const levels: Array<Level> = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getLevels();
            const minimumElevation: number = /* size */(<number>levels.length) === 0 ? 10 : 10 + /* get */levels[0].getElevation();
            newElevation = Math.min(Math.max(newElevation, minimumElevation), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumElevation());
            this.selectedCamera.setZ(newElevation);
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(newElevation), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedCamera.setZ(this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedCamera = null;
        }

        getToolTipFeedbackText(elevation: number): string {
            let toolTipFeedbackText: string = "<html>" + CoreTools.format(this.cameraElevationToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(elevation));
            if (!this.selectedCamera.isFixedSize() && elevation >= 70 && elevation <= 218.75) {
                toolTipFeedbackText += "<br>" + CoreTools.format(this.observerHeightToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(elevation * 15 / 14));
            }
            return toolTipFeedbackText;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedCamera === undefined) { this.selectedCamera = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.cameraElevationToolTipFeedback === undefined) { this.cameraElevationToolTipFeedback = null; }
            if (this.observerHeightToolTipFeedback === undefined) { this.observerHeightToolTipFeedback = null; }
        }
    }
    CameraElevationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CameraElevationState";


    /**
     * Dimension line drawing state. This state manages dimension line creation at mouse press.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLineDrawingState extends PlanController.ControllerState {
        public __parent: any;
        xStart: number;

        yStart: number;

        editingStartPoint: boolean;

        newDimensionLine: DimensionLine;

        oldSelection: Array<Selectable>;

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        offsetChoice: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.DIMENSION_LINE_CREATION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            this.escape();
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.PANNING_$LI$()) {
                this.__parent.setState(this.__parent.getPanningState());
            } else if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getWallCreationState());
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getRoomCreationState());
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public enter() {
            this.oldSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.oldBasePlanLocked = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            this.oldAllLevelsSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            this.xStart = this.__parent.getXLastMouseMove();
            this.yStart = this.__parent.getYLastMouseMove();
            this.editingStartPoint = false;
            this.offsetChoice = false;
            this.newDimensionLine = null;
            this.__parent.deselectAll();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            const dimensionLine: DimensionLine = this.__parent.getMeasuringDimensionLineAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), this.magnetismEnabled);
            if (this.__parent.feedbackDisplayed) {
                if (dimensionLine != null) {
                    this.__parent.getView().setDimensionLinesFeedback(/* asList */[dimensionLine].slice(0));
                }
                this.__parent.getView().setAlignmentFeedback(DimensionLine, null, this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), false);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            planView.deleteFeedback();
            if (this.offsetChoice) {
                const distanceToDimensionLine: number = <number>java.awt.geom.Line2D.ptLineDist(this.newDimensionLine.getXStart(), this.newDimensionLine.getYStart(), this.newDimensionLine.getXEnd(), this.newDimensionLine.getYEnd(), x, y);
                if (this.newDimensionLine.getLength() > 0) {
                    const relativeCCW: number = java.awt.geom.Line2D.relativeCCW(this.newDimensionLine.getXStart(), this.newDimensionLine.getYStart(), this.newDimensionLine.getXEnd(), this.newDimensionLine.getYEnd(), x, y);
                    this.newDimensionLine.setOffset(-/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(relativeCCW) * distanceToDimensionLine);
                }
            } else {
                let newX: number;
                let newY: number;
                if (this.magnetismEnabled || this.alignmentActivated) {
                    const point: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.xStart, this.yStart, x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                    newX = point.getX();
                    newY = point.getY();
                } else {
                    newX = x;
                    newY = y;
                }
                if (this.newDimensionLine == null) {
                    this.newDimensionLine = this.__parent.createDimensionLine(this.xStart, this.yStart, newX, newY, 0);
                    this.__parent.getView().setDimensionLinesFeedback(null);
                } else {
                    if (this.editingStartPoint) {
                        this.newDimensionLine.setXStart(newX);
                        this.newDimensionLine.setYStart(newY);
                    } else {
                        this.newDimensionLine.setXEnd(newX);
                        this.newDimensionLine.setYEnd(newY);
                    }
                }
                this.updateReversedDimensionLine();
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(DimensionLine, this.newDimensionLine, newX, newY, false);
                }
            }
            planView.makePointVisible(x, y);
        }

        /**
         * Swaps start and end point of the created dimension line if needed
         * to ensure its text is never upside down.
         * @private
         */
        updateReversedDimensionLine() {
            const angle: number = this.getDimensionLineAngle();
            const reverse: boolean = angle < -Math.PI / 2 || angle > Math.PI / 2;
            if ((reverse) !== (this.editingStartPoint)) {
                PlanController.reverseDimensionLine(this.newDimensionLine);
                this.editingStartPoint = !this.editingStartPoint;
            }
        }

        getDimensionLineAngle(): number {
            if (this.newDimensionLine.getLength() === 0) {
                return 0;
            } else {
                if (this.editingStartPoint) {
                    return Math.atan2(this.yStart - this.newDimensionLine.getYStart(), this.newDimensionLine.getXStart() - this.xStart);
                } else {
                    return Math.atan2(this.yStart - this.newDimensionLine.getYEnd(), this.newDimensionLine.getXEnd() - this.xStart);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (this.newDimensionLine == null && clickCount === 2) {
                const dimensionLine: DimensionLine = this.__parent.getMeasuringDimensionLineAt(x, y, this.magnetismEnabled);
                if (dimensionLine != null) {
                    this.newDimensionLine = this.__parent.createDimensionLine(dimensionLine.getXStart(), dimensionLine.getYStart(), dimensionLine.getXEnd(), dimensionLine.getYEnd(), dimensionLine.getOffset());
                    if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                        this.validateDrawnDimensionLine();
                    }
                } else {
                    this.__parent.setState(this.__parent.getDimensionLineCreationState());
                    return;
                }
            }
            if (this.newDimensionLine != null) {
                if (this.offsetChoice) {
                    this.validateDrawnDimensionLine();
                } else {
                    this.offsetChoice = true;
                    const planView: PlanView = this.__parent.getView();
                    planView.setCursor(PlanView.CursorType.HEIGHT);
                    planView.deleteFeedback();
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH && this.newDimensionLine != null) {
                this.validateDrawnDimensionLine();
            }
        }

        validateDrawnDimensionLine() {
            this.__parent.selectItem(this.newDimensionLine);
            this.__parent.postCreateDimensionLines(/* asList */[this.newDimensionLine].slice(0), this.oldSelection, this.oldBasePlanLocked, this.oldAllLevelsSelection);
            this.newDimensionLine = null;
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            }
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            const planView: PlanView = this.__parent.getView();
            if (editionActivated) {
                planView.deleteFeedback();
                if (this.newDimensionLine == null) {
                    planView.setToolTipEditedProperties(["X", "Y"], [this.xStart, this.yStart], this.xStart, this.yStart);
                } else if (this.offsetChoice) {
                    planView.setToolTipEditedProperties(["OFFSET"], [this.newDimensionLine.getOffset()], this.newDimensionLine.getXEnd(), this.newDimensionLine.getYEnd());
                } else {
                    planView.setToolTipEditedProperties(["LENGTH", "ANGLE"], [this.newDimensionLine.getLength(), (<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(this.getDimensionLineAngle())) | 0)], this.newDimensionLine.getXEnd(), this.newDimensionLine.getYEnd());
                }
                this.showDimensionLineFeedback();
            } else {
                if (this.newDimensionLine == null) {
                    const lengthUnit: any = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit();
                    const defaultLength: number = lengthUnit.isMetric() ? 100 : LengthUnit.footToCentimeter(3);
                    this.newDimensionLine = this.__parent.createDimensionLine(this.xStart, this.yStart, this.xStart + defaultLength, this.yStart, 0);
                    planView.deleteFeedback();
                    this.setEditionActivated(true);
                } else if (this.offsetChoice) {
                    this.validateDrawnDimensionLine();
                } else {
                    this.offsetChoice = true;
                    this.setEditionActivated(true);
                }
            }
        }

        /**
         * 
         * @param {string} editableProperty
         * @param {Object} value
         */
        public updateEditableProperty(editableProperty: any, value: any) {
            const maximumLength: number = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength();
            if (this.newDimensionLine == null) {
                switch ((editableProperty)) {
                    case "X":
                        this.xStart = value != null ? /* floatValue */(<number>value) : 0;
                        this.xStart = Math.max(-maximumLength, Math.min(this.xStart, maximumLength));
                        break;
                    case "Y":
                        this.yStart = value != null ? /* floatValue */(<number>value) : 0;
                        this.yStart = Math.max(-maximumLength, Math.min(this.yStart, maximumLength));
                        break;
                }
            } else if (this.offsetChoice) {
                if (editableProperty === "OFFSET") {
                    let offset: number = value != null ? /* floatValue */(<number>value) : 0;
                    offset = Math.max(-maximumLength, Math.min(offset, maximumLength));
                    this.newDimensionLine.setOffset(offset);
                }
            } else {
                let newX: number;
                let newY: number;
                switch ((editableProperty)) {
                    case "LENGTH":
                        let length: number = value != null ? /* floatValue */(<number>value) : 0;
                        length = Math.max(0.001, Math.min(length, maximumLength));
                        let dimensionLineAngle: number = this.getDimensionLineAngle();
                        newX = <number>(this.xStart + length * Math.cos(dimensionLineAngle));
                        newY = <number>(this.yStart - length * Math.sin(dimensionLineAngle));
                        break;
                    case "ANGLE":
                        dimensionLineAngle = /* toRadians */(x => x * Math.PI / 180)(value != null ? /* floatValue */(<number>value) : 0);
                        const dimensionLineLength: number = this.newDimensionLine.getLength();
                        newX = <number>(this.xStart + dimensionLineLength * Math.cos(dimensionLineAngle));
                        newY = <number>(this.yStart - dimensionLineLength * Math.sin(dimensionLineAngle));
                        break;
                    default:
                        return;
                }
                if (this.editingStartPoint) {
                    this.newDimensionLine.setXStart(newX);
                    this.newDimensionLine.setYStart(newY);
                } else {
                    this.newDimensionLine.setXEnd(newX);
                    this.newDimensionLine.setYEnd(newY);
                }
            }
            this.showDimensionLineFeedback();
        }

        showDimensionLineFeedback() {
            const planView: PlanView = this.__parent.getView();
            if (this.newDimensionLine == null) {
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(DimensionLine, null, this.xStart, this.yStart, true);
                }
                planView.makePointVisible(this.xStart, this.yStart);
            } else if (!this.offsetChoice) {
                let updatedX: number;
                let updatedY: number;
                if (this.editingStartPoint) {
                    updatedX = this.newDimensionLine.getXStart();
                    updatedY = this.newDimensionLine.getYStart();
                } else {
                    updatedX = this.newDimensionLine.getXEnd();
                    updatedY = this.newDimensionLine.getYEnd();
                }
                this.updateReversedDimensionLine();
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(DimensionLine, this.newDimensionLine, updatedX, updatedY, false);
                }
                planView.makePointVisible(this.xStart, this.yStart);
                planView.makePointVisible(updatedX, updatedY);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.newDimensionLine != null && !this.offsetChoice) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            if (this.newDimensionLine != null) {
                this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteDimensionLine(this.newDimensionLine);
            }
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            }
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
            this.newDimensionLine = null;
            this.oldSelection = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.editingStartPoint === undefined) { this.editingStartPoint = false; }
            if (this.newDimensionLine === undefined) { this.newDimensionLine = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.offsetChoice === undefined) { this.offsetChoice = false; }
        }
    }
    DimensionLineDrawingState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineDrawingState";


    /**
     * Dimension line resize state. This state manages dimension line resizing.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLineResizeState extends PlanController.ControllerState {
        public __parent: any;
        selectedDimensionLine: DimensionLine;

        editingStartPoint: boolean;

        oldX: number;

        oldY: number;

        reversedDimensionLine: boolean;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        distanceFromResizePointToDimensionBaseLine: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            this.selectedDimensionLine = <DimensionLine><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.editingStartPoint = this.selectedDimensionLine === this.__parent.getResizedDimensionLineStartAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            if (this.editingStartPoint) {
                this.oldX = this.selectedDimensionLine.getXStart();
                this.oldY = this.selectedDimensionLine.getYStart();
            } else {
                this.oldX = this.selectedDimensionLine.getXEnd();
                this.oldY = this.selectedDimensionLine.getYEnd();
            }
            this.reversedDimensionLine = false;
            let xResizePoint: number;
            let yResizePoint: number;
            const alpha1: number = <number>(this.selectedDimensionLine.getYEnd() - this.selectedDimensionLine.getYStart()) / (this.selectedDimensionLine.getXEnd() - this.selectedDimensionLine.getXStart());
            if (Math.abs(alpha1) > 100000.0) {
                xResizePoint = this.__parent.getXLastMousePress();
                if (this.editingStartPoint) {
                    yResizePoint = this.selectedDimensionLine.getYStart();
                } else {
                    yResizePoint = this.selectedDimensionLine.getYEnd();
                }
            } else if (this.selectedDimensionLine.getYStart() === this.selectedDimensionLine.getYEnd()) {
                if (this.editingStartPoint) {
                    xResizePoint = this.selectedDimensionLine.getXStart();
                } else {
                    xResizePoint = this.selectedDimensionLine.getXEnd();
                }
                yResizePoint = this.__parent.getYLastMousePress();
            } else {
                const beta1: number = this.__parent.getYLastMousePress() - alpha1 * this.__parent.getXLastMousePress();
                const alpha2: number = -1 / alpha1;
                let beta2: number;
                if (this.editingStartPoint) {
                    beta2 = this.selectedDimensionLine.getYStart() - alpha2 * this.selectedDimensionLine.getXStart();
                } else {
                    beta2 = this.selectedDimensionLine.getYEnd() - alpha2 * this.selectedDimensionLine.getXEnd();
                }
                xResizePoint = (beta2 - beta1) / (alpha1 - alpha2);
                yResizePoint = alpha1 * xResizePoint + beta1;
            }
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - xResizePoint;
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - yResizePoint;
            if (this.editingStartPoint) {
                this.distanceFromResizePointToDimensionBaseLine = <number>java.awt.geom.Point2D.distance(xResizePoint, yResizePoint, this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart());
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(DimensionLine, this.selectedDimensionLine, this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), false);
                }
            } else {
                this.distanceFromResizePointToDimensionBaseLine = <number>java.awt.geom.Point2D.distance(xResizePoint, yResizePoint, this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd());
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(DimensionLine, this.selectedDimensionLine, this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd(), false);
                }
            }
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const xResizePoint: number = x - this.deltaXToResizePoint;
            const yResizePoint: number = y - this.deltaYToResizePoint;
            if (this.editingStartPoint) {
                const distanceFromResizePointToDimensionLineEnd: number = java.awt.geom.Point2D.distance(xResizePoint, yResizePoint, this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd());
                const distanceFromDimensionLineStartToDimensionLineEnd: number = Math.sqrt(distanceFromResizePointToDimensionLineEnd * distanceFromResizePointToDimensionLineEnd - this.distanceFromResizePointToDimensionBaseLine * this.distanceFromResizePointToDimensionBaseLine);
                if (distanceFromDimensionLineStartToDimensionLineEnd > 0) {
                    let dimensionLineRelativeAngle: number = -Math.atan2(this.distanceFromResizePointToDimensionBaseLine, distanceFromDimensionLineStartToDimensionLineEnd);
                    if (this.selectedDimensionLine.getOffset() >= 0) {
                        dimensionLineRelativeAngle = -dimensionLineRelativeAngle;
                    }
                    const resizePointToDimensionLineEndAngle: number = Math.atan2(yResizePoint - this.selectedDimensionLine.getYEnd(), xResizePoint - this.selectedDimensionLine.getXEnd());
                    const dimensionLineStartToDimensionLineEndAngle: number = dimensionLineRelativeAngle + resizePointToDimensionLineEndAngle;
                    let xNewStartPoint: number = this.selectedDimensionLine.getXEnd() + <number>(distanceFromDimensionLineStartToDimensionLineEnd * Math.cos(dimensionLineStartToDimensionLineEndAngle));
                    let yNewStartPoint: number = this.selectedDimensionLine.getYEnd() + <number>(distanceFromDimensionLineStartToDimensionLineEnd * Math.sin(dimensionLineStartToDimensionLineEndAngle));
                    if (this.alignmentActivated || this.magnetismEnabled) {
                        const point: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd(), xNewStartPoint, yNewStartPoint, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                        xNewStartPoint = point.getX();
                        yNewStartPoint = point.getY();
                    }
                    PlanController.moveDimensionLinePoint(this.selectedDimensionLine, xNewStartPoint, yNewStartPoint, this.editingStartPoint);
                    this.updateReversedDimensionLine();
                    if (this.__parent.feedbackDisplayed) {
                        planView.setAlignmentFeedback(DimensionLine, this.selectedDimensionLine, xNewStartPoint, yNewStartPoint, false);
                    }
                } else {
                    planView.deleteFeedback();
                }
            } else {
                const distanceFromResizePointToDimensionLineStart: number = java.awt.geom.Point2D.distance(xResizePoint, yResizePoint, this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart());
                const distanceFromDimensionLineStartToDimensionLineEnd: number = Math.sqrt(distanceFromResizePointToDimensionLineStart * distanceFromResizePointToDimensionLineStart - this.distanceFromResizePointToDimensionBaseLine * this.distanceFromResizePointToDimensionBaseLine);
                if (distanceFromDimensionLineStartToDimensionLineEnd > 0) {
                    let dimensionLineRelativeAngle: number = Math.atan2(this.distanceFromResizePointToDimensionBaseLine, distanceFromDimensionLineStartToDimensionLineEnd);
                    if (this.selectedDimensionLine.getOffset() >= 0) {
                        dimensionLineRelativeAngle = -dimensionLineRelativeAngle;
                    }
                    const resizePointToDimensionLineStartAngle: number = Math.atan2(yResizePoint - this.selectedDimensionLine.getYStart(), xResizePoint - this.selectedDimensionLine.getXStart());
                    const dimensionLineStartToDimensionLineEndAngle: number = dimensionLineRelativeAngle + resizePointToDimensionLineStartAngle;
                    let xNewEndPoint: number = this.selectedDimensionLine.getXStart() + <number>(distanceFromDimensionLineStartToDimensionLineEnd * Math.cos(dimensionLineStartToDimensionLineEndAngle));
                    let yNewEndPoint: number = this.selectedDimensionLine.getYStart() + <number>(distanceFromDimensionLineStartToDimensionLineEnd * Math.sin(dimensionLineStartToDimensionLineEndAngle));
                    if (this.alignmentActivated || this.magnetismEnabled) {
                        const point: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), xNewEndPoint, yNewEndPoint, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                        xNewEndPoint = point.getX();
                        yNewEndPoint = point.getY();
                    }
                    PlanController.moveDimensionLinePoint(this.selectedDimensionLine, xNewEndPoint, yNewEndPoint, this.editingStartPoint);
                    this.updateReversedDimensionLine();
                    if (this.__parent.feedbackDisplayed) {
                        planView.setAlignmentFeedback(DimensionLine, this.selectedDimensionLine, xNewEndPoint, yNewEndPoint, false);
                    }
                } else {
                    planView.deleteFeedback();
                }
            }
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * Swaps start and end point of the dimension line if needed
         * to ensure its text is never upside down.
         * @private
         */
        updateReversedDimensionLine() {
            const angle: number = this.getDimensionLineAngle();
            if (angle < -Math.PI / 2 || angle > Math.PI / 2) {
                PlanController.reverseDimensionLine(this.selectedDimensionLine);
                this.editingStartPoint = !this.editingStartPoint;
                this.reversedDimensionLine = !this.reversedDimensionLine;
            }
        }

        getDimensionLineAngle(): number {
            if (this.selectedDimensionLine.getLength() === 0) {
                return 0;
            } else {
                return Math.atan2(this.selectedDimensionLine.getYStart() - this.selectedDimensionLine.getYEnd(), this.selectedDimensionLine.getXEnd() - this.selectedDimensionLine.getXStart());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postDimensionLineResize(this.selectedDimensionLine, this.oldX, this.oldY, this.editingStartPoint, this.reversedDimensionLine);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            if (this.reversedDimensionLine) {
                PlanController.reverseDimensionLine(this.selectedDimensionLine);
                this.editingStartPoint = !this.editingStartPoint;
            }
            PlanController.moveDimensionLinePoint(this.selectedDimensionLine, this.oldX, this.oldY, this.editingStartPoint);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.deleteFeedback();
            planView.setResizeIndicatorVisible(false);
            this.selectedDimensionLine = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedDimensionLine === undefined) { this.selectedDimensionLine = null; }
            if (this.editingStartPoint === undefined) { this.editingStartPoint = false; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.reversedDimensionLine === undefined) { this.reversedDimensionLine = false; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.distanceFromResizePointToDimensionBaseLine === undefined) { this.distanceFromResizePointToDimensionBaseLine = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    DimensionLineResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineResizeState";


    /**
     * Dimension line offset state. This state manages dimension line offset.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLineOffsetState extends PlanController.ControllerState {
        public __parent: any;
        selectedDimensionLine: DimensionLine;

        oldOffset: number;

        deltaXToOffsetPoint: number;

        deltaYToOffsetPoint: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedDimensionLine = <DimensionLine><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldOffset = this.selectedDimensionLine.getOffset();
            const angle: number = this.selectedDimensionLine.getYEnd() !== this.selectedDimensionLine.getYStart() || this.selectedDimensionLine.getXEnd() !== this.selectedDimensionLine.getXStart() ? Math.atan2(this.selectedDimensionLine.getYEnd() - this.selectedDimensionLine.getYStart(), this.selectedDimensionLine.getXEnd() - this.selectedDimensionLine.getXStart()) : this.selectedDimensionLine.getPitch();
            const dx: number = <number>-Math.sin(angle) * this.oldOffset;
            const dy: number = <number>Math.cos(angle) * this.oldOffset;
            const xMiddle: number = (this.selectedDimensionLine.getXStart() + this.selectedDimensionLine.getXEnd()) / 2 + dx;
            const yMiddle: number = (this.selectedDimensionLine.getYStart() + this.selectedDimensionLine.getYEnd()) / 2 + dy;
            this.deltaXToOffsetPoint = this.__parent.getXLastMousePress() - xMiddle;
            this.deltaYToOffsetPoint = this.__parent.getYLastMousePress() - yMiddle;
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const newX: number = x - this.deltaXToOffsetPoint;
            const newY: number = y - this.deltaYToOffsetPoint;
            let distanceToDimensionLine: number;
            let relativeCCW: number;
            if (this.selectedDimensionLine.getYEnd() !== this.selectedDimensionLine.getYStart() || this.selectedDimensionLine.getXEnd() !== this.selectedDimensionLine.getXStart()) {
                distanceToDimensionLine = <number>java.awt.geom.Line2D.ptLineDist(this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd(), newX, newY);
                relativeCCW = java.awt.geom.Line2D.relativeCCW(this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), this.selectedDimensionLine.getXEnd(), this.selectedDimensionLine.getYEnd(), newX, newY);
            } else {
                distanceToDimensionLine = <number>java.awt.geom.Point2D.distance(this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), newX, newY);
                relativeCCW = java.awt.geom.Line2D.relativeCCW(this.selectedDimensionLine.getXStart(), this.selectedDimensionLine.getYStart(), this.selectedDimensionLine.getXStart() + Math.cos(this.selectedDimensionLine.getPitch()), this.selectedDimensionLine.getYStart() + Math.sin(this.selectedDimensionLine.getPitch()), newX, newY);
            }
            let newOffset: number;
            newOffset = -/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(relativeCCW) * distanceToDimensionLine;
            this.selectedDimensionLine.setOffset(newOffset);
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postDimensionLineOffset(this.selectedDimensionLine, this.oldOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedDimensionLine.setOffset(this.oldOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedDimensionLine = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedDimensionLine === undefined) { this.selectedDimensionLine = null; }
            if (this.oldOffset === undefined) { this.oldOffset = 0; }
            if (this.deltaXToOffsetPoint === undefined) { this.deltaXToOffsetPoint = 0; }
            if (this.deltaYToOffsetPoint === undefined) { this.deltaYToOffsetPoint = 0; }
        }
    }
    DimensionLineOffsetState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineOffsetState";


    /**
     * Dimension line rotation state. This states manages the pitch rotation modification
     * of an elevation dimension line.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLinePitchRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        selectedDimensionLine: DimensionLine;

        oldPitch: number;

        pitchMousePress: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedDimensionLine = <DimensionLine><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.pitchMousePress = <number>Math.atan2(this.selectedDimensionLine.getYStart() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedDimensionLine.getXStart());
            this.oldPitch = this.selectedDimensionLine.getPitch();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            this.__parent.getView().setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedDimensionLine.getXStart() || y !== this.selectedDimensionLine.getYStart()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedDimensionLine.getYStart() - y, x - this.selectedDimensionLine.getXStart());
                let newPitch: number = <number>((this.oldPitch - angleMouseMove + this.pitchMousePress + 2 * Math.PI) % (2 * Math.PI));
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / DimensionLinePitchRotationState.STEP_COUNT;
                    newPitch = Math.round(newPitch / angleStep) * angleStep;
                }
                this.selectedDimensionLine.setPitch(newPitch);
                this.__parent.planView.makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postDimensionLinePitchRotation(this.selectedDimensionLine, this.oldPitch);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedDimensionLine.setPitch(this.oldPitch);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedDimensionLine = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedDimensionLine === undefined) { this.selectedDimensionLine = null; }
            if (this.oldPitch === undefined) { this.oldPitch = 0; }
            if (this.pitchMousePress === undefined) { this.pitchMousePress = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    DimensionLinePitchRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLinePitchRotationState";


    /**
     * Dimension line height state. This states manages the height resizing of an elevation dimension line.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLineHeightState extends PlanController.ControllerState {
        public __parent: any;
        selectedDimensionLine: DimensionLine;

        oldHeight: number;

        magnetismEnabled: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedDimensionLine = <DimensionLine><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldHeight = this.selectedDimensionLine.getElevationEnd() - this.selectedDimensionLine.getElevationStart();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const deltaY: number = y - this.__parent.getYLastMousePress();
            let newHeight: number = Math.max(this.oldHeight - deltaY, 0.0);
            if (this.magnetismEnabled) {
                newHeight = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newHeight, this.__parent.planView.getPixelLength());
            }
            newHeight = Math.min(Math.max(newHeight, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength()), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength());
            this.selectedDimensionLine.setElevationEnd(this.selectedDimensionLine.getElevationStart() + newHeight);
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postDimensionLineHeight(this.selectedDimensionLine, this.oldHeight);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedDimensionLine.setElevationEnd(this.selectedDimensionLine.getElevationStart() + this.oldHeight);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedDimensionLine = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedDimensionLine === undefined) { this.selectedDimensionLine = null; }
            if (this.oldHeight === undefined) { this.oldHeight = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
        }
    }
    DimensionLineHeightState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineHeightState";


    /**
     * Dimension line elevation state. This states manages the elevation modification
     * of an elevation dimension line.
     * @extends PlanController.ControllerState
     * @class
     */
    export class DimensionLineElevationState extends PlanController.ControllerState {
        public __parent: any;
        selectedDimensionLine: DimensionLine;

        elevationToolTipFeedback: string;

        oldElevation: number;

        magnetismEnabled: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedDimensionLine = <DimensionLine><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.elevationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "elevationToolTipFeedback");
            this.oldElevation = this.selectedDimensionLine.getElevationStart();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldElevation), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const deltaY: number = y - this.__parent.getYLastMousePress();
            let newElevation: number = Math.max(this.oldElevation - deltaY, 0.0);
            if (this.magnetismEnabled) {
                newElevation = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newElevation, planView.getPixelLength());
            }
            newElevation = Math.min(newElevation, this.selectedDimensionLine.getElevationEnd() - this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength());
            this.selectedDimensionLine.setElevationStart(newElevation);
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newElevation), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postDimensionLineElevation(this.selectedDimensionLine, this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedDimensionLine.setElevationStart(this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedDimensionLine = null;
        }

        getToolTipFeedbackText(height: number): string {
            return CoreTools.format(this.elevationToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(height));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedDimensionLine === undefined) { this.selectedDimensionLine = null; }
            if (this.elevationToolTipFeedback === undefined) { this.elevationToolTipFeedback = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
        }
    }
    DimensionLineElevationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineElevationState";


    /**
     * Room modification state.
     * @extends PlanController.ControllerState
     * @class
     */
    export abstract class AbstractRoomState extends PlanController.ControllerState {
        public __parent: any;
        roomSideLengthToolTipFeedback: string;

        roomDiagonalLengthToolTipFeedback: string;

        roomSideAngleToolTipFeedback: string;

        /**
         * 
         */
        public enter() {
            this.roomSideLengthToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "roomSideLengthToolTipFeedback");
            try {
                this.roomDiagonalLengthToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "roomDiagonalLengthToolTipFeedback");
            } catch (ex) {
            }
            try {
                this.roomSideAngleToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "roomSideAngleToolTipFeedback");
            } catch (ex) {
            }
        }

        getToolTipFeedbackText(room: Room, pointIndex: number): string {
            const length: number = this.getRoomSideLength(room, pointIndex);
            const angle: number = this.getRoomSideAngle(room, pointIndex);
            let toolTipFeedbackText: string = "<html>" + CoreTools.format(this.roomSideLengthToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(length));
            if (this.roomDiagonalLengthToolTipFeedback != null && this.roomDiagonalLengthToolTipFeedback.length > 0 && room.getPointCount() > 2) {
                const diagonalLength: number = this.getRoomDiagonalLength(room, pointIndex);
                toolTipFeedbackText += "<br>" + CoreTools.format(this.roomDiagonalLengthToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(diagonalLength));
            }
            if (this.roomSideAngleToolTipFeedback != null && this.roomSideAngleToolTipFeedback.length > 0) {
                toolTipFeedbackText += "<br>" + CoreTools.format(this.roomSideAngleToolTipFeedback, angle);
            }
            return toolTipFeedbackText;
        }

        getRoomSideLength(room: Room, pointIndex: number): number {
            const points: number[][] = room.getPoints();
            const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
            return <number>java.awt.geom.Point2D.distance(previousPoint[0], previousPoint[1], points[pointIndex][0], points[pointIndex][1]);
        }

        getRoomDiagonalLength(room: Room, pointIndex: number): number {
            const points: number[][] = room.getPoints();
            if (points.length > 2) {
                const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
                return <number>java.awt.geom.Point2D.distance(points[pointIndex][0], points[pointIndex][1], previousPreviousPoint[0], previousPreviousPoint[1]);
            } else {
                throw new IllegalArgumentException("Room doesn\'t have at least 3 points");
            }
        }

        getTriangulationDimensionLines(room: Room, pointIndex: number): Array<DimensionLine> {
            const points: number[][] = room.getPoints();
            const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
            const dimensionLines: Array<DimensionLine> = <any>([]);
            const offset: number = 20 / this.__parent.getView().getScale();
            if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(points[pointIndex], previousPoint)) {
                /* add */(dimensionLines.push(this.__parent.getDimensionLineBetweenPoints(previousPoint, points[pointIndex], this.isDimensionInsideRoom(room, previousPoint, points[pointIndex]) ? -offset : offset, false)) > 0);
            }
            if (points.length > 2) {
                const nextPoint: number[] = points[pointIndex + 1 < points.length ? pointIndex + 1 : 0];
                if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(points[pointIndex], nextPoint)) {
                    /* add */(dimensionLines.push(this.__parent.getDimensionLineBetweenPoints(points[pointIndex], nextPoint, this.isDimensionInsideRoom(room, points[pointIndex], nextPoint) ? -offset : offset, false)) > 0);
                }
                const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
                if (points.length === 3) {
                    /* add */(dimensionLines.push(this.__parent.getDimensionLineBetweenPoints(previousPoint, previousPreviousPoint, this.isDimensionInsideRoom(room, previousPoint, previousPreviousPoint) ? -offset : offset, false)) > 0);
                } else if (!/* equals */((a1, a2) => { if (a1 == null && a2 == null) return true; if (a1 == null || a2 == null) return false; if (a1.length != a2.length) return false; for (let i = 0; i < a1.length; i++) { if (<any>a1[i] != <any>a2[i]) return false; } return true; })(points[pointIndex], previousPreviousPoint)) {
                    /* add */(dimensionLines.push(this.__parent.getDimensionLineBetweenPoints(points[pointIndex], previousPreviousPoint, 0, false)) > 0);
                }
            }
            return dimensionLines;
        }

        isDimensionInsideRoom(room: Room, point1: number[], point2: number[]): boolean {
            const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(Math.atan2(point2[1] - point1[1], point2[0] - point1[0]), point1[0], point1[1]);
            const dimensionPoint: number[] = [<number>(point1[0] + java.awt.geom.Point2D.distance(point1[0], point1[1], point2[0], point2[1]) / 2), point1[1] + 1.0];
            rotation.transform(dimensionPoint, 0, dimensionPoint, 0, 1);
            return room.containsPoint(dimensionPoint[0], dimensionPoint[1], 0);
        }

        /**
         * Returns room side angle at the given point index in degrees.
         * @param {Room} room
         * @param {number} pointIndex
         * @return {number}
         */
        getRoomSideAngle(room: Room, pointIndex: number): number {
            const points: number[][] = room.getPoints();
            const point: number[] = points[pointIndex];
            const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
            const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
            const sideLength: number = <number>java.awt.geom.Point2D.distance(previousPoint[0], previousPoint[1], points[pointIndex][0], points[pointIndex][1]);
            const previousSideLength: number = <number>java.awt.geom.Point2D.distance(previousPreviousPoint[0], previousPreviousPoint[1], previousPoint[0], previousPoint[1]);
            if (previousPreviousPoint !== point && sideLength !== 0 && previousSideLength !== 0) {
                const xSideVector: number = (point[0] - previousPoint[0]) / sideLength;
                const ySideVector: number = (point[1] - previousPoint[1]) / sideLength;
                const xPreviousSideVector: number = (previousPoint[0] - previousPreviousPoint[0]) / previousSideLength;
                const yPreviousSideVector: number = (previousPoint[1] - previousPreviousPoint[1]) / previousSideLength;
                let sideAngle: number = (<number>Math.round(180 - /* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(ySideVector * xPreviousSideVector - xSideVector * yPreviousSideVector, xSideVector * xPreviousSideVector + ySideVector * yPreviousSideVector))) | 0);
                if (sideAngle > 180) {
                    sideAngle -= 360;
                }
                return sideAngle;
            }
            if (sideLength === 0) {
                return 0;
            } else {
                return (<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(previousPoint[1] - point[1], point[0] - previousPoint[0]))) | 0);
            }
        }

        showRoomAngleFeedback(room: Room, pointIndex: number) {
            const points: number[][] = room.getPoints();
            if (this.roomSideAngleToolTipFeedback != null && this.roomSideAngleToolTipFeedback.length > 0 && points.length > 2) {
                const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
                const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
                if (this.getRoomSideAngle(room, pointIndex) > 0) {
                    this.__parent.getView().setAngleFeedback(previousPoint[0], previousPoint[1], previousPreviousPoint[0], previousPreviousPoint[1], points[pointIndex][0], points[pointIndex][1]);
                } else {
                    this.__parent.getView().setAngleFeedback(previousPoint[0], previousPoint[1], points[pointIndex][0], points[pointIndex][1], previousPreviousPoint[0], previousPreviousPoint[1]);
                }
            }
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.roomSideLengthToolTipFeedback === undefined) { this.roomSideLengthToolTipFeedback = null; }
            if (this.roomDiagonalLengthToolTipFeedback === undefined) { this.roomDiagonalLengthToolTipFeedback = null; }
            if (this.roomSideAngleToolTipFeedback === undefined) { this.roomSideAngleToolTipFeedback = null; }
        }
    }
    AbstractRoomState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.AbstractRoomState";


    /**
     * Room name offset state. This state manages room name offset.
     * @extends PlanController.ControllerState
     * @class
     */
    export class RoomNameOffsetState extends PlanController.ControllerState {
        public __parent: any;
        selectedRoom: Room;

        oldNameXOffset: number;

        oldNameYOffset: number;

        xLastMouseMove: number;

        yLastMouseMove: number;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedRoom = <Room><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldNameXOffset = this.selectedRoom.getNameXOffset();
            this.oldNameYOffset = this.selectedRoom.getNameYOffset();
            this.xLastMouseMove = this.__parent.getXLastMousePress();
            this.yLastMouseMove = this.__parent.getYLastMousePress();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.alignmentActivated) {
                const alignedPoint: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), this.__parent.getView().getPixelLength(), 4);
                x = alignedPoint.getX();
                y = alignedPoint.getY();
            }
            this.selectedRoom.setNameXOffset(this.selectedRoom.getNameXOffset() + x - this.xLastMouseMove);
            this.selectedRoom.setNameYOffset(this.selectedRoom.getNameYOffset() + y - this.yLastMouseMove);
            this.xLastMouseMove = x;
            this.yLastMouseMove = y;
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postRoomNameOffset(this.selectedRoom, this.oldNameXOffset, this.oldNameYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedRoom.setNameXOffset(this.oldNameXOffset);
            this.selectedRoom.setNameYOffset(this.oldNameYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedRoom = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedRoom === undefined) { this.selectedRoom = null; }
            if (this.oldNameXOffset === undefined) { this.oldNameXOffset = 0; }
            if (this.oldNameYOffset === undefined) { this.oldNameYOffset = 0; }
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    RoomNameOffsetState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomNameOffsetState";


    /**
     * Room name rotation state. This state manages the name rotation of a room.
     * @extends PlanController.ControllerState
     * @class
     */
    export class RoomNameRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        selectedRoom: Room;

        oldNameAngle: number;

        angleMousePress: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedRoom = <Room><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedRoom.getYCenter() + this.selectedRoom.getNameYOffset() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedRoom.getXCenter() - this.selectedRoom.getNameXOffset());
            this.oldNameAngle = this.selectedRoom.getNameAngle();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedRoom.getXCenter() + this.selectedRoom.getNameXOffset() || y !== this.selectedRoom.getYCenter() + this.selectedRoom.getNameYOffset()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedRoom.getYCenter() + this.selectedRoom.getNameYOffset() - y, x - this.selectedRoom.getXCenter() - this.selectedRoom.getNameXOffset());
                let newAngle: number = this.oldNameAngle - angleMouseMove + this.angleMousePress;
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / RoomNameRotationState.STEP_COUNT;
                    newAngle = Math.round(newAngle / angleStep) * angleStep;
                }
                this.selectedRoom.setNameAngle(newAngle);
                this.__parent.getView().makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postRoomNameRotation(this.selectedRoom, this.oldNameAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedRoom.setNameAngle(this.oldNameAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedRoom = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedRoom === undefined) { this.selectedRoom = null; }
            if (this.oldNameAngle === undefined) { this.oldNameAngle = 0; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    RoomNameRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomNameRotationState";


    /**
     * Room area offset state. This state manages room area offset.
     * @extends PlanController.ControllerState
     * @class
     */
    export class RoomAreaOffsetState extends PlanController.ControllerState {
        public __parent: any;
        selectedRoom: Room;

        oldAreaXOffset: number;

        oldAreaYOffset: number;

        xLastMouseMove: number;

        yLastMouseMove: number;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedRoom = <Room><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldAreaXOffset = this.selectedRoom.getAreaXOffset();
            this.oldAreaYOffset = this.selectedRoom.getAreaYOffset();
            this.xLastMouseMove = this.__parent.getXLastMousePress();
            this.yLastMouseMove = this.__parent.getYLastMousePress();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.alignmentActivated) {
                const alignedPoint: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), this.__parent.getView().getPixelLength(), 4);
                x = alignedPoint.getX();
                y = alignedPoint.getY();
            }
            this.selectedRoom.setAreaXOffset(this.selectedRoom.getAreaXOffset() + x - this.xLastMouseMove);
            this.selectedRoom.setAreaYOffset(this.selectedRoom.getAreaYOffset() + y - this.yLastMouseMove);
            this.xLastMouseMove = x;
            this.yLastMouseMove = y;
            this.__parent.getView().makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postRoomAreaOffset(this.selectedRoom, this.oldAreaXOffset, this.oldAreaYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedRoom.setAreaXOffset(this.oldAreaXOffset);
            this.selectedRoom.setAreaYOffset(this.oldAreaYOffset);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedRoom = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedRoom === undefined) { this.selectedRoom = null; }
            if (this.oldAreaXOffset === undefined) { this.oldAreaXOffset = 0; }
            if (this.oldAreaYOffset === undefined) { this.oldAreaYOffset = 0; }
            if (this.xLastMouseMove === undefined) { this.xLastMouseMove = 0; }
            if (this.yLastMouseMove === undefined) { this.yLastMouseMove = 0; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    RoomAreaOffsetState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomAreaOffsetState";


    /**
     * Room area rotation state. This state manages the area rotation of a room.
     * @extends PlanController.ControllerState
     * @class
     */
    export class RoomAreaRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        selectedRoom: Room;

        oldAreaAngle: number;

        angleMousePress: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedRoom = <Room><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedRoom.getYCenter() + this.selectedRoom.getAreaYOffset() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedRoom.getXCenter() - this.selectedRoom.getAreaXOffset());
            this.oldAreaAngle = this.selectedRoom.getAreaAngle();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedRoom.getXCenter() + this.selectedRoom.getAreaXOffset() || y !== this.selectedRoom.getYCenter() + this.selectedRoom.getAreaYOffset()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedRoom.getYCenter() + this.selectedRoom.getAreaYOffset() - y, x - this.selectedRoom.getXCenter() - this.selectedRoom.getAreaXOffset());
                let newAngle: number = this.oldAreaAngle - angleMouseMove + this.angleMousePress;
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / RoomAreaRotationState.STEP_COUNT;
                    newAngle = Math.round(newAngle / angleStep) * angleStep;
                }
                this.selectedRoom.setAreaAngle(newAngle);
                this.__parent.getView().makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postRoomAreaRotation(this.selectedRoom, this.oldAreaAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedRoom.setAreaAngle(this.oldAreaAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedRoom = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedRoom === undefined) { this.selectedRoom = null; }
            if (this.oldAreaAngle === undefined) { this.oldAreaAngle = 0; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    RoomAreaRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomAreaRotationState";


    /**
     * Polyline modification state.
     * @extends PlanController.ControllerState
     * @class
     */
    export abstract class AbstractPolylineState extends PlanController.ControllerState {
        public __parent: any;
        polylineSegmentLengthToolTipFeedback: string;

        polylineSegmentAngleToolTipFeedback: string;

        /**
         * 
         */
        public enter() {
            this.polylineSegmentLengthToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "polylineSegmentLengthToolTipFeedback");
            try {
                this.polylineSegmentAngleToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "polylineSegmentAngleToolTipFeedback");
            } catch (ex) {
            }
        }

        getToolTipFeedbackText(polyline: Polyline, pointIndex: number): string {
            const length: number = this.getPolylineSegmentLength(polyline, pointIndex);
            const angle: number = this.getPolylineSegmentAngle(polyline, pointIndex);
            let toolTipFeedbackText: string = "<html>" + CoreTools.format(this.polylineSegmentLengthToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(length));
            if (this.polylineSegmentAngleToolTipFeedback != null && this.polylineSegmentAngleToolTipFeedback.length > 0) {
                toolTipFeedbackText += "<br>" + CoreTools.format(this.polylineSegmentAngleToolTipFeedback, angle);
            }
            return toolTipFeedbackText;
        }

        getPolylineSegmentLength(polyline: Polyline, pointIndex: number): number {
            if (pointIndex === 0 && !polyline.isClosedPath()) {
                pointIndex++;
            }
            const points: number[][] = polyline.getPoints();
            const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
            return <number>java.awt.geom.Point2D.distance(previousPoint[0], previousPoint[1], points[pointIndex][0], points[pointIndex][1]);
        }

        /**
         * Returns polyline segment angle at the given point index in degrees.
         * @param {Polyline} polyline
         * @param {number} pointIndex
         * @return {number}
         */
        getPolylineSegmentAngle(polyline: Polyline, pointIndex: number): number {
            if (pointIndex === 0 && !polyline.isClosedPath()) {
                pointIndex++;
            }
            const points: number[][] = polyline.getPoints();
            const point: number[] = points[pointIndex];
            const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
            const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
            const segmentLength: number = <number>java.awt.geom.Point2D.distance(previousPoint[0], previousPoint[1], points[pointIndex][0], points[pointIndex][1]);
            const previousSegmentLength: number = <number>java.awt.geom.Point2D.distance(previousPreviousPoint[0], previousPreviousPoint[1], previousPoint[0], previousPoint[1]);
            if (previousPreviousPoint !== point && segmentLength !== 0 && previousSegmentLength !== 0) {
                const xSegmentVector: number = (point[0] - previousPoint[0]) / segmentLength;
                const ySegmentVector: number = (point[1] - previousPoint[1]) / segmentLength;
                const xPreviousSegmentVector: number = (previousPoint[0] - previousPreviousPoint[0]) / previousSegmentLength;
                const yPreviousSegmentVector: number = (previousPoint[1] - previousPreviousPoint[1]) / previousSegmentLength;
                let segmentAngle: number = (<number>Math.round(180 - /* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(ySegmentVector * xPreviousSegmentVector - xSegmentVector * yPreviousSegmentVector, xSegmentVector * xPreviousSegmentVector + ySegmentVector * yPreviousSegmentVector))) | 0);
                if (segmentAngle > 180) {
                    segmentAngle -= 360;
                }
                return segmentAngle;
            }
            if (segmentLength === 0) {
                return 0;
            } else {
                return (<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(Math.atan2(previousPoint[1] - point[1], point[0] - previousPoint[0]))) | 0);
            }
        }

        showPolylineAngleFeedback(polyline: Polyline, pointIndex: number) {
            const points: number[][] = polyline.getPoints();
            if (this.polylineSegmentAngleToolTipFeedback != null && this.polylineSegmentAngleToolTipFeedback.length > 0 && (pointIndex >= 2 || points.length > 2 && polyline.isClosedPath())) {
                const previousPoint: number[] = points[(pointIndex + points.length - 1) % points.length];
                const previousPreviousPoint: number[] = points[(pointIndex + points.length - 2) % points.length];
                this.__parent.getView().setAngleFeedback(previousPoint[0], previousPoint[1], previousPreviousPoint[0], previousPreviousPoint[1], points[pointIndex][0], points[pointIndex][1]);
            }
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.polylineSegmentLengthToolTipFeedback === undefined) { this.polylineSegmentLengthToolTipFeedback = null; }
            if (this.polylineSegmentAngleToolTipFeedback === undefined) { this.polylineSegmentAngleToolTipFeedback = null; }
        }
    }
    AbstractPolylineState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.AbstractPolylineState";


    /**
     * Label rotation state. This state manages the rotation of a label.
     * @extends PlanController.ControllerState
     * @class
     */
    export class LabelRotationState extends PlanController.ControllerState {
        public __parent: any;
        static STEP_COUNT: number = 24;

        selectedLabel: Label;

        oldAngle: number;

        angleMousePress: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.selectedLabel = <Label><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedLabel.getY() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedLabel.getX());
            this.oldAngle = this.selectedLabel.getAngle();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedLabel.getX() || y !== this.selectedLabel.getY()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedLabel.getY() - y, x - this.selectedLabel.getX());
                let newAngle: number = this.oldAngle - angleMouseMove + this.angleMousePress;
                if (this.alignmentActivated || this.magnetismEnabled) {
                    const angleStep: number = 2 * <number>Math.PI / LabelRotationState.STEP_COUNT;
                    newAngle = Math.round(newAngle / angleStep) * angleStep;
                }
                this.selectedLabel.setAngle(newAngle);
                this.__parent.getView().makePointVisible(x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postLabelRotation(this.selectedLabel, this.oldAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedLabel.setAngle(this.oldAngle);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().setResizeIndicatorVisible(false);
            this.selectedLabel = null;
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedLabel === undefined) { this.selectedLabel = null; }
            if (this.oldAngle === undefined) { this.oldAngle = 0; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    LabelRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelRotationState";


    /**
     * Label elevation state. This states manages the elevation change of a label.
     * @extends PlanController.ControllerState
     * @class
     */
    export class LabelElevationState extends PlanController.ControllerState {
        public __parent: any;
        magnetismEnabled: boolean;

        deltaYToElevationPoint: number;

        selectedLabel: Label;

        oldElevation: number;

        elevationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.elevationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "elevationToolTipFeedback");
            this.selectedLabel = <Label><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            const textStyle: TextStyle = this.__parent.getItemTextStyle(this.selectedLabel, this.selectedLabel.getStyle());
            const textBounds: number[][] = this.__parent.getView().getTextBounds(this.selectedLabel.getText(), textStyle, this.selectedLabel.getX(), this.selectedLabel.getY(), this.selectedLabel.getAngle());
            this.deltaYToElevationPoint = this.__parent.getYLastMousePress() - (textBounds[2][1] + textBounds[3][1]) / 2;
            this.oldElevation = this.selectedLabel.getElevation();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldElevation), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const textStyle: TextStyle = this.__parent.getItemTextStyle(this.selectedLabel, this.selectedLabel.getStyle());
            const textBounds: number[][] = this.__parent.getView().getTextBounds(this.selectedLabel.getText(), textStyle, this.selectedLabel.getX(), this.selectedLabel.getY(), this.selectedLabel.getAngle());
            const deltaY: number = y - this.deltaYToElevationPoint - (textBounds[2][1] + textBounds[3][1]) / 2;
            let newElevation: number = this.oldElevation - deltaY;
            newElevation = Math.min(Math.max(newElevation, 0.0), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumElevation());
            if (this.magnetismEnabled) {
                newElevation = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newElevation, planView.getPixelLength());
            }
            this.selectedLabel.setElevation(newElevation);
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newElevation), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postLabelElevation(this.selectedLabel, this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedLabel.setElevation(this.oldElevation);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedLabel = null;
        }

        getToolTipFeedbackText(height: number): string {
            return CoreTools.format(this.elevationToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(height));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.deltaYToElevationPoint === undefined) { this.deltaYToElevationPoint = 0; }
            if (this.selectedLabel === undefined) { this.selectedLabel = null; }
            if (this.oldElevation === undefined) { this.oldElevation = 0; }
            if (this.elevationToolTipFeedback === undefined) { this.elevationToolTipFeedback = null; }
        }
    }
    LabelElevationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelElevationState";


    /**
     * Compass rotation state. This states manages the rotation of the compass.
     * @extends PlanController.ControllerState
     * @class
     */
    export class CompassRotationState extends PlanController.ControllerState {
        public __parent: any;
        selectedCompass: Compass;

        angleMousePress: number;

        oldNorthDirection: number;

        rotationToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.rotationToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "rotationToolTipFeedback");
            this.selectedCompass = <Compass><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.angleMousePress = <number>Math.atan2(this.selectedCompass.getY() - this.__parent.getYLastMousePress(), this.__parent.getXLastMousePress() - this.selectedCompass.getX());
            this.oldNorthDirection = this.selectedCompass.getNorthDirection();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldNorthDirection), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (x !== this.selectedCompass.getX() || y !== this.selectedCompass.getY()) {
                const angleMouseMove: number = <number>Math.atan2(this.selectedCompass.getY() - y, x - this.selectedCompass.getX());
                let newNorthDirection: number = this.oldNorthDirection - angleMouseMove + this.angleMousePress;
                const angleStep: number = <number>Math.PI / 180;
                newNorthDirection = Math.round(newNorthDirection / angleStep) * angleStep;
                newNorthDirection = <number>((newNorthDirection + 2 * Math.PI) % (2 * Math.PI));
                this.selectedCompass.setNorthDirection(newNorthDirection);
                const planView: PlanView = this.__parent.getView();
                planView.makePointVisible(x, y);
                if (this.__parent.feedbackDisplayed) {
                    planView.setToolTipFeedback(this.getToolTipFeedbackText(newNorthDirection), x, y);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postCompassRotation(this.selectedCompass, this.oldNorthDirection);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedCompass.setNorthDirection(this.oldNorthDirection);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedCompass = null;
        }

        getToolTipFeedbackText(angle: number): string {
            return CoreTools.format(this.rotationToolTipFeedback, Math.round(/* toDegrees */(x => x * 180 / Math.PI)(angle)));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedCompass === undefined) { this.selectedCompass = null; }
            if (this.angleMousePress === undefined) { this.angleMousePress = 0; }
            if (this.oldNorthDirection === undefined) { this.oldNorthDirection = 0; }
            if (this.rotationToolTipFeedback === undefined) { this.rotationToolTipFeedback = null; }
        }
    }
    CompassRotationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CompassRotationState";


    /**
     * Compass resize state. This states manages the resizing of the compass.
     * @extends PlanController.ControllerState
     * @class
     */
    export class CompassResizeState extends PlanController.ControllerState {
        public __parent: any;
        selectedCompass: Compass;

        oldDiameter: number;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        resizeToolTipFeedback: string;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            this.resizeToolTipFeedback = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLocalizedString(PlanController, "diameterToolTipFeedback");
            this.selectedCompass = <Compass><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            const compassPoints: number[][] = this.selectedCompass.getPoints();
            const xMiddleSecondAndThirdPoint: number = (compassPoints[1][0] + compassPoints[2][0]) / 2;
            const yMiddleSecondAndThirdPoint: number = (compassPoints[1][1] + compassPoints[2][1]) / 2;
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - xMiddleSecondAndThirdPoint;
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - yMiddleSecondAndThirdPoint;
            this.oldDiameter = this.selectedCompass.getDiameter();
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.oldDiameter), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let newDiameter: number = <number>java.awt.geom.Point2D.distance(this.selectedCompass.getX(), this.selectedCompass.getY(), x - this.deltaXToResizePoint, y - this.deltaYToResizePoint) * 2;
            newDiameter = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMagnetizedLength(newDiameter, planView.getPixelLength());
            newDiameter = Math.min(Math.max(newDiameter, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMinimumLength()), this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength() / 10);
            this.selectedCompass.setDiameter(newDiameter);
            planView.makePointVisible(x, y);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(newDiameter), x, y);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postCompassResize(this.selectedCompass, this.oldDiameter);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public escape() {
            this.selectedCompass.setDiameter(this.oldDiameter);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedCompass = null;
        }

        getToolTipFeedbackText(diameter: number): string {
            return CoreTools.format(this.resizeToolTipFeedback, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getFormatWithUnit().format(diameter));
        }

        constructor(__parent: any) {
            super();
            this.__parent = __parent;
            if (this.selectedCompass === undefined) { this.selectedCompass = null; }
            if (this.oldDiameter === undefined) { this.oldDiameter = 0; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.resizeToolTipFeedback === undefined) { this.resizeToolTipFeedback = null; }
        }
    }
    CompassResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.CompassResizeState";


    /**
     * Default selection state. This state manages transition to other modes,
     * the deletion of selected items, and the move of selected items with arrow keys.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class SelectionState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        selectionListener: SelectionListener;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            if (this.__parent.getView() != null) {
                if (this.__parent.getPointerTypeLastMousePress() !== View.PointerType.TOUCH) {
                    this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                }
                this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.addSelectionListener(this.selectionListener);
                this.selectionListener.selectionChanged(null);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.__parent.getRotatedLabelAt(x, y) != null || this.__parent.getYawRotatedCameraAt(x, y) != null || this.__parent.getPitchRotatedCameraAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getElevatedLabelAt(x, y) != null || this.__parent.getElevatedCameraAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ELEVATION);
            } else if (this.__parent.getRoomNameAt(x, y) != null || this.__parent.getRoomAreaAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.RESIZE);
            } else if (this.__parent.getRoomRotatedNameAt(x, y) != null || this.__parent.getRoomRotatedAreaAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getResizedDimensionLineStartAt(x, y) != null || this.__parent.getResizedDimensionLineEndAt(x, y) != null || this.__parent.getHeightResizedDimensionLineAt(x, y) != null || this.__parent.getWidthAndDepthResizedPieceOfFurnitureAt(x, y) != null || this.__parent.getResizedWallStartAt(x, y) != null || this.__parent.getResizedWallEndAt(x, y) != null || this.__parent.getResizedPolylineAt(x, y) != null || this.__parent.getResizedRoomAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.RESIZE);
            } else if (this.__parent.getPitchRotatedPieceOfFurnitureAt(x, y) != null || this.__parent.getRollRotatedPieceOfFurnitureAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getModifiedLightPowerAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.POWER);
            } else if (this.__parent.getOffsetDimensionLineAt(x, y) != null || this.__parent.getHeightResizedPieceOfFurnitureAt(x, y) != null || this.__parent.getArcExtentWallAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.HEIGHT);
            } else if (this.__parent.getRotatedPieceOfFurnitureAt(x, y) != null || this.__parent.getPitchRotatedDimensionLineAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getElevatedPieceOfFurnitureAt(x, y) != null || this.__parent.getElevatedDimensionLineAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ELEVATION);
            } else if (this.__parent.getPieceOfFurnitureNameAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.RESIZE);
            } else if (this.__parent.getPieceOfFurnitureRotatedNameAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getRotatedCompassAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.ROTATION);
            } else if (this.__parent.getResizedCompassAt(x, y) != null) {
                this.__parent.getView().setCursor(PlanView.CursorType.RESIZE);
            } else {
                if (this.__parent.isItemSelectedAt(x, y)) {
                    this.__parent.getView().setCursor(PlanView.CursorType.MOVE);
                } else {
                    this.__parent.getView().setCursor(PlanView.CursorType.SELECTION);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 1) {
                if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                    this.moveMouse(x, y);
                }
                if (this.__parent.getRotatedLabelAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getLabelRotationState());
                } else if (this.__parent.getYawRotatedCameraAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getCameraYawRotationState());
                } else if (this.__parent.getPitchRotatedCameraAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getCameraPitchRotationState());
                } else if (this.__parent.getElevatedLabelAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getLabelElevationState());
                } else if (this.__parent.getElevatedCameraAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getCameraElevationState());
                } else if (this.__parent.getRoomNameAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getRoomNameOffsetState());
                } else if (this.__parent.getRoomRotatedNameAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getRoomNameRotationState());
                } else if (this.__parent.getRoomAreaAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getRoomAreaOffsetState());
                } else if (this.__parent.getRoomRotatedAreaAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getRoomAreaRotationState());
                } else if (this.__parent.getResizedDimensionLineStartAt(x, y) != null || this.__parent.getResizedDimensionLineEndAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getDimensionLineResizeState());
                } else if (this.__parent.getHeightResizedDimensionLineAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getDimensionLineHeightState());
                } else if (this.__parent.getWidthAndDepthResizedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureResizeState());
                } else if (this.__parent.getResizedWallStartAt(x, y) != null || this.__parent.getResizedWallEndAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getWallResizeState());
                } else if (this.__parent.getResizedRoomAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getRoomResizeState());
                } else if (this.__parent.getOffsetDimensionLineAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getDimensionLineOffsetState());
                } else if (this.__parent.getResizedPolylineAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPolylineResizeState());
                } else if (this.__parent.getPitchRotatedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurniturePitchRotationState());
                } else if (this.__parent.getRollRotatedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureRollRotationState());
                } else if (this.__parent.getModifiedLightPowerAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getLightPowerModificationState());
                } else if (this.__parent.getHeightResizedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureHeightState());
                } else if (this.__parent.getArcExtentWallAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getWallArcExtentState());
                } else if (this.__parent.getRotatedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureRotationState());
                } else if (this.__parent.getPitchRotatedDimensionLineAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getDimensionLinePitchRotationState());
                } else if (this.__parent.getElevatedPieceOfFurnitureAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureElevationState());
                } else if (this.__parent.getElevatedDimensionLineAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getDimensionLineElevationState());
                } else if (this.__parent.getPieceOfFurnitureNameAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureNameOffsetState());
                } else if (this.__parent.getPieceOfFurnitureRotatedNameAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getPieceOfFurnitureNameRotationState());
                } else if (this.__parent.getRotatedCompassAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getCompassRotationState());
                } else if (this.__parent.getResizedCompassAt(x, y) != null) {
                    this.__parent.setState(this.__parent.getCompassResizeState());
                } else {
                    if (!shiftDown && (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH || this.__parent.getSelectableItemAt(x, y) != null)) {
                        this.__parent.setState(this.__parent.getSelectionMoveState());
                    } else {
                        this.__parent.setState(this.__parent.getRectangleSelectionState());
                    }
                }
            } else if (clickCount === 2) {
                const item: Selectable = this.__parent.getSelectableItemAt(x, y);
                if (!shiftDown && item != null) {
                    this.__parent.modifySelectedItem();
                }
            }
        }

        /**
         * 
         */
        public exit() {
            if (this.__parent.getView() != null) {
                this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.removeSelectionListener(this.selectionListener);
                this.__parent.getView().setResizeIndicatorVisible(false);
            }
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            this.selectionListener = new SelectionState.SelectionState$0(this);
        }
    }
    SelectionState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.SelectionState";


    export namespace SelectionState {

        export class SelectionState$0 implements SelectionListener {
            public __parent: any;
            public selectionChanged(selectionEvent: SelectionEvent) {
                const selectedItems: Array<Selectable> = this.__parent.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
                this.__parent.__parent.getView().setResizeIndicatorVisible(/* size */(<number>selectedItems.length) === 1 && (this.__parent.__parent.isItemResizable(/* get */selectedItems[0]) || this.__parent.__parent.isItemMovable(/* get */selectedItems[0])));
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        SelectionState$0["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];


    }


    /**
     * Wall creation state. This state manages transition to other modes,
     * and initial wall creation.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class WallCreationState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        magnetismEnabled: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.WALL_CREATION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.DRAW);
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.magnetismEnabled) {
                const point: PlanController.WallPointWithAngleMagnetism = new PlanController.WallPointWithAngleMagnetism(this.__parent, null, x, y, x, y);
                x = point.getX();
                y = point.getY();
            }
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setAlignmentFeedback(Wall, null, x, y, false);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            this.__parent.setState(this.__parent.getWallDrawingState());
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            if (editionActivated) {
                this.__parent.setState(this.__parent.getWallDrawingState());
                this.setEditionActivated(editionActivated);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.__parent.getPointerTypeLastMousePress() !== View.PointerType.TOUCH) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
        }
    }
    WallCreationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallCreationState";


    /**
     * Dimension line creation state. This state manages transition to
     * other modes, and initial dimension line creation.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class DimensionLineCreationState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        magnetismEnabled: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.DIMENSION_LINE_CREATION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.DRAW);
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setAlignmentFeedback(DimensionLine, null, x, y, false);
                const dimensionLine: DimensionLine = this.__parent.getMeasuringDimensionLineAt(x, y, this.magnetismEnabled);
                if (dimensionLine != null) {
                    this.__parent.getView().setDimensionLinesFeedback(/* asList */[dimensionLine].slice(0));
                } else {
                    this.__parent.getView().setDimensionLinesFeedback(null);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 1) {
                if (this.__parent.wasDuplicationActivatedLastMousePress()) {
                    this.__parent.getView().deleteFeedback();
                    this.__parent.createDimensionLine(x, y);
                } else {
                    this.__parent.setState(this.__parent.getDimensionLineDrawingState());
                }
            }
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            if (editionActivated) {
                this.__parent.setState(this.__parent.getDimensionLineDrawingState());
                this.setEditionActivated(editionActivated);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.__parent.getPointerTypeLastMousePress() !== View.PointerType.TOUCH) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
        }
    }
    DimensionLineCreationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.DimensionLineCreationState";


    /**
     * Room creation state. This state manages transition to
     * other modes, and initial room creation.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class RoomCreationState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        magnetismEnabled: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.ROOM_CREATION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.DRAW);
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            if (this.__parent.feedbackDisplayed && this.magnetismEnabled) {
                const point: PlanController.PointMagnetizedToClosestWallOrRoomPoint = new PlanController.PointMagnetizedToClosestWallOrRoomPoint(this.__parent, x, y);
                if (point.isMagnetized()) {
                    this.__parent.getView().setAlignmentFeedback(Room, null, point.getX(), point.getY(), point.isMagnetized());
                } else {
                    const pointWithAngleMagnetism: PlanController.RoomPointWithAngleMagnetism = new PlanController.RoomPointWithAngleMagnetism(this.__parent, null, -1, this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove(), this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                    this.__parent.getView().setAlignmentFeedback(Room, null, pointWithAngleMagnetism.getX(), pointWithAngleMagnetism.getY(), point.isMagnetized());
                }
            } else {
                this.__parent.getView().setAlignmentFeedback(Room, null, x, y, false);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            this.__parent.setState(this.__parent.getRoomDrawingState());
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            if (editionActivated) {
                this.__parent.setState(this.__parent.getRoomDrawingState());
                this.setEditionActivated(editionActivated);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.__parent.getPointerTypeLastMousePress() !== View.PointerType.TOUCH) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
        }
    }
    RoomCreationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomCreationState";


    /**
     * Polyline creation state. This state manages transition to
     * other modes, and initial polyline creation.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class PolylineCreationState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.POLYLINE_CREATION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.DRAW);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            this.__parent.setState(this.__parent.getPolylineDrawingState());
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            if (editionActivated) {
                this.__parent.setState(this.__parent.getPolylineDrawingState());
                this.setEditionActivated(editionActivated);
            }
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
        }
    }
    PolylineCreationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PolylineCreationState";


    /**
     * Label creation state. This state manages transition to
     * other modes, and initial label creation.
     * @extends PlanController.AbstractModeChangeState
     * @class
     */
    export class LabelCreationState extends PlanController.AbstractModeChangeState {
        public __parent: any;
        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.LABEL_CREATION_$LI$();
        }

        /**
         * 
         */
        public enter() {
            this.__parent.getView().setCursor(PlanView.CursorType.DRAW);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            this.__parent.createLabel(x, y);
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            }
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
        }
    }
    LabelCreationState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.LabelCreationState";


    /**
     * Wall drawing state. This state manages wall creation at each mouse press.
     * @extends PlanController.AbstractWallState
     * @class
     */
    export class WallDrawingState extends PlanController.AbstractWallState {
        public __parent: any;
        xStart: number;

        yStart: number;

        xLastEnd: number;

        yLastEnd: number;

        wallStartAtStart: Wall;

        wallEndAtStart: Wall;

        newWall: Wall;

        wallStartAtEnd: Wall;

        wallEndAtEnd: Wall;

        lastWall: Wall;

        oldSelection: Array<Selectable>;

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        newWalls: Array<Wall>;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        roundWall: boolean;

        lastWallCreationTime: number;

        wallArcExtent: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.WALL_CREATION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            this.escape();
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.PANNING_$LI$()) {
                this.__parent.setState(this.__parent.getPanningState());
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getRoomCreationState());
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.oldSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.oldBasePlanLocked = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            this.oldAllLevelsSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            this.xStart = this.__parent.getXLastMouseMove();
            this.yStart = this.__parent.getYLastMouseMove();
            this.wallEndAtStart = this.__parent.getWallEndAt(this.xStart, this.yStart, null);
            if (this.wallEndAtStart != null) {
                this.wallStartAtStart = null;
                this.xStart = this.wallEndAtStart.getXEnd();
                this.yStart = this.wallEndAtStart.getYEnd();
            } else {
                this.wallStartAtStart = this.__parent.getWallStartAt(this.xStart, this.yStart, null);
                if (this.wallStartAtStart != null) {
                    this.xStart = this.wallStartAtStart.getXStart();
                    this.yStart = this.wallStartAtStart.getYStart();
                } else if (this.magnetismEnabled) {
                    const point: PlanController.WallPointWithAngleMagnetism = new PlanController.WallPointWithAngleMagnetism(this.__parent, null, this.xStart, this.yStart, this.xStart, this.yStart);
                    this.xStart = point.getX();
                    this.yStart = point.getY();
                }
            }
            this.newWall = null;
            this.wallStartAtEnd = null;
            this.wallEndAtEnd = null;
            this.lastWall = null;
            this.newWalls = <any>([]);
            this.lastWallCreationTime = -1;
            this.__parent.deselectAll();
            this.setDuplicationActivated(this.__parent.wasDuplicationActivatedLastMousePress());
            if (this.__parent.feedbackDisplayed) {
                this.__parent.getView().setAlignmentFeedback(Wall, null, this.xStart, this.yStart, false);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let xEnd: number;
            let yEnd: number;
            if (this.alignmentActivated) {
                const point: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.xStart, this.yStart, x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                xEnd = point.getX();
                yEnd = point.getY();
            } else if (this.magnetismEnabled) {
                const point: PlanController.WallPointWithAngleMagnetism = new PlanController.WallPointWithAngleMagnetism(this.__parent, this.newWall, this.xStart, this.yStart, x, y);
                xEnd = point.getX();
                yEnd = point.getY();
            } else {
                xEnd = x;
                yEnd = y;
            }
            if (this.newWall == null) {
                this.newWall = this.__parent.createWall(this.xStart, this.yStart, xEnd, yEnd, this.wallStartAtStart, this.wallEndAtStart);
                /* add */(this.newWalls.push(this.newWall) > 0);
            } else if (this.wallArcExtent != null) {
                this.wallArcExtent = this.getArcExtent(this.newWall.getXStart(), this.newWall.getXEnd(), this.newWall.getYStart(), this.newWall.getYEnd(), x, y);
                if (this.alignmentActivated || this.magnetismEnabled) {
                    this.wallArcExtent = <number>/* toRadians */(x => x * Math.PI / 180)(Math.round(/* toDegrees */(x => x * 180 / Math.PI)(this.wallArcExtent)));
                }
                this.newWall.setArcExtent(this.wallArcExtent);
            } else {
                this.newWall.setXEnd(xEnd);
                this.newWall.setYEnd(yEnd);
            }
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.newWall, false), x, y);
                planView.setAlignmentFeedback(Wall, this.newWall, xEnd, yEnd, false);
                this.showWallAngleFeedback(this.newWall, false);
            }
            this.wallStartAtEnd = this.__parent.getWallStartAt(xEnd, yEnd, this.newWall);
            if (this.wallStartAtEnd != null) {
                this.wallEndAtEnd = null;
                this.__parent.selectItem(this.wallStartAtEnd);
            } else {
                this.wallEndAtEnd = this.__parent.getWallEndAt(xEnd, yEnd, this.newWall);
                if (this.wallEndAtEnd != null) {
                    this.__parent.selectItem(this.wallEndAtEnd);
                } else {
                    this.__parent.deselectAll();
                }
            }
            planView.makePointVisible(x, y);
            this.xLastEnd = xEnd;
            this.yLastEnd = yEnd;
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 2) {
                const selectableItem: Selectable = this.__parent.getSelectableItemAt(x, y);
                if (/* size */(<number>this.newWalls.length) === 0 && (selectableItem != null && selectableItem instanceof <any>Room)) {
                    this.createWallsAroundRoom(<Room><any>selectableItem);
                } else {
                    if (this.roundWall && this.newWall != null) {
                        this.endWallCreation();
                    }
                    if (this.lastWall != null) {
                        this.__parent.joinNewWallEndToWall(this.lastWall, this.wallStartAtEnd, this.wallEndAtEnd);
                    }
                }
                this.validateDrawnWalls();
            } else {
                if (this.newWall != null && this.newWall.getStartPointToEndPointDistance() > 0) {
                    if (this.roundWall && this.wallArcExtent == null) {
                        this.wallArcExtent = <number>Math.PI;
                        this.newWall.setArcExtent(this.wallArcExtent);
                        if (this.__parent.feedbackDisplayed) {
                            this.__parent.getView().setToolTipFeedback(this.getToolTipFeedbackText(this.newWall, false), x, y);
                        }
                    } else {
                        this.__parent.getView().deleteToolTipFeedback();
                        this.__parent.selectItem(this.newWall);
                        this.endWallCreation();
                    }
                }
            }
        }

        /**
         * Creates walls around the given <code>room</code>.
         * @param {Room} room
         * @private
         */
        createWallsAroundRoom(room: Room) {
            if (room.isSingular()) {
                let roomPoints: number[][] = room.getPoints();
                const pointsList: Array<number[]> = <any>(/* asList */roomPoints.slice(0).slice(0));
                if (!room.isClockwise()) {
                    /* reverse */pointsList.reverse();
                }
                for (let i: number = 0; i < /* size */(<number>pointsList.length);) {
                    {
                        const point: number[] = /* get */pointsList[i];
                        const nextPoint: number[] = /* get */pointsList[(i + 1) % /* size */(<number>pointsList.length)];
                        if (point[0] === nextPoint[0] && point[1] === nextPoint[1]) {
                        /* remove */pointsList.splice(i, 1)[0];
                        } else {
                            i++;
                        }
                    };
                }
                roomPoints = /* toArray */pointsList.slice(0);
                const halfWallThickness: number = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getNewWallThickness() / 2;
                const largerRoomPoints: number[][] = (s => { let a = []; while (s-- > 0) a.push(null); return a; })(roomPoints.length);
                for (let i: number = 0; i < roomPoints.length; i++) {
                    {
                        const point: number[] = roomPoints[i];
                        const previousPoint: number[] = roomPoints[(i + roomPoints.length - 1) % roomPoints.length];
                        const nextPoint: number[] = roomPoints[(i + 1) % roomPoints.length];
                        const previousAngle: number = Math.atan2(point[0] - previousPoint[0], previousPoint[1] - point[1]);
                        let deltaX: number = <number>(Math.cos(previousAngle) * halfWallThickness);
                        let deltaY: number = <number>(Math.sin(previousAngle) * halfWallThickness);
                        const point1: number[] = [previousPoint[0] - deltaX, previousPoint[1] - deltaY];
                        const point2: number[] = [point[0] - deltaX, point[1] - deltaY];
                        const nextAngle: number = Math.atan2(nextPoint[0] - point[0], point[1] - nextPoint[1]);
                        deltaX = <number>(Math.cos(nextAngle) * halfWallThickness);
                        deltaY = <number>(Math.sin(nextAngle) * halfWallThickness);
                        const point3: number[] = [point[0] - deltaX, point[1] - deltaY];
                        const point4: number[] = [nextPoint[0] - deltaX, nextPoint[1] - deltaY];
                        largerRoomPoints[i] = PlanController.computeIntersection(point1, point2, point3, point4);
                    };
                }
                let lastWall: Wall = null;
                const wallsArea: java.awt.geom.Area = this.__parent.getWallsArea(false);
                const thinThickness: number = 0.05;
                for (let i: number = 0; i < largerRoomPoints.length; i++) {
                    {
                        const sidePoint: number[] = largerRoomPoints[i];
                        const nextSidePoint: number[] = largerRoomPoints[(i + 1) % roomPoints.length];
                        const lineArea: java.awt.geom.Area = new java.awt.geom.Area(this.__parent.getPath(new Wall(sidePoint[0], sidePoint[1], nextSidePoint[0], nextSidePoint[1], thinThickness, 0).getPoints$()));
                        lineArea.subtract(wallsArea);
                        const newWallPaths: Array<java.awt.geom.GeneralPath> = this.__parent.getAreaPaths(lineArea);
                        const roomSideWalls: Array<Wall> = <any>([]);
                        let ignoredWall: number = 0;
                        for (let j: number = 0; j < /* size */(<number>newWallPaths.length); j++) {
                            {
                                let newWallPoints: number[][] = this.__parent.getPathPoints(/* get */newWallPaths[j], false);
                                if (newWallPoints.length > 4) {
                                    newWallPoints = this.__parent.getPathPoints(/* get */newWallPaths[j], true);
                                }
                                if (newWallPoints.length === 4) {
                                    let point1: number[];
                                    let point2: number[];
                                    if (java.awt.geom.Point2D.distanceSq(newWallPoints[0][0], newWallPoints[0][1], newWallPoints[1][0], newWallPoints[1][1]) < java.awt.geom.Point2D.distanceSq(newWallPoints[0][0], newWallPoints[0][1], newWallPoints[3][0], newWallPoints[3][1])) {
                                        point1 = [(newWallPoints[0][0] + newWallPoints[1][0]) / 2, (newWallPoints[0][1] + newWallPoints[1][1]) / 2];
                                        point2 = [(newWallPoints[2][0] + newWallPoints[3][0]) / 2, (newWallPoints[2][1] + newWallPoints[3][1]) / 2];
                                    } else {
                                        point1 = [(newWallPoints[0][0] + newWallPoints[3][0]) / 2, (newWallPoints[0][1] + newWallPoints[3][1]) / 2];
                                        point2 = [(newWallPoints[1][0] + newWallPoints[2][0]) / 2, (newWallPoints[1][1] + newWallPoints[2][1]) / 2];
                                    }
                                    let startPoint: number[];
                                    let endPoint: number[];
                                    if (java.awt.geom.Point2D.distanceSq(point1[0], point1[1], sidePoint[0], sidePoint[1]) < java.awt.geom.Point2D.distanceSq(point2[0], point2[1], sidePoint[0], sidePoint[1])) {
                                        startPoint = point1;
                                        endPoint = point2;
                                    } else {
                                        startPoint = point2;
                                        endPoint = point1;
                                    }
                                    if (java.awt.geom.Point2D.distanceSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1]) > 0.01) {
                                /* add */(roomSideWalls.push(this.__parent.createWall(startPoint[0], startPoint[1], endPoint[0], endPoint[1], null, lastWall != null && java.awt.geom.Point2D.distanceSq(lastWall.getXEnd(), lastWall.getYEnd(), startPoint[0], startPoint[1]) < 0.01 ? lastWall : null)) > 0);
                                    } else {
                                        ignoredWall++;
                                    }
                                }
                            };
                        }
                        if (/* size */(<number>newWallPaths.length) > ignoredWall && /* isEmpty */(roomSideWalls.length == 0)) {
                            let existingWall: Wall = null;
                            {
                                let array = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getWalls();
                                for (let index = 0; index < array.length; index++) {
                                    let wall = array[index];
                                    {
                                        if (wall.isAtLevel(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel()) && Math.abs(wall.getXStart() - sidePoint[0]) < 0.05 && Math.abs(wall.getYStart() - sidePoint[1]) < 0.05 && Math.abs(wall.getXEnd() - nextSidePoint[0]) < 0.05 && Math.abs(wall.getYEnd() - nextSidePoint[1]) < 0.05 && (wall.getArcExtent() == null || wall.getArcExtent() === 0)) {
                                            existingWall = wall;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (existingWall == null) {
                            /* add */(roomSideWalls.push(this.__parent.createWall(sidePoint[0], sidePoint[1], nextSidePoint[0], nextSidePoint[1], null, lastWall)) > 0);
                            }
                        }
                        if (/* size */(<number>roomSideWalls.length) > 0) {
                        /* sort */((l, c) => { if ((<any>c).compare) l.sort((e1, e2) => (<any>c).compare(e1, e2)); else l.sort(<any>c); })(roomSideWalls, new WallDrawingState.WallDrawingState$0(this, sidePoint));
                        /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.newWalls, roomSideWalls);
                            lastWall = /* get */roomSideWalls[/* size */(<number>roomSideWalls.length) - 1];
                        } else {
                            lastWall = null;
                        }
                    };
                }
                if (lastWall != null && java.awt.geom.Point2D.distanceSq(lastWall.getXEnd(), lastWall.getYEnd(), /* get */this.newWalls[0].getXStart(), /* get */this.newWalls[0].getYStart()) < 0.01) {
                    this.__parent.joinNewWallEndToWall(lastWall, /* get */this.newWalls[0], null);
                }
            }
        }

        validateDrawnWalls() {
            if (/* size */(<number>this.newWalls.length) > 0) {
                this.__parent.postCreateWalls(this.newWalls, this.oldSelection, this.oldBasePlanLocked, this.oldAllLevelsSelection);
                this.__parent.selectItems(this.newWalls);
            }
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else {
                this.__parent.setState(this.__parent.getWallCreationState());
            }
        }

        endWallCreation() {
            this.lastWall = this.wallEndAtStart = this.newWall;
            this.wallStartAtStart = null;
            this.xStart = this.newWall.getXEnd();
            this.yStart = this.newWall.getYEnd();
            this.newWall = null;
            this.wallArcExtent = null;
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            const planView: PlanView = this.__parent.getView();
            if (editionActivated) {
                planView.deleteFeedback();
                if (/* size */(<number>this.newWalls.length) === 0 && this.wallEndAtStart == null && this.wallStartAtStart == null) {
                    planView.setToolTipEditedProperties(["X", "Y"], [this.xStart, this.yStart], this.xStart, this.yStart);
                } else {
                    if (this.newWall == null) {
                        this.createNextWall();
                    }
                    if (this.wallArcExtent == null) {
                        planView.setToolTipEditedProperties(["LENGTH", "ANGLE", "THICKNESS"], [this.newWall.getLength(), this.getWallAngleInDegrees$com_eteks_sweethome3d_model_Wall(this.newWall), this.newWall.getThickness()], this.newWall.getXEnd(), this.newWall.getYEnd());
                    } else {
                        planView.setToolTipEditedProperties(["ARC_EXTENT"], [new Number((<number>Math.round(/* toDegrees */(x => x * 180 / Math.PI)(this.wallArcExtent)) | 0)).valueOf()], this.newWall.getXEnd(), this.newWall.getYEnd());
                    }
                }
                if (this.__parent.feedbackDisplayed) {
                    this.showWallFeedback();
                }
            } else {
                if (this.newWall == null) {
                    const lengthUnit: any = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit();
                    const defaultLength: number = !lengthUnit.isMetric() ? 300 : LengthUnit.footToCentimeter(10);
                    this.xLastEnd = this.xStart + defaultLength;
                    this.yLastEnd = this.yStart;
                    this.newWall = this.__parent.createWall(this.xStart, this.yStart, this.xLastEnd, this.yLastEnd, this.wallStartAtStart, this.wallEndAtStart);
                    /* add */(this.newWalls.push(this.newWall) > 0);
                    planView.deleteFeedback();
                    this.setEditionActivated(true);
                } else if (this.roundWall && this.wallArcExtent == null) {
                    this.wallArcExtent = <number>Math.PI;
                    this.newWall.setArcExtent(this.wallArcExtent);
                    this.setEditionActivated(true);
                } else if (/* currentTimeMillis */Date.now() - this.lastWallCreationTime < 300) {
                    if (/* size */(<number>this.newWalls.length) > 1) {
                        /* remove */(a => { let index = a.indexOf(this.newWall); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.newWalls);
                        this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteWall(this.newWall);
                    }
                    this.validateDrawnWalls();
                } else {
                    this.endWallCreation();
                    if (/* size */(<number>this.newWalls.length) > 2 && this.wallStartAtEnd != null) {
                        this.__parent.joinNewWallEndToWall(this.lastWall, this.wallStartAtEnd, null);
                        this.validateDrawnWalls();
                        return;
                    }
                    this.createNextWall();
                    planView.deleteToolTipFeedback();
                    this.setEditionActivated(true);
                }
            }
        }

        createNextWall() {
            const previousWall: Wall = this.wallEndAtStart != null ? this.wallEndAtStart : this.wallStartAtStart;
            let previousWallAngle: number = Math.PI - Math.atan2(previousWall.getYStart() - previousWall.getYEnd(), previousWall.getXStart() - previousWall.getXEnd());
            previousWallAngle -= Math.PI / 2;
            const previousWallSegmentDistance: number = previousWall.getStartPointToEndPointDistance();
            this.xLastEnd = <number>(this.xStart + previousWallSegmentDistance * Math.cos(previousWallAngle));
            this.yLastEnd = <number>(this.yStart - previousWallSegmentDistance * Math.sin(previousWallAngle));
            this.newWall = this.__parent.createWall(this.xStart, this.yStart, this.xLastEnd, this.yLastEnd, this.wallStartAtStart, previousWall);
            this.newWall.setThickness(previousWall.getThickness());
            /* add */(this.newWalls.push(this.newWall) > 0);
            this.lastWallCreationTime = /* currentTimeMillis */Date.now();
            this.__parent.deselectAll();
        }

        /**
         * 
         * @param {string} editableProperty
         * @param {Object} value
         */
        public updateEditableProperty(editableProperty: any, value: any) {
            if (this.newWall == null) {
                const maximumLength: number = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength();
                switch ((editableProperty)) {
                    case "X":
                        this.xStart = value != null ? /* floatValue */(<number>value) : 0;
                        this.xStart = Math.max(-maximumLength, Math.min(this.xStart, maximumLength));
                        break;
                    case "Y":
                        this.yStart = value != null ? /* floatValue */(<number>value) : 0;
                        this.yStart = Math.max(-maximumLength, Math.min(this.yStart, maximumLength));
                        break;
                }
            } else {
                if (editableProperty === "THICKNESS") {
                    let thickness: number = value != null ? Math.abs(/* floatValue */(<number>value)) : 0;
                    thickness = Math.max(0.01, Math.min(thickness, 1000));
                    this.newWall.setThickness(thickness);
                } else if (editableProperty === "ARC_EXTENT") {
                    const arcExtent: number = /* toRadians */(x => x * Math.PI / 180)(value != null ? /* doubleValue */(<number>value) : 0);
                    this.wallArcExtent = <number>(/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(arcExtent) * Math.min(Math.abs(arcExtent), 3 * Math.PI / 2));
                    this.newWall.setArcExtent(this.wallArcExtent);
                    if (this.__parent.feedbackDisplayed) {
                        this.showWallAngleFeedback(this.newWall, false);
                    }
                    return;
                } else {
                    switch ((editableProperty)) {
                        case "LENGTH":
                            let length: number = value != null ? /* floatValue */(<number>value) : 0;
                            length = Math.max(0.001, Math.min(length, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength()));
                            let wallAngle: number = Math.PI - Math.atan2(this.yStart - this.yLastEnd, this.xStart - this.xLastEnd);
                            this.xLastEnd = <number>(this.xStart + length * Math.cos(wallAngle));
                            this.yLastEnd = <number>(this.yStart - length * Math.sin(wallAngle));
                            break;
                        case "ANGLE":
                            wallAngle = /* toRadians */(x => x * Math.PI / 180)(value != null ? /* doubleValue */(<number>value) : 0);
                            const previousWall: Wall = this.newWall.getWallAtStart();
                            if (previousWall != null && previousWall.getStartPointToEndPointDistance() > 0) {
                                wallAngle -= Math.atan2(previousWall.getYStart() - previousWall.getYEnd(), previousWall.getXStart() - previousWall.getXEnd());
                            }
                            const startPointToEndPointDistance: number = this.newWall.getStartPointToEndPointDistance();
                            this.xLastEnd = <number>(this.xStart + startPointToEndPointDistance * Math.cos(wallAngle));
                            this.yLastEnd = <number>(this.yStart - startPointToEndPointDistance * Math.sin(wallAngle));
                            break;
                        default:
                            return;
                    }
                    this.newWall.setXEnd(this.xLastEnd);
                    this.newWall.setYEnd(this.yLastEnd);
                }
            }
            if (this.__parent.feedbackDisplayed) {
                this.showWallFeedback();
            }
        }

        showWallFeedback() {
            const planView: PlanView = this.__parent.getView();
            if (this.newWall == null) {
                planView.setAlignmentFeedback(Wall, null, this.xStart, this.yStart, true);
                planView.makePointVisible(this.xStart, this.yStart);
            } else {
                planView.setAlignmentFeedback(Wall, this.newWall, this.xLastEnd, this.yLastEnd, false);
                this.showWallAngleFeedback(this.newWall, false);
                planView.makePointVisible(this.xStart, this.yStart);
                planView.makePointVisible(this.xLastEnd, this.yLastEnd);
                if (/* size */(<number>this.newWalls.length) > 2 && /* get */this.newWalls[0].getWallAtStart() == null && /* get */this.newWalls[0].containsWallStartAt(this.xLastEnd, this.yLastEnd, 0.001)) {
                    this.wallStartAtEnd = /* get */this.newWalls[0];
                    this.__parent.selectItem(this.wallStartAtEnd);
                } else {
                    this.wallStartAtEnd = null;
                    this.__parent.deselectAll();
                }
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.newWall != null) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} duplicationActivated
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            this.roundWall = duplicationActivated;
        }

        /**
         * 
         */
        public escape() {
            if (this.newWall != null) {
                this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteWall(this.newWall);
                /* remove */(a => { let index = a.indexOf(this.newWall); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.newWalls);
            }
            this.validateDrawnWalls();
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.deleteFeedback();
            this.wallStartAtStart = null;
            this.wallEndAtStart = null;
            this.newWall = null;
            this.wallArcExtent = null;
            this.wallStartAtEnd = null;
            this.wallEndAtEnd = null;
            this.lastWall = null;
            this.oldSelection = null;
            this.newWalls = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.xStart === undefined) { this.xStart = 0; }
            if (this.yStart === undefined) { this.yStart = 0; }
            if (this.xLastEnd === undefined) { this.xLastEnd = 0; }
            if (this.yLastEnd === undefined) { this.yLastEnd = 0; }
            if (this.wallStartAtStart === undefined) { this.wallStartAtStart = null; }
            if (this.wallEndAtStart === undefined) { this.wallEndAtStart = null; }
            if (this.newWall === undefined) { this.newWall = null; }
            if (this.wallStartAtEnd === undefined) { this.wallStartAtEnd = null; }
            if (this.wallEndAtEnd === undefined) { this.wallEndAtEnd = null; }
            if (this.lastWall === undefined) { this.lastWall = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.newWalls === undefined) { this.newWalls = null; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.roundWall === undefined) { this.roundWall = false; }
            if (this.lastWallCreationTime === undefined) { this.lastWallCreationTime = 0; }
            if (this.wallArcExtent === undefined) { this.wallArcExtent = null; }
        }
    }
    WallDrawingState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallDrawingState";


    export namespace WallDrawingState {

        export class WallDrawingState$0 {
            public __parent: any;
            public compare(wall1: Wall, wall2: Wall): number {
                return /* compare */(java.awt.geom.Point2D.distanceSq(wall1.getXStart(), wall1.getYStart(), this.sidePoint[0], this.sidePoint[1]) - java.awt.geom.Point2D.distanceSq(wall2.getXStart(), wall2.getYStart(), this.sidePoint[0], this.sidePoint[1]));
            }

            constructor(__parent: any, private sidePoint: any) {
                this.__parent = __parent;
            }
        }

    }


    /**
     * Wall resize state. This state manages wall resizing.
     * @extends PlanController.AbstractWallState
     * @class
     */
    export class WallResizeState extends PlanController.AbstractWallState {
        public __parent: any;
        selectedWall: Wall;

        startPoint: boolean;

        oldX: number;

        oldY: number;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.selectedWall = <Wall><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.startPoint = this.selectedWall === this.__parent.getResizedWallStartAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
            if (this.startPoint) {
                this.oldX = this.selectedWall.getXStart();
                this.oldY = this.selectedWall.getYStart();
            } else {
                this.oldX = this.selectedWall.getXEnd();
                this.oldY = this.selectedWall.getYEnd();
            }
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - this.oldX;
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - this.oldY;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedWall, true), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
                planView.setAlignmentFeedback(Wall, this.selectedWall, this.oldX, this.oldY, false);
                this.showWallAngleFeedback(this.selectedWall, true);
                planView.setDimensionLinesFeedback(this.getDimensionLinesAlongWall(this.selectedWall));
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let newX: number = x - this.deltaXToResizePoint;
            let newY: number = y - this.deltaYToResizePoint;
            const opositeEndX: number = this.startPoint ? this.selectedWall.getXEnd() : this.selectedWall.getXStart();
            const opositeEndY: number = this.startPoint ? this.selectedWall.getYEnd() : this.selectedWall.getYStart();
            if (this.alignmentActivated) {
                const point: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(opositeEndX, opositeEndY, newX, newY, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                newX = point.getX();
                newY = point.getY();
            } else if (this.magnetismEnabled) {
                const point: PlanController.WallPointWithAngleMagnetism = new PlanController.WallPointWithAngleMagnetism(this.__parent, this.selectedWall, opositeEndX, opositeEndY, newX, newY);
                newX = point.getX();
                newY = point.getY();
            }
            PlanController.moveWallPoint(this.selectedWall, newX, newY, this.startPoint);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedWall, true), x, y);
                planView.setAlignmentFeedback(Wall, this.selectedWall, newX, newY, false);
                this.showWallAngleFeedback(this.selectedWall, true);
                planView.setDimensionLinesFeedback(this.getDimensionLinesAlongWall(this.selectedWall));
            }
            planView.makePointVisible(x, y);
        }

        getDimensionLinesAlongWall(wall: Wall): Array<DimensionLine> {
            const dimensionLines: Array<DimensionLine> = <any>([]);
            if (wall.getArcExtent() == null || wall.getArcExtent() === 0) {
                const offset: number = 20 / this.__parent.getView().getScale();
                const wallPoints: number[][] = wall.getPoints$();
                const roomPaths: Array<java.awt.geom.GeneralPath> = this.__parent.getRoomPathsFromWalls();
                for (let i: number = 0; i < /* size */(<number>roomPaths.length); i++) {
                    {
                        const roomPoints: number[][] = this.__parent.getPathPoints(/* get */roomPaths[i], true);
                        for (let j: number = 0; j < roomPoints.length; j++) {
                            {
                                const startPoint: number[] = roomPoints[j];
                                const endPoint: number[] = roomPoints[(j + 1) % roomPoints.length];
                                const segmentPartOfLeftSide: boolean = java.awt.geom.Line2D.ptLineDistSq(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], startPoint[0], startPoint[1]) < 1.0E-4 && java.awt.geom.Line2D.ptLineDistSq(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], endPoint[0], endPoint[1]) < 1.0E-4;
                                let segmentAccepted: boolean;
                                if (segmentPartOfLeftSide) {
                                    segmentAccepted = java.awt.geom.Line2D.ptSegDistSq(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], startPoint[0], startPoint[1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(wallPoints[0][0], wallPoints[0][1], wallPoints[1][0], wallPoints[1][1], endPoint[0], endPoint[1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], wallPoints[0][0], wallPoints[0][1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], wallPoints[1][0], wallPoints[1][1]) < 1.0E-4;
                                } else {
                                    segmentAccepted = java.awt.geom.Line2D.ptLineDistSq(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], startPoint[0], startPoint[1]) < 1.0E-4 && java.awt.geom.Line2D.ptLineDistSq(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], endPoint[0], endPoint[1]) < 1.0E-4 && (java.awt.geom.Line2D.ptSegDistSq(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], startPoint[0], startPoint[1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(wallPoints[2][0], wallPoints[2][1], wallPoints[3][0], wallPoints[3][1], endPoint[0], endPoint[1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], wallPoints[2][0], wallPoints[2][1]) < 1.0E-4 || java.awt.geom.Line2D.ptSegDistSq(startPoint[0], startPoint[1], endPoint[0], endPoint[1], wallPoints[3][0], wallPoints[3][1]) < 1.0E-4);
                                }
                                if (segmentAccepted) {
                            /* add */(dimensionLines.push(this.__parent.getDimensionLineBetweenPoints(startPoint, endPoint, this.isDimensionInsideWall(wall, startPoint, endPoint) ? -offset : offset, false)) > 0);
                                }
                            };
                        }
                    };
                }
                for (let i: number = /* size */(<number>dimensionLines.length) - 1; i >= 0; i--) {
                    {
                        if (/* get */dimensionLines[i].getLength() < 0.01) {
                        /* remove */dimensionLines.splice(i, 1)[0];
                        }
                    };
                }
                if (/* size */(<number>dimensionLines.length) === 2 && Math.abs(/* get */dimensionLines[0].getLength() - /* get */dimensionLines[1].getLength()) < 0.01) {
                    /* remove */dimensionLines.splice(1, 1)[0];
                }
            }
            return dimensionLines;
        }

        isDimensionInsideWall(wall: Wall, point1: number[], point2: number[]): boolean {
            const rotation: java.awt.geom.AffineTransform = java.awt.geom.AffineTransform.getRotateInstance(Math.atan2(point2[1] - point1[1], point2[0] - point1[0]), point1[0], point1[1]);
            const dimensionPoint: number[] = [<number>(point1[0] + java.awt.geom.Point2D.distance(point1[0], point1[1], point2[0], point2[1]) / 2), point1[1] + 0.01];
            rotation.transform(dimensionPoint, 0, dimensionPoint, 0, 1);
            return wall.containsPoint$float$float$float(dimensionPoint[0], dimensionPoint[1], 0);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postWallResize(this.selectedWall, this.oldX, this.oldY, this.startPoint);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            PlanController.moveWallPoint(this.selectedWall, this.oldX, this.oldY, this.startPoint);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedWall = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.selectedWall === undefined) { this.selectedWall = null; }
            if (this.startPoint === undefined) { this.startPoint = false; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    WallResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallResizeState";


    /**
     * Wall arc extent state. This state manages wall arc extent change.
     * @extends PlanController.AbstractWallState
     * @class
     */
    export class WallArcExtentState extends PlanController.AbstractWallState {
        public __parent: any;
        selectedWall: Wall;

        oldArcExtent: number;

        deltaXToMiddlePoint: number;

        deltaYToMiddlePoint: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.selectedWall = <Wall><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.oldArcExtent = this.selectedWall.getArcExtent();
            const wallPoints: number[][] = this.selectedWall.getPoints$();
            let leftSideMiddlePointIndex: number = (wallPoints.length / 4 | 0);
            const rightSideMiddlePointIndex: number = wallPoints.length - 1 - leftSideMiddlePointIndex;
            if (wallPoints.length % 4 === 0) {
                leftSideMiddlePointIndex--;
            }
            const middleX: number = (wallPoints[leftSideMiddlePointIndex][0] + wallPoints[rightSideMiddlePointIndex][0]) / 2;
            const middleY: number = (wallPoints[leftSideMiddlePointIndex][1] + wallPoints[rightSideMiddlePointIndex][1]) / 2;
            this.deltaXToMiddlePoint = this.__parent.getXLastMousePress() - middleX;
            this.deltaYToMiddlePoint = this.__parent.getYLastMousePress() - middleY;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedWall, false), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
                this.showWallAngleFeedback(this.selectedWall, false);
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            const newX: number = x - this.deltaXToMiddlePoint;
            const newY: number = y - this.deltaYToMiddlePoint;
            let arcExtent: number = this.getArcExtent(this.selectedWall.getXStart(), this.selectedWall.getYStart(), this.selectedWall.getXEnd(), this.selectedWall.getYEnd(), newX, newY);
            if (this.alignmentActivated || this.magnetismEnabled) {
                arcExtent = <number>/* toRadians */(x => x * Math.PI / 180)(Math.round(/* toDegrees */(x => x * 180 / Math.PI)(arcExtent)));
            }
            this.selectedWall.setArcExtent(arcExtent);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedWall, false), x, y);
                this.showWallAngleFeedback(this.selectedWall, false);
            }
            planView.makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postWallArcExtent(this.selectedWall, this.oldArcExtent);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedWall.setArcExtent(this.oldArcExtent);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedWall = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.selectedWall === undefined) { this.selectedWall = null; }
            if (this.oldArcExtent === undefined) { this.oldArcExtent = null; }
            if (this.deltaXToMiddlePoint === undefined) { this.deltaXToMiddlePoint = 0; }
            if (this.deltaYToMiddlePoint === undefined) { this.deltaYToMiddlePoint = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    WallArcExtentState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.WallArcExtentState";


    /**
     * Room drawing state. This state manages room creation at mouse press.
     * @extends PlanController.AbstractRoomState
     * @class
     */
    export class RoomDrawingState extends PlanController.AbstractRoomState {
        public __parent: any;
        xPreviousPoint: number;

        yPreviousPoint: number;

        newRoom: Room;

        newPoint: number[];

        oldSelection: Array<Selectable>;

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        lastPointCreationTime: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.ROOM_CREATION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            this.escape();
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.PANNING_$LI$()) {
                this.__parent.setState(this.__parent.getPanningState());
            } else if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getWallCreationState());
            } else if (mode === PlanController.Mode.POLYLINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.oldSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.oldBasePlanLocked = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            this.oldAllLevelsSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            this.newRoom = null;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            if (this.magnetismEnabled) {
                const point: PlanController.PointMagnetizedToClosestWallOrRoomPoint = new PlanController.PointMagnetizedToClosestWallOrRoomPoint(this.__parent, this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                if (point.isMagnetized()) {
                    this.xPreviousPoint = point.getX();
                    this.yPreviousPoint = point.getY();
                } else {
                    const pointWithAngleMagnetism: PlanController.RoomPointWithAngleMagnetism = new PlanController.RoomPointWithAngleMagnetism(this.__parent, null, -1, this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove(), this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
                    this.xPreviousPoint = pointWithAngleMagnetism.getX();
                    this.yPreviousPoint = pointWithAngleMagnetism.getY();
                }
                if (this.__parent.feedbackDisplayed) {
                    this.__parent.getView().setAlignmentFeedback(Room, null, this.xPreviousPoint, this.yPreviousPoint, point.isMagnetized());
                }
            } else {
                this.xPreviousPoint = this.__parent.getXLastMousePress();
                this.yPreviousPoint = this.__parent.getYLastMousePress();
                if (this.__parent.feedbackDisplayed) {
                    this.__parent.getView().setAlignmentFeedback(Room, null, this.xPreviousPoint, this.yPreviousPoint, false);
                }
            }
            this.__parent.deselectAll();
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let xEnd: number = x;
            let yEnd: number = y;
            let magnetizedPoint: boolean = false;
            if (this.alignmentActivated) {
                const pointWithAngleMagnetism: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.xPreviousPoint, this.yPreviousPoint, x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                xEnd = pointWithAngleMagnetism.getX();
                yEnd = pointWithAngleMagnetism.getY();
            } else if (this.magnetismEnabled) {
                const point: PlanController.PointMagnetizedToClosestWallOrRoomPoint = this.newRoom != null ? new PlanController.PointMagnetizedToClosestWallOrRoomPoint(this.__parent, this.newRoom, this.newRoom.getPointCount() - 1, x, y) : new PlanController.PointMagnetizedToClosestWallOrRoomPoint(this.__parent, x, y);
                magnetizedPoint = point.isMagnetized();
                if (magnetizedPoint) {
                    xEnd = point.getX();
                    yEnd = point.getY();
                } else {
                    const editedPointIndex: number = this.newRoom != null ? this.newRoom.getPointCount() - 1 : -1;
                    const pointWithAngleMagnetism: PlanController.RoomPointWithAngleMagnetism = new PlanController.RoomPointWithAngleMagnetism(this.__parent, this.newRoom, editedPointIndex, this.xPreviousPoint, this.yPreviousPoint, x, y);
                    xEnd = pointWithAngleMagnetism.getX();
                    yEnd = pointWithAngleMagnetism.getY();
                }
            }
            if (this.newRoom == null) {
                this.newRoom = this.createAndSelectRoom(this.xPreviousPoint, this.yPreviousPoint, xEnd, yEnd);
            } else if (this.newPoint != null) {
                const points: number[][] = this.newRoom.getPoints();
                this.xPreviousPoint = points[points.length - 1][0];
                this.yPreviousPoint = points[points.length - 1][1];
                this.newRoom.addPoint$float$float(xEnd, yEnd);
                this.newPoint = null;
            } else {
                this.newRoom.setPoint(xEnd, yEnd, this.newRoom.getPointCount() - 1);
            }
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.newRoom, this.newRoom.getPointCount() - 1), x, y);
                planView.setAlignmentFeedback(Room, this.newRoom, xEnd, yEnd, magnetizedPoint);
                this.showRoomAngleFeedback(this.newRoom, this.newRoom.getPointCount() - 1);
                planView.setDimensionLinesFeedback(this.getTriangulationDimensionLines(this.newRoom, this.newRoom.getPointCount() - 1));
            }
            planView.makePointVisible(x, y);
        }

        /**
         * Returns a new room instance with one side between (<code>xStart</code>,
         * <code>yStart</code>) and (<code>xEnd</code>, <code>yEnd</code>) points.
         * The new room is added to home and selected
         * @param {number} xStart
         * @param {number} yStart
         * @param {number} xEnd
         * @param {number} yEnd
         * @return {Room}
         * @private
         */
        createAndSelectRoom(xStart: number, yStart: number, xEnd: number, yEnd: number): Room {
            const newRoom: Room = this.__parent.createRoom([[xStart, yStart], [xEnd, yEnd]]);
            const insideWallsArea: java.awt.geom.Area = this.__parent.getInsideWallsArea();
            newRoom.setCeilingVisible(insideWallsArea.contains(xStart, yStart));
            this.__parent.selectItem(newRoom);
            return newRoom;
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 2) {
                if (this.newRoom == null) {
                    const roomPoints: number[][] = this.__parent.computeRoomPointsAt(x, y);
                    if (roomPoints != null) {
                        this.newRoom = this.__parent.createRoom(roomPoints);
                        this.__parent.selectItem(this.newRoom);
                    }
                }
                this.validateDrawnRoom();
            } else {
                this.endRoomSide();
            }
        }

        validateDrawnRoom() {
            if (this.newRoom != null) {
                const points: number[][] = this.newRoom.getPoints();
                if (points.length < 3) {
                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deleteRoom(this.newRoom);
                } else {
                    this.__parent.postCreateRooms(/* asList */[this.newRoom].slice(0), this.oldSelection, this.oldBasePlanLocked, this.oldAllLevelsSelection);
                }
            }
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else {
                this.__parent.setState(this.__parent.getRoomCreationState());
            }
        }

        endRoomSide() {
            if (this.newRoom != null && this.getRoomSideLength(this.newRoom, this.newRoom.getPointCount() - 1) > 0) {
                this.newPoint = [0, 0];
                if (this.newRoom.isCeilingVisible()) {
                    const roomPoints: number[][] = this.newRoom.getPoints();
                    const lastPoint: number[] = roomPoints[roomPoints.length - 1];
                    if (!this.__parent.getInsideWallsArea().contains(lastPoint[0], lastPoint[1])) {
                        this.newRoom.setCeilingVisible(false);
                    }
                }
            }
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            const planView: PlanView = this.__parent.getView();
            if (editionActivated) {
                planView.deleteFeedback();
                if (this.newRoom == null) {
                    planView.setToolTipEditedProperties(["X", "Y"], [this.xPreviousPoint, this.yPreviousPoint], this.xPreviousPoint, this.yPreviousPoint);
                } else {
                    if (this.newPoint != null) {
                        this.createNextSide();
                    }
                    const points: number[][] = this.newRoom.getPoints();
                    if (points.length > 2) {
                        planView.setToolTipEditedProperties(["LENGTH", "DIAGONAL", "ANGLE"], [this.getRoomSideLength(this.newRoom, points.length - 1), this.getRoomDiagonalLength(this.newRoom, points.length - 1), this.getRoomSideAngle(this.newRoom, points.length - 1)], points[points.length - 1][0], points[points.length - 1][1]);
                    } else {
                        planView.setToolTipEditedProperties(["LENGTH", "ANGLE"], [this.getRoomSideLength(this.newRoom, points.length - 1), this.getRoomSideAngle(this.newRoom, points.length - 1)], points[points.length - 1][0], points[points.length - 1][1]);
                    }
                }
                this.showRoomFeedback();
            } else {
                if (this.newRoom == null) {
                    const lengthUnit: any = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit();
                    const defaultLength: number = lengthUnit.isMetric() ? 300 : LengthUnit.footToCentimeter(10);
                    this.newRoom = this.createAndSelectRoom(this.xPreviousPoint, this.yPreviousPoint, this.xPreviousPoint + defaultLength, this.yPreviousPoint);
                    planView.deleteFeedback();
                    this.setEditionActivated(true);
                } else if (/* currentTimeMillis */Date.now() - this.lastPointCreationTime < 300) {
                    this.escape();
                } else {
                    this.endRoomSide();
                    const points: number[][] = this.newRoom.getPoints();
                    if (points.length > 2 && this.newRoom.getPointIndexAt(points[points.length - 1][0], points[points.length - 1][1], 0.001) === 0) {
                        this.newRoom.removePoint(this.newRoom.getPointCount() - 1);
                        this.validateDrawnRoom();
                        return;
                    }
                    this.createNextSide();
                    planView.deleteToolTipFeedback();
                    this.setEditionActivated(true);
                }
            }
        }

        createNextSide() {
            const points: number[][] = this.newRoom.getPoints();
            this.xPreviousPoint = points[points.length - 1][0];
            this.yPreviousPoint = points[points.length - 1][1];
            let previousSideAngle: number = Math.PI - Math.atan2(points[points.length - 2][1] - points[points.length - 1][1], points[points.length - 2][0] - points[points.length - 1][0]);
            previousSideAngle -= Math.PI / 2;
            const previousSideLength: number = this.getRoomSideLength(this.newRoom, points.length - 1);
            this.newRoom.addPoint$float$float(<number>(this.xPreviousPoint + previousSideLength * Math.cos(previousSideAngle)), <number>(this.yPreviousPoint - previousSideLength * Math.sin(previousSideAngle)));
            this.newPoint = null;
            this.lastPointCreationTime = /* currentTimeMillis */Date.now();
        }

        /**
         * 
         * @param {string} editableProperty
         * @param {Object} value
         */
        public updateEditableProperty(editableProperty: any, value: any) {
            if (this.newRoom == null) {
                const maximumLength: number = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength();
                switch ((editableProperty)) {
                    case "X":
                        this.xPreviousPoint = value != null ? /* floatValue */(<number>value) : 0;
                        this.xPreviousPoint = Math.max(-maximumLength, Math.min(this.xPreviousPoint, maximumLength));
                        break;
                    case "Y":
                        this.yPreviousPoint = value != null ? /* floatValue */(<number>value) : 0;
                        this.yPreviousPoint = Math.max(-maximumLength, Math.min(this.yPreviousPoint, maximumLength));
                        break;
                }
            } else {
                const planView: PlanView = this.__parent.getView();
                const roomPoints: number[][] = this.newRoom.getPoints();
                const previousPoint: number[] = roomPoints[roomPoints.length - 2];
                const point: number[] = roomPoints[roomPoints.length - 1];
                switch ((editableProperty)) {
                    case "LENGTH":
                        let sideLength: number = value != null ? /* floatValue */(<number>value) : 0;
                        sideLength = Math.max(0.001, Math.min(sideLength, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength()));
                        let sideAngle: number = Math.PI - Math.atan2(previousPoint[1] - point[1], previousPoint[0] - point[0]);
                        let newX: number = <number>(previousPoint[0] + sideLength * Math.cos(sideAngle));
                        let newY: number = <number>(previousPoint[1] - sideLength * Math.sin(sideAngle));
                        this.newRoom.setPoint(newX, newY, roomPoints.length - 1);
                        if (roomPoints.length > 2) {
                            planView.setToolTipEditedPropertyValue("DIAGONAL", this.getRoomDiagonalLength(this.newRoom, roomPoints.length - 1));
                        }
                        break;
                    case "DIAGONAL":
                        const diagonalLength: number = value != null ? /* floatValue */(<number>value) : 0;
                        sideLength = this.getRoomSideLength(this.newRoom, roomPoints.length - 1);
                        const previousSideLength: number = this.getRoomSideLength(this.newRoom, roomPoints.length - 2);
                        if (diagonalLength >= sideLength && diagonalLength <= sideLength + previousSideLength) {
                            const cosAngle: number = (sideLength * sideLength + previousSideLength * previousSideLength - diagonalLength * diagonalLength) / (2 * sideLength * previousSideLength);
                            sideAngle = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.getRoomSideAngle(this.newRoom, roomPoints.length - 1)) * Math.acos(cosAngle);
                            sideAngle -= Math.atan2(roomPoints[roomPoints.length - 3][1] - previousPoint[1], roomPoints[roomPoints.length - 3][0] - previousPoint[0]);
                            newX = <number>(previousPoint[0] + sideLength * Math.cos(sideAngle));
                            newY = <number>(previousPoint[1] - sideLength * Math.sin(sideAngle));
                            this.newRoom.setPoint(newX, newY, roomPoints.length - 1);
                            planView.setToolTipEditedPropertyValue("ANGLE", this.getRoomSideAngle(this.newRoom, roomPoints.length - 1));
                        }
                        break;
                    case "ANGLE":
                        sideAngle = /* toRadians */(x => x * Math.PI / 180)(value != null ? /* floatValue */(<number>value) : 0);
                        if (roomPoints.length > 2) {
                            sideAngle -= Math.atan2(roomPoints[roomPoints.length - 3][1] - previousPoint[1], roomPoints[roomPoints.length - 3][0] - previousPoint[0]);
                        }
                        sideLength = this.getRoomSideLength(this.newRoom, roomPoints.length - 1);
                        newX = <number>(previousPoint[0] + sideLength * Math.cos(sideAngle));
                        newY = <number>(previousPoint[1] - sideLength * Math.sin(sideAngle));
                        this.newRoom.setPoint(newX, newY, roomPoints.length - 1);
                        if (roomPoints.length > 2) {
                            planView.setToolTipEditedPropertyValue("DIAGONAL", this.getRoomDiagonalLength(this.newRoom, roomPoints.length - 1));
                        }
                        break;
                    default:
                        return;
                }
            }
            this.showRoomFeedback();
        }

        showRoomFeedback() {
            const planView: PlanView = this.__parent.getView();
            if (this.newRoom == null) {
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(Room, null, this.xPreviousPoint, this.yPreviousPoint, true);
                }
                planView.makePointVisible(this.xPreviousPoint, this.yPreviousPoint);
            } else {
                const roomPoints: number[][] = this.newRoom.getPoints();
                const editedPoint: number[] = roomPoints[roomPoints.length - 1];
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(Room, this.newRoom, editedPoint[0], editedPoint[1], false);
                    this.showRoomAngleFeedback(this.newRoom, roomPoints.length - 1);
                    planView.setDimensionLinesFeedback(this.getTriangulationDimensionLines(this.newRoom, roomPoints.length - 1));
                }
                const previousPoint: number[] = roomPoints[roomPoints.length - 2];
                planView.makePointVisible(previousPoint[0], previousPoint[1]);
                planView.makePointVisible(editedPoint[0], editedPoint[1]);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.newRoom != null) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            if (this.newRoom != null && this.newPoint == null) {
                this.newRoom.removePoint(this.newRoom.getPointCount() - 1);
            }
            this.validateDrawnRoom();
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
            this.newRoom = null;
            this.newPoint = null;
            this.oldSelection = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.xPreviousPoint === undefined) { this.xPreviousPoint = 0; }
            if (this.yPreviousPoint === undefined) { this.yPreviousPoint = 0; }
            if (this.newRoom === undefined) { this.newRoom = null; }
            if (this.newPoint === undefined) { this.newPoint = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.lastPointCreationTime === undefined) { this.lastPointCreationTime = 0; }
        }
    }
    RoomDrawingState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomDrawingState";


    /**
     * Room resize state. This state manages room resizing.
     * @extends PlanController.AbstractRoomState
     * @class
     */
    export class RoomResizeState extends PlanController.AbstractRoomState {
        public __parent: any;
        selectedRoom: Room;

        roomPointIndex: number;

        oldX: number;

        oldY: number;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.selectedRoom = <Room><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            const margin: number = this.__parent.getIndicatorMargin();
            this.roomPointIndex = this.selectedRoom.getPointIndexAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), margin);
            const roomPoints: number[][] = this.selectedRoom.getPoints();
            this.oldX = roomPoints[this.roomPointIndex][0];
            this.oldY = roomPoints[this.roomPointIndex][1];
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - this.oldX;
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - this.oldY;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedRoom, this.roomPointIndex), this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
                this.showRoomAngleFeedback(this.selectedRoom, this.roomPointIndex);
                planView.setDimensionLinesFeedback(this.getTriangulationDimensionLines(this.selectedRoom, this.roomPointIndex));
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let newX: number = x - this.deltaXToResizePoint;
            let newY: number = y - this.deltaYToResizePoint;
            const roomPoints: number[][] = this.selectedRoom.getPoints();
            const previousPointIndex: number = this.roomPointIndex === 0 ? roomPoints.length - 1 : this.roomPointIndex - 1;
            const xPreviousPoint: number = roomPoints[previousPointIndex][0];
            const yPreviousPoint: number = roomPoints[previousPointIndex][1];
            let magnetizedPoint: boolean = false;
            if (this.alignmentActivated) {
                const pointWithAngleMagnetism: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(xPreviousPoint, yPreviousPoint, newX, newY, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                newX = pointWithAngleMagnetism.getX();
                newY = pointWithAngleMagnetism.getY();
            } else if (this.magnetismEnabled) {
                const point: PlanController.PointMagnetizedToClosestWallOrRoomPoint = new PlanController.PointMagnetizedToClosestWallOrRoomPoint(this.__parent, this.selectedRoom, this.roomPointIndex, newX, newY);
                magnetizedPoint = point.isMagnetized();
                if (magnetizedPoint) {
                    newX = point.getX();
                    newY = point.getY();
                } else {
                    const pointWithAngleMagnetism: PlanController.RoomPointWithAngleMagnetism = new PlanController.RoomPointWithAngleMagnetism(this.__parent, this.selectedRoom, this.roomPointIndex, xPreviousPoint, yPreviousPoint, newX, newY);
                    newX = pointWithAngleMagnetism.getX();
                    newY = pointWithAngleMagnetism.getY();
                }
            }
            PlanController.moveRoomPoint(this.selectedRoom, newX, newY, this.roomPointIndex);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedRoom, this.roomPointIndex), x, y);
                planView.setAlignmentFeedback(Room, this.selectedRoom, newX, newY, magnetizedPoint);
                this.showRoomAngleFeedback(this.selectedRoom, this.roomPointIndex);
                planView.setDimensionLinesFeedback(this.getTriangulationDimensionLines(this.selectedRoom, this.roomPointIndex));
            }
            planView.makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postRoomResize(this.selectedRoom, this.oldX, this.oldY, this.roomPointIndex);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            PlanController.moveRoomPoint(this.selectedRoom, this.oldX, this.oldY, this.roomPointIndex);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedRoom = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.selectedRoom === undefined) { this.selectedRoom = null; }
            if (this.roomPointIndex === undefined) { this.roomPointIndex = 0; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    RoomResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.RoomResizeState";


    /**
     * Polyline drawing state. This state manages polyline creation at mouse press.
     * @extends PlanController.AbstractPolylineState
     * @class
     */
    export class PolylineDrawingState extends PlanController.AbstractPolylineState {
        public __parent: any;
        xPreviousPoint: number;

        yPreviousPoint: number;

        newPolyline: Polyline;

        newPoint: number[];

        oldSelection: Array<Selectable>;

        oldBasePlanLocked: boolean;

        oldAllLevelsSelection: boolean;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        curvedPolyline: boolean;

        lastPointCreationTime: number;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.POLYLINE_CREATION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @param {PlanController.Mode} mode
         */
        public setMode(mode: PlanController.Mode) {
            this.escape();
            if (mode === PlanController.Mode.SELECTION_$LI$()) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else if (mode === PlanController.Mode.PANNING_$LI$()) {
                this.__parent.setState(this.__parent.getPanningState());
            } else if (mode === PlanController.Mode.WALL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getWallCreationState());
            } else if (mode === PlanController.Mode.ROOM_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getRoomCreationState());
            } else if (mode === PlanController.Mode.DIMENSION_LINE_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getDimensionLineCreationState());
            } else if (mode === PlanController.Mode.LABEL_CREATION_$LI$()) {
                this.__parent.setState(this.__parent.getLabelCreationState());
            }
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.oldSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems();
            this.oldBasePlanLocked = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isBasePlanLocked();
            this.oldAllLevelsSelection = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection();
            this.newPolyline = null;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            this.xPreviousPoint = this.__parent.getXLastMousePress();
            this.yPreviousPoint = this.__parent.getYLastMousePress();
            this.setDuplicationActivated(this.__parent.wasDuplicationActivatedLastMousePress());
            this.__parent.deselectAll();
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let xEnd: number = x;
            let yEnd: number = y;
            if (this.alignmentActivated || this.magnetismEnabled) {
                const pointWithAngleMagnetism: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(this.xPreviousPoint, this.yPreviousPoint, x, y, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                xEnd = pointWithAngleMagnetism.getX();
                yEnd = pointWithAngleMagnetism.getY();
            }
            if (this.newPolyline == null) {
                this.newPolyline = this.createAndSelectPolyline(this.xPreviousPoint, this.yPreviousPoint, xEnd, yEnd);
            } else if (this.newPoint != null) {
                const points: number[][] = this.newPolyline.getPoints();
                this.xPreviousPoint = points[points.length - 1][0];
                this.yPreviousPoint = points[points.length - 1][1];
                this.newPolyline.addPoint$float$float(xEnd, yEnd);
                this.newPoint[0] = xEnd;
                this.newPoint[1] = yEnd;
                this.newPoint = null;
            } else {
                this.newPolyline.setPoint(xEnd, yEnd, this.newPolyline.getPointCount() - 1);
            }
            if (this.__parent.feedbackDisplayed) {
                planView.setAlignmentFeedback(Polyline, null, x, y, false);
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.newPolyline, this.newPolyline.getPointCount() - 1), x, y);
                if (this.newPolyline.getJoinStyle() !== Polyline.JoinStyle.CURVED) {
                    this.showPolylineAngleFeedback(this.newPolyline, this.newPolyline.getPointCount() - 1);
                }
            }
            planView.makePointVisible(x, y);
        }

        /**
         * Returns a new polyline instance with one segment between (<code>xStart</code>,
         * <code>yStart</code>) and (<code>xEnd</code>, <code>yEnd</code>) points.
         * The new polyline is added to home and selected
         * @param {number} xStart
         * @param {number} yStart
         * @param {number} xEnd
         * @param {number} yEnd
         * @return {Polyline}
         * @private
         */
        createAndSelectPolyline(xStart: number, yStart: number, xEnd: number, yEnd: number): Polyline {
            const newPolyline: Polyline = this.__parent.createPolyline([[xStart, yStart], [xEnd, yEnd]]);
            if (this.curvedPolyline) {
                newPolyline.setJoinStyle(Polyline.JoinStyle.CURVED);
            }
            this.__parent.selectItems(/* asList */[newPolyline].slice(0));
            return newPolyline;
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {number} clickCount
         * @param {boolean} shiftDown
         * @param {boolean} duplicationActivated
         */
        public pressMouse(x: number, y: number, clickCount: number, shiftDown: boolean, duplicationActivated: boolean) {
            if (clickCount === 2) {
                if (this.newPolyline != null) {
                    const pointIndex: number = this.newPolyline.getPointIndexAt(x, y, this.__parent.getSelectionMargin());
                    if (pointIndex === 0) {
                        this.newPolyline.removePoint(this.newPolyline.getPointCount() - 1);
                        this.newPolyline.setClosedPath(true);
                    }
                    this.validateDrawnPolyline();
                } else {
                    if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                        this.__parent.setState(this.__parent.getSelectionState());
                    } else {
                        this.__parent.setState(this.__parent.getPolylineCreationState());
                    }
                }
            } else {
                this.endPolylineSegment();
            }
        }

        validateDrawnPolyline() {
            if (this.newPolyline != null) {
                const points: number[][] = this.newPolyline.getPoints();
                if (points.length < 2) {
                    this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.deletePolyline(this.newPolyline);
                } else {
                    this.__parent.postCreatePolylines(/* asList */[this.newPolyline].slice(0), this.oldSelection, this.oldBasePlanLocked, this.oldAllLevelsSelection);
                }
            }
            if (this.__parent.getPointerTypeLastMousePress() === View.PointerType.TOUCH) {
                this.__parent.setState(this.__parent.getSelectionState());
            } else {
                this.__parent.setState(this.__parent.getPolylineCreationState());
            }
        }

        endPolylineSegment() {
            if (this.newPolyline != null && this.getPolylineSegmentLength(this.newPolyline, this.newPolyline.getPointCount() - 1) > 0) {
                this.newPoint = [0, 0];
                if (this.newPolyline.getPointCount() <= 2 && this.curvedPolyline && this.newPolyline.getJoinStyle() !== Polyline.JoinStyle.CURVED) {
                    this.newPolyline.setJoinStyle(Polyline.JoinStyle.CURVED);
                }
            }
        }

        /**
         * 
         * @param {boolean} editionActivated
         */
        public setEditionActivated(editionActivated: boolean) {
            const planView: PlanView = this.__parent.getView();
            if (editionActivated) {
                planView.deleteFeedback();
                if (this.newPolyline == null) {
                    planView.setToolTipEditedProperties(["X", "Y"], [this.xPreviousPoint, this.yPreviousPoint], this.xPreviousPoint, this.yPreviousPoint);
                } else {
                    if (this.newPoint != null) {
                        this.createNextSegment();
                    }
                    const points: number[][] = this.newPolyline.getPoints();
                    planView.setToolTipEditedProperties(["LENGTH", "ANGLE"], [this.getPolylineSegmentLength(this.newPolyline, points.length - 1), this.getPolylineSegmentAngle(this.newPolyline, points.length - 1)], points[points.length - 1][0], points[points.length - 1][1]);
                }
                this.showPolylineFeedback();
            } else {
                if (this.newPolyline == null) {
                    const lengthUnit: any = this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit();
                    const defaultLength: number = lengthUnit.isMetric() ? 300 : LengthUnit.footToCentimeter(10);
                    this.newPolyline = this.createAndSelectPolyline(this.xPreviousPoint, this.yPreviousPoint, this.xPreviousPoint + defaultLength, this.yPreviousPoint);
                    planView.deleteFeedback();
                    this.setEditionActivated(true);
                } else if (/* currentTimeMillis */Date.now() - this.lastPointCreationTime < 300) {
                    this.escape();
                } else {
                    this.endPolylineSegment();
                    const points: number[][] = this.newPolyline.getPoints();
                    if (points.length > 2 && this.newPolyline.getPointIndexAt(points[points.length - 1][0], points[points.length - 1][1], 0.001) === 0) {
                        this.newPolyline.removePoint(this.newPolyline.getPointCount() - 1);
                        this.newPolyline.setClosedPath(true);
                        this.validateDrawnPolyline();
                        return;
                    }
                    this.createNextSegment();
                    planView.deleteToolTipFeedback();
                    this.setEditionActivated(true);
                }
            }
        }

        createNextSegment() {
            const points: number[][] = this.newPolyline.getPoints();
            this.xPreviousPoint = points[points.length - 1][0];
            this.yPreviousPoint = points[points.length - 1][1];
            let previousSegmentAngle: number = Math.PI - Math.atan2(points[points.length - 2][1] - points[points.length - 1][1], points[points.length - 2][0] - points[points.length - 1][0]);
            previousSegmentAngle -= Math.PI / 2;
            const previousSegmentLength: number = this.getPolylineSegmentLength(this.newPolyline, points.length - 1);
            this.newPolyline.addPoint$float$float(<number>(this.xPreviousPoint + previousSegmentLength * Math.cos(previousSegmentAngle)), <number>(this.yPreviousPoint - previousSegmentLength * Math.sin(previousSegmentAngle)));
            this.newPoint = null;
            this.lastPointCreationTime = /* currentTimeMillis */Date.now();
        }

        /**
         * 
         * @param {string} editableProperty
         * @param {Object} value
         */
        public updateEditableProperty(editableProperty: any, value: any) {
            if (this.newPolyline == null) {
                switch ((editableProperty)) {
                    case "X":
                        this.xPreviousPoint = value != null ? /* floatValue */(<number>value) : 0;
                        this.xPreviousPoint = Math.max(-100000.0, Math.min(this.xPreviousPoint, 100000.0));
                        break;
                    case "Y":
                        this.yPreviousPoint = value != null ? /* floatValue */(<number>value) : 0;
                        this.yPreviousPoint = Math.max(-100000.0, Math.min(this.yPreviousPoint, 100000.0));
                        break;
                }
            } else {
                const points: number[][] = this.newPolyline.getPoints();
                const previousPoint: number[] = points[points.length - 2];
                const point: number[] = points[points.length - 1];
                let newX: number;
                let newY: number;
                switch ((editableProperty)) {
                    case "LENGTH":
                        let length: number = value != null ? /* floatValue */(<number>value) : 0;
                        length = Math.max(0.001, Math.min(length, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit().getMaximumLength()));
                        let segmentAngle: number = Math.PI - Math.atan2(previousPoint[1] - point[1], previousPoint[0] - point[0]);
                        newX = <number>(previousPoint[0] + length * Math.cos(segmentAngle));
                        newY = <number>(previousPoint[1] - length * Math.sin(segmentAngle));
                        break;
                    case "ANGLE":
                        segmentAngle = /* toRadians */(x => x * Math.PI / 180)(value != null ? /* floatValue */(<number>value) : 0);
                        if (points.length > 2) {
                            segmentAngle -= Math.atan2(points[points.length - 3][1] - previousPoint[1], points[points.length - 3][0] - previousPoint[0]);
                        }
                        const segmentLength: number = this.getPolylineSegmentLength(this.newPolyline, points.length - 1);
                        newX = <number>(previousPoint[0] + segmentLength * Math.cos(segmentAngle));
                        newY = <number>(previousPoint[1] - segmentLength * Math.sin(segmentAngle));
                        break;
                    default:
                        return;
                }
                this.newPolyline.setPoint(newX, newY, points.length - 1);
            }
            this.showPolylineFeedback();
        }

        showPolylineFeedback() {
            const planView: PlanView = this.__parent.getView();
            if (this.newPolyline == null) {
                if (this.__parent.feedbackDisplayed) {
                    planView.setAlignmentFeedback(Polyline, null, this.xPreviousPoint, this.yPreviousPoint, true);
                }
                planView.makePointVisible(this.xPreviousPoint, this.yPreviousPoint);
            } else {
                const points: number[][] = this.newPolyline.getPoints();
                const previousPoint: number[] = points[points.length - 2];
                const editedPoint: number[] = points[points.length - 1];
                if (this.__parent.feedbackDisplayed) {
                    if (this.newPolyline.getJoinStyle() !== Polyline.JoinStyle.CURVED) {
                        this.showPolylineAngleFeedback(this.newPolyline, points.length - 1);
                    }
                    planView.setAlignmentFeedback(Polyline, null, editedPoint[0], editedPoint[1], false);
                }
                planView.makePointVisible(previousPoint[0], previousPoint[1]);
                planView.makePointVisible(editedPoint[0], editedPoint[1]);
            }
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            if (this.newPolyline != null) {
                this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
            }
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} duplicationActivated
         */
        public setDuplicationActivated(duplicationActivated: boolean) {
            this.curvedPolyline = duplicationActivated;
        }

        /**
         * 
         */
        public escape() {
            if (this.newPolyline != null && this.newPoint == null) {
                this.newPolyline.removePoint(this.newPolyline.getPointCount() - 1);
            }
            this.validateDrawnPolyline();
        }

        /**
         * 
         */
        public exit() {
            this.__parent.getView().deleteFeedback();
            this.newPolyline = null;
            this.newPoint = null;
            this.oldSelection = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.xPreviousPoint === undefined) { this.xPreviousPoint = 0; }
            if (this.yPreviousPoint === undefined) { this.yPreviousPoint = 0; }
            if (this.newPolyline === undefined) { this.newPolyline = null; }
            if (this.newPoint === undefined) { this.newPoint = null; }
            if (this.oldSelection === undefined) { this.oldSelection = null; }
            if (this.oldBasePlanLocked === undefined) { this.oldBasePlanLocked = false; }
            if (this.oldAllLevelsSelection === undefined) { this.oldAllLevelsSelection = false; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
            if (this.curvedPolyline === undefined) { this.curvedPolyline = false; }
            if (this.lastPointCreationTime === undefined) { this.lastPointCreationTime = 0; }
        }
    }
    PolylineDrawingState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PolylineDrawingState";


    /**
     * Polyline resize state. This state manages polyline resizing.
     * @extends PlanController.AbstractPolylineState
     * @class
     */
    export class PolylineResizeState extends PlanController.AbstractPolylineState {
        public __parent: any;
        polylines: Array<Polyline>;

        selectedPolyline: Polyline;

        polylinePointIndex: number;

        oldX: number;

        oldY: number;

        deltaXToResizePoint: number;

        deltaYToResizePoint: number;

        magnetismEnabled: boolean;

        alignmentActivated: boolean;

        /**
         * 
         * @return {PlanController.Mode}
         */
        public getMode(): PlanController.Mode {
            return PlanController.Mode.SELECTION_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public isModificationState(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isBasePlanModificationState(): boolean {
            return true;
        }

        /**
         * 
         */
        public enter() {
            super.enter();
            this.selectedPolyline = <Polyline><any>/* get */this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems()[0];
            this.polylines = <any>(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getPolylines().slice(0));
            /* remove */(a => { let index = a.indexOf(this.selectedPolyline); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(this.polylines);
            const margin: number = this.__parent.getIndicatorMargin();
            this.polylinePointIndex = this.selectedPolyline.getPointIndexAt(this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress(), margin);
            const polylinePoints: number[][] = this.selectedPolyline.getPoints();
            this.oldX = polylinePoints[this.polylinePointIndex][0];
            this.oldY = polylinePoints[this.polylinePointIndex][1];
            this.deltaXToResizePoint = this.__parent.getXLastMousePress() - this.oldX;
            this.deltaYToResizePoint = this.__parent.getYLastMousePress() - this.oldY;
            this.alignmentActivated = this.__parent.wasAlignmentActivatedLastMousePress();
            this.toggleMagnetism(this.__parent.wasMagnetismToggledLastMousePress());
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(true);
            const toolTipFeedbackText: string = this.getToolTipFeedbackText(this.selectedPolyline, this.polylinePointIndex);
            if (this.__parent.feedbackDisplayed && toolTipFeedbackText != null) {
                planView.setToolTipFeedback(toolTipFeedbackText, this.__parent.getXLastMousePress(), this.__parent.getYLastMousePress());
                if (this.selectedPolyline.getJoinStyle() !== Polyline.JoinStyle.CURVED) {
                    this.showPolylineAngleFeedback(this.selectedPolyline, this.polylinePointIndex);
                }
            }
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public moveMouse(x: number, y: number) {
            const planView: PlanView = this.__parent.getView();
            let newX: number = x - this.deltaXToResizePoint;
            let newY: number = y - this.deltaYToResizePoint;
            if (this.alignmentActivated || this.magnetismEnabled) {
                const polylinePoints: number[][] = this.selectedPolyline.getPoints();
                const previousPointIndex: number = this.polylinePointIndex === 0 ? (this.selectedPolyline.isClosedPath() ? polylinePoints.length - 1 : 1) : this.polylinePointIndex - 1;
                const xPreviousPoint: number = polylinePoints[previousPointIndex][0];
                const yPreviousPoint: number = polylinePoints[previousPointIndex][1];
                const pointWithAngleMagnetism: PlanController.PointWithAngleMagnetism = new PlanController.PointWithAngleMagnetism(xPreviousPoint, yPreviousPoint, newX, newY, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.getLengthUnit(), planView.getPixelLength());
                newX = pointWithAngleMagnetism.getX();
                newY = pointWithAngleMagnetism.getY();
            }
            this.selectedPolyline.setPoint(newX, newY, this.polylinePointIndex);
            if (this.__parent.feedbackDisplayed) {
                planView.setToolTipFeedback(this.getToolTipFeedbackText(this.selectedPolyline, this.polylinePointIndex), x, y);
                if (this.selectedPolyline.getJoinStyle() !== Polyline.JoinStyle.CURVED) {
                    this.showPolylineAngleFeedback(this.selectedPolyline, this.polylinePointIndex);
                }
            }
            planView.makePointVisible(x, y);
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        public releaseMouse(x: number, y: number) {
            this.__parent.postPolylineResize(this.selectedPolyline, this.oldX, this.oldY, this.polylinePointIndex);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         * @param {boolean} magnetismToggled
         */
        public toggleMagnetism(magnetismToggled: boolean) {
            this.magnetismEnabled = (this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_preferences.isMagnetismEnabled()) !== (magnetismToggled);
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         * @param {boolean} alignmentActivated
         */
        public setAlignmentActivated(alignmentActivated: boolean) {
            this.alignmentActivated = alignmentActivated;
            this.moveMouse(this.__parent.getXLastMouseMove(), this.__parent.getYLastMouseMove());
        }

        /**
         * 
         */
        public escape() {
            this.selectedPolyline.setPoint(this.oldX, this.oldY, this.polylinePointIndex);
            this.__parent.setState(this.__parent.getSelectionState());
        }

        /**
         * 
         */
        public exit() {
            const planView: PlanView = this.__parent.getView();
            planView.setResizeIndicatorVisible(false);
            planView.deleteFeedback();
            this.selectedPolyline = null;
        }

        constructor(__parent: any) {
            super(__parent);
            this.__parent = __parent;
            if (this.polylines === undefined) { this.polylines = null; }
            if (this.selectedPolyline === undefined) { this.selectedPolyline = null; }
            if (this.polylinePointIndex === undefined) { this.polylinePointIndex = 0; }
            if (this.oldX === undefined) { this.oldX = 0; }
            if (this.oldY === undefined) { this.oldY = 0; }
            if (this.deltaXToResizePoint === undefined) { this.deltaXToResizePoint = 0; }
            if (this.deltaYToResizePoint === undefined) { this.deltaYToResizePoint = 0; }
            if (this.magnetismEnabled === undefined) { this.magnetismEnabled = false; }
            if (this.alignmentActivated === undefined) { this.alignmentActivated = false; }
        }
    }
    PolylineResizeState["__class"] = "com.eteks.sweethome3d.viewcontroller.PlanController.PolylineResizeState";


    export class PlanController$0 {
        public __parent: any;
        public compare(wall1: Wall, wall2: Wall): number {
            const intersection1: number[] = PlanController.computeIntersection(wall1.getXStart(), wall1.getYStart(), wall1.getXEnd(), wall1.getYEnd(), this.walls[0].getXStart(), this.walls[0].getYStart(), this.walls[0].getXEnd(), this.walls[0].getYEnd());
            const intersection2: number[] = PlanController.computeIntersection(wall2.getXStart(), wall2.getYStart(), wall2.getXEnd(), wall2.getYEnd(), this.walls[0].getXStart(), this.walls[0].getYStart(), this.walls[0].getXEnd(), this.walls[0].getYEnd());
            const closestPoint1: number = Math.min(java.awt.geom.Point2D.distanceSq(this.walls[0].getXStart(), this.walls[0].getYStart(), intersection1[0], intersection1[1]), java.awt.geom.Point2D.distanceSq(this.walls[0].getXEnd(), this.walls[0].getYEnd(), intersection1[0], intersection1[1]));
            const closestPoint2: number = Math.min(java.awt.geom.Point2D.distanceSq(this.walls[0].getXStart(), this.walls[0].getYStart(), intersection2[0], intersection2[1]), java.awt.geom.Point2D.distanceSq(this.walls[0].getXEnd(), this.walls[0].getYEnd(), intersection2[0], intersection2[1]));
            return /* compare */(closestPoint1 - closestPoint2);
        }

        constructor(__parent: any, private walls: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$1 implements SelectionListener {
        public __parent: any;
        public selectionChanged(ev: SelectionEvent) {
            this.__parent.selectLevelFromSelectedItems();
            if (this.__parent.getView() != null) {
                this.__parent.getView().makeSelectionVisible();
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }
    PlanController$1["__interfaces"] = ["com.eteks.sweethome3d.model.SelectionListener"];



    export class PlanController$2 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            if (/* contains */(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems().indexOf(<any>(ev.getSource())) >= 0)) {
                if (this.__parent.getView() != null) {
                    this.__parent.getView().makeSelectionVisible();
                }
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$3 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const propertyName: string = ev.getPropertyName();
            if ((/* name */"X_START" === propertyName) || (/* name */"X_END" === propertyName) || (/* name */"Y_START" === propertyName) || (/* name */"Y_END" === propertyName) || (/* name */"WALL_AT_START" === propertyName) || (/* name */"WALL_AT_END" === propertyName) || (/* name */"THICKNESS" === propertyName) || (/* name */"ARC_EXTENT" === propertyName) || (/* name */"LEVEL" === propertyName) || (/* name */"HEIGHT" === propertyName) || (/* name */"HEIGHT_AT_END" === propertyName) || (/* name */"LEFT_SIDE_BASEBOARD" === propertyName) || (/* name */"RIGHT_SIDE_BASEBOARD" === propertyName)) {
                this.__parent.resetAreaCache();
                const wall: Wall = <Wall>ev.getSource();
                if (!wall.isAtLevel(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedLevel())) {
                    const selectedItems: Array<Selectable> = <any>(this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.getSelectedItems().slice(0));
                    if (/* remove */(a => { let index = a.indexOf(wall); if (index >= 0) { a.splice(index, 1); return true; } else { return false; } })(selectedItems)) {
                        this.__parent.selectItems(selectedItems, this.__parent.__com_eteks_sweethome3d_viewcontroller_PlanController_home.isAllLevelsSelection());
                    }
                }
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$4 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const propertyName: string = ev.getPropertyName();
            if ((/* name */"X" === propertyName) || (/* name */"Y" === propertyName) || (/* name */"WIDTH_IN_PLAN" === propertyName) || (/* name */"DEPTH_IN_PLAN" === propertyName)) {
                /* remove */((m, k) => { if (m.entries == null) m.entries = []; for (let i = 0; i < m.entries.length; i++) if (m.entries[i].key == null && k == null || m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) { return m.entries.splice(i, 1)[0]; } })(<any>this.__parent.furnitureSidesCache, <HomePieceOfFurniture>ev.getSource());
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$5 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            const piece: HomePieceOfFurniture = <HomePieceOfFurniture>ev.getSource();
            const propertyName: string = ev.getPropertyName();
            if ((/* name */"MODEL" === propertyName) || (/* name */"MODEL_MIRRORED" === propertyName) || (/* name */"MODEL_ROTATION" === propertyName) || (/* name */"WIDTH" === propertyName) || (/* name */"DEPTH" === propertyName) || (/* name */"HEIGHT" === propertyName) || (/* name */"ROLL" === propertyName) || (/* name */"PITCH" === propertyName)) {
                const size: number[] = this.__parent.getView().getPieceOfFurnitureSizeInPlan(piece);
                if (size != null) {
                    piece.setWidthInPlan(size[0]);
                    piece.setDepthInPlan(size[1]);
                    piece.setHeightInPlan(size[2]);
                } else if (/* name */"WIDTH" === propertyName) {
                    const scale: number = piece.getWidth() / /* floatValue */(<number>ev.getOldValue());
                    piece.setWidthInPlan(scale * piece.getWidthInPlan());
                    piece.setDepthInPlan(scale * piece.getDepthInPlan());
                    piece.setHeightInPlan(scale * piece.getHeightInPlan());
                }
            }
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$6 {
        public __parent: any;
        public propertyChange(ev: PropertyChangeEvent) {
            this.__parent.resetAreaCache();
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }


    export class PlanController$7 {
        public __parent: any;
        public compare(p1: HomePieceOfFurniture, p2: HomePieceOfFurniture): number {
            return -/* compare */(p1.getGroundElevation() - p2.getGroundElevation());
        }

        constructor(__parent: any) {
            this.__parent = __parent;
        }
    }

}




PlanController.Mode.LABEL_CREATION_$LI$();

PlanController.Mode.DIMENSION_LINE_CREATION_$LI$();

PlanController.Mode.POLYLINE_CREATION_$LI$();

PlanController.Mode.ROOM_CREATION_$LI$();

PlanController.Mode.WALL_CREATION_$LI$();

PlanController.Mode.PANNING_$LI$();

PlanController.Mode.SELECTION_$LI$();

Home.LEVEL_ELEVATION_COMPARATOR_$LI$();

HomeController.UserPreferencesChangeListener.writingPreferences_$LI$();

Label.TWICE_PI_$LI$();

Room.TWICE_PI_$LI$();

HomePieceOfFurniture.SORTABLE_PROPERTY_COMPARATORS_$LI$();

HomePieceOfFurniture.EMPTY_PROPERTY_ARRAY_$LI$();

HomePieceOfFurniture.ROUND_WALL_ANGLE_MARGIN_$LI$();

HomePieceOfFurniture.STRAIGHT_WALL_ANGLE_MARGIN_$LI$();

HomePieceOfFurniture.TWICE_PI_$LI$();

HomePieceOfFurniture.__static_initialize();

CatalogLight.EMPTY_LIGHT_SOURCE_MATERIAL_NAMES_$LI$();

CatalogLight.EMPTY_LIGHT_SOURCES_$LI$();

CatalogShelfUnit.EMPTY_SHELF_BOXES_$LI$();

CatalogShelfUnit.EMPTY_SHELF_ELEVATIONS_$LI$();

ExportableView.FormatType.CSV_$LI$();

ExportableView.FormatType.SVG_$LI$();

TransferableView.DataType.FURNITURE_LIST_$LI$();

TransferableView.DataType.PLAN_IMAGE_$LI$();

TexturesCategory.COMPARATOR_$LI$();

CatalogTexture.recentFilters_$LI$();

CatalogTexture.COMPARATOR_$LI$();

CatalogTexture.EMPTY_CRITERIA_$LI$();

CatalogTexture.__static_initialize();

TextStyle.textStylesCache_$LI$();

Baseboard.baseboardsCache_$LI$();

FurnitureCategory.COMPARATOR_$LI$();

CatalogPieceOfFurniture.recentFilters_$LI$();

CatalogPieceOfFurniture.COMPARATOR_$LI$();

CatalogPieceOfFurniture.EMPTY_CRITERIA_$LI$();

CatalogPieceOfFurniture.__static_initialize();
